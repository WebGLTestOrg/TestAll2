System.register([], (function (exports, module) {
    'use strict';
    return {
        execute: (function () {

            exports({
                BitMask: BitMask,
                CCClass: CCClass,
                Enum: Enum,
                Eventify: Eventify,
                WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
                WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI,
                __checkObsoleteInNamespace__: __checkObsoleteInNamespace__,
                __checkObsolete__: __checkObsolete__,
                _resetDebugSetting: _resetDebugSetting,
                absMax: absMax,
                absMaxComponent: absMaxComponent,
                applyMixins: applyMixins,
                approx: approx,
                assert: assert,
                assertID: assertID,
                assertIsNonNullable: assertIsNonNullable,
                assertIsTrue: assertIsTrue,
                assertsArrayIndex: assertsArrayIndex,
                bezier: bezier$1,
                bezierByTime: bezierByTime,
                binarySearch: binarySearch,
                binarySearchBy: binarySearchBy,
                binarySearchEpsilon: binarySearchEpsilon,
                ccenum: ccenum,
                clamp: clamp,
                clamp01: clamp01,
                color: color,
                debug: debug,
                debugID: debugID,
                deprecateModuleExportedName: deprecateModuleExportedName,
                deserialize: deserialize,
                enumerableProps: enumerableProps,
                equals: equals,
                error: error,
                errorID: errorID,
                find: find,
                flattenCodeArray: flattenCodeArray,
                floatToHalf: floatToHalf,
                formerlySerializedAs: formerlySerializedAs$3,
                getError: getError,
                getSerializationMetadata: getSerializationMetadata,
                halfToFloat: halfToFloat,
                instantiate: instantiate,
                inverseLerp: inverseLerp,
                isCCClassOrFastDefined: isCCClassOrFastDefined,
                isCCObject: isCCObject,
                isDisplayStats: isDisplayStats,
                isValid: isValid,
                lerp: lerp,
                log: log,
                logID: logID,
                mat4: mat4,
                murmurhash2_32_gc: murmurhash2_32_gc,
                nextPow2: nextPow2,
                pingPong: pingPong,
                pseudoRandom: pseudoRandom,
                pseudoRandomRange: pseudoRandomRange,
                pseudoRandomRangeInt: pseudoRandomRangeInt,
                quat: quat,
                random: random,
                randomRange: randomRange,
                randomRangeInt: randomRangeInt,
                rect: rect,
                repeat: repeat$2,
                setDefaultLogTimes: setDefaultLogTimes,
                setDisplayStats: setDisplayStats,
                setPropertyEnumType: setPropertyEnumType,
                setPropertyEnumTypeOnAttrs: setPropertyEnumTypeOnAttrs,
                setRandGenerator: setRandGenerator,
                shift: shift,
                size: size,
                toDegree: toDegree,
                toRadian: toRadian,
                tween: tween,
                tweenUtil: tweenUtil,
                v2: v2$1,
                v3: v3,
                v4: v4,
                warn: warn,
                warnID: warnID
            });

            function tryDefineGlobal (name, value) {
                const _global = typeof window === 'undefined' ? global : window;
                if (typeof _global[name] === 'undefined') {
                    return (_global[name] = value);
                } else {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return _global[name];
                }
            }
            tryDefineGlobal('CC_WECHAT', false);

            const WECHAT_MINI_PROGRAM = false;

            const XIAOMI = false;
            tryDefineGlobal('CC_XIAOMI', false);
            tryDefineGlobal('CC_ALIPAY', false);

            const BYTEDANCE = false;
            tryDefineGlobal('CC_BYTEDANCE', false);
            tryDefineGlobal('CC_OPPO', false);
            tryDefineGlobal('CC_VIVO', false);
            tryDefineGlobal('CC_HUAWEI', false);
            tryDefineGlobal('CC_MIGU', false);
            tryDefineGlobal('CC_HONOR', false);
            tryDefineGlobal('CC_COCOS_RUNTIME', false);

            const EDITOR = false;
            tryDefineGlobal('CC_EDITOR', false);

            const EDITOR_NOT_IN_PREVIEW = false;

            const PREVIEW = false;
            tryDefineGlobal('CC_PREVIEW', false);
            tryDefineGlobal('CC_BUILD', true);

            const TEST = false;
            tryDefineGlobal('CC_TEST', false);
            tryDefineGlobal('CC_DEBUG', true);
            tryDefineGlobal('CC_DEV', false);
            tryDefineGlobal('CC_MINIGAME', false);
            tryDefineGlobal('CC_RUNTIME_BASED', false);
            tryDefineGlobal('CC_SUPPORT_JIT', true);
            tryDefineGlobal('CC_JSB', false);

            const USE_XR = false;

            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps) _defineProperties(Constructor.prototype, protoProps);
              if (staticProps) _defineProperties(Constructor, staticProps);
              Object.defineProperty(Constructor, "prototype", {
                writable: false
              });
              return Constructor;
            }
            function _extends() {
              _extends = Object.assign ? Object.assign.bind() : function (target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i];
                  for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                      target[key] = source[key];
                    }
                  }
                }
                return target;
              };
              return _extends.apply(this, arguments);
            }
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o);
              };
              return _getPrototypeOf(o);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
                o.__proto__ = p;
                return o;
              };
              return _setPrototypeOf(o, p);
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct) return false;
              if (Reflect.construct.sham) return false;
              if (typeof Proxy === "function") return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
                return true;
              } catch (e) {
                return false;
              }
            }
            function _construct(Parent, args, Class) {
              if (_isNativeReflectConstruct()) {
                _construct = Reflect.construct.bind();
              } else {
                _construct = function _construct(Parent, args, Class) {
                  var a = [null];
                  a.push.apply(a, args);
                  var Constructor = Function.bind.apply(Parent, a);
                  var instance = new Constructor();
                  if (Class) _setPrototypeOf(instance, Class.prototype);
                  return instance;
                };
              }
              return _construct.apply(null, arguments);
            }
            function _isNativeFunction(fn) {
              return Function.toString.call(fn).indexOf("[native code]") !== -1;
            }
            function _wrapNativeSuper(Class) {
              var _cache = typeof Map === "function" ? new Map() : undefined;
              _wrapNativeSuper = function _wrapNativeSuper(Class) {
                if (Class === null || !_isNativeFunction(Class)) return Class;
                if (typeof Class !== "function") {
                  throw new TypeError("Super expression must either be null or a function");
                }
                if (typeof _cache !== "undefined") {
                  if (_cache.has(Class)) return _cache.get(Class);
                  _cache.set(Class, Wrapper);
                }
                function Wrapper() {
                  return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                }
                Wrapper.prototype = Object.create(Class.prototype, {
                  constructor: {
                    value: Wrapper,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
                return _setPrototypeOf(Wrapper, Class);
              };
              return _wrapNativeSuper(Class);
            }
            function _assertThisInitialized(self) {
              if (self === undefined) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self;
            }
            function _unsupportedIterableToArray(o, minLen) {
              if (!o) return;
              if (typeof o === "string") return _arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor) n = o.constructor.name;
              if (n === "Map" || n === "Set") return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
            }
            function _arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length) len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
              return arr2;
            }
            function _createForOfIteratorHelperLoose(o, allowArrayLike) {
              var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
              if (it) return (it = it.call(o)).next.bind(it);
              if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
                if (it) o = it;
                var i = 0;
                return function () {
                  if (i >= o.length) return {
                    done: true
                  };
                  return {
                    done: false,
                    value: o[i++]
                  };
                };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function _toPrimitive(input, hint) {
              if (typeof input !== "object" || input === null) return input;
              var prim = input[Symbol.toPrimitive];
              if (prim !== undefined) {
                var res = prim.call(input, hint);
                if (typeof res !== "object") return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (String )(input);
            }
            function _toPropertyKey(arg) {
              var key = _toPrimitive(arg, "string");
              return typeof key === "symbol" ? key : String(key);
            }
            function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
              var desc = {};
              Object.keys(descriptor).forEach(function (key) {
                desc[key] = descriptor[key];
              });
              desc.enumerable = !!desc.enumerable;
              desc.configurable = !!desc.configurable;
              if ('value' in desc || desc.initializer) {
                desc.writable = true;
              }
              desc = decorators.slice().reverse().reduce(function (desc, decorator) {
                return decorator(target, property, desc) || desc;
              }, desc);
              if (context && desc.initializer !== undefined) {
                desc.value = desc.initializer ? desc.initializer.call(context) : undefined;
                desc.initializer = undefined;
              }
              if (desc.initializer === undefined) {
                Object.defineProperty(target, property, desc);
                desc = null;
              }
              return desc;
            }

            var debugInfos = {
            	"1006": "[Action step]. override me",
            	"1007": "[Action update]. override me",
            	"1008": "[Action reverse]. override me",
            	"1031": "Set `setter` to boolean is deprecated. Please don not use like this again.",
            	"1100": "Expected 'data' dict, but not found. Config file: %s",
            	"1101": "Please load the resource first : %s",
            	"1102": "Effect settings not found, effects will not be imported.",
            	"1103": "Success to load scene: %s",
            	"1200": "cocos2d: Director: Error in gettimeofday",
            	"1204": "Running scene should not be null",
            	"1205": "The scene should not be null",
            	"1206": "loadScene: The scene index to load (%s) is out of range.",
            	"1207": "loadScene: Unknown name type to load: '%s'",
            	"1208": "loadScene: Failed to load scene '%s' because '%s' is already being loaded.",
            	"1209": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
            	"1210": "Failed to preload '%s', %s",
            	"1211": "loadScene: The scene index to load (%s) is out of range.",
            	"1212": "loadScene: Unknown name type to load: '%s'",
            	"1213": "loadScene: Failed to load scene '%s' because '%s' is already loading",
            	"1214": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
            	"1215": "Failed to preload '%s', %s",
            	"1216": "Director.runSceneImmediate: scene is not valid",
            	"1217": "Director._initOnEngineInitialized: renderer root initialization failed",
            	"1218": "Forward render pipeline initialized.",
            	"1219": "Deferred render pipeline initialized. Note that non-transparent materials with no lighting will not be rendered, such as builtin-unlit.",
            	"1220": "Failed to set shading scale, pipelineSceneData is invalid.",
            	"1221": "Setting orientation is not supported yet.",
            	"1222": "Failed to initialize render pipeline.",
            	"1223": "Custom pipeline and legacy pipeline are all culled.",
            	"1300": "%s is not in the model pool and cannot be destroyed by destroyModel.",
            	"1400": "'%s' is deprecated, please use '%s' instead.",
            	"1404": "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
            	"1406": "'%s.%s' is removed",
            	"1408": "'%s' is removed",
            	"1409": "element type is wrong!",
            	"1502": "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
            	"1503": "cc.Scheduler.pauseTarget():target should be non-null",
            	"1504": "cc.Scheduler.resumeTarget():target should be non-null",
            	"1505": "cc.Scheduler.isTargetPaused():target should be non-null",
            	"1506": "warning: you CANNOT change update priority in scheduled function",
            	"1507": "scheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
            	"1508": "Argument callback must not be empty",
            	"1509": "Argument target must be non-nullptr",
            	"1510": "cc.Scheduler: Illegal target which doesn't have id, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
            	"1511": "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
            	"1513": "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do Scheduler.enableForTarget(target) before all scheduler API usage on target",
            	"1514": "since v3.8.0, `Scheduler.schedule(target, callback, interval)` is deprecated, please use `Scheduler.schedule(callback, target, interval)` instead.",
            	"1607": "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
            	"1619": "callback function must be non-null",
            	"1620": "interval must be positive",
            	"1623": "Set '%s' to normal node (not persist root node).",
            	"1624": "Replacing with the same sgNode",
            	"1625": "The replacement sgNode should not contain any child.",
            	"1626": "Should not set alpha via 'color', set 'opacity' please.",
            	"1627": "Not support for asynchronous creating node in SG",
            	"1632": "Node name can not include '/'.",
            	"1633": "Internal error, should not remove unknown node from parent.",
            	"1635": "reorderChild: this child is not in children list.",
            	"1636": "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
            	"1637": "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
            	"1638": "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
            	"1640": "Node %s(%s) has not attached to a scene.",
            	"1800": "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
            	"1801": "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
            	"1802": "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
            	"1803": "cc._EventListenerAcceleration.checkAvailable():_onAccelerationEvent must be non-nil",
            	"1900": "Invalid parameter.",
            	"2104": "Layer collision. The name of layer (%s) is collided with the name or value of some layer",
            	"2200": "Design resolution not valid",
            	"2201": "should set resolutionPolicy",
            	"2300": "The touches is more than MAX_TOUCHES.",
            	"2301": "Cannot create the same touch object.",
            	"2302": "The touches is more than MAX_TOUCHES, release touch id %s.",
            	"2402": "Forward pipeline startup failed!",
            	"3103": "cc.Texture.addImage(): path should be non-null",
            	"3119": "Lazy init texture with image element failed due to image loading failure: %s",
            	"3120": "Loading texture with unsupported type: '%s'. Add '%s' into 'cc.macro.SUPPORT_TEXTURE_FORMATS' please.",
            	"3121": "Can't find a texture format supported by the current platform! Please add a fallback format in the editor.",
            	"3122": "Error Texture in %s.",
            	"3123": "Set same texture %s.",
            	"3124": "Texture: setMipRange failed because base level is larger than max level",
            	"3300": "Rect width exceeds maximum margin: %s",
            	"3301": "Rect height exceeds maximum margin: %s",
            	"3500": "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
            	"3501": "Invalid listener type!",
            	"3502": "Can't set fixed priority with scene graph based listener.",
            	"3503": "Invalid parameters.",
            	"3504": "listener must be a cc.EventListener object when adding a fixed priority listener",
            	"3505": "The listener has been registered, please don't register it again.",
            	"3506": "Unsupported listener target.",
            	"3507": "Invalid scene graph priority!",
            	"3508": "If program goes here, there should be event in dispatch.",
            	"3509": "_inDispatch should be 1 here.",
            	"3510": "%s's scene graph node not contains in the parent's children",
            	"3511": "event is undefined",
            	"3512": "Event manager only support scene graph priority for ui nodes which contain UIComponent",
            	"3520": "Device Motion Event request permission: %s",
            	"3521": "Device Motion Event request permission failed: %s",
            	"3601": "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
            	"3602": "Unknown editor property '%s' in class '%s'.",
            	"3603": "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
            	"3604": "Can only indicate one type attribute for %s.",
            	"3605": "The default value of %s is not instance of %s.",
            	"3606": "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
            	"3607": "The default value of %s must be an empty string.",
            	"3608": "The type of %s must be CCString, not String.",
            	"3609": "The type of %s must be CCBoolean, not Boolean.",
            	"3610": "The type of %s must be CCFloat or CCInteger, not Number.",
            	"3611": "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
            	"3612": "%s Just set the default value to 'new %s()' and it will be handled properly.",
            	"3613": "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
            	"3614": "Should not define constructor for cc.Component %s.",
            	"3615": "Each script can have at most one Component.",
            	"3616": "Should not specify class name %s for Component which defines in project.",
            	"3618": "ctor of '%s' can not be another CCClass",
            	"3623": "Can not use 'editor' attribute, '%s' not inherits from Components.",
            	"3625": "[isChildClassOf] superclass should be function type, not",
            	"3626": "Can't remove '%s' because '%s' depends on it.",
            	"3627": "Should not add renderer component (%s) to a Canvas node.",
            	"3628": "Should not add %s to a node which size is already used by its other component.",
            	"3633": "Properties function of '%s' should return an object!",
            	"3634": "Disallow to use '.' in property name",
            	"3637": "Can not declare %s.%s, it is already defined in the prototype of %s",
            	"3639": "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
            	"3640": "'%s': the setter of '%s' is already defined!",
            	"3641": "Can not construct %s because it contains object property.",
            	"3644": "Please define 'type' parameter of %s.%s as the actual constructor.",
            	"3645": "Please define 'type' parameter of %s.%s as the constructor of %s.",
            	"3646": "Unknown 'type' parameter of %s.%s：%s",
            	"3647": "The length of range array must be equal or greater than 2",
            	"3648": "Can not declare %s.%s method, it is already defined in the properties of %s.",
            	"3652": "Failed to `new %s()` under the hood, %s\nIt is used for getting default values declared in TypeScript in the first place.\nPlease ensure the constructor can be called during the script's initialization.",
            	"3653": "Please do not specify \"default\" attribute in decorator of \"%s\" property in \"%s\" class.\nDefault value must be initialized at their declaration:\n\n \n// Before:\n@property({\n  type: cc.SpriteFrame\n  default: null  // <--\n})\nmyProp;\n// After:\n@property({\n  type: cc.SpriteFrame\n})\nmyProp = null;   // <--",
            	"3654": "Please specify a default value for \"%s.%s\" property at its declaration:\n\n \n// Before:\n@property(...)\nmyProp;\n// After:\n@property(...)\nmyProp = 0;",
            	"3655": "Can not specify \"get\" or \"set\"  attribute in decorator for \"%s\" property in \"%s\" class.\nPlease use:\n\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}",
            	"3659": "Violation error: extending enumerations shall have non-overlaped member names or member values",
            	"3660": "You are explicitly specifying `undefined` type to cc property \"%s\" of cc class \"%s\".\nIs this intended? If not, this may indicate a circular reference.\nFor example:\n\n \n// foo.ts\nimport { _decorator } from 'cc';\nimport { Bar } from './bar';  // Given that './bar' also reference 'foo.ts'.\n                              // When importing './bar', execution of './bar' is hung on to wait execution of 'foo.ts',\n                              // the `Bar` imported here is `undefined` until './bar' finish its execution.\n                              // It leads to that\n@_decorator.ccclass           //  ↓\nexport class Foo {            //  ↓\n    @_decorator.type(Bar)     //  → is equivalent to `@_decorator.type(undefined)`\n    public bar: Bar;          // To eliminate this error, either:\n                              // - Refactor your module structure(recommended), or\n                              // - specify the type as cc class name: `@_decorator.type('Bar'/* or any name you specified for `Bar` */)`\n}",
            	"3700": "internal error: _prefab is undefined",
            	"3701": "Failed to load prefab asset for node '%s'",
            	"3702": "The json file of asset %s is empty or missing.",
            	"3800": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
            	"3801": "The node can not be made persist because it's not under root node.",
            	"3802": "The node can not be made persist because it's not in current scene.",
            	"3803": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
            	"3804": "getComponent: Type must be non-nil",
            	"3805": "Can't add component '%s' because %s already contains the same component.",
            	"3806": "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
            	"3807": "addComponent: Failed to get class '%s'",
            	"3808": "addComponent: Should not add component ('%s') when the scripts are still loading.",
            	"3809": "addComponent: The component to add must be a constructor",
            	"3810": "addComponent: The component to add must be child class of cc.Component",
            	"3811": "_addComponentAt: The component to add must be a constructor",
            	"3812": "_addComponentAt: Index out of range",
            	"3813": "removeComponent: Component must be non-nil",
            	"3814": "Argument must be non-nil",
            	"3815": "Component not owned by this entity",
            	"3816": "Node '%s' is already activating",
            	"3817": "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
            	"3818": "Failed to read or parse project.json",
            	"3819": "Warning: target element is not a DIV or CANVAS",
            	"3820": "The renderer doesn't support the renderMode %s",
            	"3821": "Cannot change hierarchy while activating or deactivating the parent.",
            	"3822": "addComponent: Cannot add any component to the scene.",
            	"3823": "The enabled component (id: %s, name: %s) doesn't have a valid node",
            	"3900": "Invalid clip to add",
            	"3901": "Invalid clip to remove",
            	"3902": "clip is defaultClip, set force to true to force remove clip and animation state",
            	"3903": "animation state is playing, set force to true to force stop and remove clip and animation state",
            	"3904": "motion path of target [%s] in prop [%s] frame [%s] is not valid",
            	"3905": "sprite frames must be an Array.",
            	"3906": "Can't find easing type [%s]",
            	"3907": "Animation state is not playing or already removed",
            	"3912": "already-playing",
            	"3920": "Current context does not allow root motion.",
            	"3921": "You provided a ill-formed track path. The last component of track path should be property key, or the setter should not be empty.",
            	"3923": "Root motion is ignored since root bone could not be located in animation.",
            	"3924": "Root motion is ignored since the root bone could not be located in scene.",
            	"3925": "Target of hierarchy path should be of type Node.",
            	"3926": "Node \"%s\" has no path \"%s\".",
            	"3927": "Target of component path should be of type Node.",
            	"3928": "Node \"%s\" has no component \"%s\".",
            	"3929": "Target object has no property \"%s\".",
            	"3930": "Can not decide type for untyped track: runtime binding does not provide a getter.",
            	"3931": "Can not decide type for untyped track: got a unsupported value from runtime binding.",
            	"3932": "Common targets should only target Vectors/`Size`/`Color`.",
            	"3933": "Each curve that has common target should be numeric curve and targets string property.",
            	"3934": "Misconfigured legacy curve: the first keyframe value is number but others aren't.",
            	"3935": "We don't currently support conversion of \\`CubicSplineQuatValue\\`.",
            	"3936": "Instancing/Batching enabled for non-baked skinning model or used AnimationController '%s', this may result in unexpected rendering artifacts. Consider turning it off in the material if you do not intend to do this.",
            	"3937": "Previous error occurred when instantiating animation clip %s on node %s.",
            	"3938": "'%s' is not found from '%s'. It's specified as the root node to play animation clip '%s'.",
            	"3940": "Error when animation attempted to bind material uniform target: target %s is not a material.",
            	"3941": "Error when animation attempted to bind material uniform target: material %s has no recorded pass %s.",
            	"3942": "Error when animation attempted to bind material uniform target: material %s at pass %s has no recorded uniform %s.",
            	"3943": "Error when animation attempted to bind material uniform target: material %s at pass %s's uniform %s has no recorded channel %s.",
            	"4003": "Label font size can't be shirnked less than 0!",
            	"4004": "force notify all fonts loaded!",
            	"4011": "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
            	"4012": "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
            	"4013": "Sorry, lineHeight of system font not supported on JSB.",
            	"4200": "MaskType: IMAGE_STENCIL only support WebGL mode.",
            	"4201": "The alphaThreshold invalid in Canvas Mode.",
            	"4202": "The inverted invalid in Canvas Mode.",
            	"4300": "Can not found the %s page.",
            	"4301": "Can not add a page without UITransform.",
            	"4302": "Can not set the scroll view content when it hasn't UITransform or its parent hasn't UITransform.",
            	"4303": "The %s scrollBar on the '%s' node is not available, please check it.",
            	"4400": "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
            	"4500": "Graphics: There is no model in %s.",
            	"4501": "Graphics feature is not enabled in 'Project Settings -> Feature Cropping', %s",
            	"4600": "Script attached to '%s' is missing or invalid.",
            	"4601": "Failed to load wasm module, WebAssembly is not supported on this platform, but as a fallback Asm.js module is culled by mistake.",
            	"4700": "The dom control is not created!",
            	"4800": "unknown asset type",
            	"4901": "loadRes: should not specify the extname in %s %s",
            	"4902": "No need to release non-cached asset.",
            	"4914": "Resources url '%s' does not exist.",
            	"4915": "Pack indices and data do not match in size",
            	"4916": "Failed to download package for %s",
            	"4921": "Invalid pipe or invalid index provided!",
            	"4922": "The pipe to be inserted is already in the pipeline!",
            	"4923": "Uuid Loader: Parse asset [ %s ] failed : %s",
            	"4924": "JSON Loader: Input item doesn't contain string content",
            	"4925": "Uuid Loader: Deserialize asset [ %s ] failed : %s",
            	"4926": "Audio Downloader: no web audio context.",
            	"4927": "Audio Downloader: audio not supported on this browser!",
            	"4928": "Load %s failed!",
            	"4929": "Load Webp ( %s ) failed",
            	"4930": "Load image ( %s ) failed",
            	"4932": "Since v1.10, for any atlas (\"%s\") in the \"resources\" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.",
            	"4933": "Download Font [ %s ] failed, using Arial or system default font instead",
            	"4934": "Please assure that the full path of sub asset is correct!",
            	"4935": "Failed to skip prefab asset while deserializing PrefabInfo",
            	"5000": "You are trying to destroy a object twice or more.",
            	"5001": "object not yet destroyed",
            	"5100": "Not a plist file!",
            	"5200": "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
            	"5201": "browser don't support web audio",
            	"5202": "This feature supports WebGL render mode only.",
            	"5203": "Audio buffer cache %s has not been added.",
            	"5204": "Audio buffer %s has been cached.",
            	"5300": "Type of target to deserialize not matched with data: target is %s, data is %s",
            	"5301": "Can not find script '%s'",
            	"5302": "Can not find class '%s'",
            	"5303": "Failed to deserialize %s, missing _deserialize function.",
            	"5304": "Unable to deserialize version %s data.",
            	"5402": "cc.js.addon called on non-object:",
            	"5403": "cc.js.mixin: arguments must be type object:",
            	"5404": "The base class to extend from must be non-nil",
            	"5405": "The class to extend must be non-nil",
            	"5406": "Class should be extended before assigning any prototype members.",
            	"5500": "'notify' can not be used in 'get/set' !",
            	"5501": "'notify' must be used with 'default' !",
            	"5507": "The 'default' attribute of '%s.%s' must be an array",
            	"5508": "Invalid type of %s.%s",
            	"5510": "The 'type' attribute of '%s.%s' can not be 'Number', use cc.Float or cc.Integer instead please.",
            	"5511": "The 'type' attribute of '%s.%s' is undefined when loading script",
            	"5512": "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
            	"5513": "The 'default' value of '%s.%s' should not be used with a 'get' function.",
            	"5514": "The 'default' value of '%s.%s' should not be used with a 'set' function.",
            	"5515": "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
            	"5517": "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
            	"5601": "Can not get current scene.",
            	"5602": "Scene is destroyed",
            	"5603": "reference node is destroyed",
            	"5700": "no %s or %s on %s",
            	"5800": "%s.lerp not yet implemented.",
            	"5801": "%s.clone not yet implemented.",
            	"5802": "%s.equals not yet implemented.",
            	"5900": "MotionStreak only support WebGL mode.",
            	"5901": "cc.MotionStreak.getOpacity has not been supported.",
            	"5902": "cc.MotionStreak.setOpacity has not been supported.",
            	"6000": "Custom should not be false if file is not specified.",
            	"6001": "The new %s must not be NaN",
            	"6017": "Incomplete or corrupt PNG file",
            	"6018": "Invalid filter algorithm: %s",
            	"6019": "Invalid byte order value.",
            	"6020": "You forgot your towel!",
            	"6021": "Unknown Field Tag: %s",
            	"6022": "Too many bits requested",
            	"6023": "No bits requested",
            	"6024": "Cannot recover from missing StripByteCounts",
            	"6025": "Cannot handle sub-byte bits per sample",
            	"6026": "Cannot handle sub-byte bits per pixel",
            	"6027": "Palette image missing color map",
            	"6028": "Unknown Photometric Interpretation: %s",
            	"6029": "Unkown error",
            	"6030": "cc.ParticleSystem: error decoding or ungzipping textureImageData",
            	"6031": "cc.ParticleSystem: unknown image format with Data",
            	"6032": "cc.ParticleSystem.initWithDictionary() : error loading the texture",
            	"6033": "cc.ParticleSystem: not allowing create to be invoked twice with different particle system",
            	"6034": "cc.ParticleSystem: shouldn't be initialized repetitively, otherwise there will be potential leak",
            	"6035": "cc.ParticleSystem: change material failed, please use proper particle material",
            	"6036": "cc.ParticleSystem: life time should bigger than 1 or buffer will be insufficient",
            	"6400": "asset.url is not usable in core process",
            	"6402": "AssetLibrary has already been initialized!",
            	"6500": "Widget target must be one of the parent nodes of it",
            	"6600": "collider not added or already removed",
            	"6601": "Can't find testFunc for (%s, $s).",
            	"6700": "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time.",
            	"6705": "Argument must be non-nil",
            	"6706": "Priority can't be set in RenderRoot2D node",
            	"6800": "Callback of event must be non-nil",
            	"6801": "The message must be provided",
            	"6900": "The thing you want to instantiate must be an object",
            	"6901": "The thing you want to instantiate is nil",
            	"6902": "The thing you want to instantiate is destroyed",
            	"6903": "The instantiate method for given asset do not implemented",
            	"6904": "Can not instantiate array",
            	"6905": "Can not instantiate DOM element",
            	"7100": "%s already defined in Enum.",
            	"7101": "Sorry, 'cc.Enum' not available on this platform, please report this error here: <https://github.com/cocos-creator/engine/issues/new>",
            	"7200": "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
            	"7201": "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
            	"7202": "Add component TiledLayer into node failed.",
            	"7203": "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
            	"7210": "TMX Hexa zOrder not supported",
            	"7211": "TMX invalid value",
            	"7215": "cocos2d: Warning: TMX Layer %s has no tiles",
            	"7216": "cocos2d: TMXFormat: Unsupported TMX version: %s",
            	"7217": "cocos2d: TMXFomat: Unsupported orientation: %s",
            	"7218": "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
            	"7219": "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
            	"7221": "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
            	"7222": "Parse %s failed.",
            	"7236": "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
            	"7237": "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
            	"7238": "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
            	"7239": "cc.TMXLayer.setTileGID(): invalid gid: %s",
            	"7240": "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
            	"7241": "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
            	"7242": "TiledLayer.addUserNode node has been added.",
            	"7243": "TiledLayer.removeUserNode node is not exist",
            	"7401": "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
            	"7402": "Failed to set _animationIndex for '%s' because the index is out of range.",
            	"7501": "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
            	"7502": "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
            	"7503": "Failed to set _animationIndex for '%s' because the index is out of range.",
            	"7504": "Can not render dynamic created SkeletonData",
            	"7506": "Failed to load spine atlas '$s'",
            	"7507": "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
            	"7508": "The atlas asset of '%s' is not exists!",
            	"7509": "Spine: Animation not found: %s",
            	"7510": "Spine: Animation not found: %s",
            	"7511": "Spine: Invalid input!",
            	"7600": "The context of RenderTexture is invalid.",
            	"7601": "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
            	"7602": "Could not attach texture to the framebuffer",
            	"7603": "clearDepth isn't supported on Cocos2d-Html5",
            	"7604": "saveToFile isn't supported on Cocos2d-Html5",
            	"7605": "newCCImage isn't supported on Cocos2d-Html5",
            	"7606": "GFXTexture is null",
            	"7607": "readPixels buffer size smaller than %d",
            	"7700": "On the web is always keep the aspect ratio",
            	"7701": "Can't know status",
            	"7702": "Video player's duration is not ready to get now!",
            	"7703": "Video Downloader: video not supported on this browser!",
            	"7800": "Web does not support loading",
            	"7801": "Web does not support query history",
            	"7802": "Web does not support query history",
            	"7803": "The current browser does not support the GoBack",
            	"7804": "The current browser does not support the GoForward",
            	"7805": "Web does not support zoom",
            	"7900": "cc.math.Matrix3.assign(): current matrix equals matIn",
            	"7901": "cc.math.mat4Assign(): pOut equals pIn",
            	"7902": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
            	"7903": "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
            	"7904": "cc.math.Matrix4.extractPlane: Invalid plane index",
            	"7905": "cc.math.mat4Assign(): pOut equals pIn",
            	"7906": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
            	"7907": "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
            	"7908": "Invalid matrix mode specified",
            	"7909": "current quaternion is an invalid value",
            	"8000": "Can't handle this field type or size",
            	"8001": "No bytes requested",
            	"8002": "Too many bytes requested",
            	"8003": "Missing StripByteCounts!",
            	"8100": "cocos2d: ERROR: Failed to compile shader:\n %s",
            	"8101": "cocos2d: ERROR: Failed to compile vertex shader",
            	"8102": "cocos2d: ERROR: Failed to compile fragment shader",
            	"8103": "cc.GLProgram.link(): Cannot link invalid program",
            	"8104": "cocos2d: ERROR: Failed to link program: %s",
            	"8105": "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
            	"8106": "Please load the resource firset : %s",
            	"8107": "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
            	"8108": "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
            	"8109": "modelView matrix is undefined.",
            	"8200": "Please set node's active instead of rigidbody's enabled.",
            	"8300": "Should only one camera exists, please check your project.",
            	"8301": "Camera does not support Canvas Mode.",
            	"8302": "Camera.viewport is deprecated, please use setViewportInOrientedSpace instead.",
            	"8400": "Wrong type arguments, 'filePath' must be a String.",
            	"9000": "Stencil manager does not support level bigger than %d in this device.",
            	"9001": "Stencil manager is already empty, cannot pop any mask",
            	"9002": "Failed to request any buffer from a mesh buffer without accessor",
            	"9003": "The internal state of LinearBufferAccessor have severe issue and irreversible, please check the reason",
            	"9004": "Failed to allocate chunk in StaticVBAccessor, the requested buffer might be too large: %d bytes",
            	"9005": "BATCHER2D_MEM_INCREMENT is too large, the Max value for BATCHER2D_MEM_INCREMENT is 2303KB (smaller than 65536 *9* 4 / 1024 = 2304KB)",
            	"9006": "QuadRenderData is removed, please use MeshRenderData instead.",
            	"9007": "Since v3.6, Because mask changes the inheritance relationship, you can directly manipulate the rendering components under the same node to complete the operation.",
            	"9008": "request fullscreen is not supported on this platform.",
            	"9009": "exit fullscreen is not supported on this platform.",
            	"9100": "texture size exceeds current device limits %d/%d",
            	"9101": "The length of the TypedArrayBuffer must be an integer.",
            	"9201": "Cannot access game frame or container.",
            	"9202": "Setting window size is not supported.",
            	"9300": "The current buffer beyond the limit in ui static component, please reduce the amount",
            	"9301": "The UI has not been initialized",
            	"9302": "Can't getGFXSampler with out device",
            	"9600": "[Physics]: please check to see if physics modules are included",
            	"9610": "[Physics]: cannon.js physics system doesn't support capsule collider",
            	"9611": "[Physics]: builtin physics system doesn't support mesh collider",
            	"9612": "[Physics]: builtin physics system doesn't support cylinder collider",
            	"9613": "[Physics]: cannon.js physics system doesn't support hinge drive and angular limit",
            	"9620": "[Physics][Ammo]: changing the mesh is not supported after the initialization is completed",
            	"9630": "[Physics]: A dynamic rigid body can not have the following collider shapes: Terrain, Plane and Non-convex Mesh. Node name: %s",
            	"9640": "[Physics][builtin]: sweep functions are not supported in builtin",
            	"9641": "[Physics][cannon.js]: sweep functions are not supported in cannon.js",
            	"9642": "[Physics] PhysicsSystem initDefaultMaterial() Failed to load builtinMaterial.",
            	"9643": "[Physics] Failed to load user customized default physics material: %s, will fallback to built-in default physics material",
            	"9644": "[Physics] Failed to find ear. There might be self-intersection in the polygon.",
            	"10001": "The sub-mesh contains %d vertices, which beyonds the capability (%d vertices most) of renderer of your platform.",
            	"10002": "Sub-mesh may include at most %d morph targets, but you specified %d.",
            	"11000": "WebGL context lost.",
            	"12001": "BlendFactors are disabled when using custom material, please modify the blend state in the material instead.",
            	"12002": "Can't add renderable component to this node because it already have one.",
            	"12004": "SubModel can only support %d passes.",
            	"12005": "Material already initialized, request aborted.",
            	"12006": "Pass already destroyed.",
            	"12007": "This is old usage, please swap the parameters.",
            	"12008": "GeometryRenderer: too many lines.",
            	"12009": "GeometryRenderer: too many triangles.",
            	"12010": "PassUtils: illegal uniform handle, accessing uniform at offset %d",
            	"12011": "Pass: setUniform is invoked with incompatible uniform data type for binding %d, expected type is %s",
            	"12012": "Can't set a material instance to a sharedMaterial slot",
            	"12100": "The font size is too big to be fitted into texture atlas. Please switch to other label cache modes or choose a smaller font size.",
            	"12101": "The asset %s has been destroyed!",
            	"12102": "Base pass cannot override states, please use pass instance instead.",
            	"12103": "Custom pipeline create shader %s failed. Please reimport all effects (Menu->Developer->Refresh All Effect) and restart creator.",
            	"12104": "Create shader %s failed.",
            	"12105": "Pass resources incomplete.",
            	"12106": "Cannot patch non-builtin macros.",
            	"12107": "Custom pipeline invalid render pass, program: %s. Please reimport all effects (Menu->Developer->Refresh All Effect) and restart creator.",
            	"12108": "Custom pipeline invalid render phase, program: %s. Please reimport all effects (Menu->Developer->Refresh All Effect) and restart creator.",
            	"12109": "custom-pipeline module not available.",
            	"12110": "MaterialPass passID in legacy pipeline is wrongly initialized.",
            	"13100": "Incorrect CCON magic.",
            	"13101": "Unknown CCON version number: %d.",
            	"13102": "CCON Format error.",
            	"13103": "Can not encode CCON binary: lack of text encoder.",
            	"13104": "Can not decode CCON binary: lack of text decoder.",
            	"14000": "State machine matched too many transitions(greater than %s) during this frame: %s.",
            	"14100": "Pool.destroy no longer take a function as parameter, Please specify destruct function in the construction of Pool instead",
            	"14200": "Can not update a static mesh.",
            	"14201": "The primitiveIndex is out of range.",
            	"14202": "meshopt asm decoder initialized",
            	"14203": "meshopt wasm decoder initialized",
            	"14204": "meshopt decoder error: %d",
            	"14300": "Can not keep world transform due to the zero scaling of parent node",
            	"14400": "Spline error: less than 2 knots.",
            	"14401": "Spline error: less than 4 knots or not a multiple of 4.\n\n<!-- Rendering algorithm reserved: 15000 - 16000 -->",
            	"15000": "Can not find corresponding diffuse map for environment lighting, use hemisphere diffuse instead, change environment lighting type to regenerate diffuse map",
            	"15001": "Can not find environment map, disable IBL lighting",
            	"15002": "Diffuse map resource is missing, please change environment lighting type to regenerate resource",
            	"15003": "The shadow visible distance is so small that CSM stratification is not effective, Please change the value of shadowDistance so that it is 10 times greater than 0.1",
            	"15004": "The native folder may be generated from older versions, please refer <https://docs.cocos.com/creator/manual/en/release-notes/> to upgrade.",
            	"15100": "Camera '%s' clear flag is skybox, but skybox is disabled,  may cause strange background effect, please set camera clear flag to solid color.",
            	"16000": "'%s' is deprecated since v%s.",
            	"16001": "'%s' is deprecated since v%s, please use '%s' instead.",
            	"16002": "'%s' is removed since v%s.",
            	"16003": "'%s' is removed since v%s, please use '%s' instead.",
            	"16101": "The effect('%s') you are looking for does not exist, please confirm the effect name in the editor. NOTE: Since 3.6, the name of the built-in effect has been changed to its name in the editor, please check it out. More information please refer to <https://docs.cocos.com/creator/manual/en/shader/effect-inspector.html>",
            	"16201": "The asset replacing failed, can not found override asset('%s') for '%s'",
            	"16300": "node '%s' doesn't have any UIRenderer component, this component will not work. please add UIRenderer component first",
            	"16301": "node '%s' doesn't have any ModelRenderer component, this component will not work. please add ModelRenderer component first",
            	"16302": "There is no reflection probe in the scene or no probe is near the current object. No reflection probe will take effect on this object. Please create a new reflection probe or move existing ones closer.",
            	"16303": "Skin material needs floating-point render target, please check ENABLE_FLOAT_OUTPUT define in Project Settings--Macro",
            	"16304": "Skin material may need more accurate calculations, please select a head model of standard size, check the isGlobalStandardSkinObject option in the MeshRender component.",
            	"16305": "failed to stop accelerometer",
            	"16306": "The data must have positions field",
            	"16307": "please change type to sprite_stencil first",
            	"16308": "illegal index count!",
            	"16309": "Unsupported Format, convert to WebGL internal format failed.",
            	"16310": "Unsupported Format, convert to WebGL format failed.",
            	"16311": "Unsupported GLType, convert to GL type failed.",
            	"16312": "Unsupported GLType, convert to TypedArrayConstructor failed.",
            	"16313": "Unsupported GLType, convert to Type failed.",
            	"16314": "Unsupported GLType, get type failed.",
            	"16315": "Unsupported BufferType, create buffer failed.",
            	"16316": "Unsupported BufferType, update buffer failed.",
            	"16317": "Unsupported TextureType, create texture failed.",
            	"16318": "glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
            	"16319": "glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
            	"16320": "glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
            	"16321": "glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED",
            	"16322": "Unsupported ShaderType.",
            	"16323": "%s in '%s' compilation failed.",
            	"16324": "Shader source dump: %s",
            	"16325": "Shader '%s' compilation succeeded.",
            	"16326": "Failed to link shader: %s",
            	"16327": "Unsupported GL texture type, copy buffer to texture failed.",
            	"16328": "Command 'draw' must be recorded inside a render pass.",
            	"16329": "Command 'updateBuffer' must be recorded outside a render pass.",
            	"16330": "Command 'copyBufferToTexture' must be recorded outside a render pass.",
            	"16331": "InputAssemblerInfo.vertexBuffers is null.",
            	"16332": "Illegal index buffer stride.",
            	"16333": "This device does not support WebGL.",
            	"16334": "A Class already exists with the same %s : %s. %s",
            	"16335": "\"%s\" has already been set as name or alias of another class.",
            	"16336": "\"%s\" has already been set as id or alias of another class.",
            	"16337": "can not support canvas rendering in 3D",
            	"16338": "The '_$erialized' prop in MissingScript is missing. Please contact jare.",
            	"16339": "Error props: ['%s']",
            	"16340": "Error when checking MissingScript 5, %s",
            	"16341": "The '_$erialized' prop of MissingScript is missing. Will force the raw data to be save.",
            	"16342": "Error props: ['%s']. Please contact jare.",
            	"16343": "Unable to stash previously serialized data. %s",
            	"16344": "Error when checking MissingScript 6, %s",
            	"16345": "uniform '%s' must have a count",
            	"16346": "Invalid GFX API!",
            	"16347": "The number of mipmaps of each face is different.",
            	"16348": "builtin UBO '%s' not available!",
            	"16349": "builtin samplerTexture '%s' not available!",
            	"16350": "The asset %s is missing!",
            	"16351": "the native asset of %s is missing!",
            	"16352": "The asset %s is invalid for some reason, detail message: %s, stack: %s",
            	"16353": "Can't find letter in this bitmap-font",
            	"16354": "Can't find letter definition in texture atlas %s for letter:%s",
            	"16355": "Can't find letter definition in font family %s for letter: %s",
            	"16356": "wrong format of version when compare version",
            	"16357": "should use Vec3.multiply for vector * vector operation",
            	"16358": "should use Vec3.scale for vector * scalar operation",
            	"16359": "should use Vec2.multiply for vector * vector operation",
            	"16360": "should use Vec2.scale for vector * scalar operation",
            	"16361": "should use Vec4.multiply for vector * vector operation",
            	"16362": "should use Vec4.scale for vector * scalar operation",
            	"16363": "Unable to get device",
            	"16364": "bitNum can't be undefined",
            	"16365": "maximum layers reached.",
            	"16366": "do not change buildin layers.",
            	"16367": "name can't be undefined",
            	"16368": "Unable to access unknown layer.",
            	"16369": "unknown define type '%s'",
            	"16370": "Shaders in material asset '%s' cannot be modified at runtime, please instantiate the material first.",
            	"16371": "Pipeline states in material asset '%s' cannot be modified at runtime, please instantiate the material first.",
            	"16372": "illegal pass index: %s.",
            	"16373": "illegal property name: %s.",
            	"16374": "Unexpected attribute!",
            	"16375": "Unexpected: failed to create morph texture?",
            	"16376": "The fnt config is not exists!",
            	"16377": "SpriteAtlas is null.",
            	"16378": "node '%s' doesn't have any renderable component",
            	"16379": "cannot resize buffer views!",
            	"16380": "cannot update through buffer views!",
            	"16381": "Profiler._stats is deprecated, please use Profiler.stats instead.",
            	"16382": "reverse: could not reverse a non-relative action",
            	"16383": "Need 'clone' for custom prop '%s'",
            	"16384": "Need 'add' for custom prop '%s'",
            	"16385": "Need 'sub' for custom prop '%s' in reverse mode",
            	"16386": "TweenAction: '%s' can't be converted to number",
            	"16387": "Wrong return type for 'progress', number or string needed",
            	"16388": "reverse: current tween could not be reversed, empty actions",
            	"16389": "pause: tween wasn't started, can't pause",
            	"16390": "resume: tween wasn't started, can't resume",
            	"16391": "reverse: could not find action id %s",
            	"16392": "Please set target to tween first",
            	"16393": "start: no actions in Tween",
            	"16394": "repeatForever: the last action is not ActionInterval",
            	"16395": "reverseTime: the last action is not ActionInterval",
            	"16396": "tweenUtil' is deprecated, please use 'tween' instead",
            	"16397": "ProgressBar FILLED mode only works when barSprite's Type is FILLED!",
            	"16398": "ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!",
            	"16399": "CopyTextureToBuffers: not supported texture target.",
            	"16400": "Limit values to be greater than 0",
            	"16401": "beginRenderPass: Only primary command buffer is supported.",
            	"16402": "execute is not supported.",
            	"16403": "GPU memory alias is not supported",
            	"16404": "Block '%s' does not bound",
            	"16405": "This device does not support WebGL2",
            	"16406": "Can't find the spriteFrame of tilesets %s",
            	"16407": "Spline error: invalid mode",
            	"16408": "[Physics2D] b2PolygonShape failed to decompose polygon into convex polygons, node name: %s",
            	"16409": "setVertexEffectDelegate is deprecated since spine 4.2.",
            	"16410": "Debug bones or slots is invalid in cached mode.",
            	"16411": "Slots visible range can not be modified in cached mode.",
            	"16412": "Track index can not greater than 0 in cached mode.",
            	"16413": "Track index can not greater than 0 in cached mode.",
            	"16414": "'getCurrent' interface can not be invoked in cached mode.",
            	"16415": "cached mode not support setMix!!!",
            	"16416": "'clearTracks' interface can not be invoked in cached mode.",
            	"16417": "'clearTrack' interface can not be invoked in cached mode.",
            	"16418": "Debug bones or slots is invalid in cached mode.",
            	"16419": "Spine version not supported.",
            	"0100": "%s not yet implemented.",
            	"0200": "You should specify a valid DOM canvas element."
            };

            var _global = typeof window === 'undefined' ? global : window;
            var cclegacy = exports("cclegacy", {
              _global: _global
            });
            var legacyCC = cclegacy;
            cclegacy.internal = {};
            var engineVersion = exports("VERSION", '3.8.7');
            _global.CocosEngine = legacyCC.ENGINE_VERSION = engineVersion;
            _global.cc = legacyCC;
            var ccwindow = typeof globalThis.jsb !== 'undefined' ? typeof jsb.window !== 'undefined' ? jsb.window : globalThis : globalThis;
            _global.ccwindow = ccwindow;

            var ccdocument$2 = ccwindow.document;
            var logList = null;
            var ccLog = console.log.bind(console);
            var ccWarn = ccLog;
            var ccError = ccLog;
            var ccAssert = function ccAssert(condition, message) {
              if (!condition) {
                for (var _len = arguments.length, optionalParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                  optionalParams[_key - 2] = arguments[_key];
                }
                console.log("ASSERT: " + formatString.apply(undefined, [message].concat(optionalParams)));
              }
            };
            var ccDebug = ccLog;
            function formatString() {
              for (var _len2 = arguments.length, data = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                data[_key2] = arguments[_key2];
              }
              return legacyCC.js.formatStr.apply(null, data);
            }
            function log() {
              return ccLog.apply(undefined, arguments);
            }
            function warn() {
              return ccWarn.apply(undefined, arguments);
            }
            function error() {
              return ccError.apply(undefined, arguments);
            }
            function assert(condition, message) {
              for (var _len3 = arguments.length, optionalParams = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
                optionalParams[_key3 - 2] = arguments[_key3];
              }
              return ccAssert.apply(undefined, [condition, message].concat(optionalParams));
            }
            function debug() {
              return ccDebug.apply(undefined, arguments);
            }
            function _resetDebugSetting(mode) {
              ccLog = ccWarn = ccError = ccAssert = ccDebug = function ccDebug() {};
              if (mode === 0) {
                return;
              }
              if (mode > 4) {
                var logToWebPage = function logToWebPage(msg) {
                  if (!legacyCC.game.canvas) {
                    return;
                  }
                  if (!logList) {
                    var logDiv = ccdocument$2.createElement('Div');
                    logDiv.setAttribute('id', 'logInfoDiv');
                    logDiv.setAttribute('width', '200');
                    var height = legacyCC.game.canvas.height;
                    logDiv.setAttribute('height', "" + height);
                    var logDivStyle = logDiv.style;
                    logDivStyle.zIndex = '99999';
                    logDivStyle.position = 'absolute';
                    logDivStyle.top = logDivStyle.left = '0';
                    logList = ccdocument$2.createElement('textarea');
                    logList.setAttribute('rows', '20');
                    logList.setAttribute('cols', '30');
                    logList.setAttribute('disabled', 'true');
                    var logListStyle = logList.style;
                    logListStyle.backgroundColor = 'transparent';
                    logListStyle.borderBottom = '1px solid #cccccc';
                    logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = '0px';
                    logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = 'none';
                    logListStyle.padding = '0px';
                    logListStyle.margin = '0px';
                    logDiv.appendChild(logList);
                    legacyCC.game.canvas.parentNode.appendChild(logDiv);
                  }
                  logList.value = logList.value + msg + "\r\n";
                  logList.scrollTop = logList.scrollHeight;
                };
                ccError = function ccError() {
                  logToWebPage("ERROR :  " + formatString.apply(undefined, arguments));
                };
                ccAssert = function ccAssert(condition, message) {
                  if (!condition) {
                    for (var _len4 = arguments.length, optionalParams = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
                      optionalParams[_key4 - 2] = arguments[_key4];
                    }
                    logToWebPage("ASSERT: " + formatString.apply(undefined, [message].concat(optionalParams)));
                  }
                };
                if (mode !== 7) {
                  ccWarn = function ccWarn() {
                    logToWebPage("WARN :  " + formatString.apply(undefined, arguments));
                  };
                }
                if (mode === 5) {
                  ccLog = function ccLog() {
                    logToWebPage(formatString.apply(undefined, arguments));
                  };
                }
              } else if (console) {
                if (!console.error) {
                  console.error = console.log;
                }
                if (!console.warn) {
                  console.warn = console.log;
                }
                if (console.error.bind) {
                  ccError = console.error.bind(console);
                } else {
                  ccError = function () {
                    for (var _len5 = arguments.length, data = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                      data[_key5] = arguments[_key5];
                    }
                    return console.error.apply(console, data);
                  };
                }
                ccAssert = function ccAssert(condition, message) {
                  if (!condition) {
                    for (var _len6 = arguments.length, optionalParams = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
                      optionalParams[_key6 - 2] = arguments[_key6];
                    }
                    var errorText = formatString.apply(undefined, [message].concat(optionalParams));
                    {
                      throw new Error(errorText);
                    }
                  }
                };
              }
              if (mode !== 4) {
                if (console.warn.bind) {
                  ccWarn = console.warn.bind(console);
                } else {
                  ccWarn = function () {
                    for (var _len7 = arguments.length, data = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
                      data[_key7] = arguments[_key7];
                    }
                    return console.warn.apply(console, data);
                  };
                }
              }
              if (mode <= 2) {
                if (console.log.bind) {
                  ccLog = console.log.bind(console);
                } else {
                  ccLog = function ccLog() {
                    for (var _len8 = arguments.length, data = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
                      data[_key8] = arguments[_key8];
                    }
                    return console.log.apply(console, data);
                  };
                }
              }
              if (mode <= 1) {
                if (typeof console.debug === 'function') {
                  var vendorDebug = console.debug.bind(console);
                  ccDebug = function ccDebug() {
                    return vendorDebug.apply(undefined, arguments);
                  };
                }
              }
            }
            function _throw(error_) {
              {
                var stack = error_.stack;
                if (stack) {
                  error(stack);
                } else {
                  error(error_);
                }
                return undefined;
              }
            }
            function getTypedFormatter(type) {
              return function (id) {
                var msg = debugInfos[id] || 'unknown id' ;
                for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
                  args[_key9 - 1] = arguments[_key9];
                }
                if (args.length === 0) {
                  return msg;
                }
                return formatString.apply(undefined, [msg].concat(args)) ;
              };
            }
            var logFormatter = getTypedFormatter();
            function logID(id) {
              for (var _len10 = arguments.length, optionalParams = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {
                optionalParams[_key10 - 1] = arguments[_key10];
              }
              log(logFormatter.apply(undefined, [id].concat(optionalParams)));
            }
            var debugFormatter = getTypedFormatter();
            function debugID(id) {
              for (var _len11 = arguments.length, optionalParams = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {
                optionalParams[_key11 - 1] = arguments[_key11];
              }
              debug(debugFormatter.apply(undefined, [id].concat(optionalParams)));
            }
            var warnFormatter = getTypedFormatter();
            function warnID(id) {
              for (var _len12 = arguments.length, optionalParams = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {
                optionalParams[_key12 - 1] = arguments[_key12];
              }
              warn(warnFormatter.apply(undefined, [id].concat(optionalParams)));
            }
            var errorFormatter = getTypedFormatter();
            function errorID(id) {
              for (var _len13 = arguments.length, optionalParams = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {
                optionalParams[_key13 - 1] = arguments[_key13];
              }
              error(errorFormatter.apply(undefined, [id].concat(optionalParams)));
            }
            var assertFormatter = getTypedFormatter();
            function assertID(condition, id) {
              if (condition) {
                return;
              }
              for (var _len14 = arguments.length, optionalParams = new Array(_len14 > 2 ? _len14 - 2 : 0), _key14 = 2; _key14 < _len14; _key14++) {
                optionalParams[_key14 - 2] = arguments[_key14];
              }
              assert(false, assertFormatter.apply(undefined, [id].concat(optionalParams)));
            }
            var DebugMode = exports("DebugMode", {
              NONE: 0,
              VERBOSE: 1,
              INFO: 2,
              WARN: 3,
              ERROR: 4,
              INFO_FOR_WEB_PAGE: 5,
              WARN_FOR_WEB_PAGE: 6,
              ERROR_FOR_WEB_PAGE: 7
            });
            function getError(errorId) {
              for (var _len15 = arguments.length, param = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
                param[_key15 - 1] = arguments[_key15];
              }
              return errorFormatter.apply(undefined, [errorId].concat(param));
            }
            function isDisplayStats() {
              return legacyCC.profiler ? legacyCC.profiler.isShowingStats() : false;
            }
            function setDisplayStats(displayStats) {
              if (legacyCC.profiler) {
                displayStats ? legacyCC.profiler.showStats() : legacyCC.profiler.hideStats();
              }
            }

            var debug$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                DebugMode: DebugMode,
                _resetDebugSetting: _resetDebugSetting,
                _throw: _throw,
                assert: assert,
                assertID: assertID,
                debug: debug,
                debugID: debugID,
                error: error,
                errorID: errorID,
                getError: getError,
                isDisplayStats: isDisplayStats,
                log: log,
                logID: logID,
                setDisplayStats: setDisplayStats,
                warn: warn,
                warnID: warnID
            });

            function find(path, referenceNode) {
              if (!referenceNode) {
                var scene = legacyCC.director.getScene();
                if (!scene) {
                  return null;
                }
                referenceNode = scene;
              }
              return referenceNode.getChildByPath(path);
            }
            legacyCC.find = find;

            function toPPM(buffer, w, h) {
              return "P3 " + w + " " + h + " 255\n" + buffer.filter(function (e, i) {
                return i % 4 < 3;
              }).toString() + "\n";
            }

            var GarbageCollectionManager = function () {
              function GarbageCollectionManager() {
                this._finalizationRegistry = null;
                this._gcObjects = new WeakMap();
              }
              var _proto = GarbageCollectionManager.prototype;
              _proto.registerGCObject = function registerGCObject(gcObject) {
                {
                  return gcObject;
                }
              };
              _proto.init = function init() {};
              _proto.finalizationRegistryCallback = function finalizationRegistryCallback(token) {
                return;
              };
              _proto.destroy = function destroy() {};
              return GarbageCollectionManager;
            }();
            var garbageCollectionManager = exports("garbageCollectionManager", new GarbageCollectionManager());

            var GCObject = exports("GCObject", function () {
              function GCObject() {
                return garbageCollectionManager.registerGCObject(this);
              }
              var _proto = GCObject.prototype;
              _proto.destroy = function destroy() {};
              return GCObject;
            }());

            var deepCopy = function deepCopy(target, source, Ctor) {
              for (var i = 0; i < source.length; ++i) {
                if (target.length <= i) target.push(new Ctor());
                target[i].copy(source[i]);
              }
              target.length = source.length;
            };
            var ObjectType = {
              UNKNOWN: 0,
              SWAPCHAIN: 1,
              BUFFER: 2,
              TEXTURE: 3,
              RENDER_PASS: 4,
              FRAMEBUFFER: 5,
              SAMPLER: 6,
              SHADER: 7,
              DESCRIPTOR_SET_LAYOUT: 8,
              PIPELINE_LAYOUT: 9,
              PIPELINE_STATE: 10,
              DESCRIPTOR_SET: 11,
              INPUT_ASSEMBLER: 12,
              COMMAND_BUFFER: 13,
              QUEUE: 14,
              QUERY_POOL: 15,
              GLOBAL_BARRIER: 16,
              TEXTURE_BARRIER: 17,
              BUFFER_BARRIER: 18,
              COUNT: 19
            };
            var Status = {
              UNREADY: 0,
              FAILED: 1,
              SUCCESS: 2
            };
            var API = {
              UNKNOWN: 0,
              GLES2: 1,
              GLES3: 2,
              METAL: 3,
              VULKAN: 4,
              NVN: 5,
              WEBGL: 6,
              WEBGL2: 7,
              WEBGPU: 8
            };
            var SurfaceTransform = {
              IDENTITY: 0,
              ROTATE_90: 1,
              ROTATE_180: 2,
              ROTATE_270: 3
            };
            var Feature$1 = {
              ELEMENT_INDEX_UINT: 0,
              INSTANCED_ARRAYS: 1,
              MULTIPLE_RENDER_TARGETS: 2,
              BLEND_MINMAX: 3,
              COMPUTE_SHADER: 4,
              INPUT_ATTACHMENT_BENEFIT: 5,
              SUBPASS_COLOR_INPUT: 6,
              SUBPASS_DEPTH_STENCIL_INPUT: 7,
              RASTERIZATION_ORDER_NOCOHERENT: 8,
              MULTI_SAMPLE_RESOLVE_DEPTH_STENCIL: 9,
              COUNT: 10
            };
            var Format = {
              UNKNOWN: 0,
              A8: 1,
              L8: 2,
              LA8: 3,
              R8: 4,
              R8SN: 5,
              R8UI: 6,
              R8I: 7,
              R16F: 8,
              R16UI: 9,
              R16I: 10,
              R32F: 11,
              R32UI: 12,
              R32I: 13,
              RG8: 14,
              RG8SN: 15,
              RG8UI: 16,
              RG8I: 17,
              RG16F: 18,
              RG16UI: 19,
              RG16I: 20,
              RG32F: 21,
              RG32UI: 22,
              RG32I: 23,
              RGB8: 24,
              SRGB8: 25,
              RGB8SN: 26,
              RGB8UI: 27,
              RGB8I: 28,
              RGB16F: 29,
              RGB16UI: 30,
              RGB16I: 31,
              RGB32F: 32,
              RGB32UI: 33,
              RGB32I: 34,
              RGBA8: 35,
              BGRA8: 36,
              SRGB8_A8: 37,
              RGBA8SN: 38,
              RGBA8UI: 39,
              RGBA8I: 40,
              RGBA16F: 41,
              RGBA16UI: 42,
              RGBA16I: 43,
              RGBA32F: 44,
              RGBA32UI: 45,
              RGBA32I: 46,
              R5G6B5: 47,
              R11G11B10F: 48,
              RGB5A1: 49,
              RGBA4: 50,
              RGB10A2: 51,
              RGB10A2UI: 52,
              RGB9E5: 53,
              DEPTH: 54,
              DEPTH_STENCIL: 55,
              BC1: 56,
              BC1_ALPHA: 57,
              BC1_SRGB: 58,
              BC1_SRGB_ALPHA: 59,
              BC2: 60,
              BC2_SRGB: 61,
              BC3: 62,
              BC3_SRGB: 63,
              BC4: 64,
              BC4_SNORM: 65,
              BC5: 66,
              BC5_SNORM: 67,
              BC6H_UF16: 68,
              BC6H_SF16: 69,
              BC7: 70,
              BC7_SRGB: 71,
              ETC_RGB8: 72,
              ETC2_RGB8: 73,
              ETC2_SRGB8: 74,
              ETC2_RGB8_A1: 75,
              ETC2_SRGB8_A1: 76,
              ETC2_RGBA8: 77,
              ETC2_SRGB8_A8: 78,
              EAC_R11: 79,
              EAC_R11SN: 80,
              EAC_RG11: 81,
              EAC_RG11SN: 82,
              PVRTC_RGB2: 83,
              PVRTC_RGBA2: 84,
              PVRTC_RGB4: 85,
              PVRTC_RGBA4: 86,
              PVRTC2_2BPP: 87,
              PVRTC2_4BPP: 88,
              ASTC_RGBA_4X4: 89,
              ASTC_RGBA_5X4: 90,
              ASTC_RGBA_5X5: 91,
              ASTC_RGBA_6X5: 92,
              ASTC_RGBA_6X6: 93,
              ASTC_RGBA_8X5: 94,
              ASTC_RGBA_8X6: 95,
              ASTC_RGBA_8X8: 96,
              ASTC_RGBA_10X5: 97,
              ASTC_RGBA_10X6: 98,
              ASTC_RGBA_10X8: 99,
              ASTC_RGBA_10X10: 100,
              ASTC_RGBA_12X10: 101,
              ASTC_RGBA_12X12: 102,
              ASTC_SRGBA_4X4: 103,
              ASTC_SRGBA_5X4: 104,
              ASTC_SRGBA_5X5: 105,
              ASTC_SRGBA_6X5: 106,
              ASTC_SRGBA_6X6: 107,
              ASTC_SRGBA_8X5: 108,
              ASTC_SRGBA_8X6: 109,
              ASTC_SRGBA_8X8: 110,
              ASTC_SRGBA_10X5: 111,
              ASTC_SRGBA_10X6: 112,
              ASTC_SRGBA_10X8: 113,
              ASTC_SRGBA_10X10: 114,
              ASTC_SRGBA_12X10: 115,
              ASTC_SRGBA_12X12: 116,
              COUNT: 117
            };
            var FormatType = {
              NONE: 0,
              UNORM: 1,
              SNORM: 2,
              UINT: 3,
              INT: 4,
              UFLOAT: 5,
              FLOAT: 6
            };
            var SampleType = {
              FLOAT: 0,
              UNFILTERABLE_FLOAT: 1,
              SINT: 2,
              UINT: 3
            };
            var Type = {
              UNKNOWN: 0,
              BOOL: 1,
              BOOL2: 2,
              BOOL3: 3,
              BOOL4: 4,
              INT: 5,
              INT2: 6,
              INT3: 7,
              INT4: 8,
              UINT: 9,
              UINT2: 10,
              UINT3: 11,
              UINT4: 12,
              FLOAT: 13,
              FLOAT2: 14,
              FLOAT3: 15,
              FLOAT4: 16,
              MAT2: 17,
              MAT2X3: 18,
              MAT2X4: 19,
              MAT3X2: 20,
              MAT3: 21,
              MAT3X4: 22,
              MAT4X2: 23,
              MAT4X3: 24,
              MAT4: 25,
              SAMPLER1D: 26,
              SAMPLER1D_ARRAY: 27,
              SAMPLER2D: 28,
              SAMPLER2D_ARRAY: 29,
              SAMPLER3D: 30,
              SAMPLER_CUBE: 31,
              SAMPLER: 32,
              TEXTURE1D: 33,
              TEXTURE1D_ARRAY: 34,
              TEXTURE2D: 35,
              TEXTURE2D_ARRAY: 36,
              TEXTURE3D: 37,
              TEXTURE_CUBE: 38,
              IMAGE1D: 39,
              IMAGE1D_ARRAY: 40,
              IMAGE2D: 41,
              IMAGE2D_ARRAY: 42,
              IMAGE3D: 43,
              IMAGE_CUBE: 44,
              SUBPASS_INPUT: 45,
              COUNT: 46
            };
            var BufferUsageBit = {
              NONE: 0,
              TRANSFER_SRC: 1,
              TRANSFER_DST: 2,
              INDEX: 4,
              VERTEX: 8,
              UNIFORM: 16,
              STORAGE: 32,
              INDIRECT: 64
            };
            var BufferFlagBit = {
              NONE: 0,
              ENABLE_STAGING_WRITE: 1
            };
            var MemoryAccessBit = {
              NONE: 0,
              READ_ONLY: 1,
              WRITE_ONLY: 2,
              READ_WRITE: 3
            };
            var MemoryUsageBit = {
              NONE: 0,
              DEVICE: 1,
              HOST: 2
            };
            var TextureType = {
              TEX1D: 0,
              TEX2D: 1,
              TEX3D: 2,
              CUBE: 3,
              TEX1D_ARRAY: 4,
              TEX2D_ARRAY: 5
            };
            var ViewDimension = {
              UNKNOWN: 0,
              BUFFER: 1,
              TEX1D: 2,
              TEX1D_ARRAY: 3,
              TEX2D: 4,
              TEX2D_ARRAY: 5,
              TEX2DMS: 6,
              TEX2DMS_ARRAY: 7,
              TEX3D: 8,
              TEXCUBE: 9,
              TEXCUBE_ARRAY: 10,
              RAYTRACING_ACCELERATION_STRUCTURE: 11
            };
            var TextureUsageBit = {
              NONE: 0,
              TRANSFER_SRC: 1,
              TRANSFER_DST: 2,
              SAMPLED: 4,
              STORAGE: 8,
              COLOR_ATTACHMENT: 16,
              DEPTH_STENCIL_ATTACHMENT: 32,
              INPUT_ATTACHMENT: 64,
              SHADING_RATE: 128
            };
            var TextureFlagBit = {
              NONE: 0,
              GEN_MIPMAP: 1,
              GENERAL_LAYOUT: 2,
              EXTERNAL_OES: 4,
              EXTERNAL_NORMAL: 8,
              LAZILY_ALLOCATED: 16,
              MUTABLE_VIEW_FORMAT: 64,
              MUTABLE_STORAGE: 128
            };
            var FormatFeatureBit = {
              NONE: 0,
              RENDER_TARGET: 1,
              SAMPLED_TEXTURE: 2,
              LINEAR_FILTER: 4,
              STORAGE_TEXTURE: 8,
              VERTEX_ATTRIBUTE: 16,
              SHADING_RATE: 32
            };
            var SampleCount = {
              X1: 1,
              X2: 2,
              X4: 4,
              X8: 8,
              X16: 16,
              X32: 32,
              X64: 64
            };
            var VsyncMode = {
              OFF: 0,
              ON: 1,
              RELAXED: 2,
              MAILBOX: 3,
              HALF: 4
            };
            var Filter = {
              NONE: 0,
              POINT: 1,
              LINEAR: 2,
              ANISOTROPIC: 3
            };
            var Address = {
              WRAP: 0,
              MIRROR: 1,
              CLAMP: 2,
              BORDER: 3
            };
            var ComparisonFunc = {
              NEVER: 0,
              LESS: 1,
              EQUAL: 2,
              LESS_EQUAL: 3,
              GREATER: 4,
              NOT_EQUAL: 5,
              GREATER_EQUAL: 6,
              ALWAYS: 7
            };
            var StencilOp = {
              ZERO: 0,
              KEEP: 1,
              REPLACE: 2,
              INCR: 3,
              DECR: 4,
              INVERT: 5,
              INCR_WRAP: 6,
              DECR_WRAP: 7
            };
            var BlendFactor = {
              ZERO: 0,
              ONE: 1,
              SRC_ALPHA: 2,
              DST_ALPHA: 3,
              ONE_MINUS_SRC_ALPHA: 4,
              ONE_MINUS_DST_ALPHA: 5,
              SRC_COLOR: 6,
              DST_COLOR: 7,
              ONE_MINUS_SRC_COLOR: 8,
              ONE_MINUS_DST_COLOR: 9,
              SRC_ALPHA_SATURATE: 10,
              CONSTANT_COLOR: 11,
              ONE_MINUS_CONSTANT_COLOR: 12,
              CONSTANT_ALPHA: 13,
              ONE_MINUS_CONSTANT_ALPHA: 14
            };
            var BlendOp = {
              ADD: 0,
              SUB: 1,
              REV_SUB: 2,
              MIN: 3,
              MAX: 4
            };
            var ColorMask = {
              NONE: 0,
              R: 1,
              G: 2,
              B: 4,
              A: 8,
              ALL: 15
            };
            var ShaderStageFlagBit = {
              NONE: 0,
              VERTEX: 1,
              CONTROL: 2,
              EVALUATION: 4,
              GEOMETRY: 8,
              FRAGMENT: 16,
              COMPUTE: 32,
              ALL: 63
            };
            var LoadOp = {
              LOAD: 0,
              CLEAR: 1,
              DISCARD: 2
            };
            var StoreOp = {
              STORE: 0,
              DISCARD: 1
            };
            var AccessFlagBit = {
              NONE: 0,
              INDIRECT_BUFFER: 1,
              INDEX_BUFFER: 2,
              VERTEX_BUFFER: 4,
              VERTEX_SHADER_READ_UNIFORM_BUFFER: 8,
              VERTEX_SHADER_READ_TEXTURE: 16,
              VERTEX_SHADER_READ_OTHER: 32,
              FRAGMENT_SHADER_READ_UNIFORM_BUFFER: 64,
              FRAGMENT_SHADER_READ_TEXTURE: 128,
              FRAGMENT_SHADER_READ_COLOR_INPUT_ATTACHMENT: 256,
              FRAGMENT_SHADER_READ_DEPTH_STENCIL_INPUT_ATTACHMENT: 512,
              FRAGMENT_SHADER_READ_OTHER: 1024,
              COLOR_ATTACHMENT_READ: 2048,
              DEPTH_STENCIL_ATTACHMENT_READ: 4096,
              COMPUTE_SHADER_READ_UNIFORM_BUFFER: 8192,
              COMPUTE_SHADER_READ_TEXTURE: 16384,
              COMPUTE_SHADER_READ_OTHER: 32768,
              TRANSFER_READ: 65536,
              HOST_READ: 131072,
              PRESENT: 262144,
              VERTEX_SHADER_WRITE: 524288,
              FRAGMENT_SHADER_WRITE: 1048576,
              COLOR_ATTACHMENT_WRITE: 2097152,
              DEPTH_STENCIL_ATTACHMENT_WRITE: 4194304,
              COMPUTE_SHADER_WRITE: 8388608,
              TRANSFER_WRITE: 16777216,
              HOST_PREINITIALIZED: 33554432,
              HOST_WRITE: 67108864,
              SHADING_RATE: 134217728
            };
            var ResolveMode = {
              NONE: 0,
              SAMPLE_ZERO: 1,
              AVERAGE: 2,
              MIN: 3,
              MAX: 4
            };
            var PipelineBindPoint = {
              GRAPHICS: 0,
              COMPUTE: 1,
              RAY_TRACING: 2
            };
            var PrimitiveMode = {
              POINT_LIST: 0,
              LINE_LIST: 1,
              LINE_STRIP: 2,
              LINE_LOOP: 3,
              LINE_LIST_ADJACENCY: 4,
              LINE_STRIP_ADJACENCY: 5,
              ISO_LINE_LIST: 6,
              TRIANGLE_LIST: 7,
              TRIANGLE_STRIP: 8,
              TRIANGLE_FAN: 9,
              TRIANGLE_LIST_ADJACENCY: 10,
              TRIANGLE_STRIP_ADJACENCY: 11,
              TRIANGLE_PATCH_ADJACENCY: 12,
              QUAD_PATCH_LIST: 13
            };
            var PolygonMode = {
              FILL: 0,
              POINT: 1,
              LINE: 2
            };
            var ShadeModel = {
              GOURAND: 0,
              FLAT: 1
            };
            var CullMode = {
              NONE: 0,
              FRONT: 1,
              BACK: 2
            };
            var DynamicStateFlagBit = {
              NONE: 0,
              LINE_WIDTH: 1,
              DEPTH_BIAS: 2,
              BLEND_CONSTANTS: 4,
              DEPTH_BOUNDS: 8,
              STENCIL_WRITE_MASK: 16,
              STENCIL_COMPARE_MASK: 32
            };
            var StencilFace = {
              FRONT: 1,
              BACK: 2,
              ALL: 3
            };
            var DescriptorType = {
              UNKNOWN: 0,
              UNIFORM_BUFFER: 1,
              DYNAMIC_UNIFORM_BUFFER: 2,
              STORAGE_BUFFER: 4,
              DYNAMIC_STORAGE_BUFFER: 8,
              SAMPLER_TEXTURE: 16,
              SAMPLER: 32,
              TEXTURE: 64,
              STORAGE_IMAGE: 128,
              INPUT_ATTACHMENT: 256
            };
            var QueueType = {
              GRAPHICS: 0,
              COMPUTE: 1,
              TRANSFER: 2
            };
            var QueryType = {
              OCCLUSION: 0,
              PIPELINE_STATISTICS: 1,
              TIMESTAMP: 2
            };
            var CommandBufferType = {
              PRIMARY: 0,
              SECONDARY: 1
            };
            var ClearFlagBit = {
              NONE: 0,
              COLOR: 1,
              DEPTH: 2,
              STENCIL: 4,
              DEPTH_STENCIL: 6,
              ALL: 7
            };
            var BarrierType = {
              FULL: 0,
              SPLIT_BEGIN: 1,
              SPLIT_END: 2
            };
            var PassType = {
              RASTER: 0,
              COMPUTE: 1,
              COPY: 2,
              MOVE: 3,
              RAYTRACE: 4,
              PRESENT: 5
            };
            var Size$1 = function () {
              function Size(x, y, z) {
                if (x === undefined) {
                  x = 0;
                }
                if (y === undefined) {
                  y = 0;
                }
                if (z === undefined) {
                  z = 0;
                }
                this.x = x;
                this.y = y;
                this.z = z;
              }
              var _proto = Size.prototype;
              _proto.copy = function copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.z = info.z;
                return this;
              };
              return Size;
            }();
            var DeviceCaps = function () {
              function DeviceCaps(maxVertexAttributes, maxVertexUniformVectors, maxFragmentUniformVectors, maxTextureUnits, maxImageUnits, maxVertexTextureUnits, maxColorRenderTargets, maxShaderStorageBufferBindings, maxShaderStorageBlockSize, maxUniformBufferBindings, maxUniformBlockSize, maxTextureSize, maxCubeMapTextureSize, maxArrayTextureLayers, max3DTextureSize, uboOffsetAlignment, maxComputeSharedMemorySize, maxComputeWorkGroupInvocations, maxComputeWorkGroupSize, maxComputeWorkGroupCount, supportQuery, supportVariableRateShading, supportSubPassShading, clipSpaceMinZ, screenSpaceSignY, clipSpaceSignY) {
                if (maxVertexAttributes === undefined) {
                  maxVertexAttributes = 0;
                }
                if (maxVertexUniformVectors === undefined) {
                  maxVertexUniformVectors = 0;
                }
                if (maxFragmentUniformVectors === undefined) {
                  maxFragmentUniformVectors = 0;
                }
                if (maxTextureUnits === undefined) {
                  maxTextureUnits = 0;
                }
                if (maxImageUnits === undefined) {
                  maxImageUnits = 0;
                }
                if (maxVertexTextureUnits === undefined) {
                  maxVertexTextureUnits = 0;
                }
                if (maxColorRenderTargets === undefined) {
                  maxColorRenderTargets = 0;
                }
                if (maxShaderStorageBufferBindings === undefined) {
                  maxShaderStorageBufferBindings = 0;
                }
                if (maxShaderStorageBlockSize === undefined) {
                  maxShaderStorageBlockSize = 0;
                }
                if (maxUniformBufferBindings === undefined) {
                  maxUniformBufferBindings = 0;
                }
                if (maxUniformBlockSize === undefined) {
                  maxUniformBlockSize = 0;
                }
                if (maxTextureSize === undefined) {
                  maxTextureSize = 0;
                }
                if (maxCubeMapTextureSize === undefined) {
                  maxCubeMapTextureSize = 0;
                }
                if (maxArrayTextureLayers === undefined) {
                  maxArrayTextureLayers = 0;
                }
                if (max3DTextureSize === undefined) {
                  max3DTextureSize = 0;
                }
                if (uboOffsetAlignment === undefined) {
                  uboOffsetAlignment = 1;
                }
                if (maxComputeSharedMemorySize === undefined) {
                  maxComputeSharedMemorySize = 0;
                }
                if (maxComputeWorkGroupInvocations === undefined) {
                  maxComputeWorkGroupInvocations = 0;
                }
                if (maxComputeWorkGroupSize === undefined) {
                  maxComputeWorkGroupSize = new Size$1();
                }
                if (maxComputeWorkGroupCount === undefined) {
                  maxComputeWorkGroupCount = new Size$1();
                }
                if (supportQuery === undefined) {
                  supportQuery = false;
                }
                if (supportVariableRateShading === undefined) {
                  supportVariableRateShading = false;
                }
                if (supportSubPassShading === undefined) {
                  supportSubPassShading = false;
                }
                if (clipSpaceMinZ === undefined) {
                  clipSpaceMinZ = -1;
                }
                if (screenSpaceSignY === undefined) {
                  screenSpaceSignY = 1;
                }
                if (clipSpaceSignY === undefined) {
                  clipSpaceSignY = 1;
                }
                this.maxVertexAttributes = maxVertexAttributes;
                this.maxVertexUniformVectors = maxVertexUniformVectors;
                this.maxFragmentUniformVectors = maxFragmentUniformVectors;
                this.maxTextureUnits = maxTextureUnits;
                this.maxImageUnits = maxImageUnits;
                this.maxVertexTextureUnits = maxVertexTextureUnits;
                this.maxColorRenderTargets = maxColorRenderTargets;
                this.maxShaderStorageBufferBindings = maxShaderStorageBufferBindings;
                this.maxShaderStorageBlockSize = maxShaderStorageBlockSize;
                this.maxUniformBufferBindings = maxUniformBufferBindings;
                this.maxUniformBlockSize = maxUniformBlockSize;
                this.maxTextureSize = maxTextureSize;
                this.maxCubeMapTextureSize = maxCubeMapTextureSize;
                this.maxArrayTextureLayers = maxArrayTextureLayers;
                this.max3DTextureSize = max3DTextureSize;
                this.uboOffsetAlignment = uboOffsetAlignment;
                this.maxComputeSharedMemorySize = maxComputeSharedMemorySize;
                this.maxComputeWorkGroupInvocations = maxComputeWorkGroupInvocations;
                this.maxComputeWorkGroupSize = maxComputeWorkGroupSize;
                this.maxComputeWorkGroupCount = maxComputeWorkGroupCount;
                this.supportQuery = supportQuery;
                this.supportVariableRateShading = supportVariableRateShading;
                this.supportSubPassShading = supportSubPassShading;
                this.clipSpaceMinZ = clipSpaceMinZ;
                this.screenSpaceSignY = screenSpaceSignY;
                this.clipSpaceSignY = clipSpaceSignY;
              }
              var _proto2 = DeviceCaps.prototype;
              _proto2.copy = function copy(info) {
                this.maxVertexAttributes = info.maxVertexAttributes;
                this.maxVertexUniformVectors = info.maxVertexUniformVectors;
                this.maxFragmentUniformVectors = info.maxFragmentUniformVectors;
                this.maxTextureUnits = info.maxTextureUnits;
                this.maxImageUnits = info.maxImageUnits;
                this.maxVertexTextureUnits = info.maxVertexTextureUnits;
                this.maxColorRenderTargets = info.maxColorRenderTargets;
                this.maxShaderStorageBufferBindings = info.maxShaderStorageBufferBindings;
                this.maxShaderStorageBlockSize = info.maxShaderStorageBlockSize;
                this.maxUniformBufferBindings = info.maxUniformBufferBindings;
                this.maxUniformBlockSize = info.maxUniformBlockSize;
                this.maxTextureSize = info.maxTextureSize;
                this.maxCubeMapTextureSize = info.maxCubeMapTextureSize;
                this.maxArrayTextureLayers = info.maxArrayTextureLayers;
                this.max3DTextureSize = info.max3DTextureSize;
                this.uboOffsetAlignment = info.uboOffsetAlignment;
                this.maxComputeSharedMemorySize = info.maxComputeSharedMemorySize;
                this.maxComputeWorkGroupInvocations = info.maxComputeWorkGroupInvocations;
                this.maxComputeWorkGroupSize.copy(info.maxComputeWorkGroupSize);
                this.maxComputeWorkGroupCount.copy(info.maxComputeWorkGroupCount);
                this.supportQuery = info.supportQuery;
                this.supportVariableRateShading = info.supportVariableRateShading;
                this.supportSubPassShading = info.supportSubPassShading;
                this.clipSpaceMinZ = info.clipSpaceMinZ;
                this.screenSpaceSignY = info.screenSpaceSignY;
                this.clipSpaceSignY = info.clipSpaceSignY;
                return this;
              };
              return DeviceCaps;
            }();
            var DeviceOptions = function () {
              function DeviceOptions(enableBarrierDeduce) {
                if (enableBarrierDeduce === undefined) {
                  enableBarrierDeduce = true;
                }
                this.enableBarrierDeduce = enableBarrierDeduce;
              }
              var _proto3 = DeviceOptions.prototype;
              _proto3.copy = function copy(info) {
                this.enableBarrierDeduce = info.enableBarrierDeduce;
                return this;
              };
              return DeviceOptions;
            }();
            var Offset = function () {
              function Offset(x, y, z) {
                if (x === undefined) {
                  x = 0;
                }
                if (y === undefined) {
                  y = 0;
                }
                if (z === undefined) {
                  z = 0;
                }
                this.x = x;
                this.y = y;
                this.z = z;
              }
              var _proto4 = Offset.prototype;
              _proto4.copy = function copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.z = info.z;
                return this;
              };
              return Offset;
            }();
            var Rect$1 = function () {
              function Rect(x, y, width, height) {
                if (x === undefined) {
                  x = 0;
                }
                if (y === undefined) {
                  y = 0;
                }
                if (width === undefined) {
                  width = 0;
                }
                if (height === undefined) {
                  height = 0;
                }
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
              }
              var _proto5 = Rect.prototype;
              _proto5.copy = function copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.width = info.width;
                this.height = info.height;
                return this;
              };
              return Rect;
            }();
            var Extent = function () {
              function Extent(width, height, depth) {
                if (width === undefined) {
                  width = 0;
                }
                if (height === undefined) {
                  height = 0;
                }
                if (depth === undefined) {
                  depth = 1;
                }
                this.width = width;
                this.height = height;
                this.depth = depth;
              }
              var _proto6 = Extent.prototype;
              _proto6.copy = function copy(info) {
                this.width = info.width;
                this.height = info.height;
                this.depth = info.depth;
                return this;
              };
              return Extent;
            }();
            var TextureSubresLayers = function () {
              function TextureSubresLayers(mipLevel, baseArrayLayer, layerCount) {
                if (mipLevel === undefined) {
                  mipLevel = 0;
                }
                if (baseArrayLayer === undefined) {
                  baseArrayLayer = 0;
                }
                if (layerCount === undefined) {
                  layerCount = 1;
                }
                this.mipLevel = mipLevel;
                this.baseArrayLayer = baseArrayLayer;
                this.layerCount = layerCount;
              }
              var _proto7 = TextureSubresLayers.prototype;
              _proto7.copy = function copy(info) {
                this.mipLevel = info.mipLevel;
                this.baseArrayLayer = info.baseArrayLayer;
                this.layerCount = info.layerCount;
                return this;
              };
              return TextureSubresLayers;
            }();
            var TextureSubresRange = function () {
              function TextureSubresRange(baseMipLevel, levelCount, baseArrayLayer, layerCount) {
                if (baseMipLevel === undefined) {
                  baseMipLevel = 0;
                }
                if (levelCount === undefined) {
                  levelCount = 1;
                }
                if (baseArrayLayer === undefined) {
                  baseArrayLayer = 0;
                }
                if (layerCount === undefined) {
                  layerCount = 1;
                }
                this.baseMipLevel = baseMipLevel;
                this.levelCount = levelCount;
                this.baseArrayLayer = baseArrayLayer;
                this.layerCount = layerCount;
              }
              var _proto8 = TextureSubresRange.prototype;
              _proto8.copy = function copy(info) {
                this.baseMipLevel = info.baseMipLevel;
                this.levelCount = info.levelCount;
                this.baseArrayLayer = info.baseArrayLayer;
                this.layerCount = info.layerCount;
                return this;
              };
              return TextureSubresRange;
            }();
            var TextureCopy = function () {
              function TextureCopy(srcSubres, srcOffset, dstSubres, dstOffset, extent) {
                if (srcSubres === undefined) {
                  srcSubres = new TextureSubresLayers();
                }
                if (srcOffset === undefined) {
                  srcOffset = new Offset();
                }
                if (dstSubres === undefined) {
                  dstSubres = new TextureSubresLayers();
                }
                if (dstOffset === undefined) {
                  dstOffset = new Offset();
                }
                if (extent === undefined) {
                  extent = new Extent();
                }
                this.srcSubres = srcSubres;
                this.srcOffset = srcOffset;
                this.dstSubres = dstSubres;
                this.dstOffset = dstOffset;
                this.extent = extent;
              }
              var _proto9 = TextureCopy.prototype;
              _proto9.copy = function copy(info) {
                this.srcSubres.copy(info.srcSubres);
                this.srcOffset.copy(info.srcOffset);
                this.dstSubres.copy(info.dstSubres);
                this.dstOffset.copy(info.dstOffset);
                this.extent.copy(info.extent);
                return this;
              };
              return TextureCopy;
            }();
            var TextureBlit = function () {
              function TextureBlit(srcSubres, srcOffset, srcExtent, dstSubres, dstOffset, dstExtent) {
                if (srcSubres === undefined) {
                  srcSubres = new TextureSubresLayers();
                }
                if (srcOffset === undefined) {
                  srcOffset = new Offset();
                }
                if (srcExtent === undefined) {
                  srcExtent = new Extent();
                }
                if (dstSubres === undefined) {
                  dstSubres = new TextureSubresLayers();
                }
                if (dstOffset === undefined) {
                  dstOffset = new Offset();
                }
                if (dstExtent === undefined) {
                  dstExtent = new Extent();
                }
                this.srcSubres = srcSubres;
                this.srcOffset = srcOffset;
                this.srcExtent = srcExtent;
                this.dstSubres = dstSubres;
                this.dstOffset = dstOffset;
                this.dstExtent = dstExtent;
              }
              var _proto10 = TextureBlit.prototype;
              _proto10.copy = function copy(info) {
                this.srcSubres.copy(info.srcSubres);
                this.srcOffset.copy(info.srcOffset);
                this.srcExtent.copy(info.srcExtent);
                this.dstSubres.copy(info.dstSubres);
                this.dstOffset.copy(info.dstOffset);
                this.dstExtent.copy(info.dstExtent);
                return this;
              };
              return TextureBlit;
            }();
            var BufferTextureCopy = function () {
              function BufferTextureCopy(buffOffset, buffStride, buffTexHeight, texOffset, texExtent, texSubres) {
                if (buffOffset === undefined) {
                  buffOffset = 0;
                }
                if (buffStride === undefined) {
                  buffStride = 0;
                }
                if (buffTexHeight === undefined) {
                  buffTexHeight = 0;
                }
                if (texOffset === undefined) {
                  texOffset = new Offset();
                }
                if (texExtent === undefined) {
                  texExtent = new Extent();
                }
                if (texSubres === undefined) {
                  texSubres = new TextureSubresLayers();
                }
                this.buffOffset = buffOffset;
                this.buffStride = buffStride;
                this.buffTexHeight = buffTexHeight;
                this.texOffset = texOffset;
                this.texExtent = texExtent;
                this.texSubres = texSubres;
              }
              var _proto11 = BufferTextureCopy.prototype;
              _proto11.copy = function copy(info) {
                this.buffOffset = info.buffOffset;
                this.buffStride = info.buffStride;
                this.buffTexHeight = info.buffTexHeight;
                this.texOffset.copy(info.texOffset);
                this.texExtent.copy(info.texExtent);
                this.texSubres.copy(info.texSubres);
                return this;
              };
              return BufferTextureCopy;
            }();
            var Viewport = function () {
              function Viewport(left, top, width, height, minDepth, maxDepth) {
                if (left === undefined) {
                  left = 0;
                }
                if (top === undefined) {
                  top = 0;
                }
                if (width === undefined) {
                  width = 0;
                }
                if (height === undefined) {
                  height = 0;
                }
                if (minDepth === undefined) {
                  minDepth = 0;
                }
                if (maxDepth === undefined) {
                  maxDepth = 1;
                }
                this.left = left;
                this.top = top;
                this.width = width;
                this.height = height;
                this.minDepth = minDepth;
                this.maxDepth = maxDepth;
              }
              var _proto12 = Viewport.prototype;
              _proto12.copy = function copy(info) {
                this.left = info.left;
                this.top = info.top;
                this.width = info.width;
                this.height = info.height;
                this.minDepth = info.minDepth;
                this.maxDepth = info.maxDepth;
                return this;
              };
              _proto12.reset = function reset() {
                this.left = 0;
                this.top = 0;
                this.width = 0;
                this.height = 0;
                this.minDepth = 0;
                this.maxDepth = 1;
              };
              return Viewport;
            }();
            var Color$1 = function () {
              function Color(x, y, z, w) {
                if (x === undefined) {
                  x = 0;
                }
                if (y === undefined) {
                  y = 0;
                }
                if (z === undefined) {
                  z = 0;
                }
                if (w === undefined) {
                  w = 0;
                }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
              }
              var _proto13 = Color.prototype;
              _proto13.copy = function copy(info) {
                this.x = info.x;
                this.y = info.y;
                this.z = info.z;
                this.w = info.w;
                return this;
              };
              _proto13.set = function set(x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
                return this;
              };
              _proto13.reset = function reset() {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
              };
              return Color;
            }();
            var MarkerInfo = function () {
              function MarkerInfo(name, color) {
                if (name === undefined) {
                  name = '';
                }
                if (color === undefined) {
                  color = new Color$1();
                }
                this.name = name;
                this.color = color;
              }
              var _proto14 = MarkerInfo.prototype;
              _proto14.copy = function copy(info) {
                this.name = info.name;
                this.color.copy(info.color);
                return this;
              };
              return MarkerInfo;
            }();
            var BindingMappingInfo = function () {
              function BindingMappingInfo(maxBlockCounts, maxSamplerTextureCounts, maxSamplerCounts, maxTextureCounts, maxBufferCounts, maxImageCounts, maxSubpassInputCounts, setIndices) {
                if (maxBlockCounts === undefined) {
                  maxBlockCounts = [0];
                }
                if (maxSamplerTextureCounts === undefined) {
                  maxSamplerTextureCounts = [0];
                }
                if (maxSamplerCounts === undefined) {
                  maxSamplerCounts = [0];
                }
                if (maxTextureCounts === undefined) {
                  maxTextureCounts = [0];
                }
                if (maxBufferCounts === undefined) {
                  maxBufferCounts = [0];
                }
                if (maxImageCounts === undefined) {
                  maxImageCounts = [0];
                }
                if (maxSubpassInputCounts === undefined) {
                  maxSubpassInputCounts = [0];
                }
                if (setIndices === undefined) {
                  setIndices = [0];
                }
                this.maxBlockCounts = maxBlockCounts;
                this.maxSamplerTextureCounts = maxSamplerTextureCounts;
                this.maxSamplerCounts = maxSamplerCounts;
                this.maxTextureCounts = maxTextureCounts;
                this.maxBufferCounts = maxBufferCounts;
                this.maxImageCounts = maxImageCounts;
                this.maxSubpassInputCounts = maxSubpassInputCounts;
                this.setIndices = setIndices;
              }
              var _proto15 = BindingMappingInfo.prototype;
              _proto15.copy = function copy(info) {
                this.maxBlockCounts = info.maxBlockCounts.slice();
                this.maxSamplerTextureCounts = info.maxSamplerTextureCounts.slice();
                this.maxSamplerCounts = info.maxSamplerCounts.slice();
                this.maxTextureCounts = info.maxTextureCounts.slice();
                this.maxBufferCounts = info.maxBufferCounts.slice();
                this.maxImageCounts = info.maxImageCounts.slice();
                this.maxSubpassInputCounts = info.maxSubpassInputCounts.slice();
                this.setIndices = info.setIndices.slice();
                return this;
              };
              return BindingMappingInfo;
            }();
            var SwapchainInfo = function () {
              function SwapchainInfo(windowId, windowHandle, vsyncMode, width, height) {
                if (windowId === undefined) {
                  windowId = 0;
                }
                if (windowHandle === undefined) {
                  windowHandle = null;
                }
                if (vsyncMode === undefined) {
                  vsyncMode = 1;
                }
                if (width === undefined) {
                  width = 0;
                }
                if (height === undefined) {
                  height = 0;
                }
                this.windowId = windowId;
                this.windowHandle = windowHandle;
                this.vsyncMode = vsyncMode;
                this.width = width;
                this.height = height;
              }
              var _proto16 = SwapchainInfo.prototype;
              _proto16.copy = function copy(info) {
                this.windowId = info.windowId;
                this.windowHandle = info.windowHandle;
                this.vsyncMode = info.vsyncMode;
                this.width = info.width;
                this.height = info.height;
                return this;
              };
              return SwapchainInfo;
            }();
            var DeviceInfo = function () {
              function DeviceInfo(bindingMappingInfo) {
                if (bindingMappingInfo === undefined) {
                  bindingMappingInfo = new BindingMappingInfo();
                }
                this.bindingMappingInfo = bindingMappingInfo;
              }
              var _proto17 = DeviceInfo.prototype;
              _proto17.copy = function copy(info) {
                this.bindingMappingInfo.copy(info.bindingMappingInfo);
                return this;
              };
              return DeviceInfo;
            }();
            var BufferInfo = function () {
              function BufferInfo(usage, memUsage, size, stride, flags) {
                if (usage === undefined) {
                  usage = 0;
                }
                if (memUsage === undefined) {
                  memUsage = 0;
                }
                if (size === undefined) {
                  size = 0;
                }
                if (stride === undefined) {
                  stride = 1;
                }
                if (flags === undefined) {
                  flags = 0;
                }
                this.usage = usage;
                this.memUsage = memUsage;
                this.size = size;
                this.stride = stride;
                this.flags = flags;
              }
              var _proto18 = BufferInfo.prototype;
              _proto18.copy = function copy(info) {
                this.usage = info.usage;
                this.memUsage = info.memUsage;
                this.size = info.size;
                this.stride = info.stride;
                this.flags = info.flags;
                return this;
              };
              return BufferInfo;
            }();
            var BufferViewInfo = function () {
              function BufferViewInfo(buffer, offset, range) {
                if (buffer === undefined) {
                  buffer = null;
                }
                if (offset === undefined) {
                  offset = 0;
                }
                if (range === undefined) {
                  range = 0;
                }
                this.buffer = buffer;
                this.offset = offset;
                this.range = range;
              }
              var _proto19 = BufferViewInfo.prototype;
              _proto19.copy = function copy(info) {
                this.buffer = info.buffer;
                this.offset = info.offset;
                this.range = info.range;
                return this;
              };
              return BufferViewInfo;
            }();
            var DrawInfo = function () {
              function DrawInfo(vertexCount, firstVertex, indexCount, firstIndex, vertexOffset, instanceCount, firstInstance) {
                if (vertexCount === undefined) {
                  vertexCount = 0;
                }
                if (firstVertex === undefined) {
                  firstVertex = 0;
                }
                if (indexCount === undefined) {
                  indexCount = 0;
                }
                if (firstIndex === undefined) {
                  firstIndex = 0;
                }
                if (vertexOffset === undefined) {
                  vertexOffset = 0;
                }
                if (instanceCount === undefined) {
                  instanceCount = 0;
                }
                if (firstInstance === undefined) {
                  firstInstance = 0;
                }
                this.vertexCount = vertexCount;
                this.firstVertex = firstVertex;
                this.indexCount = indexCount;
                this.firstIndex = firstIndex;
                this.vertexOffset = vertexOffset;
                this.instanceCount = instanceCount;
                this.firstInstance = firstInstance;
              }
              var _proto20 = DrawInfo.prototype;
              _proto20.copy = function copy(info) {
                this.vertexCount = info.vertexCount;
                this.firstVertex = info.firstVertex;
                this.indexCount = info.indexCount;
                this.firstIndex = info.firstIndex;
                this.vertexOffset = info.vertexOffset;
                this.instanceCount = info.instanceCount;
                this.firstInstance = info.firstInstance;
                return this;
              };
              return DrawInfo;
            }();
            var DispatchInfo = function () {
              function DispatchInfo(groupCountX, groupCountY, groupCountZ, indirectBuffer, indirectOffset) {
                if (groupCountX === undefined) {
                  groupCountX = 0;
                }
                if (groupCountY === undefined) {
                  groupCountY = 0;
                }
                if (groupCountZ === undefined) {
                  groupCountZ = 0;
                }
                if (indirectBuffer === undefined) {
                  indirectBuffer = null;
                }
                if (indirectOffset === undefined) {
                  indirectOffset = 0;
                }
                this.groupCountX = groupCountX;
                this.groupCountY = groupCountY;
                this.groupCountZ = groupCountZ;
                this.indirectBuffer = indirectBuffer;
                this.indirectOffset = indirectOffset;
              }
              var _proto21 = DispatchInfo.prototype;
              _proto21.copy = function copy(info) {
                this.groupCountX = info.groupCountX;
                this.groupCountY = info.groupCountY;
                this.groupCountZ = info.groupCountZ;
                this.indirectBuffer = info.indirectBuffer;
                this.indirectOffset = info.indirectOffset;
                return this;
              };
              return DispatchInfo;
            }();
            var IndirectBuffer = function () {
              function IndirectBuffer(drawInfos) {
                if (drawInfos === undefined) {
                  drawInfos = [];
                }
                this.drawInfos = drawInfos;
              }
              var _proto22 = IndirectBuffer.prototype;
              _proto22.copy = function copy(info) {
                deepCopy(this.drawInfos, info.drawInfos, DrawInfo);
                return this;
              };
              return IndirectBuffer;
            }();
            var TextureInfo = function () {
              function TextureInfo(type, usage, format, width, height, flags, layerCount, levelCount, samples, depth, externalRes) {
                if (type === undefined) {
                  type = 1;
                }
                if (usage === undefined) {
                  usage = 0;
                }
                if (format === undefined) {
                  format = 0;
                }
                if (width === undefined) {
                  width = 0;
                }
                if (height === undefined) {
                  height = 0;
                }
                if (flags === undefined) {
                  flags = 0;
                }
                if (layerCount === undefined) {
                  layerCount = 1;
                }
                if (levelCount === undefined) {
                  levelCount = 1;
                }
                if (samples === undefined) {
                  samples = 1;
                }
                if (depth === undefined) {
                  depth = 1;
                }
                if (externalRes === undefined) {
                  externalRes = 0;
                }
                this.type = type;
                this.usage = usage;
                this.format = format;
                this.width = width;
                this.height = height;
                this.flags = flags;
                this.layerCount = layerCount;
                this.levelCount = levelCount;
                this.samples = samples;
                this.depth = depth;
                this.externalRes = externalRes;
              }
              var _proto23 = TextureInfo.prototype;
              _proto23.copy = function copy(info) {
                this.type = info.type;
                this.usage = info.usage;
                this.format = info.format;
                this.width = info.width;
                this.height = info.height;
                this.flags = info.flags;
                this.layerCount = info.layerCount;
                this.levelCount = info.levelCount;
                this.samples = info.samples;
                this.depth = info.depth;
                this.externalRes = info.externalRes;
                return this;
              };
              return TextureInfo;
            }();
            var TextureViewInfo = function () {
              function TextureViewInfo(texture, type, format, baseLevel, levelCount, baseLayer, layerCount, basePlane, planeCount) {
                if (texture === undefined) {
                  texture = null;
                }
                if (type === undefined) {
                  type = 1;
                }
                if (format === undefined) {
                  format = 0;
                }
                if (baseLevel === undefined) {
                  baseLevel = 0;
                }
                if (levelCount === undefined) {
                  levelCount = 1;
                }
                if (baseLayer === undefined) {
                  baseLayer = 0;
                }
                if (layerCount === undefined) {
                  layerCount = 1;
                }
                if (basePlane === undefined) {
                  basePlane = 0;
                }
                if (planeCount === undefined) {
                  planeCount = 1;
                }
                this.texture = texture;
                this.type = type;
                this.format = format;
                this.baseLevel = baseLevel;
                this.levelCount = levelCount;
                this.baseLayer = baseLayer;
                this.layerCount = layerCount;
                this.basePlane = basePlane;
                this.planeCount = planeCount;
              }
              var _proto24 = TextureViewInfo.prototype;
              _proto24.copy = function copy(info) {
                this.texture = info.texture;
                this.type = info.type;
                this.format = info.format;
                this.baseLevel = info.baseLevel;
                this.levelCount = info.levelCount;
                this.baseLayer = info.baseLayer;
                this.layerCount = info.layerCount;
                this.basePlane = info.basePlane;
                this.planeCount = info.planeCount;
                return this;
              };
              return TextureViewInfo;
            }();
            var SamplerInfo = function () {
              function SamplerInfo(minFilter, magFilter, mipFilter, addressU, addressV, addressW, maxAnisotropy, cmpFunc) {
                if (minFilter === undefined) {
                  minFilter = 2;
                }
                if (magFilter === undefined) {
                  magFilter = 2;
                }
                if (mipFilter === undefined) {
                  mipFilter = 0;
                }
                if (addressU === undefined) {
                  addressU = 0;
                }
                if (addressV === undefined) {
                  addressV = 0;
                }
                if (addressW === undefined) {
                  addressW = 0;
                }
                if (maxAnisotropy === undefined) {
                  maxAnisotropy = 0;
                }
                if (cmpFunc === undefined) {
                  cmpFunc = 7;
                }
                this.minFilter = minFilter;
                this.magFilter = magFilter;
                this.mipFilter = mipFilter;
                this.addressU = addressU;
                this.addressV = addressV;
                this.addressW = addressW;
                this.maxAnisotropy = maxAnisotropy;
                this.cmpFunc = cmpFunc;
              }
              var _proto25 = SamplerInfo.prototype;
              _proto25.copy = function copy(info) {
                this.minFilter = info.minFilter;
                this.magFilter = info.magFilter;
                this.mipFilter = info.mipFilter;
                this.addressU = info.addressU;
                this.addressV = info.addressV;
                this.addressW = info.addressW;
                this.maxAnisotropy = info.maxAnisotropy;
                this.cmpFunc = info.cmpFunc;
                return this;
              };
              return SamplerInfo;
            }();
            var Uniform = function () {
              function Uniform(name, type, count) {
                if (name === undefined) {
                  name = '';
                }
                if (type === undefined) {
                  type = 0;
                }
                if (count === undefined) {
                  count = 0;
                }
                this.name = name;
                this.type = type;
                this.count = count;
              }
              var _proto26 = Uniform.prototype;
              _proto26.copy = function copy(info) {
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                return this;
              };
              return Uniform;
            }();
            var UniformBlock = function () {
              function UniformBlock(set, binding, name, members, count, flattened) {
                if (set === undefined) {
                  set = 0;
                }
                if (binding === undefined) {
                  binding = 0;
                }
                if (name === undefined) {
                  name = '';
                }
                if (members === undefined) {
                  members = [];
                }
                if (count === undefined) {
                  count = 0;
                }
                if (flattened === undefined) {
                  flattened = 0;
                }
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.members = members;
                this.count = count;
                this.flattened = flattened;
              }
              var _proto27 = UniformBlock.prototype;
              _proto27.copy = function copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                deepCopy(this.members, info.members, Uniform);
                this.count = info.count;
                this.flattened = info.flattened;
                return this;
              };
              return UniformBlock;
            }();
            var UniformSamplerTexture = function () {
              function UniformSamplerTexture(set, binding, name, type, count, flattened) {
                if (set === undefined) {
                  set = 0;
                }
                if (binding === undefined) {
                  binding = 0;
                }
                if (name === undefined) {
                  name = '';
                }
                if (type === undefined) {
                  type = 0;
                }
                if (count === undefined) {
                  count = 0;
                }
                if (flattened === undefined) {
                  flattened = 0;
                }
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.type = type;
                this.count = count;
                this.flattened = flattened;
              }
              var _proto28 = UniformSamplerTexture.prototype;
              _proto28.copy = function copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                this.flattened = info.flattened;
                return this;
              };
              return UniformSamplerTexture;
            }();
            var UniformSampler = function () {
              function UniformSampler(set, binding, name, count, flattened) {
                if (set === undefined) {
                  set = 0;
                }
                if (binding === undefined) {
                  binding = 0;
                }
                if (name === undefined) {
                  name = '';
                }
                if (count === undefined) {
                  count = 0;
                }
                if (flattened === undefined) {
                  flattened = 0;
                }
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.count = count;
                this.flattened = flattened;
              }
              var _proto29 = UniformSampler.prototype;
              _proto29.copy = function copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.count = info.count;
                this.flattened = info.flattened;
                return this;
              };
              return UniformSampler;
            }();
            var UniformTexture = function () {
              function UniformTexture(set, binding, name, type, count, flattened) {
                if (set === undefined) {
                  set = 0;
                }
                if (binding === undefined) {
                  binding = 0;
                }
                if (name === undefined) {
                  name = '';
                }
                if (type === undefined) {
                  type = 0;
                }
                if (count === undefined) {
                  count = 0;
                }
                if (flattened === undefined) {
                  flattened = 0;
                }
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.type = type;
                this.count = count;
                this.flattened = flattened;
              }
              var _proto30 = UniformTexture.prototype;
              _proto30.copy = function copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                this.flattened = info.flattened;
                return this;
              };
              return UniformTexture;
            }();
            var UniformStorageImage = function () {
              function UniformStorageImage(set, binding, name, type, count, memoryAccess, flattened) {
                if (set === undefined) {
                  set = 0;
                }
                if (binding === undefined) {
                  binding = 0;
                }
                if (name === undefined) {
                  name = '';
                }
                if (type === undefined) {
                  type = 0;
                }
                if (count === undefined) {
                  count = 0;
                }
                if (memoryAccess === undefined) {
                  memoryAccess = 3;
                }
                if (flattened === undefined) {
                  flattened = 0;
                }
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.type = type;
                this.count = count;
                this.memoryAccess = memoryAccess;
                this.flattened = flattened;
              }
              var _proto31 = UniformStorageImage.prototype;
              _proto31.copy = function copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.type = info.type;
                this.count = info.count;
                this.memoryAccess = info.memoryAccess;
                this.flattened = info.flattened;
                return this;
              };
              return UniformStorageImage;
            }();
            var UniformStorageBuffer = function () {
              function UniformStorageBuffer(set, binding, name, count, memoryAccess, flattened) {
                if (set === undefined) {
                  set = 0;
                }
                if (binding === undefined) {
                  binding = 0;
                }
                if (name === undefined) {
                  name = '';
                }
                if (count === undefined) {
                  count = 0;
                }
                if (memoryAccess === undefined) {
                  memoryAccess = 3;
                }
                if (flattened === undefined) {
                  flattened = 0;
                }
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.count = count;
                this.memoryAccess = memoryAccess;
                this.flattened = flattened;
              }
              var _proto32 = UniformStorageBuffer.prototype;
              _proto32.copy = function copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.count = info.count;
                this.memoryAccess = info.memoryAccess;
                this.flattened = info.flattened;
                return this;
              };
              return UniformStorageBuffer;
            }();
            var UniformInputAttachment = function () {
              function UniformInputAttachment(set, binding, name, count, flattened) {
                if (set === undefined) {
                  set = 0;
                }
                if (binding === undefined) {
                  binding = 0;
                }
                if (name === undefined) {
                  name = '';
                }
                if (count === undefined) {
                  count = 0;
                }
                if (flattened === undefined) {
                  flattened = 0;
                }
                this.set = set;
                this.binding = binding;
                this.name = name;
                this.count = count;
                this.flattened = flattened;
              }
              var _proto33 = UniformInputAttachment.prototype;
              _proto33.copy = function copy(info) {
                this.set = info.set;
                this.binding = info.binding;
                this.name = info.name;
                this.count = info.count;
                this.flattened = info.flattened;
                return this;
              };
              return UniformInputAttachment;
            }();
            var ShaderStage = function () {
              function ShaderStage(stage, source) {
                if (stage === undefined) {
                  stage = 0;
                }
                if (source === undefined) {
                  source = '';
                }
                this.stage = stage;
                this.source = source;
              }
              var _proto34 = ShaderStage.prototype;
              _proto34.copy = function copy(info) {
                this.stage = info.stage;
                this.source = info.source;
                return this;
              };
              return ShaderStage;
            }();
            var Attribute = function () {
              function Attribute(name, format, isNormalized, stream, isInstanced, location) {
                if (name === undefined) {
                  name = '';
                }
                if (format === undefined) {
                  format = 0;
                }
                if (isNormalized === undefined) {
                  isNormalized = false;
                }
                if (stream === undefined) {
                  stream = 0;
                }
                if (isInstanced === undefined) {
                  isInstanced = false;
                }
                if (location === undefined) {
                  location = 0;
                }
                this.name = name;
                this.format = format;
                this.isNormalized = isNormalized;
                this.stream = stream;
                this.isInstanced = isInstanced;
                this.location = location;
              }
              var _proto35 = Attribute.prototype;
              _proto35.copy = function copy(info) {
                this.name = info.name;
                this.format = info.format;
                this.isNormalized = info.isNormalized;
                this.stream = info.stream;
                this.isInstanced = info.isInstanced;
                this.location = info.location;
                return this;
              };
              return Attribute;
            }();
            var ShaderInfo = function () {
              function ShaderInfo(name, stages, attributes, blocks, buffers, samplerTextures, samplers, textures, images, subpassInputs, hash) {
                if (name === undefined) {
                  name = '';
                }
                if (stages === undefined) {
                  stages = [];
                }
                if (attributes === undefined) {
                  attributes = [];
                }
                if (blocks === undefined) {
                  blocks = [];
                }
                if (buffers === undefined) {
                  buffers = [];
                }
                if (samplerTextures === undefined) {
                  samplerTextures = [];
                }
                if (samplers === undefined) {
                  samplers = [];
                }
                if (textures === undefined) {
                  textures = [];
                }
                if (images === undefined) {
                  images = [];
                }
                if (subpassInputs === undefined) {
                  subpassInputs = [];
                }
                if (hash === undefined) {
                  hash = 0xFFFFFFFF;
                }
                this.name = name;
                this.stages = stages;
                this.attributes = attributes;
                this.blocks = blocks;
                this.buffers = buffers;
                this.samplerTextures = samplerTextures;
                this.samplers = samplers;
                this.textures = textures;
                this.images = images;
                this.subpassInputs = subpassInputs;
                this.hash = hash;
              }
              var _proto36 = ShaderInfo.prototype;
              _proto36.copy = function copy(info) {
                this.name = info.name;
                deepCopy(this.stages, info.stages, ShaderStage);
                deepCopy(this.attributes, info.attributes, Attribute);
                deepCopy(this.blocks, info.blocks, UniformBlock);
                deepCopy(this.buffers, info.buffers, UniformStorageBuffer);
                deepCopy(this.samplerTextures, info.samplerTextures, UniformSamplerTexture);
                deepCopy(this.samplers, info.samplers, UniformSampler);
                deepCopy(this.textures, info.textures, UniformTexture);
                deepCopy(this.images, info.images, UniformStorageImage);
                deepCopy(this.subpassInputs, info.subpassInputs, UniformInputAttachment);
                this.hash = info.hash;
                return this;
              };
              return ShaderInfo;
            }();
            var InputAssemblerInfo = function () {
              function InputAssemblerInfo(attributes, vertexBuffers, indexBuffer, indirectBuffer) {
                if (attributes === undefined) {
                  attributes = [];
                }
                if (vertexBuffers === undefined) {
                  vertexBuffers = [];
                }
                if (indexBuffer === undefined) {
                  indexBuffer = null;
                }
                if (indirectBuffer === undefined) {
                  indirectBuffer = null;
                }
                this.attributes = attributes;
                this.vertexBuffers = vertexBuffers;
                this.indexBuffer = indexBuffer;
                this.indirectBuffer = indirectBuffer;
              }
              var _proto37 = InputAssemblerInfo.prototype;
              _proto37.copy = function copy(info) {
                deepCopy(this.attributes, info.attributes, Attribute);
                this.vertexBuffers = info.vertexBuffers.slice();
                this.indexBuffer = info.indexBuffer;
                this.indirectBuffer = info.indirectBuffer;
                return this;
              };
              return InputAssemblerInfo;
            }();
            var ColorAttachment = function () {
              function ColorAttachment(format, sampleCount, loadOp, storeOp, barrier) {
                if (format === undefined) {
                  format = 0;
                }
                if (sampleCount === undefined) {
                  sampleCount = 1;
                }
                if (loadOp === undefined) {
                  loadOp = 1;
                }
                if (storeOp === undefined) {
                  storeOp = 0;
                }
                if (barrier === undefined) {
                  barrier = null;
                }
                this.format = format;
                this.sampleCount = sampleCount;
                this.loadOp = loadOp;
                this.storeOp = storeOp;
                this.barrier = barrier;
              }
              var _proto38 = ColorAttachment.prototype;
              _proto38.copy = function copy(info) {
                this.format = info.format;
                this.sampleCount = info.sampleCount;
                this.loadOp = info.loadOp;
                this.storeOp = info.storeOp;
                this.barrier = info.barrier;
                return this;
              };
              return ColorAttachment;
            }();
            var DepthStencilAttachment = function () {
              function DepthStencilAttachment(format, sampleCount, depthLoadOp, depthStoreOp, stencilLoadOp, stencilStoreOp, barrier) {
                if (format === undefined) {
                  format = 0;
                }
                if (sampleCount === undefined) {
                  sampleCount = 1;
                }
                if (depthLoadOp === undefined) {
                  depthLoadOp = 1;
                }
                if (depthStoreOp === undefined) {
                  depthStoreOp = 0;
                }
                if (stencilLoadOp === undefined) {
                  stencilLoadOp = 1;
                }
                if (stencilStoreOp === undefined) {
                  stencilStoreOp = 0;
                }
                if (barrier === undefined) {
                  barrier = null;
                }
                this.format = format;
                this.sampleCount = sampleCount;
                this.depthLoadOp = depthLoadOp;
                this.depthStoreOp = depthStoreOp;
                this.stencilLoadOp = stencilLoadOp;
                this.stencilStoreOp = stencilStoreOp;
                this.barrier = barrier;
              }
              var _proto39 = DepthStencilAttachment.prototype;
              _proto39.copy = function copy(info) {
                this.format = info.format;
                this.sampleCount = info.sampleCount;
                this.depthLoadOp = info.depthLoadOp;
                this.depthStoreOp = info.depthStoreOp;
                this.stencilLoadOp = info.stencilLoadOp;
                this.stencilStoreOp = info.stencilStoreOp;
                this.barrier = info.barrier;
                return this;
              };
              return DepthStencilAttachment;
            }();
            var SubpassInfo = function () {
              function SubpassInfo(inputs, colors, resolves, preserves, depthStencil, depthStencilResolve, shadingRate, depthResolveMode, stencilResolveMode) {
                if (inputs === undefined) {
                  inputs = [];
                }
                if (colors === undefined) {
                  colors = [];
                }
                if (resolves === undefined) {
                  resolves = [];
                }
                if (preserves === undefined) {
                  preserves = [];
                }
                if (depthStencil === undefined) {
                  depthStencil = -1;
                }
                if (depthStencilResolve === undefined) {
                  depthStencilResolve = -1;
                }
                if (shadingRate === undefined) {
                  shadingRate = -1;
                }
                if (depthResolveMode === undefined) {
                  depthResolveMode = 0;
                }
                if (stencilResolveMode === undefined) {
                  stencilResolveMode = 0;
                }
                this.inputs = inputs;
                this.colors = colors;
                this.resolves = resolves;
                this.preserves = preserves;
                this.depthStencil = depthStencil;
                this.depthStencilResolve = depthStencilResolve;
                this.shadingRate = shadingRate;
                this.depthResolveMode = depthResolveMode;
                this.stencilResolveMode = stencilResolveMode;
              }
              var _proto40 = SubpassInfo.prototype;
              _proto40.copy = function copy(info) {
                this.inputs = info.inputs.slice();
                this.colors = info.colors.slice();
                this.resolves = info.resolves.slice();
                this.preserves = info.preserves.slice();
                this.depthStencil = info.depthStencil;
                this.depthStencilResolve = info.depthStencilResolve;
                this.shadingRate = info.shadingRate;
                this.depthResolveMode = info.depthResolveMode;
                this.stencilResolveMode = info.stencilResolveMode;
                return this;
              };
              return SubpassInfo;
            }();
            var SubpassDependency = function () {
              function SubpassDependency(srcSubpass, dstSubpass, generalBarrier, prevAccesses, nextAccesses) {
                if (srcSubpass === undefined) {
                  srcSubpass = 0;
                }
                if (dstSubpass === undefined) {
                  dstSubpass = 0;
                }
                if (generalBarrier === undefined) {
                  generalBarrier = null;
                }
                if (prevAccesses === undefined) {
                  prevAccesses = 0;
                }
                if (nextAccesses === undefined) {
                  nextAccesses = 0;
                }
                this.srcSubpass = srcSubpass;
                this.dstSubpass = dstSubpass;
                this.generalBarrier = generalBarrier;
                this.prevAccesses = prevAccesses;
                this.nextAccesses = nextAccesses;
              }
              var _proto41 = SubpassDependency.prototype;
              _proto41.copy = function copy(info) {
                this.srcSubpass = info.srcSubpass;
                this.dstSubpass = info.dstSubpass;
                this.generalBarrier = info.generalBarrier;
                this.prevAccesses = info.prevAccesses;
                this.nextAccesses = info.nextAccesses;
                return this;
              };
              return SubpassDependency;
            }();
            var RenderPassInfo = function () {
              function RenderPassInfo(colorAttachments, depthStencilAttachment, depthStencilResolveAttachment, subpasses, dependencies) {
                if (colorAttachments === undefined) {
                  colorAttachments = [];
                }
                if (depthStencilAttachment === undefined) {
                  depthStencilAttachment = new DepthStencilAttachment();
                }
                if (depthStencilResolveAttachment === undefined) {
                  depthStencilResolveAttachment = new DepthStencilAttachment();
                }
                if (subpasses === undefined) {
                  subpasses = [];
                }
                if (dependencies === undefined) {
                  dependencies = [];
                }
                this.colorAttachments = colorAttachments;
                this.depthStencilAttachment = depthStencilAttachment;
                this.depthStencilResolveAttachment = depthStencilResolveAttachment;
                this.subpasses = subpasses;
                this.dependencies = dependencies;
              }
              var _proto42 = RenderPassInfo.prototype;
              _proto42.copy = function copy(info) {
                deepCopy(this.colorAttachments, info.colorAttachments, ColorAttachment);
                this.depthStencilAttachment.copy(info.depthStencilAttachment);
                this.depthStencilResolveAttachment.copy(info.depthStencilResolveAttachment);
                deepCopy(this.subpasses, info.subpasses, SubpassInfo);
                deepCopy(this.dependencies, info.dependencies, SubpassDependency);
                return this;
              };
              return RenderPassInfo;
            }();
            var ResourceRange = function () {
              function ResourceRange(width, height, depthOrArraySize, firstSlice, numSlices, mipLevel, levelCount, basePlane, planeCount) {
                if (width === undefined) {
                  width = 0;
                }
                if (height === undefined) {
                  height = 0;
                }
                if (depthOrArraySize === undefined) {
                  depthOrArraySize = 0;
                }
                if (firstSlice === undefined) {
                  firstSlice = 0;
                }
                if (numSlices === undefined) {
                  numSlices = 0;
                }
                if (mipLevel === undefined) {
                  mipLevel = 0;
                }
                if (levelCount === undefined) {
                  levelCount = 0;
                }
                if (basePlane === undefined) {
                  basePlane = 0;
                }
                if (planeCount === undefined) {
                  planeCount = 0;
                }
                this.width = width;
                this.height = height;
                this.depthOrArraySize = depthOrArraySize;
                this.firstSlice = firstSlice;
                this.numSlices = numSlices;
                this.mipLevel = mipLevel;
                this.levelCount = levelCount;
                this.basePlane = basePlane;
                this.planeCount = planeCount;
              }
              var _proto43 = ResourceRange.prototype;
              _proto43.copy = function copy(info) {
                this.width = info.width;
                this.height = info.height;
                this.depthOrArraySize = info.depthOrArraySize;
                this.firstSlice = info.firstSlice;
                this.numSlices = info.numSlices;
                this.mipLevel = info.mipLevel;
                this.levelCount = info.levelCount;
                this.basePlane = info.basePlane;
                this.planeCount = info.planeCount;
                return this;
              };
              return ResourceRange;
            }();
            var GeneralBarrierInfo = function () {
              function GeneralBarrierInfo(prevAccesses, nextAccesses, type) {
                if (prevAccesses === undefined) {
                  prevAccesses = 0;
                }
                if (nextAccesses === undefined) {
                  nextAccesses = 0;
                }
                if (type === undefined) {
                  type = 0;
                }
                this.prevAccesses = prevAccesses;
                this.nextAccesses = nextAccesses;
                this.type = type;
              }
              var _proto44 = GeneralBarrierInfo.prototype;
              _proto44.copy = function copy(info) {
                this.prevAccesses = info.prevAccesses;
                this.nextAccesses = info.nextAccesses;
                this.type = info.type;
                return this;
              };
              return GeneralBarrierInfo;
            }();
            var TextureBarrierInfo = function () {
              function TextureBarrierInfo(prevAccesses, nextAccesses, type, range, discardContents, srcQueue, dstQueue) {
                if (prevAccesses === undefined) {
                  prevAccesses = 0;
                }
                if (nextAccesses === undefined) {
                  nextAccesses = 0;
                }
                if (type === undefined) {
                  type = 0;
                }
                if (range === undefined) {
                  range = new ResourceRange();
                }
                if (discardContents === undefined) {
                  discardContents = false;
                }
                if (srcQueue === undefined) {
                  srcQueue = null;
                }
                if (dstQueue === undefined) {
                  dstQueue = null;
                }
                this.prevAccesses = prevAccesses;
                this.nextAccesses = nextAccesses;
                this.type = type;
                this.range = range;
                this.discardContents = discardContents;
                this.srcQueue = srcQueue;
                this.dstQueue = dstQueue;
              }
              var _proto45 = TextureBarrierInfo.prototype;
              _proto45.copy = function copy(info) {
                this.prevAccesses = info.prevAccesses;
                this.nextAccesses = info.nextAccesses;
                this.type = info.type;
                this.range.copy(info.range);
                this.discardContents = info.discardContents;
                this.srcQueue = info.srcQueue;
                this.dstQueue = info.dstQueue;
                return this;
              };
              return TextureBarrierInfo;
            }();
            var BufferBarrierInfo = function () {
              function BufferBarrierInfo(prevAccesses, nextAccesses, type, offset, size, discardContents, srcQueue, dstQueue) {
                if (prevAccesses === undefined) {
                  prevAccesses = 0;
                }
                if (nextAccesses === undefined) {
                  nextAccesses = 0;
                }
                if (type === undefined) {
                  type = 0;
                }
                if (offset === undefined) {
                  offset = 0;
                }
                if (size === undefined) {
                  size = 0;
                }
                if (discardContents === undefined) {
                  discardContents = false;
                }
                if (srcQueue === undefined) {
                  srcQueue = null;
                }
                if (dstQueue === undefined) {
                  dstQueue = null;
                }
                this.prevAccesses = prevAccesses;
                this.nextAccesses = nextAccesses;
                this.type = type;
                this.offset = offset;
                this.size = size;
                this.discardContents = discardContents;
                this.srcQueue = srcQueue;
                this.dstQueue = dstQueue;
              }
              var _proto46 = BufferBarrierInfo.prototype;
              _proto46.copy = function copy(info) {
                this.prevAccesses = info.prevAccesses;
                this.nextAccesses = info.nextAccesses;
                this.type = info.type;
                this.offset = info.offset;
                this.size = info.size;
                this.discardContents = info.discardContents;
                this.srcQueue = info.srcQueue;
                this.dstQueue = info.dstQueue;
                return this;
              };
              return BufferBarrierInfo;
            }();
            var FramebufferInfo = function () {
              function FramebufferInfo(renderPass, colorTextures, depthStencilTexture, depthStencilResolveTexture) {
                if (renderPass === undefined) {
                  renderPass = null;
                }
                if (colorTextures === undefined) {
                  colorTextures = [];
                }
                if (depthStencilTexture === undefined) {
                  depthStencilTexture = null;
                }
                if (depthStencilResolveTexture === undefined) {
                  depthStencilResolveTexture = null;
                }
                this.renderPass = renderPass;
                this.colorTextures = colorTextures;
                this.depthStencilTexture = depthStencilTexture;
                this.depthStencilResolveTexture = depthStencilResolveTexture;
              }
              var _proto47 = FramebufferInfo.prototype;
              _proto47.copy = function copy(info) {
                this.renderPass = info.renderPass;
                this.colorTextures = info.colorTextures.slice();
                this.depthStencilTexture = info.depthStencilTexture;
                this.depthStencilResolveTexture = info.depthStencilResolveTexture;
                return this;
              };
              return FramebufferInfo;
            }();
            var DescriptorSetLayoutBinding = function () {
              function DescriptorSetLayoutBinding(binding, descriptorType, count, stageFlags, access, viewDimension, sampleType, format, immutableSamplers) {
                if (binding === undefined) {
                  binding = -1;
                }
                if (descriptorType === undefined) {
                  descriptorType = 0;
                }
                if (count === undefined) {
                  count = 0;
                }
                if (stageFlags === undefined) {
                  stageFlags = 0;
                }
                if (access === undefined) {
                  access = 1;
                }
                if (viewDimension === undefined) {
                  viewDimension = 0;
                }
                if (sampleType === undefined) {
                  sampleType = 0;
                }
                if (format === undefined) {
                  format = 0;
                }
                if (immutableSamplers === undefined) {
                  immutableSamplers = [];
                }
                this.binding = binding;
                this.descriptorType = descriptorType;
                this.count = count;
                this.stageFlags = stageFlags;
                this.access = access;
                this.viewDimension = viewDimension;
                this.sampleType = sampleType;
                this.format = format;
                this.immutableSamplers = immutableSamplers;
              }
              var _proto48 = DescriptorSetLayoutBinding.prototype;
              _proto48.copy = function copy(info) {
                this.binding = info.binding;
                this.descriptorType = info.descriptorType;
                this.count = info.count;
                this.stageFlags = info.stageFlags;
                this.access = info.access;
                this.viewDimension = info.viewDimension;
                this.sampleType = info.sampleType;
                this.format = info.format;
                this.immutableSamplers = info.immutableSamplers.slice();
                return this;
              };
              return DescriptorSetLayoutBinding;
            }();
            var DescriptorSetLayoutInfo = function () {
              function DescriptorSetLayoutInfo(bindings) {
                if (bindings === undefined) {
                  bindings = [];
                }
                this.bindings = bindings;
              }
              var _proto49 = DescriptorSetLayoutInfo.prototype;
              _proto49.copy = function copy(info) {
                deepCopy(this.bindings, info.bindings, DescriptorSetLayoutBinding);
                return this;
              };
              return DescriptorSetLayoutInfo;
            }();
            var DescriptorSetInfo = function () {
              function DescriptorSetInfo(layout) {
                if (layout === undefined) {
                  layout = null;
                }
                this.layout = layout;
              }
              var _proto50 = DescriptorSetInfo.prototype;
              _proto50.copy = function copy(info) {
                this.layout = info.layout;
                return this;
              };
              return DescriptorSetInfo;
            }();
            var PipelineLayoutInfo = function () {
              function PipelineLayoutInfo(setLayouts) {
                if (setLayouts === undefined) {
                  setLayouts = [];
                }
                this.setLayouts = setLayouts;
              }
              var _proto51 = PipelineLayoutInfo.prototype;
              _proto51.copy = function copy(info) {
                this.setLayouts = info.setLayouts.slice();
                return this;
              };
              return PipelineLayoutInfo;
            }();
            var InputState = function () {
              function InputState(attributes) {
                if (attributes === undefined) {
                  attributes = [];
                }
                this.attributes = attributes;
              }
              var _proto52 = InputState.prototype;
              _proto52.copy = function copy(info) {
                deepCopy(this.attributes, info.attributes, Attribute);
                return this;
              };
              return InputState;
            }();
            var CommandBufferInfo = function () {
              function CommandBufferInfo(queue, type) {
                if (queue === undefined) {
                  queue = null;
                }
                if (type === undefined) {
                  type = 0;
                }
                this.queue = queue;
                this.type = type;
              }
              var _proto53 = CommandBufferInfo.prototype;
              _proto53.copy = function copy(info) {
                this.queue = info.queue;
                this.type = info.type;
                return this;
              };
              return CommandBufferInfo;
            }();
            var QueueInfo = function () {
              function QueueInfo(type) {
                if (type === undefined) {
                  type = 0;
                }
                this.type = type;
              }
              var _proto54 = QueueInfo.prototype;
              _proto54.copy = function copy(info) {
                this.type = info.type;
                return this;
              };
              return QueueInfo;
            }();
            var QueryPoolInfo = function () {
              function QueryPoolInfo(type, maxQueryObjects, forceWait) {
                if (type === undefined) {
                  type = 0;
                }
                if (maxQueryObjects === undefined) {
                  maxQueryObjects = 32767;
                }
                if (forceWait === undefined) {
                  forceWait = true;
                }
                this.type = type;
                this.maxQueryObjects = maxQueryObjects;
                this.forceWait = forceWait;
              }
              var _proto55 = QueryPoolInfo.prototype;
              _proto55.copy = function copy(info) {
                this.type = info.type;
                this.maxQueryObjects = info.maxQueryObjects;
                this.forceWait = info.forceWait;
                return this;
              };
              return QueryPoolInfo;
            }();
            var FormatInfo = function () {
              function FormatInfo(name, size, count, type, hasAlpha, hasDepth, hasStencil, isCompressed) {
                if (name === undefined) {
                  name = '';
                }
                if (size === undefined) {
                  size = 0;
                }
                if (count === undefined) {
                  count = 0;
                }
                if (type === undefined) {
                  type = 0;
                }
                if (hasAlpha === undefined) {
                  hasAlpha = false;
                }
                if (hasDepth === undefined) {
                  hasDepth = false;
                }
                if (hasStencil === undefined) {
                  hasStencil = false;
                }
                if (isCompressed === undefined) {
                  isCompressed = false;
                }
                this.name = name;
                this.size = size;
                this.count = count;
                this.type = type;
                this.hasAlpha = hasAlpha;
                this.hasDepth = hasDepth;
                this.hasStencil = hasStencil;
                this.isCompressed = isCompressed;
              }
              var _proto56 = FormatInfo.prototype;
              _proto56.copy = function copy(info) {
                this.name = info.name;
                this.size = info.size;
                this.count = info.count;
                this.type = info.type;
                this.hasAlpha = info.hasAlpha;
                this.hasDepth = info.hasDepth;
                this.hasStencil = info.hasStencil;
                this.isCompressed = info.isCompressed;
                return this;
              };
              return FormatInfo;
            }();
            var MemoryStatus = function () {
              function MemoryStatus(bufferSize, textureSize) {
                if (bufferSize === undefined) {
                  bufferSize = 0;
                }
                if (textureSize === undefined) {
                  textureSize = 0;
                }
                this.bufferSize = bufferSize;
                this.textureSize = textureSize;
              }
              var _proto57 = MemoryStatus.prototype;
              _proto57.copy = function copy(info) {
                this.bufferSize = info.bufferSize;
                this.textureSize = info.textureSize;
                return this;
              };
              return MemoryStatus;
            }();
            var DynamicStencilStates = function () {
              function DynamicStencilStates(writeMask, compareMask, reference) {
                if (writeMask === undefined) {
                  writeMask = 0;
                }
                if (compareMask === undefined) {
                  compareMask = 0;
                }
                if (reference === undefined) {
                  reference = 0;
                }
                this.writeMask = writeMask;
                this.compareMask = compareMask;
                this.reference = reference;
              }
              var _proto58 = DynamicStencilStates.prototype;
              _proto58.copy = function copy(info) {
                this.writeMask = info.writeMask;
                this.compareMask = info.compareMask;
                this.reference = info.reference;
                return this;
              };
              return DynamicStencilStates;
            }();
            var DynamicStates = function () {
              function DynamicStates(viewport, scissor, blendConstant, lineWidth, depthBiasConstant, depthBiasClamp, depthBiasSlope, depthMinBounds, depthMaxBounds, stencilStatesFront, stencilStatesBack) {
                if (viewport === undefined) {
                  viewport = new Viewport();
                }
                if (scissor === undefined) {
                  scissor = new Rect$1();
                }
                if (blendConstant === undefined) {
                  blendConstant = new Color$1();
                }
                if (lineWidth === undefined) {
                  lineWidth = 1;
                }
                if (depthBiasConstant === undefined) {
                  depthBiasConstant = 0;
                }
                if (depthBiasClamp === undefined) {
                  depthBiasClamp = 0;
                }
                if (depthBiasSlope === undefined) {
                  depthBiasSlope = 0;
                }
                if (depthMinBounds === undefined) {
                  depthMinBounds = 0;
                }
                if (depthMaxBounds === undefined) {
                  depthMaxBounds = 0;
                }
                if (stencilStatesFront === undefined) {
                  stencilStatesFront = new DynamicStencilStates();
                }
                if (stencilStatesBack === undefined) {
                  stencilStatesBack = new DynamicStencilStates();
                }
                this.viewport = viewport;
                this.scissor = scissor;
                this.blendConstant = blendConstant;
                this.lineWidth = lineWidth;
                this.depthBiasConstant = depthBiasConstant;
                this.depthBiasClamp = depthBiasClamp;
                this.depthBiasSlope = depthBiasSlope;
                this.depthMinBounds = depthMinBounds;
                this.depthMaxBounds = depthMaxBounds;
                this.stencilStatesFront = stencilStatesFront;
                this.stencilStatesBack = stencilStatesBack;
              }
              var _proto59 = DynamicStates.prototype;
              _proto59.copy = function copy(info) {
                this.viewport.copy(info.viewport);
                this.scissor.copy(info.scissor);
                this.blendConstant.copy(info.blendConstant);
                this.lineWidth = info.lineWidth;
                this.depthBiasConstant = info.depthBiasConstant;
                this.depthBiasClamp = info.depthBiasClamp;
                this.depthBiasSlope = info.depthBiasSlope;
                this.depthMinBounds = info.depthMinBounds;
                this.depthMaxBounds = info.depthMaxBounds;
                this.stencilStatesFront.copy(info.stencilStatesFront);
                this.stencilStatesBack.copy(info.stencilStatesBack);
                return this;
              };
              return DynamicStates;
            }();
            var GFXObject = function (_GCObject) {
              _inheritsLoose(GFXObject, _GCObject);
              function GFXObject(objectType) {
                var _this;
                _this = _GCObject.call(this) || this;
                _this._objectType = 0;
                _this._objectID = 0;
                _this._typedID = 0;
                _this._objectType = objectType;
                _this._objectID = GFXObject._idTable[0]++;
                _this._typedID = GFXObject._idTable[objectType]++;
                return _this;
              }
              _createClass(GFXObject, [{
                key: "objectType",
                get: function get() {
                  return this._objectType;
                }
              }, {
                key: "objectID",
                get: function get() {
                  return this._objectID;
                }
              }, {
                key: "typedID",
                get: function get() {
                  return this._typedID;
                }
              }]);
              return GFXObject;
            }(GCObject);
            GFXObject._idTable = Array(19).fill(1 << 16);
            var AttributeName = {
              ATTR_POSITION: "a_position",
              ATTR_NORMAL: "a_normal",
              ATTR_TANGENT: "a_tangent",
              ATTR_BITANGENT: "a_bitangent",
              ATTR_WEIGHTS: "a_weights",
              ATTR_JOINTS: "a_joints",
              ATTR_COLOR: "a_color",
              ATTR_COLOR1: "a_color1",
              ATTR_COLOR2: "a_color2",
              ATTR_TEX_COORD: "a_texCoord",
              ATTR_TEX_COORD1: "a_texCoord1",
              ATTR_TEX_COORD2: "a_texCoord2",
              ATTR_TEX_COORD3: "a_texCoord3",
              ATTR_TEX_COORD4: "a_texCoord4",
              ATTR_TEX_COORD5: "a_texCoord5",
              ATTR_TEX_COORD6: "a_texCoord6",
              ATTR_TEX_COORD7: "a_texCoord7",
              ATTR_TEX_COORD8: "a_texCoord8",
              ATTR_BATCH_ID: "a_batch_id",
              ATTR_BATCH_UV: "a_batch_uv"
            };
            function createFormatInfo(name, size, count, type, hasAlpha, hasDepth, hasStencil, isCompressed) {
              return new FormatInfo(name, size, count, type, hasAlpha, hasDepth, hasStencil, isCompressed);
            }
            function createFormatInfo_ASTC_SRGBA(nameSuffix) {
              return new FormatInfo("ASTC_SRGBA_" + nameSuffix, 1, 4, 1, true, false, false, true);
            }
            function createFormatInfo_ASTC_RGBA(nameSuffix) {
              return new FormatInfo("ASTC_RGBA_" + nameSuffix, 1, 4, 1, true, false, false, true);
            }
            var FormatInfos = Object.freeze([createFormatInfo('UNKNOWN'), createFormatInfo('A8', 1, 1, 1, true), createFormatInfo('L8', 1, 1, 1), createFormatInfo('LA8', 1, 2, 1, true), createFormatInfo('R8', 1, 1, 1), createFormatInfo('R8SN', 1, 1, 2), createFormatInfo('R8UI', 1, 1, 3), createFormatInfo('R8I', 1, 1, 4), createFormatInfo('R16F', 2, 1, 6), createFormatInfo('R16UI', 2, 1, 3), createFormatInfo('R16I', 2, 1, 4), createFormatInfo('R32F', 4, 1, 6), createFormatInfo('R32UI', 4, 1, 3), createFormatInfo('R32I', 4, 1, 4), createFormatInfo('RG8', 2, 2, 1), createFormatInfo('RG8SN', 2, 2, 2), createFormatInfo('RG8UI', 2, 2, 3), createFormatInfo('RG8I', 2, 2, 4), createFormatInfo('RG16F', 4, 2, 6), createFormatInfo('RG16UI', 4, 2, 3), createFormatInfo('RG16I', 4, 2, 4), createFormatInfo('RG32F', 8, 2, 6), createFormatInfo('RG32UI', 8, 2, 3), createFormatInfo('RG32I', 8, 2, 4), createFormatInfo('RGB8', 3, 3, 1), createFormatInfo('SRGB8', 3, 3, 1), createFormatInfo('RGB8SN', 3, 3, 2), createFormatInfo('RGB8UI', 3, 3, 3), createFormatInfo('RGB8I', 3, 3, 4), createFormatInfo('RGB16F', 6, 3, 6), createFormatInfo('RGB16UI', 6, 3, 3), createFormatInfo('RGB16I', 6, 3, 4), createFormatInfo('RGB32F', 12, 3, 6), createFormatInfo('RGB32UI', 12, 3, 3), createFormatInfo('RGB32I', 12, 3, 4), createFormatInfo('RGBA8', 4, 4, 1, true), createFormatInfo('BGRA8', 4, 4, 1, true), createFormatInfo('SRGB8_A8', 4, 4, 1, true), createFormatInfo('RGBA8SN', 4, 4, 2, true), createFormatInfo('RGBA8UI', 4, 4, 3, true), createFormatInfo('RGBA8I', 4, 4, 4, true), createFormatInfo('RGBA16F', 8, 4, 6, true), createFormatInfo('RGBA16UI', 8, 4, 3, true), createFormatInfo('RGBA16I', 8, 4, 4, true), createFormatInfo('RGBA32F', 16, 4, 6, true), createFormatInfo('RGBA32UI', 16, 4, 3, true), createFormatInfo('RGBA32I', 16, 4, 4, true), createFormatInfo('R5G6B5', 2, 3, 1), createFormatInfo('R11G11B10F', 4, 3, 6), createFormatInfo('RGB5A1', 2, 4, 1, true), createFormatInfo('RGBA4', 2, 4, 1, true), createFormatInfo('RGB10A2', 2, 4, 1, true), createFormatInfo('RGB10A2UI', 2, 4, 3, true), createFormatInfo('RGB9E5', 2, 4, 6, true), createFormatInfo('DEPTH', 4, 1, 6, false, true), createFormatInfo('DEPTH_STENCIL', 5, 2, 6, false, true, true), createFormatInfo('BC1', 1, 3, 1, false, false, false, true), createFormatInfo('BC1_ALPHA', 1, 4, 1, true, false, false, true), createFormatInfo('BC1_SRGB', 1, 3, 1, false, false, false, true), createFormatInfo('BC1_SRGB_ALPHA', 1, 4, 1, true, false, false, true), createFormatInfo('BC2', 1, 4, 1, true, false, false, true), createFormatInfo('BC2_SRGB', 1, 4, 1, true, false, false, true), createFormatInfo('BC3', 1, 4, 1, true, false, false, true), createFormatInfo('BC3_SRGB', 1, 4, 1, true, false, false, true), createFormatInfo('BC4', 1, 1, 1, false, false, false, true), createFormatInfo('BC4_SNORM', 1, 1, 2, false, false, false, true), createFormatInfo('BC5', 1, 2, 1, false, false, false, true), createFormatInfo('BC5_SNORM', 1, 2, 2, false, false, false, true), createFormatInfo('BC6H_UF16', 1, 3, 5, false, false, false, true), createFormatInfo('BC6H_SF16', 1, 3, 6, false, false, false, true), createFormatInfo('BC7', 1, 4, 1, true, false, false, true), createFormatInfo('BC7_SRGB', 1, 4, 1, true, false, false, true), createFormatInfo('ETC_RGB8', 1, 3, 1, false, false, false, true), createFormatInfo('ETC2_RGB8', 1, 3, 1, false, false, false, true), createFormatInfo('ETC2_SRGB8', 1, 3, 1, false, false, false, true), createFormatInfo('ETC2_RGB8_A1', 1, 4, 1, true, false, false, true), createFormatInfo('ETC2_SRGB8_A1', 1, 4, 1, true, false, false, true), createFormatInfo('ETC2_RGBA8', 2, 4, 1, true, false, false, true), createFormatInfo('ETC2_SRGB8_A8', 2, 4, 1, true, false, false, true), createFormatInfo('EAC_R11', 1, 1, 1, false, false, false, true), createFormatInfo('EAC_R11SN', 1, 1, 2, false, false, false, true), createFormatInfo('EAC_RG11', 2, 2, 1, false, false, false, true), createFormatInfo('EAC_RG11SN', 2, 2, 2, false, false, false, true), createFormatInfo('PVRTC_RGB2', 2, 3, 1, false, false, false, true), createFormatInfo('PVRTC_RGBA2', 2, 4, 1, true, false, false, true), createFormatInfo('PVRTC_RGB4', 2, 3, 1, false, false, false, true), createFormatInfo('PVRTC_RGBA4', 2, 4, 1, true, false, false, true), createFormatInfo('PVRTC2_2BPP', 2, 4, 1, true, false, false, true), createFormatInfo('PVRTC2_4BPP', 2, 4, 1, true, false, false, true), createFormatInfo_ASTC_RGBA('4x4'), createFormatInfo_ASTC_RGBA('5x4'), createFormatInfo_ASTC_RGBA('5x5'), createFormatInfo_ASTC_RGBA('6x5'), createFormatInfo_ASTC_RGBA('6x6'), createFormatInfo_ASTC_RGBA('8x5'), createFormatInfo_ASTC_RGBA('8x6'), createFormatInfo_ASTC_RGBA('8x8'), createFormatInfo_ASTC_RGBA('10x5'), createFormatInfo_ASTC_RGBA('10x6'), createFormatInfo_ASTC_RGBA('10x8'), createFormatInfo_ASTC_RGBA('10x10'), createFormatInfo_ASTC_RGBA('12x10'), createFormatInfo_ASTC_RGBA('12x12'), createFormatInfo_ASTC_SRGBA('4x4'), createFormatInfo_ASTC_SRGBA('5x4'), createFormatInfo_ASTC_SRGBA('5x5'), createFormatInfo_ASTC_SRGBA('6x5'), createFormatInfo_ASTC_SRGBA('6x6'), createFormatInfo_ASTC_SRGBA('8x5'), createFormatInfo_ASTC_SRGBA('8x6'), createFormatInfo_ASTC_SRGBA('8x8'), createFormatInfo_ASTC_SRGBA('10x5'), createFormatInfo_ASTC_SRGBA('10x6'), createFormatInfo_ASTC_SRGBA('10x8'), createFormatInfo_ASTC_SRGBA('10x10'), createFormatInfo_ASTC_SRGBA('12x10'), createFormatInfo_ASTC_SRGBA('12x12')]);
            var DESCRIPTOR_BUFFER_TYPE = 1 | 2 | 4 | 8;
            var DESCRIPTOR_SAMPLER_TYPE = 16 | 32 | 64 | 128 | 256;
            var DESCRIPTOR_DYNAMIC_TYPE = 8 | 2;
            var DESCRIPTOR_STORAGE_BUFFER_TYPE = 4 | 8;
            var DRAW_INFO_SIZE = 28;
            function IsPowerOf2(x) {
              return x > 0 && (x & x - 1) === 0;
            }
            var ceil = Math.ceil;
            function FormatSize(format, width, height, depth) {
              if (!FormatInfos[format].isCompressed) {
                return width * height * depth * FormatInfos[format].size;
              } else {
                switch (format) {
                  case 56:
                  case 57:
                  case 58:
                  case 59:
                    return ceil(width / 4) * ceil(height / 4) * 8 * depth;
                  case 60:
                  case 61:
                  case 62:
                  case 63:
                  case 64:
                  case 65:
                  case 69:
                  case 68:
                  case 70:
                  case 71:
                    return ceil(width / 4) * ceil(height / 4) * 16 * depth;
                  case 66:
                  case 67:
                    return ceil(width / 4) * ceil(height / 4) * 32 * depth;
                  case 72:
                  case 73:
                  case 74:
                  case 75:
                  case 79:
                  case 80:
                    return ceil(width / 4) * ceil(height / 4) * 8 * depth;
                  case 77:
                  case 76:
                  case 81:
                  case 82:
                    return ceil(width / 4) * ceil(height / 4) * 16 * depth;
                  case 83:
                  case 84:
                  case 87:
                    return ceil(width / 8) * ceil(height / 4) * 8 * depth;
                  case 85:
                  case 86:
                  case 88:
                    return ceil(width / 4) * ceil(height / 4) * 8 * depth;
                  case 89:
                  case 103:
                    return ceil(width / 4) * ceil(height / 4) * 16 * depth;
                  case 90:
                  case 104:
                    return ceil(width / 5) * ceil(height / 4) * 16 * depth;
                  case 91:
                  case 105:
                    return ceil(width / 5) * ceil(height / 5) * 16 * depth;
                  case 92:
                  case 106:
                    return ceil(width / 6) * ceil(height / 5) * 16 * depth;
                  case 93:
                  case 107:
                    return ceil(width / 6) * ceil(height / 6) * 16 * depth;
                  case 94:
                  case 108:
                    return ceil(width / 8) * ceil(height / 5) * 16 * depth;
                  case 95:
                  case 109:
                    return ceil(width / 8) * ceil(height / 6) * 16 * depth;
                  case 96:
                  case 110:
                    return ceil(width / 8) * ceil(height / 8) * 16 * depth;
                  case 97:
                  case 111:
                    return ceil(width / 10) * ceil(height / 5) * 16 * depth;
                  case 98:
                  case 112:
                    return ceil(width / 10) * ceil(height / 6) * 16 * depth;
                  case 99:
                  case 113:
                    return ceil(width / 10) * ceil(height / 8) * 16 * depth;
                  case 100:
                  case 114:
                    return ceil(width / 10) * ceil(height / 10) * 16 * depth;
                  case 101:
                  case 115:
                    return ceil(width / 12) * ceil(height / 10) * 16 * depth;
                  case 102:
                  case 116:
                    return ceil(width / 12) * ceil(height / 12) * 16 * depth;
                  default:
                    {
                      return 0;
                    }
                }
              }
            }
            function FormatSurfaceSize(format, width, height, depth, mips) {
              var size = 0;
              for (var i = 0; i < mips; ++i) {
                size += FormatSize(format, width, height, depth);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
              }
              return size;
            }
            var _type2size = [0, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 4, 8, 12, 16, 16, 24, 32, 24, 36, 48, 32, 48, 64, 4, 4, 4, 4, 4, 4];
            function GetTypeSize(type) {
              return _type2size[type] || 0;
            }
            function getTypedArrayConstructor(info) {
              if (info.isCompressed) {
                return Uint8Array;
              }
              var stride = info.size / info.count;
              switch (info.type) {
                case 1:
                case 3:
                  {
                    switch (stride) {
                      case 1:
                        return Uint8Array;
                      case 2:
                        return Uint16Array;
                      case 4:
                        return Uint32Array;
                      default:
                        return Uint8Array;
                    }
                  }
                case 2:
                case 4:
                  {
                    switch (stride) {
                      case 1:
                        return Int8Array;
                      case 2:
                        return Int16Array;
                      case 4:
                        return Int32Array;
                      default:
                        return Int8Array;
                    }
                  }
                case 6:
                  {
                    switch (stride) {
                      case 2:
                        return Uint16Array;
                      case 4:
                        return Float32Array;
                      default:
                        return Float32Array;
                    }
                  }
              }
              return Float32Array;
            }
            function formatAlignment(format) {
              switch (format) {
                case 56:
                case 57:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 65:
                case 69:
                case 68:
                case 70:
                case 71:
                case 66:
                case 67:
                case 72:
                case 73:
                case 74:
                case 75:
                case 79:
                case 80:
                case 77:
                case 76:
                case 81:
                case 82:
                  return {
                    width: 4,
                    height: 4
                  };
                case 83:
                case 84:
                case 87:
                  return {
                    width: 8,
                    height: 4
                  };
                case 85:
                case 86:
                case 88:
                  return {
                    width: 4,
                    height: 4
                  };
                case 89:
                case 103:
                  return {
                    width: 4,
                    height: 4
                  };
                case 90:
                case 104:
                  return {
                    width: 5,
                    height: 4
                  };
                case 91:
                case 105:
                  return {
                    width: 5,
                    height: 5
                  };
                case 92:
                case 106:
                  return {
                    width: 6,
                    height: 5
                  };
                case 93:
                case 107:
                  return {
                    width: 6,
                    height: 6
                  };
                case 94:
                case 108:
                  return {
                    width: 8,
                    height: 5
                  };
                case 95:
                case 109:
                  return {
                    width: 8,
                    height: 6
                  };
                case 96:
                case 110:
                  return {
                    width: 8,
                    height: 8
                  };
                case 97:
                case 111:
                  return {
                    width: 10,
                    height: 5
                  };
                case 98:
                case 112:
                  return {
                    width: 10,
                    height: 6
                  };
                case 99:
                case 113:
                  return {
                    width: 10,
                    height: 8
                  };
                case 100:
                case 114:
                  return {
                    width: 10,
                    height: 10
                  };
                case 101:
                case 115:
                  return {
                    width: 12,
                    height: 10
                  };
                case 102:
                case 116:
                  return {
                    width: 12,
                    height: 12
                  };
                default:
                  return {
                    width: 1,
                    height: 1
                  };
              }
            }
            function alignTo(size, alignment) {
              return ceil(size / alignment) * alignment;
            }

            var defines = /*#__PURE__*/Object.freeze({
                __proto__: null,
                API: API,
                AccessFlagBit: AccessFlagBit,
                Address: Address,
                Attribute: Attribute,
                AttributeName: AttributeName,
                BarrierType: BarrierType,
                BindingMappingInfo: BindingMappingInfo,
                BlendFactor: BlendFactor,
                BlendOp: BlendOp,
                BufferBarrierInfo: BufferBarrierInfo,
                BufferFlagBit: BufferFlagBit,
                BufferInfo: BufferInfo,
                BufferTextureCopy: BufferTextureCopy,
                BufferUsageBit: BufferUsageBit,
                BufferViewInfo: BufferViewInfo,
                ClearFlagBit: ClearFlagBit,
                Color: Color$1,
                ColorAttachment: ColorAttachment,
                ColorMask: ColorMask,
                CommandBufferInfo: CommandBufferInfo,
                CommandBufferType: CommandBufferType,
                ComparisonFunc: ComparisonFunc,
                CullMode: CullMode,
                DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
                DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
                DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
                DESCRIPTOR_STORAGE_BUFFER_TYPE: DESCRIPTOR_STORAGE_BUFFER_TYPE,
                DRAW_INFO_SIZE: DRAW_INFO_SIZE,
                DepthStencilAttachment: DepthStencilAttachment,
                DescriptorSetInfo: DescriptorSetInfo,
                DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
                DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
                DescriptorType: DescriptorType,
                DeviceCaps: DeviceCaps,
                DeviceInfo: DeviceInfo,
                DeviceOptions: DeviceOptions,
                DispatchInfo: DispatchInfo,
                DrawInfo: DrawInfo,
                DynamicStateFlagBit: DynamicStateFlagBit,
                DynamicStates: DynamicStates,
                DynamicStencilStates: DynamicStencilStates,
                Extent: Extent,
                Feature: Feature$1,
                Filter: Filter,
                Format: Format,
                FormatFeatureBit: FormatFeatureBit,
                FormatInfo: FormatInfo,
                FormatInfos: FormatInfos,
                FormatSize: FormatSize,
                FormatSurfaceSize: FormatSurfaceSize,
                FormatType: FormatType,
                FramebufferInfo: FramebufferInfo,
                GFXObject: GFXObject,
                GeneralBarrierInfo: GeneralBarrierInfo,
                GetTypeSize: GetTypeSize,
                IndirectBuffer: IndirectBuffer,
                InputAssemblerInfo: InputAssemblerInfo,
                InputState: InputState,
                IsPowerOf2: IsPowerOf2,
                LoadOp: LoadOp,
                MarkerInfo: MarkerInfo,
                MemoryAccessBit: MemoryAccessBit,
                MemoryStatus: MemoryStatus,
                MemoryUsageBit: MemoryUsageBit,
                ObjectType: ObjectType,
                Offset: Offset,
                PassType: PassType,
                PipelineBindPoint: PipelineBindPoint,
                PipelineLayoutInfo: PipelineLayoutInfo,
                PolygonMode: PolygonMode,
                PrimitiveMode: PrimitiveMode,
                QueryPoolInfo: QueryPoolInfo,
                QueryType: QueryType,
                QueueInfo: QueueInfo,
                QueueType: QueueType,
                Rect: Rect$1,
                RenderPassInfo: RenderPassInfo,
                ResolveMode: ResolveMode,
                ResourceRange: ResourceRange,
                SampleCount: SampleCount,
                SampleType: SampleType,
                SamplerInfo: SamplerInfo,
                ShadeModel: ShadeModel,
                ShaderInfo: ShaderInfo,
                ShaderStage: ShaderStage,
                ShaderStageFlagBit: ShaderStageFlagBit,
                Size: Size$1,
                Status: Status,
                StencilFace: StencilFace,
                StencilOp: StencilOp,
                StoreOp: StoreOp,
                SubpassDependency: SubpassDependency,
                SubpassInfo: SubpassInfo,
                SurfaceTransform: SurfaceTransform,
                SwapchainInfo: SwapchainInfo,
                TextureBarrierInfo: TextureBarrierInfo,
                TextureBlit: TextureBlit,
                TextureCopy: TextureCopy,
                TextureFlagBit: TextureFlagBit,
                TextureInfo: TextureInfo,
                TextureSubresLayers: TextureSubresLayers,
                TextureSubresRange: TextureSubresRange,
                TextureType: TextureType,
                TextureUsageBit: TextureUsageBit,
                TextureViewInfo: TextureViewInfo,
                Type: Type,
                Uniform: Uniform,
                UniformBlock: UniformBlock,
                UniformInputAttachment: UniformInputAttachment,
                UniformSampler: UniformSampler,
                UniformSamplerTexture: UniformSamplerTexture,
                UniformStorageBuffer: UniformStorageBuffer,
                UniformStorageImage: UniformStorageImage,
                UniformTexture: UniformTexture,
                ViewDimension: ViewDimension,
                Viewport: Viewport,
                VsyncMode: VsyncMode,
                alignTo: alignTo,
                formatAlignment: formatAlignment,
                getTypedArrayConstructor: getTypedArrayConstructor
            });

            var Buffer = function (_GFXObject) {
              _inheritsLoose(Buffer, _GFXObject);
              function Buffer() {
                var _this;
                _this = _GFXObject.call(this, 2) || this;
                _this._usage = 0;
                _this._memUsage = 0;
                _this._size = 0;
                _this._stride = 1;
                _this._count = 0;
                _this._flags = 0;
                _this._isBufferView = false;
                return _this;
              }
              _createClass(Buffer, [{
                key: "usage",
                get: function get() {
                  return this._usage;
                }
              }, {
                key: "memUsage",
                get: function get() {
                  return this._memUsage;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                }
              }, {
                key: "stride",
                get: function get() {
                  return this._stride;
                }
              }, {
                key: "count",
                get: function get() {
                  return this._count;
                }
              }, {
                key: "flags",
                get: function get() {
                  return this._flags;
                }
              }]);
              return Buffer;
            }(GFXObject);

            var CommandBuffer = function (_GFXObject) {
              _inheritsLoose(CommandBuffer, _GFXObject);
              function CommandBuffer() {
                var _this;
                _this = _GFXObject.call(this, 13) || this;
                _this._queue = null;
                _this._type = 0;
                _this._numDrawCalls = 0;
                _this._numInstances = 0;
                _this._numTris = 0;
                return _this;
              }
              _createClass(CommandBuffer, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }, {
                key: "queue",
                get: function get() {
                  return this._queue;
                }
              }, {
                key: "numDrawCalls",
                get: function get() {
                  return this._numDrawCalls;
                }
              }, {
                key: "numInstances",
                get: function get() {
                  return this._numInstances;
                }
              }, {
                key: "numTris",
                get: function get() {
                  return this._numTris;
                }
              }]);
              return CommandBuffer;
            }(GFXObject);

            var Device = function () {
              function Device() {
                this._gfxAPI = 0;
                this._renderer = '';
                this._vendor = '';
                this._features = new Array(10);
                this._formatFeatures = new Array(117);
                this._queue = null;
                this._cmdBuff = null;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
                this._memoryStatus = new MemoryStatus();
                this._caps = new DeviceCaps();
                this._bindingMappingInfo = new BindingMappingInfo();
                this._samplers = new Map();
                this._generalBarrierss = new Map();
                this._textureBarriers = new Map();
                this._bufferBarriers = new Map();
                this._swapchainFormat = 35;
              }
              var _proto = Device.prototype;
              _proto.hasFeature = function hasFeature(feature) {
                return this._features[feature];
              };
              _proto.getFormatFeatures = function getFormatFeatures(format) {
                return this._formatFeatures[format];
              };
              _proto.enableAutoBarrier = function enableAutoBarrier(en) {};
              _proto.getMaxSampleCount = function getMaxSampleCount(format, usage, flags) {
                return 1;
              };
              _createClass(Device, [{
                key: "gfxAPI",
                get: function get() {
                  return this._gfxAPI;
                }
              }, {
                key: "queue",
                get: function get() {
                  return this._queue;
                }
              }, {
                key: "commandBuffer",
                get: function get() {
                  return this._cmdBuff;
                }
              }, {
                key: "swapchainFormat",
                get: function get() {
                  return this._swapchainFormat;
                }
              }, {
                key: "renderer",
                get: function get() {
                  return this._renderer;
                }
              }, {
                key: "vendor",
                get: function get() {
                  return this._vendor;
                }
              }, {
                key: "numDrawCalls",
                get: function get() {
                  return this._numDrawCalls;
                }
              }, {
                key: "numInstances",
                get: function get() {
                  return this._numInstances;
                }
              }, {
                key: "numTris",
                get: function get() {
                  return this._numTris;
                }
              }, {
                key: "memoryStatus",
                get: function get() {
                  return this._memoryStatus;
                }
              }, {
                key: "capabilities",
                get: function get() {
                  return this._caps;
                }
              }, {
                key: "bindingMappingInfo",
                get: function get() {
                  return this._bindingMappingInfo;
                }
              }]);
              return Device;
            }();
            Device.canvas = undefined;
            var DefaultResource = function () {
              function DefaultResource(device) {
                this._texture2D = null;
                this._texture3D = null;
                this._textureCube = null;
                this._texture2DArray = null;
                var capabilities = device.capabilities;
                var bufferSize = 64;
                var buffer = new Uint8Array(bufferSize);
                buffer.fill(255);
                if (capabilities.maxTextureSize >= 2) {
                  this._texture2D = device.createTexture(new TextureInfo(1, 8 | 4, 35, 2, 2, 0));
                  var copyRegion = new BufferTextureCopy(0, 0, 0, new Offset(0, 0, 0), new Extent(2, 2, 1));
                  device.copyBuffersToTexture([buffer], this._texture2D, [copyRegion]);
                }
                if (capabilities.maxTextureSize >= 2) {
                  this._textureCube = device.createTexture(new TextureInfo(3, 8 | 4, 35, 2, 2, 0, 6));
                  var _copyRegion = new BufferTextureCopy(0, 0, 0, new Offset(0, 0, 0), new Extent(2, 2, 1));
                  device.copyBuffersToTexture([buffer], this._textureCube, [_copyRegion]);
                  _copyRegion.texSubres.baseArrayLayer = 1;
                  device.copyBuffersToTexture([buffer], this._textureCube, [_copyRegion]);
                  _copyRegion.texSubres.baseArrayLayer = 2;
                  device.copyBuffersToTexture([buffer], this._textureCube, [_copyRegion]);
                  _copyRegion.texSubres.baseArrayLayer = 3;
                  device.copyBuffersToTexture([buffer], this._textureCube, [_copyRegion]);
                  _copyRegion.texSubres.baseArrayLayer = 4;
                  device.copyBuffersToTexture([buffer], this._textureCube, [_copyRegion]);
                  _copyRegion.texSubres.baseArrayLayer = 5;
                  device.copyBuffersToTexture([buffer], this._textureCube, [_copyRegion]);
                }
                if (capabilities.max3DTextureSize >= 2) {
                  this._texture3D = device.createTexture(new TextureInfo(2, 8 | 4, 35, 2, 2, 0, 1, 1, 1, 2));
                  var _copyRegion2 = new BufferTextureCopy(0, 0, 0, new Offset(0, 0, 0), new Extent(2, 2, 2), new TextureSubresLayers(0, 0, 1));
                  device.copyBuffersToTexture([buffer], this._texture3D, [_copyRegion2]);
                }
                if (capabilities.maxArrayTextureLayers >= 2) {
                  this._texture2DArray = device.createTexture(new TextureInfo(5, 8 | 4, 35, 2, 2, 0, 2));
                  var _copyRegion3 = new BufferTextureCopy(0, 0, 0, new Offset(0, 0, 0), new Extent(2, 2, 1), new TextureSubresLayers(0, 0, 1));
                  device.copyBuffersToTexture([buffer], this._texture2DArray, [_copyRegion3]);
                  _copyRegion3.texSubres.baseArrayLayer = 1;
                  device.copyBuffersToTexture([buffer], this._texture2DArray, [_copyRegion3]);
                }
              }
              var _proto2 = DefaultResource.prototype;
              _proto2.getTexture = function getTexture(type) {
                switch (type) {
                  case 1:
                    return this._texture2D;
                  case 2:
                    return this._texture3D;
                  case 3:
                    return this._textureCube;
                  case 5:
                    return this._texture2DArray;
                  default:
                    return null;
                }
              };
              return DefaultResource;
            }();

            var Swapchain = function (_GFXObject) {
              _inheritsLoose(Swapchain, _GFXObject);
              function Swapchain() {
                var _this;
                _this = _GFXObject.call(this, 1) || this;
                _this._transform = 0;
                _this._colorTexture = null;
                _this._depthStencilTexture = null;
                return _this;
              }
              _createClass(Swapchain, [{
                key: "colorTexture",
                get: function get() {
                  return this._colorTexture;
                }
              }, {
                key: "depthStencilTexture",
                get: function get() {
                  return this._depthStencilTexture;
                }
              }, {
                key: "surfaceTransform",
                get: function get() {
                  return this._transform;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._colorTexture.width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._colorTexture.height;
                }
              }]);
              return Swapchain;
            }(GFXObject);

            var Framebuffer = function (_GFXObject) {
              _inheritsLoose(Framebuffer, _GFXObject);
              function Framebuffer() {
                var _this;
                _this = _GFXObject.call(this, 5) || this;
                _this._renderPass = null;
                _this._colorTextures = [];
                _this._depthStencilTexture = null;
                _this._width = 0;
                _this._height = 0;
                return _this;
              }
              _createClass(Framebuffer, [{
                key: "renderPass",
                get: function get() {
                  return this._renderPass;
                }
              }, {
                key: "colorTextures",
                get: function get() {
                  return this._colorTextures;
                }
              }, {
                key: "depthStencilTexture",
                get: function get() {
                  return this._depthStencilTexture;
                }
              }, {
                key: "width",
                get: function get() {
                  if (this.colorTextures.length > 0) {
                    var _this$colorTextures$, _this$colorTextures$2;
                    return (_this$colorTextures$ = (_this$colorTextures$2 = this.colorTextures[0]) == null ? undefined : _this$colorTextures$2.width) !== null && _this$colorTextures$ !== undefined ? _this$colorTextures$ : this._width;
                  } else if (this.depthStencilTexture) {
                    return this.depthStencilTexture.width;
                  }
                  return this._width;
                }
              }, {
                key: "height",
                get: function get() {
                  if (this.colorTextures.length > 0) {
                    var _this$colorTextures$3, _this$colorTextures$4;
                    return (_this$colorTextures$3 = (_this$colorTextures$4 = this.colorTextures[0]) == null ? undefined : _this$colorTextures$4.height) !== null && _this$colorTextures$3 !== undefined ? _this$colorTextures$3 : this._height;
                  } else if (this.depthStencilTexture) {
                    return this.depthStencilTexture.height;
                  }
                  return this._height;
                }
              }, {
                key: "needRebuild",
                get: function get() {
                  return false;
                }
              }]);
              return Framebuffer;
            }(GFXObject);

            var getUint8ForString = String.prototype.charCodeAt;
            function getUint8ForArray(idx) {
              return this[idx];
            }
            function murmurhash2_32_gc(input, seed) {
              var l = input.length;
              var h = seed ^ l;
              var i = 0;
              var getUint8 = typeof input === 'string' ? getUint8ForString : getUint8ForArray;
              while (l >= 4) {
                var k = getUint8.call(input, i) & 0xff | (getUint8.call(input, ++i) & 0xff) << 8 | (getUint8.call(input, ++i) & 0xff) << 16 | (getUint8.call(input, ++i) & 0xff) << 24;
                k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
                k ^= k >>> 24;
                k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
                h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
                l -= 4;
                ++i;
              }
              switch (l) {
                case 3:
                  h ^= (getUint8.call(input, i + 2) & 0xff) << 16;
                case 2:
                  h ^= (getUint8.call(input, i + 1) & 0xff) << 8;
                case 1:
                  h ^= getUint8.call(input, i) & 0xff;
                  h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
                  break;
              }
              h ^= h >>> 13;
              h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
              h ^= h >>> 15;
              return h >>> 0;
            }

            var InputAssembler = function (_GFXObject) {
              _inheritsLoose(InputAssembler, _GFXObject);
              function InputAssembler() {
                var _this;
                _this = _GFXObject.call(this, 12) || this;
                _this._attributes = [];
                _this._attributesHash = 0;
                _this._vertexBuffers = [];
                _this._indexBuffer = null;
                _this._indirectBuffer = null;
                _this._drawInfo = new DrawInfo();
                return _this;
              }
              var _proto = InputAssembler.prototype;
              _proto.getVertexBuffer = function getVertexBuffer(stream) {
                if (stream === undefined) {
                  stream = 0;
                }
                if (stream < this._vertexBuffers.length) {
                  return this._vertexBuffers[stream];
                } else {
                  return null;
                }
              };
              _proto.computeAttributesHash = function computeAttributesHash() {
                var res = 'attrs';
                for (var i = 0; i < this.attributes.length; ++i) {
                  var at = this.attributes[i];
                  res += "," + at.name + "," + at.format + "," + at.isNormalized + "," + at.stream + "," + at.isInstanced + "," + at.location;
                }
                return murmurhash2_32_gc(res, 666);
              };
              _createClass(InputAssembler, [{
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
              }, {
                key: "vertexBuffers",
                get: function get() {
                  return this._vertexBuffers;
                }
              }, {
                key: "indexBuffer",
                get: function get() {
                  return this._indexBuffer;
                }
              }, {
                key: "indirectBuffer",
                get: function get() {
                  return this._indirectBuffer;
                }
              }, {
                key: "attributesHash",
                get: function get() {
                  return this._attributesHash;
                }
              }, {
                key: "vertexCount",
                get: function get() {
                  return this._drawInfo.vertexCount;
                },
                set: function set(count) {
                  this._drawInfo.vertexCount = count;
                }
              }, {
                key: "firstVertex",
                get: function get() {
                  return this._drawInfo.firstVertex;
                },
                set: function set(first) {
                  this._drawInfo.firstVertex = first;
                }
              }, {
                key: "indexCount",
                get: function get() {
                  return this._drawInfo.indexCount;
                },
                set: function set(count) {
                  this._drawInfo.indexCount = count;
                }
              }, {
                key: "firstIndex",
                get: function get() {
                  return this._drawInfo.firstIndex;
                },
                set: function set(first) {
                  this._drawInfo.firstIndex = first;
                }
              }, {
                key: "vertexOffset",
                get: function get() {
                  return this._drawInfo.vertexOffset;
                },
                set: function set(offset) {
                  this._drawInfo.vertexOffset = offset;
                }
              }, {
                key: "instanceCount",
                get: function get() {
                  return this._drawInfo.instanceCount;
                },
                set: function set(count) {
                  this._drawInfo.instanceCount = count;
                }
              }, {
                key: "firstInstance",
                get: function get() {
                  return this._drawInfo.firstInstance;
                },
                set: function set(first) {
                  this._drawInfo.firstInstance = first;
                }
              }, {
                key: "drawInfo",
                get: function get() {
                  return this._drawInfo;
                },
                set: function set(info) {
                  this._drawInfo = info;
                }
              }]);
              return InputAssembler;
            }(GFXObject);

            var DescriptorSet = function (_GFXObject) {
              _inheritsLoose(DescriptorSet, _GFXObject);
              function DescriptorSet() {
                var _this;
                _this = _GFXObject.call(this, 11) || this;
                _this._layout = null;
                _this._buffers = [];
                _this._textures = [];
                _this._samplers = [];
                _this._isDirty = false;
                return _this;
              }
              var _proto = DescriptorSet.prototype;
              _proto.bindBuffer = function bindBuffer(binding, buffer, index) {
                if (index === undefined) {
                  index = 0;
                }
                var bindingIndex = this._layout.bindingIndices[binding];
                var info = this._layout.bindings[bindingIndex];
                if (!info) {
                  return;
                }
                if (info.descriptorType & DESCRIPTOR_BUFFER_TYPE) {
                  var descriptorIndex = this._layout.descriptorIndices[binding];
                  if (this._buffers[descriptorIndex + index] !== buffer) {
                    this._buffers[descriptorIndex + index] = buffer;
                    this._isDirty = true;
                  }
                }
              };
              _proto.bindSampler = function bindSampler(binding, sampler, index) {
                if (index === undefined) {
                  index = 0;
                }
                var bindingIndex = this._layout.bindingIndices[binding];
                var info = this._layout.bindings[bindingIndex];
                if (!info) {
                  return;
                }
                if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
                  var descriptorIndex = this._layout.descriptorIndices[binding];
                  if (this._samplers[descriptorIndex + index] !== sampler) {
                    this._samplers[descriptorIndex + index] = sampler;
                    this._isDirty = true;
                  }
                }
              };
              _proto.bindTexture = function bindTexture(binding, texture, index, flags) {
                if (index === undefined) {
                  index = 0;
                }
                var bindingIndex = this._layout.bindingIndices[binding];
                var info = this._layout.bindings[bindingIndex];
                if (!info) {
                  return;
                }
                if (info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
                  var descriptorIndex = this._layout.descriptorIndices[binding];
                  if (this._textures[descriptorIndex + index] !== texture) {
                    this._textures[descriptorIndex + index] = texture;
                    this._isDirty = true;
                  }
                }
              };
              _proto.getBuffer = function getBuffer(binding, index) {
                if (index === undefined) {
                  index = 0;
                }
                var descriptorIndex = this._layout.descriptorIndices[binding];
                return this._buffers[descriptorIndex + index];
              };
              _proto.getSampler = function getSampler(binding, index) {
                if (index === undefined) {
                  index = 0;
                }
                var descriptorIndex = this._layout.descriptorIndices[binding];
                return this._samplers[descriptorIndex + index];
              };
              _proto.getTexture = function getTexture(binding, index) {
                if (index === undefined) {
                  index = 0;
                }
                var descriptorIndex = this._layout.descriptorIndices[binding];
                return this._textures[descriptorIndex + index];
              };
              _createClass(DescriptorSet, [{
                key: "layout",
                get: function get() {
                  return this._layout;
                }
              }]);
              return DescriptorSet;
            }(GFXObject);

            var DescriptorSetLayout = function (_GFXObject) {
              _inheritsLoose(DescriptorSetLayout, _GFXObject);
              function DescriptorSetLayout() {
                var _this;
                _this = _GFXObject.call(this, 8) || this;
                _this._bindings = [];
                _this._bindingIndices = [];
                _this._descriptorIndices = [];
                return _this;
              }
              _createClass(DescriptorSetLayout, [{
                key: "bindings",
                get: function get() {
                  return this._bindings;
                }
              }, {
                key: "bindingIndices",
                get: function get() {
                  return this._bindingIndices;
                }
              }, {
                key: "descriptorIndices",
                get: function get() {
                  return this._descriptorIndices;
                }
              }]);
              return DescriptorSetLayout;
            }(GFXObject);

            var PipelineLayout = function (_GFXObject) {
              _inheritsLoose(PipelineLayout, _GFXObject);
              function PipelineLayout() {
                var _this;
                _this = _GFXObject.call(this, 9) || this;
                _this._setLayouts = [];
                return _this;
              }
              _createClass(PipelineLayout, [{
                key: "setLayouts",
                get: function get() {
                  return this._setLayouts;
                }
              }]);
              return PipelineLayout;
            }(GFXObject);

            var RasterizerState = function () {
              function RasterizerState(isDiscard, polygonMode, shadeModel, cullMode, isFrontFaceCCW, depthBiasEnabled, depthBias, depthBiasClamp, depthBiasSlop, isDepthClip, isMultisample, lineWidth) {
                if (isDiscard === undefined) {
                  isDiscard = false;
                }
                if (polygonMode === undefined) {
                  polygonMode = 0;
                }
                if (shadeModel === undefined) {
                  shadeModel = 0;
                }
                if (cullMode === undefined) {
                  cullMode = 2;
                }
                if (isFrontFaceCCW === undefined) {
                  isFrontFaceCCW = true;
                }
                if (depthBiasEnabled === undefined) {
                  depthBiasEnabled = false;
                }
                if (depthBias === undefined) {
                  depthBias = 0;
                }
                if (depthBiasClamp === undefined) {
                  depthBiasClamp = 0.0;
                }
                if (depthBiasSlop === undefined) {
                  depthBiasSlop = 0.0;
                }
                if (isDepthClip === undefined) {
                  isDepthClip = true;
                }
                if (isMultisample === undefined) {
                  isMultisample = false;
                }
                if (lineWidth === undefined) {
                  lineWidth = 1.0;
                }
                this.isDiscard = isDiscard;
                this.polygonMode = polygonMode;
                this.shadeModel = shadeModel;
                this.cullMode = cullMode;
                this.isFrontFaceCCW = isFrontFaceCCW;
                this.depthBiasEnabled = depthBiasEnabled;
                this.depthBias = depthBias;
                this.depthBiasClamp = depthBiasClamp;
                this.depthBiasSlop = depthBiasSlop;
                this.isDepthClip = isDepthClip;
                this.isMultisample = isMultisample;
                this.lineWidth = lineWidth;
              }
              var _proto = RasterizerState.prototype;
              _proto.reset = function reset() {
                this.isDiscard = false;
                this.polygonMode = 0;
                this.shadeModel = 0;
                this.cullMode = 2;
                this.isFrontFaceCCW = true;
                this.depthBiasEnabled = false;
                this.depthBias = 0;
                this.depthBiasClamp = 0.0;
                this.depthBiasSlop = 0.0;
                this.isDepthClip = true;
                this.isMultisample = false;
                this.lineWidth = 1.0;
              };
              _proto.assign = function assign(rs) {
                Object.assign(this, rs);
              };
              _proto.destroy = function destroy() {};
              _createClass(RasterizerState, [{
                key: "native",
                get: function get() {
                  return this;
                }
              }]);
              return RasterizerState;
            }();
            var DepthStencilState = function () {
              function DepthStencilState(depthTest, depthWrite, depthFunc, stencilTestFront, stencilFuncFront, stencilReadMaskFront, stencilWriteMaskFront, stencilFailOpFront, stencilZFailOpFront, stencilPassOpFront, stencilRefFront, stencilTestBack, stencilFuncBack, stencilReadMaskBack, stencilWriteMaskBack, stencilFailOpBack, stencilZFailOpBack, stencilPassOpBack, stencilRefBack) {
                if (depthTest === undefined) {
                  depthTest = true;
                }
                if (depthWrite === undefined) {
                  depthWrite = true;
                }
                if (depthFunc === undefined) {
                  depthFunc = 1;
                }
                if (stencilTestFront === undefined) {
                  stencilTestFront = false;
                }
                if (stencilFuncFront === undefined) {
                  stencilFuncFront = 7;
                }
                if (stencilReadMaskFront === undefined) {
                  stencilReadMaskFront = 0xffff;
                }
                if (stencilWriteMaskFront === undefined) {
                  stencilWriteMaskFront = 0xffff;
                }
                if (stencilFailOpFront === undefined) {
                  stencilFailOpFront = 1;
                }
                if (stencilZFailOpFront === undefined) {
                  stencilZFailOpFront = 1;
                }
                if (stencilPassOpFront === undefined) {
                  stencilPassOpFront = 1;
                }
                if (stencilRefFront === undefined) {
                  stencilRefFront = 1;
                }
                if (stencilTestBack === undefined) {
                  stencilTestBack = false;
                }
                if (stencilFuncBack === undefined) {
                  stencilFuncBack = 7;
                }
                if (stencilReadMaskBack === undefined) {
                  stencilReadMaskBack = 0xffff;
                }
                if (stencilWriteMaskBack === undefined) {
                  stencilWriteMaskBack = 0xffff;
                }
                if (stencilFailOpBack === undefined) {
                  stencilFailOpBack = 1;
                }
                if (stencilZFailOpBack === undefined) {
                  stencilZFailOpBack = 1;
                }
                if (stencilPassOpBack === undefined) {
                  stencilPassOpBack = 1;
                }
                if (stencilRefBack === undefined) {
                  stencilRefBack = 1;
                }
                this.depthTest = depthTest;
                this.depthWrite = depthWrite;
                this.depthFunc = depthFunc;
                this.stencilTestFront = stencilTestFront;
                this.stencilFuncFront = stencilFuncFront;
                this.stencilReadMaskFront = stencilReadMaskFront;
                this.stencilWriteMaskFront = stencilWriteMaskFront;
                this.stencilFailOpFront = stencilFailOpFront;
                this.stencilZFailOpFront = stencilZFailOpFront;
                this.stencilPassOpFront = stencilPassOpFront;
                this.stencilRefFront = stencilRefFront;
                this.stencilTestBack = stencilTestBack;
                this.stencilFuncBack = stencilFuncBack;
                this.stencilReadMaskBack = stencilReadMaskBack;
                this.stencilWriteMaskBack = stencilWriteMaskBack;
                this.stencilFailOpBack = stencilFailOpBack;
                this.stencilZFailOpBack = stencilZFailOpBack;
                this.stencilPassOpBack = stencilPassOpBack;
                this.stencilRefBack = stencilRefBack;
              }
              var _proto2 = DepthStencilState.prototype;
              _proto2.reset = function reset() {
                this.depthTest = true;
                this.depthWrite = true;
                this.depthFunc = 1;
                this.stencilTestFront = false;
                this.stencilFuncFront = 7;
                this.stencilReadMaskFront = 0xffff;
                this.stencilWriteMaskFront = 0xffff;
                this.stencilFailOpFront = 1;
                this.stencilZFailOpFront = 1;
                this.stencilPassOpFront = 1;
                this.stencilRefFront = 1;
                this.stencilTestBack = false;
                this.stencilFuncBack = 7;
                this.stencilReadMaskBack = 0xffff;
                this.stencilWriteMaskBack = 0xffff;
                this.stencilFailOpBack = 1;
                this.stencilZFailOpBack = 1;
                this.stencilPassOpBack = 1;
                this.stencilRefBack = 1;
              };
              _proto2.assign = function assign(dss) {
                Object.assign(this, dss);
              };
              _proto2.destroy = function destroy() {};
              _createClass(DepthStencilState, [{
                key: "native",
                get: function get() {
                  return this;
                }
              }]);
              return DepthStencilState;
            }();
            var BlendTarget = function () {
              function BlendTarget(blend, blendSrc, blendDst, blendEq, blendSrcAlpha, blendDstAlpha, blendAlphaEq, blendColorMask) {
                if (blend === undefined) {
                  blend = false;
                }
                if (blendSrc === undefined) {
                  blendSrc = 1;
                }
                if (blendDst === undefined) {
                  blendDst = 0;
                }
                if (blendEq === undefined) {
                  blendEq = 0;
                }
                if (blendSrcAlpha === undefined) {
                  blendSrcAlpha = 1;
                }
                if (blendDstAlpha === undefined) {
                  blendDstAlpha = 0;
                }
                if (blendAlphaEq === undefined) {
                  blendAlphaEq = 0;
                }
                if (blendColorMask === undefined) {
                  blendColorMask = 15;
                }
                this.blend = blend;
                this.blendSrc = blendSrc;
                this.blendDst = blendDst;
                this.blendEq = blendEq;
                this.blendSrcAlpha = blendSrcAlpha;
                this.blendDstAlpha = blendDstAlpha;
                this.blendAlphaEq = blendAlphaEq;
                this.blendColorMask = blendColorMask;
              }
              var _proto3 = BlendTarget.prototype;
              _proto3.reset = function reset() {
                this.blend = false;
                this.blendSrc = 1;
                this.blendDst = 0;
                this.blendEq = 0;
                this.blendSrcAlpha = 1;
                this.blendDstAlpha = 0;
                this.blendAlphaEq = 0;
                this.blendColorMask = 15;
              };
              _proto3.assign = function assign(target) {
                Object.assign(this, target);
              };
              _proto3.destroy = function destroy() {};
              return BlendTarget;
            }();
            var BlendState = function () {
              function BlendState(isA2C, isIndepend, blendColor, targets) {
                if (isA2C === undefined) {
                  isA2C = false;
                }
                if (isIndepend === undefined) {
                  isIndepend = false;
                }
                if (blendColor === undefined) {
                  blendColor = new Color$1();
                }
                if (targets === undefined) {
                  targets = [new BlendTarget()];
                }
                this.isA2C = isA2C;
                this.isIndepend = isIndepend;
                this.blendColor = blendColor;
                this.targets = targets;
              }
              var _proto4 = BlendState.prototype;
              _proto4.setTarget = function setTarget(index, target) {
                var tg = this.targets[index];
                if (!tg) {
                  tg = this.targets[index] = new BlendTarget();
                }
                Object.assign(tg, target);
              };
              _proto4.reset = function reset() {
                this.isA2C = false;
                this.isIndepend = false;
                this.blendColor.x = 0;
                this.blendColor.y = 0;
                this.blendColor.z = 0;
                this.blendColor.w = 0;
                this.targets.length = 1;
                this.targets[0].reset();
              };
              _proto4.destroy = function destroy() {};
              _createClass(BlendState, [{
                key: "native",
                get: function get() {
                  return this;
                }
              }]);
              return BlendState;
            }();

            var PipelineStateInfo = function PipelineStateInfo(shader, pipelineLayout, renderPass, inputState, rasterizerState, depthStencilState, blendState, primitive, dynamicStates, bindPoint) {
              if (shader === undefined) {
                shader = null;
              }
              if (pipelineLayout === undefined) {
                pipelineLayout = null;
              }
              if (renderPass === undefined) {
                renderPass = null;
              }
              if (inputState === undefined) {
                inputState = new InputState();
              }
              if (rasterizerState === undefined) {
                rasterizerState = new RasterizerState();
              }
              if (depthStencilState === undefined) {
                depthStencilState = new DepthStencilState();
              }
              if (blendState === undefined) {
                blendState = new BlendState();
              }
              if (primitive === undefined) {
                primitive = 7;
              }
              if (dynamicStates === undefined) {
                dynamicStates = 0;
              }
              if (bindPoint === undefined) {
                bindPoint = 0;
              }
              this.shader = shader;
              this.pipelineLayout = pipelineLayout;
              this.renderPass = renderPass;
              this.inputState = inputState;
              this.rasterizerState = rasterizerState;
              this.depthStencilState = depthStencilState;
              this.blendState = blendState;
              this.primitive = primitive;
              this.dynamicStates = dynamicStates;
              this.bindPoint = bindPoint;
            };
            var PipelineState = function (_GFXObject) {
              _inheritsLoose(PipelineState, _GFXObject);
              function PipelineState() {
                var _this;
                _this = _GFXObject.call(this, 10) || this;
                _this._shader = null;
                _this._pipelineLayout = null;
                _this._primitive = 7;
                _this._is = null;
                _this._rs = new RasterizerState();
                _this._dss = new DepthStencilState();
                _this._bs = new BlendState();
                _this._dynamicStates = 0;
                _this._renderPass = null;
                return _this;
              }
              _createClass(PipelineState, [{
                key: "shader",
                get: function get() {
                  return this._shader;
                }
              }, {
                key: "pipelineLayout",
                get: function get() {
                  return this._pipelineLayout;
                }
              }, {
                key: "primitive",
                get: function get() {
                  return this._primitive;
                }
              }, {
                key: "rasterizerState",
                get: function get() {
                  return this._rs;
                }
              }, {
                key: "depthStencilState",
                get: function get() {
                  return this._dss;
                }
              }, {
                key: "blendState",
                get: function get() {
                  return this._bs;
                }
              }, {
                key: "inputState",
                get: function get() {
                  return this._is;
                }
              }, {
                key: "dynamicStates",
                get: function get() {
                  return this._dynamicStates;
                }
              }, {
                key: "renderPass",
                get: function get() {
                  return this._renderPass;
                }
              }]);
              return PipelineState;
            }(GFXObject);

            var Queue = function (_GFXObject) {
              _inheritsLoose(Queue, _GFXObject);
              function Queue() {
                var _this;
                _this = _GFXObject.call(this, 14) || this;
                _this._type = 0;
                return _this;
              }
              _createClass(Queue, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }]);
              return Queue;
            }(GFXObject);

            var RenderPass = function (_GFXObject) {
              _inheritsLoose(RenderPass, _GFXObject);
              function RenderPass() {
                var _this;
                _this = _GFXObject.call(this, 4) || this;
                _this._colorInfos = [];
                _this._depthStencilInfo = null;
                _this._subpasses = [];
                _this._hash = 0;
                return _this;
              }
              var _proto = RenderPass.prototype;
              _proto.computeHash = function computeHash() {
                var res = '';
                if (this._subpasses.length) {
                  for (var i = 0; i < this._subpasses.length; ++i) {
                    var subpass = this._subpasses[i];
                    if (subpass.inputs.length) {
                      res += 'ia';
                      for (var j = 0; j < subpass.inputs.length; ++j) {
                        var ia = this._colorInfos[subpass.inputs[j]];
                        res += "," + ia.format + "," + ia.sampleCount;
                      }
                    }
                    if (subpass.colors.length) {
                      res += 'ca';
                      for (var _j = 0; _j < subpass.colors.length; ++_j) {
                        var ca = this._colorInfos[subpass.colors[_j]];
                        res += "," + ca.format + "," + ca.sampleCount;
                      }
                    }
                    if (subpass.depthStencil >= 0) {
                      var ds = this._colorInfos[subpass.depthStencil];
                      res += "ds," + ds.format + "," + ds.sampleCount;
                    }
                  }
                } else {
                  res += 'ca';
                  for (var _i = 0; _i < this._colorInfos.length; ++_i) {
                    var _ca = this._colorInfos[_i];
                    res += "," + _ca.format + "," + _ca.sampleCount;
                  }
                  var _ds = this._depthStencilInfo;
                  if (_ds) {
                    res += "ds," + _ds.format + "," + _ds.sampleCount;
                  }
                }
                return murmurhash2_32_gc(res, 666);
              };
              _createClass(RenderPass, [{
                key: "colorAttachments",
                get: function get() {
                  return this._colorInfos;
                }
              }, {
                key: "depthStencilAttachment",
                get: function get() {
                  return this._depthStencilInfo;
                }
              }, {
                key: "subPasses",
                get: function get() {
                  return this._subpasses;
                }
              }, {
                key: "hash",
                get: function get() {
                  return this._hash;
                }
              }]);
              return RenderPass;
            }(GFXObject);

            var Sampler = function (_GFXObject) {
              _inheritsLoose(Sampler, _GFXObject);
              function Sampler(info, hash) {
                var _this;
                _this = _GFXObject.call(this, 6) || this;
                _this._info = new SamplerInfo();
                _this._hash = 0;
                _this._info.copy(info);
                _this._hash = hash;
                return _this;
              }
              Sampler.computeHash = function computeHash(info) {
                var hash = info.minFilter;
                hash |= info.magFilter << 2;
                hash |= info.mipFilter << 4;
                hash |= info.addressU << 6;
                hash |= info.addressV << 8;
                hash |= info.addressW << 10;
                hash |= Math.min(info.maxAnisotropy, 16) << 12;
                hash |= info.cmpFunc << 17;
                return hash;
              };
              Sampler.unpackFromHash = function unpackFromHash(hash) {
                var info = new SamplerInfo();
                info.minFilter = hash & 3;
                info.magFilter = hash >> 2 & 3;
                info.mipFilter = hash >> 4 & 3;
                info.addressU = hash >> 6 & 3;
                info.addressV = hash >> 8 & 3;
                info.addressW = hash >> 10 & 3;
                info.maxAnisotropy = hash >> 12 & 31;
                info.cmpFunc = hash >> 17 & 7;
                return info;
              };
              _createClass(Sampler, [{
                key: "info",
                get: function get() {
                  return this._info;
                }
              }, {
                key: "hash",
                get: function get() {
                  return this._hash;
                }
              }]);
              return Sampler;
            }(GFXObject);

            var Shader = function (_GFXObject) {
              _inheritsLoose(Shader, _GFXObject);
              function Shader() {
                var _this;
                _this = _GFXObject.call(this, 7) || this;
                _this._name = '';
                _this._stages = [];
                _this._attributes = [];
                _this._blocks = [];
                _this._samplers = [];
                return _this;
              }
              _createClass(Shader, [{
                key: "name",
                get: function get() {
                  return this._name;
                }
              }, {
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
              }, {
                key: "blocks",
                get: function get() {
                  return this._blocks;
                }
              }, {
                key: "samplers",
                get: function get() {
                  return this._samplers;
                }
              }, {
                key: "stages",
                get: function get() {
                  return this._stages;
                }
              }]);
              return Shader;
            }(GFXObject);

            var Texture = function (_GFXObject) {
              _inheritsLoose(Texture, _GFXObject);
              function Texture() {
                var _this;
                _this = _GFXObject.call(this, 3) || this;
                _this._info = new TextureInfo();
                _this._viewInfo = new TextureViewInfo();
                _this._isPowerOf2 = false;
                _this._isTextureView = false;
                _this._size = 0;
                return _this;
              }
              Texture.getLevelCount = function getLevelCount(width, height) {
                return Math.floor(Math.log2(Math.max(width, height)));
              };
              _createClass(Texture, [{
                key: "type",
                get: function get() {
                  return this._info.type;
                }
              }, {
                key: "usage",
                get: function get() {
                  return this._info.usage;
                }
              }, {
                key: "format",
                get: function get() {
                  return this._info.format;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._info.width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._info.height;
                }
              }, {
                key: "depth",
                get: function get() {
                  return this._info.depth;
                }
              }, {
                key: "layerCount",
                get: function get() {
                  return this._info.layerCount;
                }
              }, {
                key: "levelCount",
                get: function get() {
                  return this._info.levelCount;
                }
              }, {
                key: "samples",
                get: function get() {
                  return this._info.samples;
                }
              }, {
                key: "flags",
                get: function get() {
                  return this._info.flags;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                }
              }, {
                key: "info",
                get: function get() {
                  return this._info;
                }
              }, {
                key: "viewInfo",
                get: function get() {
                  return this._viewInfo;
                }
              }, {
                key: "isTextureView",
                get: function get() {
                  return this._isTextureView;
                }
              }]);
              return Texture;
            }(GFXObject);

            var GeneralBarrier = function (_GFXObject) {
              _inheritsLoose(GeneralBarrier, _GFXObject);
              function GeneralBarrier(info, hash) {
                var _this;
                _this = _GFXObject.call(this, 16) || this;
                _this._info = new GeneralBarrierInfo();
                _this._hash = 0;
                _this._info.copy(info);
                _this._hash = hash;
                return _this;
              }
              GeneralBarrier.computeHash = function computeHash(info) {
                return murmurhash2_32_gc(info.prevAccesses + " " + info.nextAccesses + " " + info.type, 666);
              };
              _createClass(GeneralBarrier, [{
                key: "info",
                get: function get() {
                  return this._info;
                }
              }, {
                key: "hash",
                get: function get() {
                  return this._hash;
                }
              }]);
              return GeneralBarrier;
            }(GFXObject);

            var TextureBarrier = function (_GFXObject) {
              _inheritsLoose(TextureBarrier, _GFXObject);
              function TextureBarrier(info, hash) {
                var _this;
                _this = _GFXObject.call(this, 17) || this;
                _this._info = new TextureBarrierInfo();
                _this._hash = 0;
                _this._info.copy(info);
                _this._hash = hash;
                return _this;
              }
              TextureBarrier.computeHash = function computeHash(info) {
                var res = info.prevAccesses + " " + info.nextAccesses;
                res += info.type;
                res += info.range.mipLevel;
                res += info.range.levelCount;
                res += info.range.firstSlice;
                res += info.range.numSlices;
                res += info.range.basePlane;
                res += info.range.planeCount;
                res += info.discardContents;
                res += info.srcQueue ? info.srcQueue.type : 0;
                res += info.dstQueue ? info.dstQueue.type : 0;
                return murmurhash2_32_gc(res, 666);
              };
              _createClass(TextureBarrier, [{
                key: "info",
                get: function get() {
                  return this._info;
                }
              }, {
                key: "hash",
                get: function get() {
                  return this._hash;
                }
              }]);
              return TextureBarrier;
            }(GFXObject);

            var BufferBarrier = function (_GFXObject) {
              _inheritsLoose(BufferBarrier, _GFXObject);
              function BufferBarrier(info, hash) {
                var _this;
                _this = _GFXObject.call(this, 18) || this;
                _this._info = new BufferBarrierInfo();
                _this._hash = 0;
                _this._info.copy(info);
                _this._hash = hash;
                return _this;
              }
              BufferBarrier.computeHash = function computeHash(info) {
                var res = info.prevAccesses + " " + info.nextAccesses;
                res += info.type;
                res += info.offset;
                res += info.size;
                res += info.discardContents;
                res += info.srcQueue ? info.srcQueue.type : 0;
                res += info.dstQueue ? info.dstQueue.type : 0;
                return murmurhash2_32_gc(res, 666);
              };
              _createClass(BufferBarrier, [{
                key: "info",
                get: function get() {
                  return this._info;
                }
              }, {
                key: "hash",
                get: function get() {
                  return this._hash;
                }
              }]);
              return BufferBarrier;
            }(GFXObject);

            var polyfills$1 = {
              Device: Device,
              Swapchain: Swapchain,
              Buffer: Buffer,
              Texture: Texture,
              Sampler: Sampler,
              Shader: Shader,
              InputAssembler: InputAssembler,
              RenderPass: RenderPass,
              Framebuffer: Framebuffer,
              DescriptorSet: DescriptorSet,
              DescriptorSetLayout: DescriptorSetLayout,
              PipelineLayout: PipelineLayout,
              PipelineState: PipelineState,
              CommandBuffer: CommandBuffer,
              Queue: Queue,
              GeneralBarrier: GeneralBarrier,
              TextureBarrier: TextureBarrier,
              BufferBarrier: BufferBarrier,
              RasterizerState: RasterizerState,
              BlendState: BlendState,
              BlendTarget: BlendTarget,
              DepthStencilState: DepthStencilState,
              PipelineStateInfo: PipelineStateInfo
            };
            Object.assign(polyfills$1, defines);
            cclegacy.gfx = polyfills$1;

            var INT_BITS = 32;
            var INT_MAX = 0x7fffffff;
            var INT_MIN = -1 << INT_BITS - 1;
            function sign$1(v) {
              return (v > 0) - (v < 0);
            }
            function abs$6(v) {
              var mask = v >> INT_BITS - 1;
              return (v ^ mask) - mask;
            }
            function min$5(x, y) {
              return y ^ (x ^ y) & -(x < y);
            }
            function max$8(x, y) {
              return x ^ (x ^ y) & -(x < y);
            }
            function isPow2(v) {
              return !(v & v - 1) && !!v;
            }
            function log2(v) {
              var r;
              var shift;
              r = (v > 0xFFFF) << 4;
              v >>>= r;
              shift = (v > 0xFF) << 3;
              v >>>= shift;
              r |= shift;
              shift = (v > 0xF) << 2;
              v >>>= shift;
              r |= shift;
              shift = (v > 0x3) << 1;
              v >>>= shift;
              r |= shift;
              return r | v >> 1;
            }
            function log10(v) {
              return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
            }
            function popCount(v) {
              v -= v >>> 1 & 0x55555555;
              v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
              return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
            }
            function countTrailingZeros(v) {
              var c = 32;
              v &= -v;
              if (v) {
                c--;
              }
              if (v & 0x0000FFFF) {
                c -= 16;
              }
              if (v & 0x00FF00FF) {
                c -= 8;
              }
              if (v & 0x0F0F0F0F) {
                c -= 4;
              }
              if (v & 0x33333333) {
                c -= 2;
              }
              if (v & 0x55555555) {
                c -= 1;
              }
              return c;
            }
            function nextPow2$1(v) {
              --v;
              v |= v >>> 1;
              v |= v >>> 2;
              v |= v >>> 4;
              v |= v >>> 8;
              v |= v >>> 16;
              return v + 1;
            }
            function prevPow2(v) {
              v |= v >>> 1;
              v |= v >>> 2;
              v |= v >>> 4;
              v |= v >>> 8;
              v |= v >>> 16;
              return v - (v >>> 1);
            }
            function parity(v) {
              v ^= v >>> 16;
              v ^= v >>> 8;
              v ^= v >>> 4;
              v &= 0xf;
              return 0x6996 >>> v & 1;
            }
            var REVERSE_TABLE = new Array(256);
            (function (tab) {
              for (var i = 0; i < 256; ++i) {
                var v = i;
                var r = i;
                var s = 7;
                for (v >>>= 1; v; v >>>= 1) {
                  r <<= 1;
                  r |= v & 1;
                  --s;
                }
                tab[i] = r << s & 0xff;
              }
            })(REVERSE_TABLE);
            function reverse(v) {
              return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
            }
            function interleave2(x, y) {
              x &= 0xFFFF;
              x = (x | x << 8) & 0x00FF00FF;
              x = (x | x << 4) & 0x0F0F0F0F;
              x = (x | x << 2) & 0x33333333;
              x = (x | x << 1) & 0x55555555;
              y &= 0xFFFF;
              y = (y | y << 8) & 0x00FF00FF;
              y = (y | y << 4) & 0x0F0F0F0F;
              y = (y | y << 2) & 0x33333333;
              y = (y | y << 1) & 0x55555555;
              return x | y << 1;
            }
            function deinterleave2(v, n) {
              v = v >>> n & 0x55555555;
              v = (v | v >>> 1) & 0x33333333;
              v = (v | v >>> 2) & 0x0F0F0F0F;
              v = (v | v >>> 4) & 0x00FF00FF;
              v = (v | v >>> 16) & 0x000FFFF;
              return v << 16 >> 16;
            }
            function interleave3(x, y, z) {
              x &= 0x3FF;
              x = (x | x << 16) & 4278190335;
              x = (x | x << 8) & 251719695;
              x = (x | x << 4) & 3272356035;
              x = (x | x << 2) & 1227133513;
              y &= 0x3FF;
              y = (y | y << 16) & 4278190335;
              y = (y | y << 8) & 251719695;
              y = (y | y << 4) & 3272356035;
              y = (y | y << 2) & 1227133513;
              x |= y << 1;
              z &= 0x3FF;
              z = (z | z << 16) & 4278190335;
              z = (z | z << 8) & 251719695;
              z = (z | z << 4) & 3272356035;
              z = (z | z << 2) & 1227133513;
              return x | z << 2;
            }
            function deinterleave3(v, n) {
              v = v >>> n & 1227133513;
              v = (v | v >>> 2) & 3272356035;
              v = (v | v >>> 4) & 251719695;
              v = (v | v >>> 8) & 4278190335;
              v = (v | v >>> 16) & 0x3FF;
              return v << 22 >> 22;
            }
            function nextCombination(v) {
              var t = v | v - 1;
              return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
            }

            var bits = /*#__PURE__*/Object.freeze({
                __proto__: null,
                INT_BITS: INT_BITS,
                INT_MAX: INT_MAX,
                INT_MIN: INT_MIN,
                abs: abs$6,
                countTrailingZeros: countTrailingZeros,
                deinterleave2: deinterleave2,
                deinterleave3: deinterleave3,
                interleave2: interleave2,
                interleave3: interleave3,
                isPow2: isPow2,
                log10: log10,
                log2: log2,
                max: max$8,
                min: min$5,
                nextCombination: nextCombination,
                nextPow2: nextPow2$1,
                parity: parity,
                popCount: popCount,
                prevPow2: prevPow2,
                reverse: reverse,
                sign: sign$1
            });
            exports("bits", bits);

            var defaultLogTimes = 10;
            function setDefaultLogTimes(times) {
              if (times > 0) {
                defaultLogTimes = times;
              }
            }
            var replaceProperty; exports("replaceProperty", replaceProperty);
            var removeProperty; exports("removeProperty", removeProperty);
            var markAsWarning; exports("markAsWarning", markAsWarning);
            var replacePropertyLog;
            var markAsWarningLog;
            var removePropertyLog;
            var messageID = 0;
            var messageMap = new Map();
            replacePropertyLog = function replacePropertyLog(n, dp, n2, newp, f, id, s) {
              var item = messageMap.get(id);
              if (item && item.logTimes > item.count) {
                f("'%s' is deprecated, please use '%s' instead. " + s, n + "." + dp, n2 + "." + newp);
                item.count++;
              }
            };
            exports("replaceProperty", replaceProperty = function replaceProperty(owner, ownerName, properties) {
              if (owner == null) return;
              properties.forEach(function (item) {
                var id = messageID++;
                messageMap.set(id, {
                  id: id,
                  count: 0,
                  logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
                });
                var target = item.target != null ? item.target : owner;
                var newName = item.newName != null ? item.newName : item.name;
                var targetName = item.targetName != null ? item.targetName : ownerName;
                var sameTarget = target === owner;
                var suggest = item.suggest ? "(" + item.suggest + ")" : '';
                if (item.customFunction != null) {
                  owner[item.name] = function () {
                    var _ref;
                    replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                    return (_ref = item.customFunction).call.apply(_ref, [this].concat(Array.prototype.slice.call(arguments)));
                  };
                } else if (item.customSetter != null || item.customGetter != null) {
                  var hasSetter = item.customSetter != null;
                  var hasGetter = item.customGetter != null;
                  if (hasSetter && hasGetter) {
                    Object.defineProperty(owner, item.name, {
                      get: function get() {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        return item.customGetter.call(this);
                      },
                      set: function set(v) {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        item.customSetter.call(this, v);
                      },
                      enumerable: false
                    });
                  } else if (hasSetter) {
                    Object.defineProperty(owner, item.name, {
                      set: function set(v) {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        item.customSetter.call(this, v);
                      },
                      enumerable: false
                    });
                  } else if (hasGetter) {
                    Object.defineProperty(owner, item.name, {
                      get: function get() {
                        replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                        return item.customGetter.call(this);
                      },
                      enumerable: false
                    });
                  }
                } else {
                  Object.defineProperty(owner, item.name, {
                    get: function get() {
                      replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                      return sameTarget ? this[newName] : target[newName];
                    },
                    set: function set(v) {
                      replacePropertyLog(ownerName, item.name, targetName, newName, warn, id, suggest);
                      if (sameTarget) {
                        this[newName] = v;
                      } else {
                        target[newName] = v;
                      }
                    },
                    enumerable: false
                  });
                }
              });
            });
            removePropertyLog = function removePropertyLog(n, dp, f, id, s) {
              var item = messageMap.get(id);
              if (item && item.logTimes > item.count) {
                f("'%s' has been removed. " + s, n + "." + dp);
                item.count++;
              }
            };
            exports("removeProperty", removeProperty = function removeProperty(owner, ownerName, properties) {
              if (owner == null) return;
              properties.forEach(function (item) {
                var id = messageID++;
                messageMap.set(id, {
                  id: id,
                  count: 0,
                  logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
                });
                var suggest = item.suggest ? "(" + item.suggest + ")" : '';
                Object.defineProperty(owner, item.name, {
                  get: function get() {
                    return removePropertyLog(ownerName, item.name, error, id, suggest);
                  },
                  set: function set() {
                    removePropertyLog(ownerName, item.name, error, id, suggest);
                  },
                  enumerable: false
                });
              });
            });
            markAsWarningLog = function markAsWarningLog(n, dp, f, id, s) {
              var item = messageMap.get(id);
              if (item && item.logTimes > item.count) {
                f("'%s' is deprecated. " + s, n + "." + dp);
                item.count++;
              }
            };
            exports("markAsWarning", markAsWarning = function markAsWarning(owner, ownerName, properties) {
              if (owner == null) return;
              var _defaultGetSet = function _defaultGetSet(d, n, dp, f, id, s) {
                if (d.get) {
                  var oldGet = d.get;
                  d.get = function () {
                    markAsWarningLog(n, dp, f, id, s);
                    return oldGet.call(this);
                  };
                }
                if (d.set) {
                  var oldSet = d.set;
                  d.set = function (v) {
                    markAsWarningLog(n, dp, f, id, s);
                    oldSet.call(this, v);
                  };
                }
                Object.defineProperty(owner, dp, d);
              };
              properties.forEach(function (item) {
                var deprecatedProp = item.name;
                var descriptor = Object.getOwnPropertyDescriptor(owner, deprecatedProp);
                if (!descriptor || !descriptor.configurable) {
                  return;
                }
                var id = messageID++;
                messageMap.set(id, {
                  id: id,
                  count: 0,
                  logTimes: item.logTimes !== undefined ? item.logTimes : defaultLogTimes
                });
                var suggest = item.suggest ? "(" + item.suggest + ")" : '';
                if (typeof descriptor.value !== 'undefined') {
                  if (typeof descriptor.value === 'function') {
                    var oldValue = descriptor.value;
                    owner[deprecatedProp] = function () {
                      markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                      return oldValue.call.apply(oldValue, [this].concat(Array.prototype.slice.call(arguments)));
                    };
                  } else {
                    var _oldValue = descriptor.value;
                    Object.defineProperty(owner, deprecatedProp, {
                      configurable: true,
                      get: function get() {
                        markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                        return _oldValue;
                      }
                    });
                    if (descriptor.writable) {
                      Object.defineProperty(owner, deprecatedProp, {
                        set: function set(value) {
                          markAsWarningLog(ownerName, deprecatedProp, warn, id, suggest);
                          _oldValue = value;
                        }
                      });
                    }
                  }
                } else {
                  _defaultGetSet(descriptor, ownerName, deprecatedProp, warn, id, suggest);
                }
                Object.defineProperty(owner, deprecatedProp, {
                  enumerable: false
                });
              });
            });
            var topLevelDeprecateList = {};
            function deprecateModuleExportedName(deprecateList) {
              for (var deprecateName in deprecateList) {
                var deprecateInfo = deprecateList[deprecateName];
                topLevelDeprecateList[deprecateName] = deprecateInfo;
              }
            }
            function _checkObsoleteByName(checkName) {
              var deprecateInfo = topLevelDeprecateList[checkName];
              if (!deprecateInfo) {
                return;
              }
              var newName = deprecateInfo.newName,
                since = deprecateInfo.since,
                removed = deprecateInfo.removed;
              if (removed) {
                if (newName) {
                  errorID(16003, checkName, since, newName);
                } else {
                  errorID(16002, checkName, since);
                }
              } else if (newName) {
                warnID(16001, checkName, since, newName);
              } else {
                warnID(16000, checkName, since);
              }
            }
            function __checkObsolete__(checkList) {
              for (var _iterator = _createForOfIteratorHelperLoose(checkList), _step; !(_step = _iterator()).done;) {
                var checkName = _step.value;
                _checkObsoleteByName(checkName);
              }
            }
            var _cachedProxy;
            function __checkObsoleteInNamespace__(ccNamespace) {
              if (!_cachedProxy) {
                if (typeof Proxy === 'undefined') {
                  _cachedProxy = {};
                } else {
                  _cachedProxy = new Proxy(ccNamespace, {
                    get: function get(target, name, receiver) {
                      _checkObsoleteByName(name);
                      return Reflect.get(target, name, receiver);
                    }
                  });
                }
              }
              return _cachedProxy;
            }

            var _class$X;
            var NonUuidMark = '.';
            var IDGenerator = function () {
              function IDGenerator(category) {
                this.id = 0 | Math.random() * 998;
                this.prefix = category ? category + NonUuidMark : '';
              }
              var _proto = IDGenerator.prototype;
              _proto.getNewId = function getNewId() {
                return this.prefix + (++this.id).toString();
              };
              return IDGenerator;
            }();
            _class$X = IDGenerator;
            IDGenerator.global = new _class$X('global');

            var tempCIDGenerator = new IDGenerator('TmpCId.');
            var aliasesTag = typeof Symbol === 'undefined' ? '__aliases__' : Symbol('[[Aliases]]');
            var classNameTag = '__classname__';
            var classIdTag = '__cid__';
            function isNumber(object) {
              return typeof object === 'number' || object instanceof Number;
            }
            function isString(object) {
              return typeof object === 'string' || object instanceof String;
            }
            function isEmptyObject(obj) {
              for (var key in obj) {
                return false;
              }
              return true;
            }
            var value = function () {
              var descriptor = {
                value: undefined,
                enumerable: false,
                writable: false,
                configurable: true
              };
              return function (object, propertyName, value_, writable, enumerable) {
                descriptor.value = value_;
                descriptor.writable = writable;
                descriptor.enumerable = enumerable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.value = undefined;
              };
            }();
            var getset = function () {
              var descriptor = {
                get: undefined,
                set: undefined,
                enumerable: false
              };
              return function (object, propertyName, getter, setter, enumerable, configurable) {
                if (enumerable === undefined) {
                  enumerable = false;
                }
                if (configurable === undefined) {
                  configurable = false;
                }
                if (typeof setter === 'boolean') {
                  logID(1031);
                  enumerable = setter;
                  setter = undefined;
                }
                descriptor.get = getter;
                descriptor.set = setter;
                descriptor.enumerable = enumerable;
                descriptor.configurable = configurable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.get = undefined;
                descriptor.set = undefined;
              };
            }();
            var get = function () {
              var descriptor = {
                get: undefined,
                enumerable: false,
                configurable: false
              };
              return function (object, propertyName, getter, enumerable, configurable) {
                descriptor.get = getter;
                descriptor.enumerable = enumerable;
                descriptor.configurable = configurable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.get = undefined;
              };
            }();
            var set = function () {
              var descriptor = {
                set: undefined,
                enumerable: false,
                configurable: false
              };
              return function (object, propertyName, setter, enumerable, configurable) {
                descriptor.set = setter;
                descriptor.enumerable = enumerable;
                descriptor.configurable = configurable;
                Object.defineProperty(object, propertyName, descriptor);
                descriptor.set = undefined;
              };
            }();
            function createMap(forceDictMode) {
              var map = Object.create(null);
              if (forceDictMode) {
                var INVALID_IDENTIFIER_1 = '.';
                var INVALID_IDENTIFIER_2 = '/';
                map[INVALID_IDENTIFIER_1] = 1;
                map[INVALID_IDENTIFIER_2] = 1;
                delete map[INVALID_IDENTIFIER_1];
                delete map[INVALID_IDENTIFIER_2];
              }
              return map;
            }
            function getClassName(objOrCtor) {
              if (typeof objOrCtor === 'function') {
                var prototype = objOrCtor.prototype;
                if (prototype && prototype.hasOwnProperty(classNameTag) && prototype[classNameTag]) {
                  return prototype[classNameTag];
                }
                var ret = '';
                if (objOrCtor.name) {
                  ret = objOrCtor.name;
                } else if (objOrCtor.toString) {
                  var arr;
                  var str = objOrCtor.toString();
                  if (str.charAt(0) === '[') {
                    arr = /\[\w+\s*(\w+)\]/.exec(str);
                  } else {
                    arr = /^function\s*(\w+)/.exec(str);
                  }
                  if (arr && arr.length === 2) {
                    ret = arr[1];
                  }
                }
                return ret !== 'Object' ? ret : '';
              } else if (objOrCtor && objOrCtor.constructor) {
                return getClassName(objOrCtor.constructor);
              }
              return '';
            }
            function obsolete(object, obsoleted, newExpr, writable) {
              var extractPropName = /([^.]+)$/;
              var oldProp = extractPropName.exec(obsoleted)[0];
              var newProp = extractPropName.exec(newExpr)[0];
              function getter() {
                return this[newProp];
              }
              function setter(value_) {
                this[newProp] = value_;
              }
              if (writable) {
                getset(object, oldProp, getter, setter);
              } else {
                get(object, oldProp, getter);
              }
            }
            function obsoletes(obj, objName, props, writable) {
              for (var obsoleted in props) {
                var newName = props[obsoleted];
                obsolete(obj, objName + "." + obsoleted, newName, writable);
              }
            }
            var REGEXP_NUM_OR_STR = /(%d)|(%s)/;
            var REGEXP_STR = /%s/;
            function formatStr(msg) {
              for (var _len = arguments.length, subst = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                subst[_key - 1] = arguments[_key];
              }
              if (arguments.length === 0) {
                return '';
              }
              if (subst.length === 0) {
                return "" + msg;
              }
              var hasSubstitution = typeof msg === 'string' && REGEXP_NUM_OR_STR.test(msg);
              if (hasSubstitution) {
                for (var _iterator = _createForOfIteratorHelperLoose(subst), _step; !(_step = _iterator()).done;) {
                  var arg = _step.value;
                  var regExpToTest = typeof arg === 'number' ? REGEXP_NUM_OR_STR : REGEXP_STR;
                  if (regExpToTest.test(msg)) {
                    var notReplaceFunction = "" + arg;
                    msg = msg.replace(regExpToTest, notReplaceFunction);
                  } else {
                    msg += " " + arg;
                  }
                }
              } else {
                for (var _iterator2 = _createForOfIteratorHelperLoose(subst), _step2; !(_step2 = _iterator2()).done;) {
                  var _arg = _step2.value;
                  msg += " " + _arg;
                }
              }
              return msg;
            }
            function shiftArguments() {
              var len = arguments.length - 1;
              var args = new Array(len);
              for (var i = 0; i < len; ++i) {
                args[i] = arguments[i + 1];
              }
              return args;
            }
            function getPropertyDescriptor(object, propertyName) {
              while (object) {
                var pd = Object.getOwnPropertyDescriptor(object, propertyName);
                if (pd) {
                  return pd;
                }
                object = Object.getPrototypeOf(object);
              }
              return null;
            }
            function _copyProp(name, source, target) {
              var pd = getPropertyDescriptor(source, name);
              if (pd) {
                Object.defineProperty(target, name, pd);
              }
            }
            function copyAllProperties(source, target, excepts) {
              var propertyNames = Object.getOwnPropertyNames(source);
              for (var i = 0, len = propertyNames.length; i < len; ++i) {
                var _propertyName = propertyNames[i];
                if (excepts.indexOf(_propertyName) !== -1) {
                  continue;
                }
                _copyProp(_propertyName, source, target);
              }
            }
            function addon(object) {
              object = object || {};
              for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); ++i) {
                var source = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
                if (source) {
                  if (typeof source !== 'object') {
                    errorID(5402, source);
                    continue;
                  }
                  for (var name in source) {
                    if (!(name in object)) {
                      _copyProp(name, source, object);
                    }
                  }
                }
              }
              return object;
            }
            function mixin(object) {
              object = object || {};
              for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); ++i) {
                var source = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
                if (source) {
                  if (typeof source !== 'object') {
                    errorID(5403, source);
                    continue;
                  }
                  for (var name in source) {
                    _copyProp(name, source, object);
                  }
                }
              }
              return object;
            }
            function extend(cls, base) {
              for (var p in base) {
                if (base.hasOwnProperty(p)) {
                  cls[p] = base[p];
                }
              }
              cls.prototype = Object.create(base.prototype, {
                constructor: {
                  value: cls,
                  writable: true,
                  configurable: true
                }
              });
              return cls;
            }
            function getSuper(constructor) {
              var proto = constructor.prototype;
              var dunderProto = proto && Object.getPrototypeOf(proto);
              return dunderProto && dunderProto.constructor;
            }
            function isChildClassOf(subclass, superclass) {
              if (subclass && superclass) {
                if (typeof subclass !== 'function') {
                  return false;
                }
                if (typeof superclass !== 'function') {
                  return false;
                }
                if (subclass === superclass) {
                  return true;
                }
                for (;;) {
                  subclass = getSuper(subclass);
                  if (!subclass) {
                    return false;
                  }
                  if (subclass === superclass) {
                    return true;
                  }
                }
              }
              return false;
            }
            function clear$1(object) {
              for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                delete object[key];
              }
            }
            var _idToClass = createMap(true);
            var _nameToClass = createMap(true);
            function setup(tag, table, allowExist) {
              return function (id, constructor) {
                if (constructor.prototype.hasOwnProperty(tag)) {
                  delete table[constructor.prototype[tag]];
                }
                value(constructor.prototype, tag, id);
                if (id) {
                  var registered = table[id];
                  if (!allowExist && registered && registered !== constructor) {
                    var detail = '';
                    errorID(16334, tag, id, detail);
                  } else {
                    table[id] = constructor;
                  }
                }
              };
            }
            var _setClassId = setup('__cid__', _idToClass, false);
            var doSetClassName = setup('__classname__', _nameToClass, true);
            function setClassName(className, constructor) {
              doSetClassName(className, constructor);
              if (!constructor.prototype.hasOwnProperty(classIdTag)) {
                var _id = className || tempCIDGenerator.getNewId();
                if (_id) {
                  _setClassId(_id, constructor);
                }
              }
            }
            function setClassAlias(target, alias) {
              var nameRegistry = _nameToClass[alias];
              var idRegistry = _idToClass[alias];
              var ok = true;
              if (nameRegistry && nameRegistry !== target) {
                errorID(16335, alias);
                ok = false;
              }
              if (idRegistry && idRegistry !== target) {
                errorID(16336, alias);
                ok = false;
              }
              if (ok) {
                var classAliases = target[aliasesTag];
                if (!classAliases) {
                  classAliases = [];
                  target[aliasesTag] = classAliases;
                }
                classAliases.push(alias);
                _nameToClass[alias] = target;
                _idToClass[alias] = target;
              }
            }
            function unregisterClass() {
              for (var _len2 = arguments.length, constructors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                constructors[_key2] = arguments[_key2];
              }
              for (var _i2 = 0, _constructors = constructors; _i2 < _constructors.length; _i2++) {
                var _constructor = _constructors[_i2];
                var p = _constructor.prototype;
                var classId = p[classIdTag];
                if (classId) {
                  delete _idToClass[classId];
                }
                var classname = p[classNameTag];
                if (classname) {
                  delete _nameToClass[classname];
                }
                var aliases = p[aliasesTag];
                if (aliases) {
                  for (var iAlias = 0; iAlias < aliases.length; ++iAlias) {
                    var alias = aliases[iAlias];
                    delete _nameToClass[alias];
                    delete _idToClass[alias];
                  }
                }
              }
            }
            function _getClassById(classId) {
              return getClassById(classId);
            }
            function getClassById(classId) {
              return _idToClass[classId];
            }
            function getClassByName(classname) {
              return _nameToClass[classname];
            }
            function _getClassId(obj, allowTempId) {
              return getClassId(obj);
            }
            function getClassId(obj, allowTempId) {
              var res;
              if (typeof obj === 'function' && obj.prototype.hasOwnProperty(classIdTag)) {
                res = obj.prototype[classIdTag];
                return res;
              }
              if (obj && obj.constructor) {
                var prototype = obj.constructor.prototype;
                if (prototype && prototype.hasOwnProperty(classIdTag)) {
                  res = obj[classIdTag];
                  return res;
                }
              }
              return '';
            }

            var Pool$1 = function () {
              var _proto = Pool.prototype;
              _proto.get = function get() {
                return this._get();
              };
              function Pool(_0, _1) {
                this.count = 0;
                var size = _1 === undefined ? _0 : _1;
                var cleanupFunc = _1 === undefined ? null : _0;
                this._pool = new Array(size);
                this._cleanup = cleanupFunc;
              }
              _proto._get = function _get() {
                if (this.count > 0) {
                  --this.count;
                  var cache = this._pool[this.count];
                  this._pool[this.count] = null;
                  return cache;
                }
                return null;
              };
              _proto.put = function put(obj) {
                var pool = this._pool;
                if (this.count < pool.length) {
                  if (this._cleanup && this._cleanup(obj) === false) {
                    return;
                  }
                  pool[this.count] = obj;
                  ++this.count;
                }
              };
              _proto.resize = function resize(length) {
                if (length >= 0) {
                  this._pool.length = length;
                  if (this.count > length) {
                    this.count = length;
                  }
                }
              };
              return Pool;
            }();

            var MutableForwardIterator = function () {
              function MutableForwardIterator(array) {
                this.i = 0;
                this.array = array;
              }
              var _proto = MutableForwardIterator.prototype;
              _proto.remove = function remove(value) {
                var index = this.array.indexOf(value);
                if (index >= 0) {
                  this.removeAt(index);
                }
              };
              _proto.removeAt = function removeAt(i) {
                this.array.splice(i, 1);
                if (i <= this.i) {
                  --this.i;
                }
              };
              _proto.fastRemove = function fastRemove(value) {
                var index = this.array.indexOf(value);
                if (index >= 0) {
                  this.fastRemoveAt(index);
                }
              };
              _proto.fastRemoveAt = function fastRemoveAt(i) {
                var array = this.array;
                array[i] = array[array.length - 1];
                --array.length;
                if (i <= this.i) {
                  --this.i;
                }
              };
              _proto.push = function push(item) {
                this.array.push(item);
              };
              _createClass(MutableForwardIterator, [{
                key: "length",
                get: function get() {
                  return this.array.length;
                },
                set: function set(value) {
                  this.array.length = value;
                  if (this.i >= value) {
                    this.i = value - 1;
                  }
                }
              }]);
              return MutableForwardIterator;
            }();
            function removeAt(array, index) {
              array.splice(index, 1);
            }
            function fastRemoveAt$2(array, index) {
              var length = array.length;
              if (index < 0 || index >= length) {
                return;
              }
              array[index] = array[length - 1];
              array.length = length - 1;
            }
            function remove(array, value) {
              var index = array.indexOf(value);
              if (index >= 0) {
                removeAt(array, index);
                return true;
              } else {
                return false;
              }
            }
            function fastRemove(array, value) {
              var index = array.indexOf(value);
              if (index >= 0) {
                array[index] = array[array.length - 1];
                --array.length;
              }
            }
            function removeIf(array, predicate) {
              var index = array.findIndex(predicate);
              if (index >= 0) {
                var _value = array[index];
                removeAt(array, index);
                return _value;
              }
              return undefined;
            }
            function verifyType(array, type) {
              if (array && array.length > 0) {
                for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done;) {
                  var item = _step.value;
                  if (!(item instanceof type)) {
                    logID(1300);
                    return false;
                  }
                }
              }
              return true;
            }
            function removeArray(array, removals) {
              for (var i = 0, l = removals.length; i < l; i++) {
                remove(array, removals[i]);
              }
            }
            function appendObjectsAt(array, objects, index) {
              array.splice.apply(array, [index, 0].concat(objects));
              return array;
            }
            function contains$1(array, value) {
              return array.indexOf(value) >= 0;
            }
            function copy(array) {
              var len = array.length;
              var cloned = new Array(len);
              for (var i = 0; i < len; i += 1) {
                cloned[i] = array[i];
              }
              return cloned;
            }
            function fillItems(array) {
              for (var i = 0, len = arguments.length <= 1 ? 0 : arguments.length - 1; i < len; ++i) {
                array[i] = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
              }
            }

            var array = /*#__PURE__*/Object.freeze({
                __proto__: null,
                MutableForwardIterator: MutableForwardIterator,
                appendObjectsAt: appendObjectsAt,
                contains: contains$1,
                copy: copy,
                fastRemove: fastRemove,
                fastRemoveAt: fastRemoveAt$2,
                fillItems: fillItems,
                remove: remove,
                removeArray: removeArray,
                removeAt: removeAt,
                removeIf: removeIf,
                verifyType: verifyType
            });

            var js = {
              IDGenerator: IDGenerator,
              Pool: Pool$1,
              array: array,
              isNumber: isNumber,
              isString: isString,
              isEmptyObject: isEmptyObject,
              getPropertyDescriptor: getPropertyDescriptor,
              addon: addon,
              mixin: mixin,
              extend: extend,
              getSuper: getSuper,
              isChildClassOf: isChildClassOf,
              clear: clear$1,
              value: value,
              getset: getset,
              get: get,
              set: set,
              unregisterClass: unregisterClass,
              getClassName: getClassName,
              setClassName: setClassName,
              setClassAlias: setClassAlias,
              getClassByName: getClassByName,
              getClassById: getClassById,
              get _registeredClassNames() {
                return _extends({}, _nameToClass);
              },
              set _registeredClassNames(value) {
                clear$1(_nameToClass);
                Object.assign(_nameToClass, value);
              },
              get _registeredClassIds() {
                return _extends({}, _idToClass);
              },
              set _registeredClassIds(value) {
                clear$1(_idToClass);
                Object.assign(_idToClass, value);
              },
              _getClassId: _getClassId,
              getClassId: getClassId,
              _setClassId: _setClassId,
              _getClassById: _getClassById,
              obsolete: obsolete,
              obsoletes: obsoletes,
              formatStr: formatStr,
              shiftArguments: shiftArguments,
              createMap: createMap
            };
            legacyCC.js = js;

            var js$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                IDGenerator: IDGenerator,
                Pool: Pool$1,
                _getClassById: _getClassById,
                _getClassId: _getClassId,
                _idToClass: _idToClass,
                _nameToClass: _nameToClass,
                _setClassId: _setClassId,
                addon: addon,
                array: array,
                clear: clear$1,
                copyAllProperties: copyAllProperties,
                createMap: createMap,
                extend: extend,
                formatStr: formatStr,
                get: get,
                getClassById: getClassById,
                getClassByName: getClassByName,
                getClassId: getClassId,
                getClassName: getClassName,
                getPropertyDescriptor: getPropertyDescriptor,
                getSuper: getSuper,
                getset: getset,
                isChildClassOf: isChildClassOf,
                isEmptyObject: isEmptyObject,
                isNumber: isNumber,
                isString: isString,
                js: js,
                mixin: mixin,
                obsolete: obsolete,
                obsoletes: obsoletes,
                set: set,
                setClassAlias: setClassAlias,
                setClassName: setClassName,
                shiftArguments: shiftArguments,
                unregisterClass: unregisterClass,
                value: value
            });
            exports("js", js$1);

            function BitMask(obj) {
              if ('__bitmask__' in obj) {
                return obj;
              }
              value(obj, '__bitmask__', null, true);
              var lastIndex = -1;
              var keys = Object.keys(obj);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var val = obj[key];
                if (val === -1) {
                  val = ++lastIndex;
                  obj[key] = val;
                } else if (typeof val === 'number') {
                  lastIndex = val;
                } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
                  continue;
                }
                var reverseKey = "" + val;
                if (key !== reverseKey) {
                  value(obj, reverseKey, key);
                }
              }
              return obj;
            }
            BitMask.isBitMask = function (BitMaskType) {
              return BitMaskType && Object.prototype.hasOwnProperty.call(BitMaskType, '__bitmask__');
            };
            BitMask.getList = function (BitMaskDef) {
              if (BitMaskDef.__bitmask__) {
                return BitMaskDef.__bitmask__;
              }
              return BitMask.update(BitMaskDef);
            };
            BitMask.update = function (BitMaskDef) {
              if (!Array.isArray(BitMaskDef.__bitmask__)) {
                BitMaskDef.__bitmask__ = [];
              }
              var bitList = BitMaskDef.__bitmask__;
              bitList.length = 0;
              for (var name in BitMaskDef) {
                var v = BitMaskDef[name];
                if (Number.isInteger(v)) {
                  bitList.push({
                    name: name,
                    value: v
                  });
                }
              }
              bitList.sort(function (a, b) {
                return a.value - b.value;
              });
              return bitList;
            };
            legacyCC.BitMask = BitMask;

            function assertIsNonNullable(expr, message) {
              assertIsTrue(!(expr === null || expr === undefined), message);
            }
            function assertIsTrue(expr, message) {
              if (!expr) {
                throw new Error("Assertion failed: " + (message !== null && message !== undefined ? message : '<no-message>'));
              }
            }
            function assertsArrayIndex(array, index) {
              assertIsTrue(index >= 0 && index < array.length, "Array index " + index + " out of bounds: [0, " + array.length + ")");
            }

            var hasOwnPropertyProto = Object.prototype.hasOwnProperty;
            function Enum(obj) {
              if ('__enums__' in obj) {
                return obj;
              }
              value(obj, '__enums__', null, true);
              return Enum.update(obj);
            }
            Enum.update = function (obj) {
              var lastIndex = -1;
              var keys = Object.keys(obj);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var val = obj[key];
                if (val === -1) {
                  val = ++lastIndex;
                  obj[key] = val;
                } else if (typeof val === 'number') {
                  lastIndex = val;
                } else if (typeof val === 'string' && Number.isInteger(parseFloat(key))) {
                  continue;
                }
                var reverseKey = "" + val;
                if (key !== reverseKey) {
                  value(obj, reverseKey, key);
                }
              }
              if (Array.isArray(obj.__enums__)) {
                updateList(obj);
              }
              return obj;
            };
            Enum.isEnum = function (enumType) {
              return enumType && hasOwnPropertyProto.call(enumType, '__enums__');
            };
            function assertIsEnum(enumType) {
              assertIsTrue(hasOwnPropertyProto.call(enumType, '__enums__'));
            }
            Enum.getList = function (enumType) {
              assertIsEnum(enumType);
              if (enumType.__enums__) {
                return enumType.__enums__;
              }
              return updateList(enumType);
            };
            function updateList(enumType) {
              assertIsEnum(enumType);
              var enums = enumType.__enums__ || [];
              enums.length = 0;
              var isAllInteger = true;
              for (var name in enumType) {
                var v = enumType[name];
                var isIntegerValue = Number.isInteger(v);
                if (!isIntegerValue) {
                  isAllInteger = false;
                }
                if (isIntegerValue || typeof v === 'string' && enumType[v] !== Number.parseInt(name)) {
                  enums.push({
                    name: name,
                    value: v
                  });
                }
              }
              if (isAllInteger) {
                enums.sort(function (a, b) {
                  return a.value - b.value;
                });
              }
              enumType.__enums__ = enums;
              return enums;
            }
            Enum.sortList = function (enumType, compareFn) {
              assertIsEnum(enumType);
              if (!Array.isArray(enumType.__enums__)) {
                return;
              }
              enumType.__enums__.sort(compareFn);
            };
            function ccenum(enumType) {
              if (!('__enums__' in enumType)) {
                value(enumType, '__enums__', null, true);
              }
            }
            legacyCC.Enum = Enum;

            var ValueType = exports("ValueType", function () {
              function ValueType() {}
              var _proto = ValueType.prototype;
              _proto.clone = function clone() {
                errorID(100, getClassName(this) + ".clone");
                return this;
              };
              _proto.equals = function equals(other) {
                return false;
              };
              _proto.set = function set(other) {
                errorID(100, getClassName(this) + ".set");
              };
              _proto.toString = function toString() {
                return "";
              };
              return ValueType;
            }());
            setClassName('cc.ValueType', ValueType);
            legacyCC.ValueType = ValueType;

            var SettingsCategory = exports("SettingsCategory", {
              PATH: "path",
              ENGINE: "engine",
              ASSETS: "assets",
              SCRIPTING: "scripting",
              PHYSICS: "physics",
              RENDERING: "rendering",
              LAUNCH: "launch",
              SCREEN: "screen",
              SPLASH_SCREEN: "splashScreen",
              ANIMATION: "animation",
              PROFILING: "profiling",
              PLUGINS: "plugins",
              XR: "xr"
            });
            var Settings = exports("Settings", function () {
              function Settings() {
                this._settings = {};
                this._override = {};
              }
              var _proto = Settings.prototype;
              _proto.init = function init(path, overrides) {
                var _this = this;
                if (path === undefined) {
                  path = '';
                }
                if (overrides === undefined) {
                  overrides = {};
                }
                for (var categoryName in overrides) {
                  var category = overrides[categoryName];
                  if (category) {
                    for (var name in category) {
                      this.overrideSettings(categoryName, name, category[name]);
                    }
                  }
                }
                if (!path) return Promise.resolve();
                return new Promise(function (resolve, reject) {
                  {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', path);
                    xhr.responseType = 'text';
                    xhr.onload = function () {
                      _this._settings = JSON.parse(xhr.response);
                      resolve();
                    };
                    xhr.onerror = function () {
                      reject(new Error('request settings failed!'));
                    };
                    xhr.send(null);
                  }
                });
              };
              _proto.overrideSettings = function overrideSettings(category, name, value) {
                if (!(category in this._override)) {
                  this._override[category] = {};
                }
                this._override[category][name] = value;
              };
              _proto.querySettings = function querySettings(category, name) {
                if (category in this._override) {
                  var categorySettings = this._override[category];
                  if (categorySettings && name in categorySettings) {
                    return categorySettings[name];
                  }
                }
                if (category in this._settings) {
                  var _categorySettings = this._settings[category];
                  if (_categorySettings && name in _categorySettings) {
                    return _categorySettings[name];
                  }
                }
                return null;
              };
              return Settings;
            }());
            Settings.Category = SettingsCategory;
            var settings = exports("settings", new Settings());
            legacyCC.settings = settings;

            var Orientation;
            (function (Orientation) {
              Orientation[Orientation["PORTRAIT"] = 1] = "PORTRAIT";
              Orientation[Orientation["PORTRAIT_UPSIDE_DOWN"] = 2] = "PORTRAIT_UPSIDE_DOWN";
              Orientation[Orientation["LANDSCAPE_LEFT"] = 4] = "LANDSCAPE_LEFT";
              Orientation[Orientation["LANDSCAPE_RIGHT"] = 8] = "LANDSCAPE_RIGHT";
              Orientation[Orientation["LANDSCAPE"] = 12] = "LANDSCAPE";
              Orientation[Orientation["AUTO"] = 13] = "AUTO";
            })(Orientation || (Orientation = {}));

            var SUPPORT_TEXTURE_FORMATS = ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png'];
            var KEY = {
              none: 0,
              back: 6,
              menu: 18,
              backspace: 8,
              tab: 9,
              enter: 13,
              shift: 16,
              ctrl: 17,
              alt: 18,
              pause: 19,
              capslock: 20,
              escape: 27,
              space: 32,
              pageup: 33,
              pagedown: 34,
              end: 35,
              home: 36,
              left: 37,
              up: 38,
              right: 39,
              down: 40,
              select: 41,
              insert: 45,
              Delete: 46,
              0: 48,
              1: 49,
              2: 50,
              3: 51,
              4: 52,
              5: 53,
              6: 54,
              7: 55,
              8: 56,
              9: 57,
              a: 65,
              b: 66,
              c: 67,
              d: 68,
              e: 69,
              f: 70,
              g: 71,
              h: 72,
              i: 73,
              j: 74,
              k: 75,
              l: 76,
              m: 77,
              n: 78,
              o: 79,
              p: 80,
              q: 81,
              r: 82,
              s: 83,
              t: 84,
              u: 85,
              v: 86,
              w: 87,
              x: 88,
              y: 89,
              z: 90,
              num0: 96,
              num1: 97,
              num2: 98,
              num3: 99,
              num4: 100,
              num5: 101,
              num6: 102,
              num7: 103,
              num8: 104,
              num9: 105,
              '*': 106,
              '+': 107,
              '-': 109,
              numdel: 110,
              '/': 111,
              f1: 112,
              f2: 113,
              f3: 114,
              f4: 115,
              f5: 116,
              f6: 117,
              f7: 118,
              f8: 119,
              f9: 120,
              f10: 121,
              f11: 122,
              f12: 123,
              numlock: 144,
              scrolllock: 145,
              ';': 186,
              semicolon: 186,
              equal: 187,
              '=': 187,
              ',': 188,
              comma: 188,
              dash: 189,
              '.': 190,
              period: 190,
              forwardslash: 191,
              grave: 192,
              '[': 219,
              openbracket: 219,
              backslash: 220,
              ']': 221,
              closebracket: 221,
              quote: 222,
              dpadLeft: 1000,
              dpadRight: 1001,
              dpadUp: 1003,
              dpadDown: 1004,
              dpadCenter: 1005
            };
            var macro = exports("macro", {
              SUPPORT_TEXTURE_FORMATS: SUPPORT_TEXTURE_FORMATS,
              KEY: KEY,
              RAD: Math.PI / 180,
              DEG: 180 / Math.PI,
              REPEAT_FOREVER: Number.MAX_VALUE - 1,
              FLT_EPSILON: 0.0000001192092896,
              ORIENTATION_PORTRAIT: Orientation.PORTRAIT,
              ORIENTATION_PORTRAIT_UPSIDE_DOWN: Orientation.PORTRAIT_UPSIDE_DOWN,
              ORIENTATION_LANDSCAPE: Orientation.LANDSCAPE,
              ORIENTATION_LANDSCAPE_LEFT: Orientation.LANDSCAPE_LEFT,
              ORIENTATION_LANDSCAPE_RIGHT: Orientation.LANDSCAPE_RIGHT,
              ORIENTATION_AUTO: Orientation.AUTO,
              ENABLE_TILEDMAP_CULLING: true,
              TOUCH_TIMEOUT: 5000,
              ENABLE_TRANSPARENT_CANVAS: false,
              ENABLE_WEBGL_ANTIALIAS: true,
              ENABLE_FLOAT_OUTPUT: false,
              CLEANUP_IMAGE_CACHE: false,
              ENABLE_MULTI_TOUCH: true,
              MAX_LABEL_CANVAS_POOL_SIZE: 20,
              ENABLE_WEBGL_HIGHP_STRUCT_VALUES: false,
              BATCHER2D_MEM_INCREMENT: 144,
              CUSTOM_PIPELINE_NAME: 'Builtin',
              init: function init() {
                var defaultValues = settings.querySettings("engine", 'macros');
                if (defaultValues) {
                  for (var key in defaultValues) {
                    macro[key] = defaultValues[key];
                  }
                }
              }
            });
            legacyCC.macro = macro;

            function setTimeoutRAF(callback, delay) {
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }
              var start = performance.now();
              var raf = requestAnimationFrame || window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
              if (raf === undefined || USE_XR) {
                return setTimeout.apply(undefined, [callback, delay].concat(args));
              }
              var handleRAF = function handleRAF() {
                if (performance.now() - start < delay) {
                  raf(handleRAF);
                } else {
                  callback.apply(undefined, args);
                }
              };
              return raf(handleRAF);
            }

            var BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
            var BASE64_KEYS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
            var values = new Array(123);
            for (var i = 0; i < 123; ++i) {
              values[i] = 64;
            }
            for (var _i = 0; _i < 64; ++_i) {
              values[BASE64_KEYS.charCodeAt(_i)] = _i;
            }
            var BASE64_VALUES = values;
            function propertyDefine(ctor, sameNameGetSets, diffNameGetSets) {
              function define(np, propName, getter, setter) {
                var pd = Object.getOwnPropertyDescriptor(np, propName);
                if (pd) {
                  if (pd.get && getter) {
                    np[getter] = pd.get;
                  }
                  if (pd.set && setter) {
                    np[setter] = pd.set;
                  }
                } else {
                  var getterFunc = np[getter];
                  {
                    getset(np, propName, getterFunc, np[setter]);
                  }
                }
              }
              var propName;
              var np = ctor.prototype;
              for (var _i2 = 0, len = sameNameGetSets.length; _i2 < len; ++_i2) {
                propName = sameNameGetSets[_i2];
                var suffix = propName[0].toUpperCase() + propName.slice(1);
                define(np, propName, "get" + suffix, "set" + suffix);
              }
              for (propName in diffNameGetSets) {
                var gs = diffNameGetSets[propName];
                define(np, propName, gs[0], gs[1]);
              }
            }
            function pushToMap(map, key, value, pushFront) {
              var exists = map[key];
              if (exists) {
                if (Array.isArray(exists)) {
                  if (pushFront) {
                    exists.push(exists[0]);
                    exists[0] = value;
                  } else {
                    exists.push(value);
                  }
                } else {
                  map[key] = pushFront ? [value, exists] : [exists, value];
                }
              } else {
                map[key] = value;
              }
            }
            function contains(refNode, otherNode) {
              if (typeof refNode.contains === 'function') {
                return refNode.contains(otherNode);
              } else if (typeof refNode.compareDocumentPosition === 'function') {
                return !!(refNode.compareDocumentPosition(otherNode) & 16);
              } else {
                var node = otherNode.parentNode;
                if (node) {
                  do {
                    if (node === refNode) {
                      return true;
                    } else {
                      node = node.parentNode;
                    }
                  } while (node !== null);
                }
                return false;
              }
            }
            function isDomNode(node) {
              if (typeof window === 'object' && typeof Node === 'function') {
                return node instanceof Node;
              } else {
                return !!node && typeof node === 'object' && typeof node.nodeType === 'number' && typeof node.nodeName === 'string';
              }
            }
            function callInNextTick(callback) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              if (callback) {
                setTimeoutRAF(function () {
                  callback.apply(undefined, args);
                }, 0);
              }
            }
            function tryCatchFunctor_EDITOR(funcName) {
              return Function('target', "" + ('try {\n' + '  target.') + funcName + "();\n" + "}\n" + "catch (e) {\n" + "  cc._throw(e);\n" + "}");
            }
            function isPlainEmptyObj_DEV(obj) {
              if (!obj || obj.constructor !== Object) {
                return false;
              }
              return isEmptyObject(obj);
            }
            function clampf(value, min_inclusive, max_inclusive) {
              if (min_inclusive > max_inclusive) {
                var temp = min_inclusive;
                min_inclusive = max_inclusive;
                max_inclusive = temp;
              }
              return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
            }
            function degreesToRadians(angle) {
              return angle * macro.RAD;
            }
            function radiansToDegrees(angle) {
              return angle * macro.DEG;
            }
            legacyCC.misc = {
              BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
              BASE64_VALUES: BASE64_VALUES,
              propertyDefine: propertyDefine,
              pushToMap: pushToMap,
              contains: contains,
              isDomNode: isDomNode,
              callInNextTick: callInNextTick,
              isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
              clampf: clampf,
              degreesToRadians: degreesToRadians,
              radiansToDegrees: radiansToDegrees
            };

            var misc = /*#__PURE__*/Object.freeze({
                __proto__: null,
                BASE64_VALUES: BASE64_VALUES,
                BUILTIN_CLASSID_RE: BUILTIN_CLASSID_RE,
                callInNextTick: callInNextTick,
                clampf: clampf,
                contains: contains,
                degreesToRadians: degreesToRadians,
                isDomNode: isDomNode,
                isPlainEmptyObj_DEV: isPlainEmptyObj_DEV,
                propertyDefine: propertyDefine,
                pushToMap: pushToMap,
                radiansToDegrees: radiansToDegrees,
                tryCatchFunctor_EDITOR: tryCatchFunctor_EDITOR
            });
            exports("misc", misc);

            var DELIMETER$1 = '$_$';
            function createAttrsSingle(owner, superAttrs) {
              var attrs = superAttrs ? Object.create(superAttrs) : {};
              value(owner, '__attrs__', attrs);
              return attrs;
            }
            function createAttrs(subclass) {
              if (typeof subclass !== 'function') {
                var instance = subclass;
                return createAttrsSingle(instance, getClassAttrs(instance.constructor));
              }
              var superClass;
              var chains = legacyCC.Class.getInheritanceChain(subclass);
              for (var i = chains.length - 1; i >= 0; i--) {
                var cls = chains[i];
                var attrs = cls.hasOwnProperty('__attrs__') && cls.__attrs__;
                if (!attrs) {
                  superClass = chains[i + 1];
                  createAttrsSingle(cls, superClass && superClass.__attrs__);
                }
              }
              superClass = chains[0];
              createAttrsSingle(subclass, superClass && superClass.__attrs__);
              return subclass.__attrs__;
            }
            function attr(constructor, propertyName) {
              var attrs = getClassAttrs(constructor);
              var prefix = propertyName + DELIMETER$1;
              var ret = {};
              for (var key in attrs) {
                if (key.startsWith(prefix)) {
                  ret[key.slice(prefix.length)] = attrs[key];
                }
              }
              return ret;
            }
            function getClassAttrs(constructor) {
              return constructor.hasOwnProperty('__attrs__') && constructor.__attrs__ || createAttrs(constructor);
            }
            function setClassAttr(ctor, propName, key, value) {
              getClassAttrs(ctor)[propName + DELIMETER$1 + key] = value;
            }
            var PrimitiveType = function () {
              function PrimitiveType(name, defaultValue) {
                this.name = name;
                this["default"] = defaultValue;
              }
              var _proto = PrimitiveType.prototype;
              _proto.toString = function toString() {
                return this.name;
              };
              return PrimitiveType;
            }();
            var CCInteger = exports("CCInteger", new PrimitiveType('Integer', 0));
            legacyCC.Integer = CCInteger;
            legacyCC.CCInteger = CCInteger;
            var CCFloat = exports("CCFloat", new PrimitiveType('Float', 0.0));
            legacyCC.Float = CCFloat;
            legacyCC.CCFloat = CCFloat;
            var CCBoolean = exports("CCBoolean", new PrimitiveType('Boolean', false));
            legacyCC.Boolean = CCBoolean;
            legacyCC.CCBoolean = CCBoolean;
            var CCString = exports("CCString", new PrimitiveType('String', ''));
            legacyCC.String = CCString;
            legacyCC.CCString = CCString;
            function getTypeChecker_ET(type, attributeName) {
              return function (constructor, mainPropertyName) {
                var propInfo = "\"" + getClassName(constructor) + "." + mainPropertyName + "\"";
                var mainPropAttrs = attr(constructor, mainPropertyName);
                var mainPropAttrsType = mainPropAttrs.type;
                if (mainPropAttrsType === CCInteger || mainPropAttrsType === CCFloat) {
                  mainPropAttrsType = 'Number';
                } else if (mainPropAttrsType === CCString || mainPropAttrsType === CCBoolean) {
                  mainPropAttrsType = "" + mainPropAttrsType;
                }
                if (mainPropAttrsType !== type) {
                  warnID(3604, propInfo);
                  return;
                }
                if (!mainPropAttrs.hasOwnProperty('default')) {
                  return;
                }
                var defaultVal = mainPropAttrs["default"];
                if (typeof defaultVal === 'undefined') {
                  return;
                }
                var isContainer = Array.isArray(defaultVal) || isPlainEmptyObj_DEV(defaultVal);
                if (isContainer) {
                  return;
                }
                var defaultType = typeof defaultVal;
                var type_lowerCase = type.toLowerCase();
                if (defaultType === type_lowerCase) {
                  if (type_lowerCase === 'object') {
                    if (defaultVal && !(defaultVal instanceof mainPropAttrs.ctor)) {
                      warnID(3605, propInfo, getClassName(mainPropAttrs.ctor));
                    } else {
                      return;
                    }
                  } else if (type !== 'Number') {
                    warnID(3606, attributeName, propInfo, type);
                  }
                } else if (defaultType !== 'function') {
                  if (type === CCString["default"] && defaultVal == null) {
                    warnID(3607, propInfo);
                  } else {
                    warnID(3611, attributeName, propInfo, defaultType);
                  }
                } else {
                  return;
                }
                delete mainPropAttrs.type;
              };
            }
            function getObjTypeChecker_ET(typeCtor) {
              return function (classCtor, mainPropName) {
                getTypeChecker_ET('Object', 'type')(classCtor, mainPropName);
                var defaultDef = getClassAttrs(classCtor)[mainPropName + DELIMETER$1 + "default"];
                var defaultVal = legacyCC.Class.getDefault(defaultDef);
                if (!Array.isArray(defaultVal) && isChildClassOf(typeCtor, legacyCC.ValueType)) {
                  var typename = getClassName(typeCtor);
                  var info = formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', getClassName(classCtor), mainPropName, typename);
                  if (defaultDef) {
                    log(info);
                  } else {
                    warnID(3612, info, typename, getClassName(classCtor), mainPropName, typename);
                  }
                }
              };
            }

            var attributeUtils = /*#__PURE__*/Object.freeze({
                __proto__: null,
                CCBoolean: CCBoolean,
                CCFloat: CCFloat,
                CCInteger: CCInteger,
                CCString: CCString,
                DELIMETER: DELIMETER$1,
                PrimitiveType: PrimitiveType,
                attr: attr,
                createAttrs: createAttrs,
                createAttrsSingle: createAttrsSingle,
                getClassAttrs: getClassAttrs,
                getObjTypeChecker_ET: getObjTypeChecker_ET,
                getTypeChecker_ET: getTypeChecker_ET,
                setClassAttr: setClassAttr
            });

            var SerializableAttrs = {
              "default": {},
              serializable: {},
              editorOnly: {},
              formerlySerializedAs: {}
            };
            function parseNotify(val, propName, notify, properties) {
              if (val.get || val.set) {
                return;
              }
              if (val.hasOwnProperty('default')) {
                var newKey = "_N$" + propName;
                val.get = function () {
                  return this[newKey];
                };
                val.set = function (value) {
                  var oldValue = this[newKey];
                  this[newKey] = value;
                  notify.call(this, oldValue);
                };
                var newValue = {};
                properties[newKey] = newValue;
                for (var attr in SerializableAttrs) {
                  var v = SerializableAttrs[attr];
                  if (val.hasOwnProperty(attr)) {
                    newValue[attr] = val[attr];
                    if (!v.canUsedInGet) {
                      delete val[attr];
                    }
                  }
                }
              }
            }
            function parseType(val, type, className, propName) {
              if (Array.isArray(type)) {
                if (type.length > 0) {
                  val.type = type = type[0];
                } else {
                  return errorID(5508, className, propName);
                }
              }
              if (typeof type === 'function') {
                if (type === String) {
                  val.type = legacyCC.String;
                } else if (type === Boolean) {
                  val.type = legacyCC.Boolean;
                } else if (type === Number) {
                  val.type = legacyCC.Float;
                }
              }
            }
            function _wrapOptions(isGetset, _default, type) {
              var res = isGetset || typeof _default === 'undefined' ? {
                _short: true
              } : {
                _short: true,
                "default": _default
              };
              if (type) {
                res.type = type;
              }
              return res;
            }
            function getFullFormOfProperty(options, isGetset) {
              var isLiteral = options && options.constructor === Object;
              if (!isLiteral) {
                if (Array.isArray(options) && options.length > 0) {
                  return _wrapOptions(isGetset, [], options);
                } else if (typeof options === 'function') {
                  var type = options;
                  return _wrapOptions(isGetset, isChildClassOf(type, legacyCC.ValueType) ? new type() : null, type);
                } else if (options instanceof PrimitiveType) {
                  return _wrapOptions(isGetset, undefined, options);
                } else {
                  return _wrapOptions(isGetset, options);
                }
              }
              return null;
            }
            function preprocessAttrs(properties, className, cls) {
              for (var propName in properties) {
                var val = properties[propName];
                var fullForm = getFullFormOfProperty(val, false);
                if (fullForm) {
                  val = properties[propName] = fullForm;
                }
                if (val) {
                  var notify = val.notify;
                  if (notify) {
                    {
                      parseNotify(val, propName, notify, properties);
                    }
                  }
                  if ('type' in val) {
                    parseType(val, val.type, className, propName);
                  }
                }
              }
            }

            var requiringFrames = [];
            function push(module, uuid, script, importMeta) {
              if (script === undefined) {
                script = uuid;
                uuid = '';
              }
              requiringFrames.push({
                uuid: uuid,
                script: script,
                module: module,
                exports: module.exports,
                beh: null,
                importMeta: importMeta
              });
            }
            function pop() {
              var frameInfo = requiringFrames.pop();
              var module = frameInfo.module;
              var exports = module.exports;
              if (exports === frameInfo.exports) {
                for (var anykey in exports) {
                  return;
                }
                module.exports = exports = frameInfo.cls;
              }
            }
            function peek() {
              return requiringFrames[requiringFrames.length - 1];
            }
            legacyCC._RF = {
              push: push,
              pop: pop,
              peek: peek
            };

            function setPropertyEnumType(objectOrConstructor, propertyName, enumType) {
              setPropertyEnumTypeOnAttrs(getClassAttrs(objectOrConstructor), propertyName, enumType);
            }
            function setPropertyEnumTypeOnAttrs(attrs, propertyName, enumType) {
              attrs["" + propertyName + DELIMETER$1 + "type"] = 'Enum';
              attrs["" + propertyName + DELIMETER$1 + "enumList"] = Enum.getList(enumType);
            }

            var DELIMETER = DELIMETER$1;
            var CCCLASS_TAG = '__ctors__';
            var ENUM_TAG = exports("ENUM_TAG", 'Enum');
            var BITMASK_TAG = exports("BITMASK_TAG", 'BitMask');
            function pushUnique(array, item) {
              if (array.indexOf(item) < 0) {
                array.push(item);
              }
            }
            function appendProp(cls, name) {
              pushUnique(cls.__props__, name);
            }
            function defineProp(cls, className, propName, val) {
              appendProp(cls, propName);
              parseAttributes(cls, val, className, propName);
            }
            function defineGetSet(cls, name, propName, val) {
              var getter = val.get;
              val.set;
              if (getter) {
                parseAttributes(cls, val, name, propName);
                setClassAttr(cls, propName, 'serializable', false);
              }
            }
            function getDefault(defaultVal) {
              if (typeof defaultVal === 'function') {
                {
                  return defaultVal();
                }
              }
              return defaultVal;
            }
            function doDefine(className, baseClass, options) {
              var ctor = options.ctor;
              value(ctor, CCCLASS_TAG, true, true);
              ctor.prototype;
              if (baseClass) {
                ctor.$super = baseClass;
              }
              setClassName(className, ctor);
              return ctor;
            }
            function define$1(className, baseClass, options) {
              var Component = legacyCC.Component;
              var frame = peek();
              if (frame && isChildClassOf(baseClass, Component)) {
                if (isChildClassOf(frame.cls, Component)) {
                  errorID(3615);
                  return null;
                }
                className = className || frame.script;
              }
              var cls = doDefine(className, baseClass, options);
              if (frame) {
                if (isChildClassOf(baseClass, Component)) {
                  var uuid = frame.uuid;
                  if (uuid) {
                    _setClassId(uuid, cls);
                  }
                  frame.cls = cls;
                } else if (!isChildClassOf(frame.cls, Component)) {
                  frame.cls = cls;
                }
              }
              return cls;
            }
            function getNewValueTypeCodeJit(value) {
              var clsName = getClassName(value);
              var type = value.constructor;
              var res = "new " + clsName + "(";
              for (var i = 0; i < type.__props__.length; i++) {
                var prop = type.__props__[i];
                var propVal = value[prop];
                res += propVal;
                if (i < type.__props__.length - 1) {
                  res += ',';
                }
              }
              return res + ")";
            }
            function escapeForJS$1(s) {
              return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
            }
            var IDENTIFIER_RE$1 = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
            function declareProperties(cls, className, properties, baseClass) {
              cls.__props__ = [];
              if (baseClass && baseClass.__props__) {
                cls.__props__ = baseClass.__props__.slice();
              }
              if (properties) {
                preprocessAttrs(properties, className);
                for (var propName in properties) {
                  var val = properties[propName];
                  if (!val.get && !val.set) {
                    defineProp(cls, className, propName, val);
                  } else {
                    defineGetSet(cls, className, propName, val);
                  }
                }
              }
              var attrs = getClassAttrs(cls);
              cls.__values__ = cls.__props__.filter(function (prop) {
                return attrs["" + prop + DELIMETER + "serializable"] !== false;
              });
            }
            function CCClass(options) {
              var name = options.name;
              var base = options["extends"];
              var cls = define$1(name, base, options);
              if (!name) {
                name = legacyCC.js.getClassName(cls);
              }
              cls._sealed = true;
              if (base) {
                base._sealed = false;
              }
              var properties = options.properties;
              declareProperties(cls, name, properties, base);
              var editor = options.editor;
              if (editor) {
                if (isChildClassOf(base, legacyCC.Component)) {
                  legacyCC.Component._registerEditorProps(cls, editor);
                }
              }
              return cls;
            }
            CCClass._isCCClass = function isCCClass(constructor) {
              return constructor == null ? undefined : constructor.hasOwnProperty == null ? undefined : constructor.hasOwnProperty(CCCLASS_TAG);
            };
            CCClass.fastDefine = function (className, constructor, serializableFields) {
              setClassName(className, constructor);
              var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields);
              var attrs = getClassAttrs(constructor);
              for (var i = 0; i < props.length; i++) {
                var key = props[i];
                attrs[key + DELIMETER + "visible"] = false;
                attrs[key + DELIMETER + "default"] = serializableFields[key];
              }
            };
            CCClass.Attr = attributeUtils;
            CCClass.attr = attr;
            function isCCClassOrFastDefined(constructor) {
              return constructor == null ? undefined : constructor.hasOwnProperty == null ? undefined : constructor.hasOwnProperty('__values__');
            }
            CCClass.isCCClassOrFastDefined = isCCClassOrFastDefined;
            function getInheritanceChain(constructor) {
              var chain = [];
              for (;;) {
                constructor = getSuper(constructor);
                if (!constructor) {
                  break;
                }
                if (constructor !== Object) {
                  chain.push(constructor);
                }
              }
              return chain;
            }
            CCClass.getInheritanceChain = getInheritanceChain;
            var PrimitiveTypes = {
              Integer: 'Number',
              Float: 'Number',
              Boolean: 'Boolean',
              String: 'String'
            };
            function parseAttributes(constructor, attributes, className, propertyName, usedInGetter) {
              var attrs = null;
              var propertyNamePrefix = '';
              function initAttrs() {
                propertyNamePrefix = propertyName + DELIMETER;
                return attrs = getClassAttrs(constructor);
              }
              if ('type' in attributes && typeof attributes.type === 'undefined') {
                warnID(3660, propertyName, className);
              }
              var type = attributes.type;
              if (type) {
                var primitiveType = PrimitiveTypes[type];
                if (primitiveType) {
                  (attrs || initAttrs())[propertyNamePrefix + "type"] = type;
                } else if (type === 'Object') ; else if (typeof type === 'object') {
                  if (Enum.isEnum(type)) {
                    setPropertyEnumTypeOnAttrs(attrs || initAttrs(), propertyName, type);
                  } else if (BitMask.isBitMask(type)) {
                    (attrs || initAttrs())[propertyNamePrefix + "type"] = BITMASK_TAG;
                    attrs[propertyNamePrefix + "bitmaskList"] = BitMask.getList(type);
                  } else ;
                } else if (typeof type === 'function') {
                  (attrs || initAttrs())[propertyNamePrefix + "type"] = 'Object';
                  attrs[propertyNamePrefix + "ctor"] = type;
                } else ;
              }
              if ('default' in attributes) {
                (attrs || initAttrs())[propertyNamePrefix + "default"] = attributes["default"];
              }
              var parseSimpleAttribute = function parseSimpleAttribute(attributeName, expectType) {
                if (attributeName in attributes) {
                  var val = attributes[attributeName];
                  if (typeof val === expectType) {
                    (attrs || initAttrs())[propertyNamePrefix + attributeName] = val;
                  }
                }
              };
              if (attributes.editorOnly) {
                {
                  (attrs || initAttrs())[propertyNamePrefix + "editorOnly"] = true;
                }
              }
              var isStandaloneMode = attributes.__internalFlags & 1;
              var normalizedSerializable;
              if (isStandaloneMode) {
                normalizedSerializable = attributes.serializable === true || (attributes.__internalFlags & 4) !== 0;
              } else if (attributes.serializable === false) {
                normalizedSerializable = false;
              }
              if (typeof normalizedSerializable !== 'undefined') {
                (attrs || initAttrs())[propertyNamePrefix + "serializable"] = normalizedSerializable;
              }
              parseSimpleAttribute('formerlySerializedAs', 'string');
              var range = attributes.range;
              if (range) {
                if (Array.isArray(range)) {
                  if (range.length >= 2) {
                    (attrs || initAttrs())[propertyNamePrefix + "min"] = range[0];
                    attrs[propertyNamePrefix + "max"] = range[1];
                    if (range.length > 2) {
                      attrs[propertyNamePrefix + "step"] = range[2];
                    }
                  }
                }
              }
              parseSimpleAttribute('step', 'number');
              parseSimpleAttribute('userData', 'object');
            }
            CCClass.isArray = function (defaultVal) {
              defaultVal = getDefault(defaultVal);
              return Array.isArray(defaultVal);
            };
            CCClass.getDefault = getDefault;
            CCClass.escapeForJS = escapeForJS$1;
            CCClass.IDENTIFIER_RE = IDENTIFIER_RE$1;
            CCClass.getNewValueTypeCode = getNewValueTypeCodeJit;
            legacyCC.Class = CCClass;

            var mathAbs$4 = Math.abs;
            var mathFloor = Math.floor;
            var PI$4 = Math.PI;
            var _d2r = PI$4 / 180.0;
            var _r2d = 180.0 / PI$4;
            var _random = Math.random;
            var HALF_PI = exports("HALF_PI", PI$4 * 0.5);
            var TWO_PI = exports("TWO_PI", PI$4 * 2.0);
            var EPSILON$1 = exports("EPSILON", 0.000001);
            function equals(a, b) {
              return mathAbs$4(a - b) <= EPSILON$1 * Math.max(1.0, mathAbs$4(a), mathAbs$4(b));
            }
            function approx(a, b, maxDiff) {
              maxDiff = maxDiff || EPSILON$1;
              return mathAbs$4(a - b) <= maxDiff;
            }
            function clamp(val, min, max) {
              if (min > max) {
                var temp = min;
                min = max;
                max = temp;
              }
              return val < min ? min : val > max ? max : val;
            }
            function clamp01(val) {
              return val < 0 ? 0 : val > 1 ? 1 : val;
            }
            function lerp(from, to, ratio) {
              return from + (to - from) * ratio;
            }
            function toRadian(a) {
              return a * _d2r;
            }
            function toDegree(a) {
              return a * _r2d;
            }
            function random() {
              return _random();
            }
            function setRandGenerator(func) {
              _random = func;
            }
            function randomRange(min, max) {
              return random() * (max - min) + min;
            }
            function randomRangeInt(min, max) {
              return mathFloor(randomRange(min, max));
            }
            function pseudoRandom(seed) {
              seed = (seed * 9301 + 49297) % 233280;
              return seed / 233280.0;
            }
            function pseudoRandomRange(seed, min, max) {
              return pseudoRandom(seed) * (max - min) + min;
            }
            function pseudoRandomRangeInt(seed, min, max) {
              return mathFloor(pseudoRandomRange(seed, min, max));
            }
            function nextPow2(val) {
              return nextPow2$1(val);
            }
            function repeat$2(t, length) {
              return t - mathFloor(t / length) * length;
            }
            function pingPong(t, length) {
              t = repeat$2(t, length * 2);
              t = length - mathAbs$4(t - length);
              return t;
            }
            function inverseLerp(from, to, value) {
              return (value - from) / (to - from);
            }
            function absMaxComponent(v) {
              if (mathAbs$4(v.x) > mathAbs$4(v.y)) {
                if (mathAbs$4(v.x) > mathAbs$4(v.z)) {
                  return v.x;
                } else {
                  return v.z;
                }
              } else if (mathAbs$4(v.y) > mathAbs$4(v.z)) {
                return v.y;
              } else {
                return v.z;
              }
            }
            function absMax(a, b) {
              if (mathAbs$4(a) > mathAbs$4(b)) {
                return a;
              } else {
                return b;
              }
            }
            function enumerableProps(prototype, attrs) {
              attrs.forEach(function (key) {
                Object.defineProperty(prototype, key, {
                  enumerable: true
                });
              });
            }
            var toHalf = function toHalf() {
              var floatView = new Float32Array(1);
              var int32View = new Int32Array(floatView.buffer);
              return function toHalf(fval) {
                floatView[0] = fval;
                var fbits = int32View[0];
                var s = fbits >> 16 & 0x8000;
                var em = fbits & 0x7fffffff;
                var h = em - (112 << 23) + (1 << 12) >> 13;
                h = em < 113 << 23 ? 0 : h;
                h = em >= 143 << 23 ? 0x7c00 : h;
                h = em > 255 << 23 ? 0x7e00 : h;
                int32View[0] = s | h;
                return int32View[0];
              };
            }();
            var fromHalf = function fromHalf() {
              var floatView = new Float32Array(1);
              var int32View = new Int32Array(floatView.buffer);
              return function fromHalf(hval) {
                var s = hval >> 15 & 0x00000001;
                var em = hval & 0x00007fff;
                var h = em << 13;
                var fbits = 0;
                if (h !== 0x7c00) {
                  h += 112 << 23;
                  if (em === 0) {
                    h = (h & 0xfffff) >> 1;
                  } else if (em === 0x7fff) {
                    h = 0x7fffffff;
                  }
                } else {
                  h = 0x7f800000;
                }
                fbits = s << 31 | h;
                int32View[0] = fbits;
                return floatView[0];
              };
            }();
            function floatToHalf(val) {
              return toHalf(val);
            }
            function halfToFloat(val) {
              return fromHalf(val);
            }

            var abs$5 = Math.abs;
            var _max$3 = Math.max;
            var _min$3 = Math.min;
            var PI$3 = Math.PI;
            var sin$4 = Math.sin;
            var cos$5 = Math.cos;
            var atan2$2 = Math.atan2;
            var sqrt$5 = Math.sqrt;
            var _ceil$2 = Math.ceil;
            var _floor$2 = Math.floor;
            var _round$2 = Math.round;
            function freezeVec4(x, y, z, w) {
              return Object.freeze(new Vec4(x, y, z, w));
            }
            var Vec4 = exports("Vec4", function (_ValueType) {
              _inheritsLoose(Vec4, _ValueType);
              Vec4.clone = function clone(a) {
                return new Vec4(a.x, a.y, a.z, a.w);
              };
              Vec4.copy = function copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                out.w = a.w;
                return out;
              };
              Vec4.set = function set(out, x, y, z, w) {
                out.x = x;
                out.y = y;
                out.z = z;
                out.w = w;
                return out;
              };
              Vec4.fromColor = function fromColor(out, color) {
                out.x = color.r;
                out.y = color.g;
                out.z = color.b;
                out.w = color.a;
                return out;
              };
              Vec4.angle = function angle(a, b) {
                var dx = a.y * b.z - a.z * b.y;
                var dy = a.z * b.x - a.x * b.z;
                var dz = a.x * b.y - a.y * b.x;
                var dotVal = a.x * b.x + a.y * b.y + a.z * b.z;
                return atan2$2(sqrt$5(dx * dx + dy * dy + dz * dz), dotVal);
              };
              Vec4.add = function add(out, a, b) {
                out.x = a.x + b.x;
                out.y = a.y + b.y;
                out.z = a.z + b.z;
                out.w = a.w + b.w;
                return out;
              };
              Vec4.subtract = function subtract(out, a, b) {
                out.x = a.x - b.x;
                out.y = a.y - b.y;
                out.z = a.z - b.z;
                out.w = a.w - b.w;
                return out;
              };
              Vec4.multiply = function multiply(out, a, b) {
                out.x = a.x * b.x;
                out.y = a.y * b.y;
                out.z = a.z * b.z;
                out.w = a.w * b.w;
                return out;
              };
              Vec4.divide = function divide(out, a, b) {
                out.x = a.x / b.x;
                out.y = a.y / b.y;
                out.z = a.z / b.z;
                out.w = a.w / b.w;
                return out;
              };
              Vec4.ceil = function ceil(out, a) {
                out.x = _ceil$2(a.x);
                out.y = _ceil$2(a.y);
                out.z = _ceil$2(a.z);
                out.w = _ceil$2(a.w);
                return out;
              };
              Vec4.floor = function floor(out, a) {
                out.x = _floor$2(a.x);
                out.y = _floor$2(a.y);
                out.z = _floor$2(a.z);
                out.w = _floor$2(a.w);
                return out;
              };
              Vec4.min = function min(out, a, b) {
                out.x = _min$3(a.x, b.x);
                out.y = _min$3(a.y, b.y);
                out.z = _min$3(a.z, b.z);
                out.w = _min$3(a.w, b.w);
                return out;
              };
              Vec4.max = function max(out, a, b) {
                out.x = _max$3(a.x, b.x);
                out.y = _max$3(a.y, b.y);
                out.z = _max$3(a.z, b.z);
                out.w = _max$3(a.w, b.w);
                return out;
              };
              Vec4.round = function round(out, a) {
                out.x = _round$2(a.x);
                out.y = _round$2(a.y);
                out.z = _round$2(a.z);
                out.w = _round$2(a.w);
                return out;
              };
              Vec4.multiplyScalar = function multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                out.w = a.w * b;
                return out;
              };
              Vec4.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                out.z = a.z + b.z * scale;
                out.w = a.w + b.w * scale;
                return out;
              };
              Vec4.distance = function distance(a, b) {
                var x = b.x - a.x;
                var y = b.y - a.y;
                var z = b.z - a.z;
                var w = b.w - a.w;
                return sqrt$5(x * x + y * y + z * z + w * w);
              };
              Vec4.squaredDistance = function squaredDistance(a, b) {
                var x = b.x - a.x;
                var y = b.y - a.y;
                var z = b.z - a.z;
                var w = b.w - a.w;
                return x * x + y * y + z * z + w * w;
              };
              Vec4.len = function len(a) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                var w = a.w;
                return sqrt$5(x * x + y * y + z * z + w * w);
              };
              Vec4.lengthSqr = function lengthSqr(a) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                var w = a.w;
                return x * x + y * y + z * z + w * w;
              };
              Vec4.negate = function negate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                out.z = -a.z;
                out.w = -a.w;
                return out;
              };
              Vec4.inverse = function inverse(out, a) {
                out.x = 1.0 / a.x;
                out.y = 1.0 / a.y;
                out.z = 1.0 / a.z;
                out.w = 1.0 / a.w;
                return out;
              };
              Vec4.inverseSafe = function inverseSafe(out, a) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                var w = a.w;
                if (abs$5(x) < EPSILON$1) {
                  out.x = 0;
                } else {
                  out.x = 1.0 / x;
                }
                if (abs$5(y) < EPSILON$1) {
                  out.y = 0;
                } else {
                  out.y = 1.0 / y;
                }
                if (abs$5(z) < EPSILON$1) {
                  out.z = 0;
                } else {
                  out.z = 1.0 / z;
                }
                if (abs$5(w) < EPSILON$1) {
                  out.w = 0;
                } else {
                  out.w = 1.0 / w;
                }
                return out;
              };
              Vec4.normalize = function normalize(out, a) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                var w = a.w;
                var len = x * x + y * y + z * z + w * w;
                if (len > 0) {
                  len = 1 / sqrt$5(len);
                  out.x = x * len;
                  out.y = y * len;
                  out.z = z * len;
                  out.w = w * len;
                } else {
                  out.x = 0;
                  out.y = 0;
                  out.z = 0;
                  out.w = 0;
                }
                return out;
              };
              Vec4.dot = function dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
              };
              Vec4.lerp = function lerp(out, a, b, t) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                out.w = a.w + t * (b.w - a.w);
                return out;
              };
              Vec4.scale = function scale(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                out.w = a.w * b;
                return out;
              };
              Vec4.random = function random$1(out, scale) {
                scale = scale || 1.0;
                var phi = random() * 2.0 * PI$3;
                var cosTheta = random() * 2 - 1;
                var sinTheta = sqrt$5(1 - cosTheta * cosTheta);
                out.x = sinTheta * cos$5(phi) * scale;
                out.y = sinTheta * sin$4(phi) * scale;
                out.z = cosTheta * scale;
                out.w = 0;
                return out;
              };
              Vec4.transformMat4 = function transformMat4(out, a, m) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                var w = a.w;
                out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
                out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
                out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
                out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
                return out;
              };
              Vec4.transformAffine = function transformAffine(out, v, m) {
                var x = v.x;
                var y = v.y;
                var z = v.z;
                var w = v.w;
                out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
                out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
                out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
                out.w = v.w;
                return out;
              };
              Vec4.transformQuat = function transformQuat(out, a, q) {
                var x = a.x,
                  y = a.y,
                  z = a.z;
                var _x = q.x;
                var _y = q.y;
                var _z = q.z;
                var _w = q.w;
                var ix = _w * x + _y * z - _z * y;
                var iy = _w * y + _z * x - _x * z;
                var iz = _w * z + _x * y - _y * x;
                var iw = -_x * x - _y * y - _z * z;
                out.x = ix * _w + iw * -_x + iy * -_z - iz * -_y;
                out.y = iy * _w + iw * -_y + iz * -_x - ix * -_z;
                out.z = iz * _w + iw * -_z + ix * -_y - iy * -_x;
                out.w = a.w;
                return out;
              };
              Vec4.toArray = function toArray(out, v, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out[ofs + 0] = v.x;
                out[ofs + 1] = v.y;
                out[ofs + 2] = v.z;
                out[ofs + 3] = v.w;
                return out;
              };
              Vec4.fromArray = function fromArray(out, arr, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                out.z = arr[ofs + 2];
                out.w = arr[ofs + 3];
                return out;
              };
              Vec4.strictEquals = function strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
              };
              Vec4.equals = function equals(a, b, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                var inf = Infinity;
                var hasInf = abs$5(a.x) === inf || abs$5(a.y) === inf || abs$5(a.z) === inf || abs$5(a.w) === inf || abs$5(b.x) === inf || abs$5(b.y) === inf || abs$5(b.z) === inf || abs$5(b.w) === inf;
                return !hasInf && abs$5(a.x - b.x) <= epsilon * _max$3(1.0, abs$5(a.x), abs$5(b.x)) && abs$5(a.y - b.y) <= epsilon * _max$3(1.0, abs$5(a.y), abs$5(b.y)) && abs$5(a.z - b.z) <= epsilon * _max$3(1.0, abs$5(a.z), abs$5(b.z)) && abs$5(a.w - b.w) <= epsilon * _max$3(1.0, abs$5(a.w), abs$5(b.w));
              };
              function Vec4(x, y, z, w) {
                var _this;
                _this = _ValueType.call(this) || this;
                if (typeof x === 'object') {
                  _this.x = x.x;
                  _this.y = x.y;
                  _this.z = x.z;
                  _this.w = x.w;
                } else {
                  _this.x = x || 0;
                  _this.y = y || 0;
                  _this.z = z || 0;
                  _this.w = w || 0;
                }
                return _this;
              }
              var _proto = Vec4.prototype;
              _proto.clone = function clone() {
                return new Vec4(this.x, this.y, this.z, this.w);
              };
              _proto.set = function set(x, y, z, w) {
                if (typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                  this.z = x.z;
                  this.w = x.w;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                  this.w = w || 0;
                }
                return this;
              };
              _proto.equals = function equals(other, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                var self = this;
                return abs$5(self.x - other.x) <= epsilon * _max$3(1.0, abs$5(self.x), abs$5(other.x)) && abs$5(self.y - other.y) <= epsilon * _max$3(1.0, abs$5(self.y), abs$5(other.y)) && abs$5(self.z - other.z) <= epsilon * _max$3(1.0, abs$5(self.z), abs$5(other.z)) && abs$5(self.w - other.w) <= epsilon * _max$3(1.0, abs$5(self.w), abs$5(other.w));
              };
              _proto.equals4f = function equals4f(x, y, z, w, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                var self = this;
                return abs$5(self.x - x) <= epsilon * _max$3(1.0, abs$5(self.x), abs$5(x)) && abs$5(self.y - y) <= epsilon * _max$3(1.0, abs$5(self.y), abs$5(y)) && abs$5(self.z - z) <= epsilon * _max$3(1.0, abs$5(self.z), abs$5(z)) && abs$5(self.w - w) <= epsilon * _max$3(1.0, abs$5(self.w), abs$5(w));
              };
              _proto.strictEquals = function strictEquals(other) {
                return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
              };
              _proto.strictEquals4f = function strictEquals4f(x, y, z, w) {
                return this.x === x && this.y === y && this.z === z && this.w === w;
              };
              _proto.lerp = function lerp(to, ratio) {
                var self = this;
                var x = self.x;
                var y = self.y;
                var z = self.z;
                var w = self.w;
                self.x = x + ratio * (to.x - x);
                self.y = y + ratio * (to.y - y);
                self.z = z + ratio * (to.z - z);
                self.w = w + ratio * (to.w - w);
                return self;
              };
              _proto.toString = function toString() {
                return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
              };
              _proto.clampf = function clampf(minInclusive, maxInclusive) {
                var self = this;
                self.x = clamp(self.x, minInclusive.x, maxInclusive.x);
                self.y = clamp(self.y, minInclusive.y, maxInclusive.y);
                self.z = clamp(self.z, minInclusive.z, maxInclusive.z);
                self.w = clamp(self.w, minInclusive.w, maxInclusive.w);
                return self;
              };
              _proto.add = function add(other) {
                var self = this;
                self.x += other.x;
                self.y += other.y;
                self.z += other.z;
                self.w += other.w;
                return self;
              };
              _proto.add4f = function add4f(x, y, z, w) {
                var self = this;
                self.x += x;
                self.y += y;
                self.z += z;
                self.w += w;
                return self;
              };
              _proto.subtract = function subtract(other) {
                var self = this;
                self.x -= other.x;
                self.y -= other.y;
                self.z -= other.z;
                self.w -= other.w;
                return self;
              };
              _proto.subtract4f = function subtract4f(x, y, z, w) {
                var self = this;
                self.x -= x;
                self.y -= y;
                self.z -= z;
                self.w -= w;
                return self;
              };
              _proto.multiplyScalar = function multiplyScalar(scalar) {
                var self = this;
                self.x *= scalar;
                self.y *= scalar;
                self.z *= scalar;
                self.w *= scalar;
                return self;
              };
              _proto.multiply = function multiply(other) {
                var self = this;
                self.x *= other.x;
                self.y *= other.y;
                self.z *= other.z;
                self.w *= other.w;
                return self;
              };
              _proto.multiply4f = function multiply4f(x, y, z, w) {
                var self = this;
                self.x *= x;
                self.y *= y;
                self.z *= z;
                self.w *= w;
                return self;
              };
              _proto.divide = function divide(other) {
                var self = this;
                self.x /= other.x;
                self.y /= other.y;
                self.z /= other.z;
                self.w /= other.w;
                return self;
              };
              _proto.divide4f = function divide4f(x, y, z, w) {
                var self = this;
                self.x /= x;
                self.y /= y;
                self.z /= z;
                self.w /= w;
                return self;
              };
              _proto.negative = function negative() {
                var self = this;
                self.x = -self.x;
                self.y = -self.y;
                self.z = -self.z;
                self.w = -self.w;
                return self;
              };
              _proto.dot = function dot(vector) {
                var self = this;
                return self.x * vector.x + self.y * vector.y + self.z * vector.z + self.w * vector.w;
              };
              _proto.cross = function cross(vector) {
                var self = this;
                var ax = self.x,
                  ay = self.y,
                  az = self.z;
                var bx = vector.x,
                  by = vector.y,
                  bz = vector.z;
                self.x = ay * bz - az * by;
                self.y = az * bx - ax * bz;
                self.z = ax * by - ay * bx;
                return self;
              };
              _proto.length = function length() {
                var self = this;
                var x = self.x;
                var y = self.y;
                var z = self.z;
                var w = self.w;
                return sqrt$5(x * x + y * y + z * z + w * w);
              };
              _proto.lengthSqr = function lengthSqr() {
                var self = this;
                var x = self.x;
                var y = self.y;
                var z = self.z;
                var w = self.w;
                return x * x + y * y + z * z + w * w;
              };
              _proto.normalize = function normalize() {
                var self = this;
                var x = self.x;
                var y = self.y;
                var z = self.z;
                var w = self.w;
                var len = x * x + y * y + z * z + w * w;
                if (len > 0) {
                  len = 1 / sqrt$5(len);
                  self.x = x * len;
                  self.y = y * len;
                  self.z = z * len;
                  self.w = w * len;
                }
                return self;
              };
              _proto.scale = function scale(scalar) {
                var self = this;
                self.x *= scalar;
                self.y *= scalar;
                self.z *= scalar;
                self.w *= scalar;
                return self;
              };
              _proto.transformMat4 = function transformMat4(matrix) {
                var self = this;
                var x = self.x;
                var y = self.y;
                var z = self.z;
                var w = self.w;
                self.x = matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12 * w;
                self.y = matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13 * w;
                self.z = matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14 * w;
                self.w = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15 * w;
                return self;
              };
              return Vec4;
            }(ValueType));
            Vec4.ZERO = freezeVec4(0, 0, 0, 0);
            Vec4.ONE = freezeVec4(1, 1, 1, 1);
            Vec4.NEG_ONE = freezeVec4(-1, -1, -1, -1);
            Vec4.UNIT_X = freezeVec4(1, 0, 0, 0);
            Vec4.UNIT_Y = freezeVec4(0, 1, 0, 0);
            Vec4.UNIT_Z = freezeVec4(0, 0, 1, 0);
            Vec4.UNIT_W = freezeVec4(0, 0, 0, 1);
            CCClass.fastDefine('cc.Vec4', Vec4, {
              x: 0,
              y: 0,
              z: 0,
              w: 0
            });
            legacyCC.Vec4 = Vec4;
            function v4(x, y, z, w) {
              return new Vec4(x, y, z, w);
            }
            legacyCC.v4 = v4;

            var _class$W;
            var abs$4 = Math.abs;
            var _max$2 = Math.max;
            var _min$2 = Math.min;
            var PI$2 = Math.PI;
            var acos$3 = Math.acos;
            var sin$3 = Math.sin;
            var cos$4 = Math.cos;
            var sqrt$4 = Math.sqrt;
            var _ceil$1 = Math.ceil;
            var _floor$1 = Math.floor;
            var _round$1 = Math.round;
            function freezeVec3(x, y, z) {
              return Object.freeze(new Vec3(x, y, z));
            }
            var Vec3 = exports("Vec3", function (_ValueType) {
              _inheritsLoose(Vec3, _ValueType);
              Vec3.zero = function zero(out) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                return out;
              };
              Vec3.clone = function clone(a) {
                return new Vec3(a.x, a.y, a.z);
              };
              Vec3.copy = function copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                return out;
              };
              Vec3.set = function set(out, x, y, z) {
                out.x = x;
                out.y = y;
                out.z = z;
                return out;
              };
              Vec3.add = function add(out, a, b) {
                out.x = a.x + b.x;
                out.y = a.y + b.y;
                out.z = a.z + b.z;
                return out;
              };
              Vec3.subtract = function subtract(out, a, b) {
                out.x = a.x - b.x;
                out.y = a.y - b.y;
                out.z = a.z - b.z;
                return out;
              };
              Vec3.multiply = function multiply(out, a, b) {
                out.x = a.x * b.x;
                out.y = a.y * b.y;
                out.z = a.z * b.z;
                return out;
              };
              Vec3.divide = function divide(out, a, b) {
                out.x = a.x / b.x;
                out.y = a.y / b.y;
                out.z = a.z / b.z;
                return out;
              };
              Vec3.ceil = function ceil(out, a) {
                out.x = _ceil$1(a.x);
                out.y = _ceil$1(a.y);
                out.z = _ceil$1(a.z);
                return out;
              };
              Vec3.floor = function floor(out, a) {
                out.x = _floor$1(a.x);
                out.y = _floor$1(a.y);
                out.z = _floor$1(a.z);
                return out;
              };
              Vec3.min = function min(out, a, b) {
                out.x = _min$2(a.x, b.x);
                out.y = _min$2(a.y, b.y);
                out.z = _min$2(a.z, b.z);
                return out;
              };
              Vec3.max = function max(out, a, b) {
                out.x = _max$2(a.x, b.x);
                out.y = _max$2(a.y, b.y);
                out.z = _max$2(a.z, b.z);
                return out;
              };
              Vec3.round = function round(out, a) {
                out.x = _round$1(a.x);
                out.y = _round$1(a.y);
                out.z = _round$1(a.z);
                return out;
              };
              Vec3.multiplyScalar = function multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                return out;
              };
              Vec3.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                out.z = a.z + b.z * scale;
                return out;
              };
              Vec3.distance = function distance(a, b) {
                var x = b.x - a.x;
                var y = b.y - a.y;
                var z = b.z - a.z;
                return sqrt$4(x * x + y * y + z * z);
              };
              Vec3.squaredDistance = function squaredDistance(a, b) {
                var x = b.x - a.x;
                var y = b.y - a.y;
                var z = b.z - a.z;
                return x * x + y * y + z * z;
              };
              Vec3.len = function len(a) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                return sqrt$4(x * x + y * y + z * z);
              };
              Vec3.lengthSqr = function lengthSqr(a) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                return x * x + y * y + z * z;
              };
              Vec3.negate = function negate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                out.z = -a.z;
                return out;
              };
              Vec3.invert = function invert(out, a) {
                out.x = 1.0 / a.x;
                out.y = 1.0 / a.y;
                out.z = 1.0 / a.z;
                return out;
              };
              Vec3.invertSafe = function invertSafe(out, a) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                if (abs$4(x) < EPSILON$1) {
                  out.x = 0;
                } else {
                  out.x = 1.0 / x;
                }
                if (abs$4(y) < EPSILON$1) {
                  out.y = 0;
                } else {
                  out.y = 1.0 / y;
                }
                if (abs$4(z) < EPSILON$1) {
                  out.z = 0;
                } else {
                  out.z = 1.0 / z;
                }
                return out;
              };
              Vec3.normalize = function normalize(out, a) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                var len = x * x + y * y + z * z;
                if (len > 0) {
                  len = 1 / sqrt$4(len);
                  out.x = x * len;
                  out.y = y * len;
                  out.z = z * len;
                } else {
                  out.x = 0;
                  out.y = 0;
                  out.z = 0;
                }
                return out;
              };
              Vec3.dot = function dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z;
              };
              Vec3.cross = function cross(out, a, b) {
                var ax = a.x,
                  ay = a.y,
                  az = a.z;
                var bx = b.x,
                  by = b.y,
                  bz = b.z;
                out.x = ay * bz - az * by;
                out.y = az * bx - ax * bz;
                out.z = ax * by - ay * bx;
                return out;
              };
              Vec3.lerp = function lerp(out, a, b, t) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                return out;
              };
              Vec3.random = function random$1(out, scale) {
                scale = scale || 1.0;
                var phi = random() * 2.0 * PI$2;
                var cosTheta = random() * 2 - 1;
                var sinTheta = sqrt$4(1 - cosTheta * cosTheta);
                out.x = sinTheta * cos$4(phi) * scale;
                out.y = sinTheta * sin$3(phi) * scale;
                out.z = cosTheta * scale;
                return out;
              };
              Vec3.transformMat4 = function transformMat4(out, a, m) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                var rhw = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
                rhw = rhw ? 1 / rhw : 1;
                out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) * rhw;
                out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) * rhw;
                out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) * rhw;
                return out;
              };
              Vec3.transformMat4Normal = function transformMat4Normal(out, a, m) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                var rhw = m.m03 * x + m.m07 * y + m.m11 * z;
                rhw = rhw ? 1 / rhw : 1;
                out.x = (m.m00 * x + m.m04 * y + m.m08 * z) * rhw;
                out.y = (m.m01 * x + m.m05 * y + m.m09 * z) * rhw;
                out.z = (m.m02 * x + m.m06 * y + m.m10 * z) * rhw;
                return out;
              };
              Vec3.transformMat3 = function transformMat3(out, a, m) {
                var x = a.x;
                var y = a.y;
                var z = a.z;
                out.x = x * m.m00 + y * m.m03 + z * m.m06;
                out.y = x * m.m01 + y * m.m04 + z * m.m07;
                out.z = x * m.m02 + y * m.m05 + z * m.m08;
                return out;
              };
              Vec3.transformAffine = function transformAffine(out, v, m) {
                var x = v.x;
                var y = v.y;
                var z = v.z;
                out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12;
                out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13;
                out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14;
                return out;
              };
              Vec3.transformQuat = function transformQuat(out, a, q) {
                var ix = q.w * a.x + q.y * a.z - q.z * a.y;
                var iy = q.w * a.y + q.z * a.x - q.x * a.z;
                var iz = q.w * a.z + q.x * a.y - q.y * a.x;
                var iw = -q.x * a.x - q.y * a.y - q.z * a.z;
                out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
                out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
                out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
                return out;
              };
              Vec3.transformRTS = function transformRTS(out, a, r, t, s) {
                var x = a.x * s.x;
                var y = a.y * s.y;
                var z = a.z * s.z;
                var ix = r.w * x + r.y * z - r.z * y;
                var iy = r.w * y + r.z * x - r.x * z;
                var iz = r.w * z + r.x * y - r.y * x;
                var iw = -r.x * x - r.y * y - r.z * z;
                out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x;
                out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y;
                out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z;
                return out;
              };
              Vec3.transformInverseRTS = function transformInverseRTS(out, a, r, t, s) {
                var x = a.x - t.x;
                var y = a.y - t.y;
                var z = a.z - t.z;
                var ix = r.w * x - r.y * z + r.z * y;
                var iy = r.w * y - r.z * x + r.x * z;
                var iz = r.w * z - r.x * y + r.y * x;
                var iw = r.x * x + r.y * y + r.z * z;
                out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x;
                out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y;
                out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z;
                return out;
              };
              Vec3.rotateX = function rotateX(out, v, o, a) {
                var x = v.x - o.x;
                var y = v.y - o.y;
                var z = v.z - o.z;
                var c = cos$4(a);
                var s = sin$3(a);
                var rx = x;
                var ry = y * c - z * s;
                var rz = y * s + z * c;
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              };
              Vec3.rotateY = function rotateY(out, v, o, a) {
                var x = v.x - o.x;
                var y = v.y - o.y;
                var z = v.z - o.z;
                var c = cos$4(a);
                var s = sin$3(a);
                var rx = z * s + x * c;
                var ry = y;
                var rz = z * c - x * s;
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              };
              Vec3.rotateZ = function rotateZ(out, v, o, a) {
                var x = v.x - o.x;
                var y = v.y - o.y;
                var z = v.z - o.z;
                var c = cos$4(a);
                var s = sin$3(a);
                var rx = x * c - y * s;
                var ry = x * s + y * c;
                var rz = z;
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              };
              Vec3.rotateN = function rotateN(out, v, o, n, a) {
                var x = v.x - o.x;
                var y = v.y - o.y;
                var z = v.z - o.z;
                var nx = n.x;
                var ny = n.y;
                var nz = n.z;
                var c = cos$4(a);
                var s = sin$3(a);
                var rx = x * (nx * nx * (1.0 - c) + c) + y * (nx * ny * (1.0 - c) - nz * s) + z * (nx * nz * (1.0 - c) + ny * s);
                var ry = x * (nx * ny * (1.0 - c) + nz * s) + y * (ny * ny * (1.0 - c) + c) + z * (ny * nz * (1.0 - c) - nx * s);
                var rz = x * (nx * nz * (1.0 - c) - ny * s) + y * (ny * nz * (1.0 - c) + nx * s) + z * (nz * nz * (1.0 - c) + c);
                out.x = rx + o.x;
                out.y = ry + o.y;
                out.z = rz + o.z;
                return out;
              };
              Vec3.toArray = function toArray(out, v, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out[ofs + 0] = v.x;
                out[ofs + 1] = v.y;
                out[ofs + 2] = v.z;
                return out;
              };
              Vec3.fromArray = function fromArray(out, arr, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                out.z = arr[ofs + 2];
                return out;
              };
              Vec3.strictEquals = function strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z;
              };
              Vec3.equals = function equals(a, b, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                var a0 = a.x,
                  a1 = a.y,
                  a2 = a.z;
                var b0 = b.x,
                  b1 = b.y,
                  b2 = b.z;
                return abs$4(a0 - b0) <= epsilon * _max$2(1.0, abs$4(a0), abs$4(b0)) && abs$4(a1 - b1) <= epsilon * _max$2(1.0, abs$4(a1), abs$4(b1)) && abs$4(a2 - b2) <= epsilon * _max$2(1.0, abs$4(a2), abs$4(b2));
              };
              Vec3.angle = function angle(a, b) {
                var magSqr1 = a.x * a.x + a.y * a.y + a.z * a.z;
                var magSqr2 = b.x * b.x + b.y * b.y + b.z * b.z;
                if (magSqr1 === 0 || magSqr2 === 0) {
                  return 0.0;
                }
                var dot = a.x * b.x + a.y * b.y + a.z * b.z;
                var cosine = dot / sqrt$4(magSqr1 * magSqr2);
                cosine = clamp(cosine, -1, 1.0);
                return acos$3(cosine);
              };
              Vec3.projectOnPlane = function projectOnPlane(out, a, n) {
                return Vec3.subtract(out, a, Vec3.project(out, a, n));
              };
              Vec3.project = function project(out, a, b) {
                var sqrLen = Vec3.lengthSqr(b);
                if (sqrLen < 0.000001) {
                  return Vec3.set(out, 0, 0, 0);
                } else {
                  return Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
                }
              };
              Vec3.moveTowards = function moveTowards(out, current, target, maxStep) {
                var deltaX = target.x - current.x;
                var deltaY = target.y - current.y;
                var deltaZ = target.z - current.z;
                var distanceSqr = deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ;
                if (distanceSqr === 0 || maxStep >= 0 && distanceSqr < maxStep * maxStep) {
                  out.x = target.x;
                  out.y = target.y;
                  out.z = target.z;
                  return out;
                }
                var distance = sqrt$4(distanceSqr);
                var scale = maxStep / distance;
                out.x = current.x + deltaX * scale;
                out.y = current.y + deltaY * scale;
                out.z = current.z + deltaZ * scale;
                return out;
              };
              Vec3.generateOrthogonal = function generateOrthogonal(out, n) {
                var x = n.x,
                  y = n.y,
                  z = n.z;
                var absX = abs$4(x);
                var absY = abs$4(y);
                var absZ = abs$4(z);
                if (absX < absY && absX < absZ) {
                  Vec3.set(out, 0.0, z, -y);
                } else if (absY < absZ) {
                  Vec3.set(out, z, 0.0, -x);
                } else {
                  Vec3.set(out, y, -x, 0.0);
                }
                return Vec3.normalize(out, out);
              };
              function Vec3(x, y, z) {
                var _this;
                _this = _ValueType.call(this) || this;
                if (typeof x === 'object') {
                  _this.x = x.x;
                  _this.y = x.y;
                  _this.z = x.z;
                } else {
                  _this.x = x || 0;
                  _this.y = y || 0;
                  _this.z = z || 0;
                }
                return _this;
              }
              var _proto = Vec3.prototype;
              _proto.clone = function clone() {
                return new Vec3(this.x, this.y, this.z);
              };
              _proto.set = function set(x, y, z) {
                if (typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                  this.z = x.z;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                }
                return this;
              };
              _proto.equals = function equals(other, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return abs$4(this.x - other.x) <= epsilon && abs$4(this.y - other.y) <= epsilon && abs$4(this.z - other.z) <= epsilon;
              };
              _proto.equals3f = function equals3f(x, y, z, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return abs$4(this.x - x) <= epsilon && abs$4(this.y - y) <= epsilon && abs$4(this.z - z) <= epsilon;
              };
              _proto.strictEquals = function strictEquals(other) {
                return this.x === other.x && this.y === other.y && this.z === other.z;
              };
              _proto.strictEquals3f = function strictEquals3f(x, y, z) {
                return this.x === x && this.y === y && this.z === z;
              };
              _proto.toString = function toString() {
                return "(" + this.x + ", " + this.y + ", " + this.z + ")";
              };
              _proto.lerp = function lerp(to, ratio) {
                this.x += ratio * (to.x - this.x);
                this.y += ratio * (to.y - this.y);
                this.z += ratio * (to.z - this.z);
                return this;
              };
              _proto.add = function add(other) {
                this.x += other.x;
                this.y += other.y;
                this.z += other.z;
                return this;
              };
              _proto.add3f = function add3f(x, y, z) {
                this.x += x;
                this.y += y;
                this.z += z;
                return this;
              };
              _proto.subtract = function subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                this.z -= other.z;
                return this;
              };
              _proto.subtract3f = function subtract3f(x, y, z) {
                this.x -= x;
                this.y -= y;
                this.z -= z;
                return this;
              };
              _proto.multiplyScalar = function multiplyScalar(scalar) {
                if (typeof scalar === 'object') {
                  warnID(16357);
                }
                this.x *= scalar;
                this.y *= scalar;
                this.z *= scalar;
                return this;
              };
              _proto.multiply = function multiply(other) {
                if (typeof other !== 'object') {
                  warnID(16358);
                }
                this.x *= other.x;
                this.y *= other.y;
                this.z *= other.z;
                return this;
              };
              _proto.multiply3f = function multiply3f(x, y, z) {
                this.x *= x;
                this.y *= y;
                this.z *= z;
                return this;
              };
              _proto.divide = function divide(other) {
                this.x /= other.x;
                this.y /= other.y;
                this.z /= other.z;
                return this;
              };
              _proto.divide3f = function divide3f(x, y, z) {
                this.x /= x;
                this.y /= y;
                this.z /= z;
                return this;
              };
              _proto.negative = function negative() {
                this.x = -this.x;
                this.y = -this.y;
                this.z = -this.z;
                return this;
              };
              _proto.clampf = function clampf(minInclusive, maxInclusive) {
                this.x = clamp(this.x, minInclusive.x, maxInclusive.x);
                this.y = clamp(this.y, minInclusive.y, maxInclusive.y);
                this.z = clamp(this.z, minInclusive.z, maxInclusive.z);
                return this;
              };
              _proto.dot = function dot(other) {
                return this.x * other.x + this.y * other.y + this.z * other.z;
              };
              _proto.cross = function cross(other) {
                var ax = this.x,
                  ay = this.y,
                  az = this.z;
                var bx = other.x,
                  by = other.y,
                  bz = other.z;
                this.x = ay * bz - az * by;
                this.y = az * bx - ax * bz;
                this.z = ax * by - ay * bx;
                return this;
              };
              _proto.length = function length() {
                var self = this;
                return sqrt$4(self.x * self.x + self.y * self.y + self.z * self.z);
              };
              _proto.lengthSqr = function lengthSqr() {
                var self = this;
                return self.x * self.x + self.y * self.y + self.z * self.z;
              };
              _proto.normalize = function normalize() {
                var self = this;
                var x = self.x;
                var y = self.y;
                var z = self.z;
                var len = x * x + y * y + z * z;
                if (len > 0) {
                  len = 1 / sqrt$4(len);
                  self.x = x * len;
                  self.y = y * len;
                  self.z = z * len;
                }
                return self;
              };
              _proto.transformMat4 = function transformMat4(matrix) {
                var self = this;
                var x = self.x;
                var y = self.y;
                var z = self.z;
                var rhw = matrix.m03 * x + matrix.m07 * y + matrix.m11 * z + matrix.m15;
                rhw = rhw ? 1 / rhw : 1;
                self.x = (matrix.m00 * x + matrix.m04 * y + matrix.m08 * z + matrix.m12) * rhw;
                self.y = (matrix.m01 * x + matrix.m05 * y + matrix.m09 * z + matrix.m13) * rhw;
                self.z = (matrix.m02 * x + matrix.m06 * y + matrix.m10 * z + matrix.m14) * rhw;
                return self;
              };
              _proto.toVec2 = function toVec2() {
                return new legacyCC.Vec2(this.x, this.y);
              };
              return Vec3;
            }(ValueType));
            _class$W = Vec3;
            Vec3.UNIT_X = freezeVec3(1, 0, 0);
            Vec3.UNIT_Y = freezeVec3(0, 1, 0);
            Vec3.UNIT_Z = freezeVec3(0, 0, 1);
            Vec3.RIGHT = freezeVec3(1, 0, 0);
            Vec3.UP = freezeVec3(0, 1, 0);
            Vec3.FORWARD = freezeVec3(0, 0, -1);
            Vec3.ZERO = freezeVec3(0, 0, 0);
            Vec3.ONE = freezeVec3(1, 1, 1);
            Vec3.NEG_ONE = freezeVec3(-1, -1, -1);
            Vec3.slerp = function () {
              var cacheV1 = new _class$W();
              var cacheV2 = new _class$W();
              var cacheV3 = new _class$W();
              return function (out, from, to, t) {
                var EPSILON = 1e-5;
                var lenFrom = _class$W.len(from);
                var lenTo = _class$W.len(to);
                if (lenFrom < EPSILON || lenTo < EPSILON) {
                  return _class$W.lerp(out, from, to, t);
                }
                var lenLerped = lerp(lenFrom, lenTo, t);
                var dot = _class$W.dot(from, to) / (lenFrom * lenTo);
                if (dot > 1.0 - EPSILON) {
                  return _class$W.lerp(out, from, to, t);
                } else if (dot < -1 + EPSILON) {
                  var fromNormalized = _class$W.multiplyScalar(cacheV1, from, 1.0 / lenFrom);
                  var _axis = _class$W.generateOrthogonal(cacheV2, fromNormalized);
                  var _angle = PI$2 * t;
                  rotateAxisAngle(cacheV3, fromNormalized, _axis, _angle);
                  _class$W.multiplyScalar(out, cacheV3, lenLerped);
                  return out;
                } else {
                  var dotClamped = dot;
                  var theta = acos$3(dotClamped) * t;
                  var _fromNormalized = _class$W.multiplyScalar(cacheV1, from, 1.0 / lenFrom);
                  var toNormalized = _class$W.multiplyScalar(cacheV2, to, 1.0 / lenTo);
                  _class$W.scaleAndAdd(cacheV3, toNormalized, _fromNormalized, -dotClamped);
                  _class$W.normalize(cacheV3, cacheV3);
                  _class$W.multiplyScalar(cacheV3, cacheV3, sin$3(theta));
                  _class$W.scaleAndAdd(cacheV3, cacheV3, _fromNormalized, cos$4(theta));
                  _class$W.multiplyScalar(out, cacheV3, lenLerped);
                  return out;
                }
              };
            }();
            Vec3.signedAngle = function () {
              var cacheCross = new _class$W();
              return function (a, b, normal) {
                var angle = _class$W.angle(a, b);
                var cross = _class$W.cross(cacheCross, a, b);
                var dot = _class$W.dot(cross, normal);
                return dot < 0 ? -angle : angle;
              };
            }();
            CCClass.fastDefine('cc.Vec3', Vec3, {
              x: 0,
              y: 0,
              z: 0
            });
            legacyCC.Vec3 = Vec3;
            function v3(x, y, z) {
              return new Vec3(x, y, z);
            }
            var rotateAxisAngle = function () {
              var cacheQ = {
                x: 0.0,
                y: 0.0,
                z: 0.0,
                w: 0.0
              };
              return function (out, input, axis, angle) {
                var rad = angle * 0.5;
                var s = sin$3(rad);
                cacheQ.x = s * axis.x;
                cacheQ.y = s * axis.y;
                cacheQ.z = s * axis.z;
                cacheQ.w = cos$4(rad);
                Vec3.transformQuat(out, input, cacheQ);
                return out;
              };
            }();
            legacyCC.v3 = v3;

            var toFloat = 1 / 255;
            var R_INDEX = 0;
            var G_INDEX = 1;
            var B_INDEX = 2;
            var A_INDEX = 3;
            var mathAbs$3 = Math.abs;
            var mathMax$1 = Math.max;
            function freezeColor(r, g, b, a) {
              return Object.freeze(new Color(r, g, b, a));
            }
            var Color = exports("Color", function (_ValueType) {
              _inheritsLoose(Color, _ValueType);
              Color.clone = function clone(a) {
                var out = new Color();
                out.r = a.r;
                out.g = a.g;
                out.b = a.b;
                out.a = a.a;
                return out;
              };
              Color.copy = function copy(out, a) {
                out.r = a.r;
                out.g = a.g;
                out.b = a.b;
                out.a = a.a;
                return out;
              };
              Color.set = function set(out, r, g, b, a) {
                out.r = r;
                out.g = g;
                out.b = b;
                out.a = a;
                return out;
              };
              Color.toVec4 = function toVec4(color, out) {
                var sourceData = color._data;
                out = out !== undefined ? out : new Vec4();
                out.x = sourceData[R_INDEX] * toFloat;
                out.y = sourceData[G_INDEX] * toFloat;
                out.z = sourceData[B_INDEX] * toFloat;
                out.w = sourceData[A_INDEX] * toFloat;
                return out;
              };
              Color.fromVec4 = function fromVec4(value, out) {
                out = out === undefined ? new Color() : out;
                var outData = out._data;
                outData[R_INDEX] = value.x / toFloat;
                outData[G_INDEX] = value.y / toFloat;
                outData[B_INDEX] = value.z / toFloat;
                outData[A_INDEX] = value.w / toFloat;
                return out;
              };
              Color.fromHEX = function fromHEX(out, hex) {
                var hexNumber;
                if (typeof hex === 'string') {
                  hex = hex[0] === '#' ? hex.substring(1) : hex;
                  if (hex.length === 6) {
                    hex += 'FF';
                  } else if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + "FF";
                  } else if (hex.length === 4) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                  }
                  hexNumber = Number("0x" + hex);
                } else {
                  if (hex < 0x1000000) {
                    hex = (hex << 8) + 0xff;
                  }
                  hexNumber = hex;
                }
                out.r = hexNumber >>> 24;
                out.g = (hexNumber & 0x00ff0000) >>> 16;
                out.b = (hexNumber & 0x0000ff00) >>> 8;
                out.a = hexNumber & 0x000000ff;
                return out;
              };
              Color.add = function add(out, a, b) {
                out.r = a.r + b.r;
                out.g = a.g + b.g;
                out.b = a.b + b.b;
                out.a = a.a + b.a;
                return out;
              };
              Color.subtract = function subtract(out, a, b) {
                out.r = a.r - b.r;
                out.g = a.g - b.g;
                out.b = a.b - b.b;
                out.a = a.a - b.a;
                return out;
              };
              Color.multiply = function multiply(out, a, b) {
                out.r = a.r * b.r;
                out.g = a.g * b.g;
                out.b = a.b * b.b;
                out.a = a.a * b.a;
                return out;
              };
              Color.divide = function divide(out, a, b) {
                out.r = a.r / b.r;
                out.g = a.g / b.g;
                out.b = a.b / b.b;
                out.a = a.a / b.a;
                return out;
              };
              Color.scale = function scale(out, a, b) {
                out.r = a.r * b;
                out.g = a.g * b;
                out.b = a.b * b;
                out.a = a.a * b;
                return out;
              };
              Color.lerp = function lerp(out, from, to, ratio) {
                var fromR = from.r;
                var fromG = from.g;
                var fromB = from.b;
                var fromA = from.a;
                out.r = fromR + (to.r - fromR) * ratio;
                out.g = fromG + (to.g - fromG) * ratio;
                out.b = fromB + (to.b - fromB) * ratio;
                out.a = fromA + (to.a - fromA) * ratio;
                return out;
              };
              Color.toArray = function toArray(out, a, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                var scale = a instanceof Color || a.a > 1 ? 1 / 255 : 1;
                out[ofs + 0] = a.r * scale;
                out[ofs + 1] = a.g * scale;
                out[ofs + 2] = a.b * scale;
                out[ofs + 3] = a.a * scale;
                return out;
              };
              Color.fromArray = function fromArray(arr, out, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out.r = arr[ofs + 0] * 255;
                out.g = arr[ofs + 1] * 255;
                out.b = arr[ofs + 2] * 255;
                out.a = arr[ofs + 3] * 255;
                return out;
              };
              Color.fromUint32 = function fromUint32(out, uint32) {
                uint32 >>>= 0;
                out.r = uint32 & 0xff;
                out.g = uint32 >> 8 & 0xff;
                out.b = uint32 >> 16 & 0xff;
                out.a = uint32 >> 24 & 0xff;
                return out;
              };
              Color.toUint32 = function toUint32(color) {
                return (color.a << 24 | color.b << 16 | color.g << 8 | color.r) >>> 0;
              };
              Color.strictEquals = function strictEquals(a, b) {
                return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
              };
              Color.equals = function equals(a, b, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                var hasInf = mathAbs$3(a.r) === Infinity || mathAbs$3(a.g) === Infinity || mathAbs$3(a.b) === Infinity || mathAbs$3(a.a) === Infinity;
                return !hasInf && mathAbs$3(a.r - b.r) <= epsilon * mathMax$1(1.0, mathAbs$3(a.r), mathAbs$3(b.r)) && mathAbs$3(a.g - b.g) <= epsilon * mathMax$1(1.0, mathAbs$3(a.g), mathAbs$3(b.g)) && mathAbs$3(a.b - b.b) <= epsilon * mathMax$1(1.0, mathAbs$3(a.b), mathAbs$3(b.b)) && mathAbs$3(a.a - b.a) <= epsilon * mathMax$1(1.0, mathAbs$3(a.a), mathAbs$3(b.a));
              };
              Color.hex = function hex(a) {
                return (a.r * 255 << 24 | a.g * 255 << 16 | a.b * 255 << 8 | a.a * 255) >>> 0;
              };
              function Color(r, g, b, a) {
                var _this;
                _this = _ValueType.call(this) || this;
                _this._data = new Uint8ClampedArray(4);
                if (typeof r === 'string') {
                  _this.fromHEX(r);
                } else if (g !== undefined) {
                  _this.set(r, g, b, a);
                } else {
                  _this.set(r);
                }
                return _this;
              }
              var _proto = Color.prototype;
              _proto.clone = function clone() {
                var ret = new Color();
                ret._data.set(this._data);
                return ret;
              };
              _proto.equals = function equals(other) {
                var otherColor = other;
                var thisData = this._data;
                return other && thisData[R_INDEX] === otherColor.r && thisData[G_INDEX] === otherColor.g && thisData[B_INDEX] === otherColor.b && thisData[A_INDEX] === otherColor.a;
              };
              _proto.lerp = function lerp(to, ratio) {
                Color.lerp(this, this, to, ratio);
                return this;
              };
              _proto.toString = function toString() {
                return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
              };
              _proto.toCSS = function toCSS(opt) {
                if (opt === undefined) {
                  opt = 'rgba';
                }
                if (opt === 'rgba') {
                  return "rgba(" + this.r + "," + this.g + "," + this.b + "," + (this.a * toFloat).toFixed(2) + ")";
                } else if (opt === 'rgb') {
                  return "rgb(" + this.r + "," + this.g + "," + this.b + ")";
                } else {
                  return "#" + this.toHEX(opt);
                }
              };
              _proto.fromHEX = function fromHEX(hex) {
                var hexNumber;
                if (typeof hex === 'string') {
                  hex = hex[0] === '#' ? hex.substring(1) : hex;
                  if (hex.length === 6) {
                    hex += 'FF';
                  } else if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + "FF";
                  } else if (hex.length === 4) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                  }
                  hexNumber = Number("0x" + hex);
                } else {
                  if (hex < 0x1000000) {
                    hex = (hex << 8) + 0xff;
                  }
                  hexNumber = hex;
                }
                this.r = hexNumber >>> 24;
                this.g = (hexNumber & 0x00ff0000) >>> 16;
                this.b = (hexNumber & 0x0000ff00) >>> 8;
                this.a = hexNumber & 0x000000ff;
                return this;
              };
              _proto.toHEX = function toHEX(fmt) {
                if (fmt === undefined) {
                  fmt = '#rrggbb';
                }
                var thisData = this._data;
                var prefix = '0';
                var hex = [(thisData[R_INDEX] < 16 ? prefix : '') + thisData[R_INDEX].toString(16), (thisData[G_INDEX] < 16 ? prefix : '') + thisData[G_INDEX].toString(16), (thisData[B_INDEX] < 16 ? prefix : '') + thisData[B_INDEX].toString(16)];
                if (fmt === '#rgb') {
                  hex[0] = hex[0][0];
                  hex[1] = hex[1][0];
                  hex[2] = hex[2][0];
                } else if (fmt === '#rrggbbaa') {
                  hex.push((thisData[A_INDEX] < 16 ? prefix : '') + thisData[A_INDEX].toString(16));
                }
                return hex.join('');
              };
              _proto.toRGBValue = function toRGBValue() {
                return this._data[B_INDEX] << 16 | this._data[G_INDEX] << 8 | this._data[R_INDEX];
              };
              _proto.fromHSV = function fromHSV(h, s, v) {
                var r = 0;
                var g = 0;
                var b = 0;
                if (s === 0) {
                  r = g = b = v;
                } else if (v === 0) {
                  r = g = b = 0;
                } else {
                  if (h === 1) {
                    h = 0;
                  }
                  h *= 6;
                  var i = Math.floor(h);
                  var f = h - i;
                  var p = v * (1 - s);
                  var q = v * (1 - s * f);
                  var t = v * (1 - s * (1 - f));
                  switch (i) {
                    default:
                      assertIsTrue(false);
                    case 0:
                      r = v;
                      g = t;
                      b = p;
                      break;
                    case 1:
                      r = q;
                      g = v;
                      b = p;
                      break;
                    case 2:
                      r = p;
                      g = v;
                      b = t;
                      break;
                    case 3:
                      r = p;
                      g = q;
                      b = v;
                      break;
                    case 4:
                      r = t;
                      g = p;
                      b = v;
                      break;
                    case 5:
                      r = v;
                      g = p;
                      b = q;
                      break;
                  }
                }
                var thisData = this._data;
                thisData[R_INDEX] = r * 255;
                thisData[G_INDEX] = g * 255;
                thisData[B_INDEX] = b * 255;
                return this;
              };
              _proto.toHSV = function toHSV() {
                var r = this._data[R_INDEX] * toFloat;
                var g = this._data[G_INDEX] * toFloat;
                var b = this._data[B_INDEX] * toFloat;
                var hsv = {
                  h: 0,
                  s: 0,
                  v: 0
                };
                var max = Math.max(r, g, b);
                var min = Math.min(r, g, b);
                var delta = 0;
                hsv.v = max;
                hsv.s = max ? (max - min) / max : 0;
                if (!hsv.s) {
                  hsv.h = 0;
                } else {
                  delta = max - min;
                  if (r === max) {
                    hsv.h = (g - b) / delta;
                  } else if (g === max) {
                    hsv.h = 2 + (b - r) / delta;
                  } else {
                    hsv.h = 4 + (r - g) / delta;
                  }
                  hsv.h /= 6;
                  if (hsv.h < 0) {
                    hsv.h += 1.0;
                  }
                }
                return hsv;
              };
              _proto.set = function set(r, g, b, a) {
                var thisData = this._data;
                if (typeof r === 'object') {
                  var _other = r;
                  if (_other._data) {
                    thisData.set(_other._data);
                  } else {
                    var _other$r, _other$g, _other$b, _other$a;
                    thisData[R_INDEX] = (_other$r = _other.r) !== null && _other$r !== undefined ? _other$r : 0;
                    thisData[G_INDEX] = (_other$g = _other.g) !== null && _other$g !== undefined ? _other$g : 0;
                    thisData[B_INDEX] = (_other$b = _other.b) !== null && _other$b !== undefined ? _other$b : 0;
                    thisData[A_INDEX] = (_other$a = _other.a) !== null && _other$a !== undefined ? _other$a : 255;
                  }
                } else {
                  thisData[R_INDEX] = r !== null && r !== undefined ? r : 0;
                  thisData[G_INDEX] = g !== null && g !== undefined ? g : 0;
                  thisData[B_INDEX] = b !== null && b !== undefined ? b : 0;
                  thisData[A_INDEX] = a !== null && a !== undefined ? a : 255;
                }
                return this;
              };
              _proto.multiply = function multiply(other) {
                var thisData = this._data;
                thisData[R_INDEX] *= other.r / 255;
                thisData[G_INDEX] *= other.g / 255;
                thisData[B_INDEX] *= other.b / 255;
                thisData[A_INDEX] *= other.a / 255;
                return this;
              };
              _proto.getModifiableProperties = function getModifiableProperties() {
                return ['r', 'g', 'b', 'a'];
              };
              _createClass(Color, [{
                key: "r",
                get: function get() {
                  return this._data[R_INDEX];
                },
                set: function set(red) {
                  this._data[R_INDEX] = red;
                }
              }, {
                key: "g",
                get: function get() {
                  return this._data[G_INDEX];
                },
                set: function set(green) {
                  this._data[G_INDEX] = green;
                }
              }, {
                key: "b",
                get: function get() {
                  return this._data[B_INDEX];
                },
                set: function set(blue) {
                  this._data[B_INDEX] = blue;
                }
              }, {
                key: "a",
                get: function get() {
                  return this._data[A_INDEX];
                },
                set: function set(alpha) {
                  this._data[A_INDEX] = alpha;
                }
              }, {
                key: "x",
                get: function get() {
                  return this._data[R_INDEX] * toFloat;
                },
                set: function set(value) {
                  this._data[R_INDEX] = value * 255;
                }
              }, {
                key: "y",
                get: function get() {
                  return this._data[G_INDEX] * toFloat;
                },
                set: function set(value) {
                  this._data[G_INDEX] = value * 255;
                }
              }, {
                key: "z",
                get: function get() {
                  return this._data[B_INDEX] * toFloat;
                },
                set: function set(value) {
                  this._data[B_INDEX] = value * 255;
                }
              }, {
                key: "w",
                get: function get() {
                  return this._data[A_INDEX] * toFloat;
                },
                set: function set(value) {
                  this._data[A_INDEX] = value * 255;
                }
              }]);
              return Color;
            }(ValueType));
            Color.WHITE = freezeColor(255, 255, 255, 255);
            Color.GRAY = freezeColor(127, 127, 127, 255);
            Color.BLACK = freezeColor(0, 0, 0, 255);
            Color.TRANSPARENT = freezeColor(0, 0, 0, 0);
            Color.RED = freezeColor(255, 0, 0, 255);
            Color.GREEN = freezeColor(0, 255, 0, 255);
            Color.BLUE = freezeColor(0, 0, 255, 255);
            Color.CYAN = freezeColor(0, 255, 255, 255);
            Color.MAGENTA = freezeColor(255, 0, 255, 255);
            Color.YELLOW = freezeColor(255, 255, 0, 255);
            CCClass.fastDefine('cc.Color', Color, {
              r: 0,
              g: 0,
              b: 0,
              a: 255
            });
            legacyCC.Color = Color;
            function color(r, g, b, a) {
              return new Color(r, g, b, a);
            }
            legacyCC.color = color;
            function clampVec3(val, min, max) {
              if (min > max) {
                var temp = min;
                min = max;
                max = temp;
              }
              return val < min ? min : val > max ? max : val;
            }
            function floorVec3(val) {
              var temp = val.clone();
              temp.x = Math.floor(val.x);
              temp.y = Math.floor(val.y);
              temp.z = Math.floor(val.z);
              return temp;
            }
            function stepVec3(a, b) {
              if (a < b) {
                return b;
              } else {
                return a;
              }
            }
            function packRGBE(rgb) {
              var maxComp = Math.max(Math.max(rgb.x, rgb.y), rgb.z);
              var e = 128.0;
              if (maxComp > 0.0001) {
                e = Math.log(maxComp) / Math.log(1.1);
                e = Math.ceil(e);
                e = clamp(e + 128.0, 0.0, 255.0);
              }
              var sc = 1.0 / Math.pow(1.1, e - 128.0);
              var encode = clampVec3(rgb.multiplyScalar(sc), new Vec3(0.0, 0.0, 0.0), new Vec3(1.0, 1.0, 1.0));
              encode.multiplyScalar(255.0);
              var encode_rounded = floorVec3(encode).add(stepVec3(encode.subtract(floorVec3(encode)), new Vec3(0.5, 0.5, 0.5)));
              return new Vec4(encode_rounded.x / 255.0, encode_rounded.y / 255.0, encode_rounded.z / 255.0, e / 255.0);
            }

            var _class$V;
            var abs$3 = Math.abs;
            var max$7 = Math.max;
            var Mat3 = exports("Mat3", function (_ValueType) {
              _inheritsLoose(Mat3, _ValueType);
              Mat3.clone = function clone(a) {
                return new Mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
              };
              Mat3.copy = function copy(out, a) {
                out.m00 = a.m00;
                out.m01 = a.m01;
                out.m02 = a.m02;
                out.m03 = a.m03;
                out.m04 = a.m04;
                out.m05 = a.m05;
                out.m06 = a.m06;
                out.m07 = a.m07;
                out.m08 = a.m08;
                return out;
              };
              Mat3.set = function set(out, m00, m01, m02, m03, m04, m05, m06, m07, m08) {
                out.m00 = m00;
                out.m01 = m01;
                out.m02 = m02;
                out.m03 = m03;
                out.m04 = m04;
                out.m05 = m05;
                out.m06 = m06;
                out.m07 = m07;
                out.m08 = m08;
                return out;
              };
              Mat3.identity = function identity(out) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 1;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 1;
                return out;
              };
              Mat3.transpose = function transpose(out, a) {
                if (out === a) {
                  var a01 = a.m01;
                  var a02 = a.m02;
                  var a12 = a.m05;
                  out.m01 = a.m03;
                  out.m02 = a.m06;
                  out.m03 = a01;
                  out.m05 = a.m07;
                  out.m06 = a02;
                  out.m07 = a12;
                } else {
                  out.m00 = a.m00;
                  out.m01 = a.m03;
                  out.m02 = a.m06;
                  out.m03 = a.m01;
                  out.m04 = a.m04;
                  out.m05 = a.m07;
                  out.m06 = a.m02;
                  out.m07 = a.m05;
                  out.m08 = a.m08;
                }
                return out;
              };
              Mat3.invert = function invert(out, a) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a10 = a.m03;
                var a11 = a.m04;
                var a12 = a.m05;
                var a20 = a.m06;
                var a21 = a.m07;
                var a22 = a.m08;
                var b01 = a22 * a11 - a12 * a21;
                var b11 = -a22 * a10 + a12 * a20;
                var b21 = a21 * a10 - a11 * a20;
                var det = a00 * b01 + a01 * b11 + a02 * b21;
                if (det === 0) {
                  Mat3.set(out, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                  return out;
                }
                det = 1.0 / det;
                out.m00 = b01 * det;
                out.m01 = (-a22 * a01 + a02 * a21) * det;
                out.m02 = (a12 * a01 - a02 * a11) * det;
                out.m03 = b11 * det;
                out.m04 = (a22 * a00 - a02 * a20) * det;
                out.m05 = (-a12 * a00 + a02 * a10) * det;
                out.m06 = b21 * det;
                out.m07 = (-a21 * a00 + a01 * a20) * det;
                out.m08 = (a11 * a00 - a01 * a10) * det;
                return out;
              };
              Mat3.determinant = function determinant(a) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a10 = a.m03;
                var a11 = a.m04;
                var a12 = a.m05;
                var a20 = a.m06;
                var a21 = a.m07;
                var a22 = a.m08;
                return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
              };
              Mat3.multiply = function multiply(out, a, b) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a10 = a.m03;
                var a11 = a.m04;
                var a12 = a.m05;
                var a20 = a.m06;
                var a21 = a.m07;
                var a22 = a.m08;
                var b00 = b.m00;
                var b01 = b.m01;
                var b02 = b.m02;
                var b10 = b.m03;
                var b11 = b.m04;
                var b12 = b.m05;
                var b20 = b.m06;
                var b21 = b.m07;
                var b22 = b.m08;
                out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
                out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
                out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
                out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
                out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
                out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
                out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
                out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
                out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
                return out;
              };
              Mat3.multiplyMat4 = function multiplyMat4(out, a, b) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a10 = a.m03;
                var a11 = a.m04;
                var a12 = a.m05;
                var a20 = a.m06;
                var a21 = a.m07;
                var a22 = a.m08;
                var b00 = b.m00;
                var b01 = b.m01;
                var b02 = b.m02;
                var b10 = b.m04;
                var b11 = b.m05;
                var b12 = b.m06;
                var b20 = b.m08;
                var b21 = b.m09;
                var b22 = b.m10;
                out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
                out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
                out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
                out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
                out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
                out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
                out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
                out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
                out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
                return out;
              };
              Mat3.transform = function transform(out, a, v) {
                this.translate(out, a, v);
              };
              Mat3.translate = function translate(out, a, v) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a10 = a.m03;
                var a11 = a.m04;
                var a12 = a.m05;
                var a20 = a.m06;
                var a21 = a.m07;
                var a22 = a.m08;
                var x = v.x;
                var y = v.y;
                out.m00 = a00;
                out.m01 = a01;
                out.m02 = a02;
                out.m03 = a10;
                out.m04 = a11;
                out.m05 = a12;
                out.m06 = x * a00 + y * a10 + a20;
                out.m07 = x * a01 + y * a11 + a21;
                out.m08 = x * a02 + y * a12 + a22;
                return out;
              };
              Mat3.scale = function scale(out, a, v) {
                var x = v.x;
                var y = v.y;
                out.m00 = x * a.m00;
                out.m01 = x * a.m01;
                out.m02 = x * a.m02;
                out.m03 = y * a.m03;
                out.m04 = y * a.m04;
                out.m05 = y * a.m05;
                out.m06 = a.m06;
                out.m07 = a.m07;
                out.m08 = a.m08;
                return out;
              };
              Mat3.rotate = function rotate(out, a, rad) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a10 = a.m03;
                var a11 = a.m04;
                var a12 = a.m05;
                var a20 = a.m06;
                var a21 = a.m07;
                var a22 = a.m08;
                var s = Math.sin(rad);
                var c = Math.cos(rad);
                out.m00 = c * a00 + s * a10;
                out.m01 = c * a01 + s * a11;
                out.m02 = c * a02 + s * a12;
                out.m03 = c * a10 - s * a00;
                out.m04 = c * a11 - s * a01;
                out.m05 = c * a12 - s * a02;
                out.m06 = a20;
                out.m07 = a21;
                out.m08 = a22;
                return out;
              };
              Mat3.fromMat4 = function fromMat4(out, a) {
                out.m00 = a.m00;
                out.m01 = a.m01;
                out.m02 = a.m02;
                out.m03 = a.m04;
                out.m04 = a.m05;
                out.m05 = a.m06;
                out.m06 = a.m08;
                out.m07 = a.m09;
                out.m08 = a.m10;
                return out;
              };
              Mat3.fromViewUp = function fromViewUp(out, view, up) {
                if (Vec3.lengthSqr(view) < EPSILON$1 * EPSILON$1) {
                  Mat3.identity(out);
                  return out;
                }
                up = up || Vec3.UNIT_Y;
                Vec3.normalize(v3_1$6, Vec3.cross(v3_1$6, up, view));
                if (Vec3.lengthSqr(v3_1$6) < EPSILON$1 * EPSILON$1) {
                  Mat3.identity(out);
                  return out;
                }
                Vec3.cross(v3_2$2, view, v3_1$6);
                Mat3.set(out, v3_1$6.x, v3_1$6.y, v3_1$6.z, v3_2$2.x, v3_2$2.y, v3_2$2.z, view.x, view.y, view.z);
                return out;
              };
              Mat3.fromTranslation = function fromTranslation(out, v) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 1;
                out.m05 = 0;
                out.m06 = v.x;
                out.m07 = v.y;
                out.m08 = 1;
                return out;
              };
              Mat3.fromScaling = function fromScaling(out, v) {
                out.m00 = v.x;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = v.y;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 1;
                return out;
              };
              Mat3.fromRotation = function fromRotation(out, rad) {
                var s = Math.sin(rad);
                var c = Math.cos(rad);
                out.m00 = c;
                out.m01 = s;
                out.m02 = 0;
                out.m03 = -s;
                out.m04 = c;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 1;
                return out;
              };
              Mat3.fromQuat = function fromQuat(out, q) {
                var x = q.x;
                var y = q.y;
                var z = q.z;
                var w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var yx = y * x2;
                var yy = y * y2;
                var zx = z * x2;
                var zy = z * y2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                out.m00 = 1 - yy - zz;
                out.m03 = yx - wz;
                out.m06 = zx + wy;
                out.m01 = yx + wz;
                out.m04 = 1 - xx - zz;
                out.m07 = zy - wx;
                out.m02 = zx - wy;
                out.m05 = zy + wx;
                out.m08 = 1 - xx - yy;
                return out;
              };
              Mat3.inverseTransposeMat4 = function inverseTransposeMat4(out, a) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a03 = a.m03;
                var a10 = a.m04;
                var a11 = a.m05;
                var a12 = a.m06;
                var a13 = a.m07;
                var a20 = a.m08;
                var a21 = a.m09;
                var a22 = a.m10;
                var a23 = a.m11;
                var a30 = a.m12;
                var a31 = a.m13;
                var a32 = a.m14;
                var a33 = a.m15;
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32;
                var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) {
                  return null;
                }
                det = 1.0 / det;
                out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                return out;
              };
              Mat3.toArray = function toArray(out, m, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out[ofs + 0] = m.m00;
                out[ofs + 1] = m.m01;
                out[ofs + 2] = m.m02;
                out[ofs + 3] = m.m03;
                out[ofs + 4] = m.m04;
                out[ofs + 5] = m.m05;
                out[ofs + 6] = m.m06;
                out[ofs + 7] = m.m07;
                out[ofs + 8] = m.m08;
                return out;
              };
              Mat3.fromArray = function fromArray(out, arr, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out.m00 = arr[ofs + 0];
                out.m01 = arr[ofs + 1];
                out.m02 = arr[ofs + 2];
                out.m03 = arr[ofs + 3];
                out.m04 = arr[ofs + 4];
                out.m05 = arr[ofs + 5];
                out.m06 = arr[ofs + 6];
                out.m07 = arr[ofs + 7];
                out.m08 = arr[ofs + 8];
                return out;
              };
              Mat3.add = function add(out, a, b) {
                out.m00 = a.m00 + b.m00;
                out.m01 = a.m01 + b.m01;
                out.m02 = a.m02 + b.m02;
                out.m03 = a.m03 + b.m03;
                out.m04 = a.m04 + b.m04;
                out.m05 = a.m05 + b.m05;
                out.m06 = a.m06 + b.m06;
                out.m07 = a.m07 + b.m07;
                out.m08 = a.m08 + b.m08;
                return out;
              };
              Mat3.subtract = function subtract(out, a, b) {
                out.m00 = a.m00 - b.m00;
                out.m01 = a.m01 - b.m01;
                out.m02 = a.m02 - b.m02;
                out.m03 = a.m03 - b.m03;
                out.m04 = a.m04 - b.m04;
                out.m05 = a.m05 - b.m05;
                out.m06 = a.m06 - b.m06;
                out.m07 = a.m07 - b.m07;
                out.m08 = a.m08 - b.m08;
                return out;
              };
              Mat3.multiplyScalar = function multiplyScalar(out, a, b) {
                out.m00 = a.m00 * b;
                out.m01 = a.m01 * b;
                out.m02 = a.m02 * b;
                out.m03 = a.m03 * b;
                out.m04 = a.m04 * b;
                out.m05 = a.m05 * b;
                out.m06 = a.m06 * b;
                out.m07 = a.m07 * b;
                out.m08 = a.m08 * b;
                return out;
              };
              Mat3.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
                out.m00 = b.m00 * scale + a.m00;
                out.m01 = b.m01 * scale + a.m01;
                out.m02 = b.m02 * scale + a.m02;
                out.m03 = b.m03 * scale + a.m03;
                out.m04 = b.m04 * scale + a.m04;
                out.m05 = b.m05 * scale + a.m05;
                out.m06 = b.m06 * scale + a.m06;
                out.m07 = b.m07 * scale + a.m07;
                out.m08 = b.m08 * scale + a.m08;
                return out;
              };
              Mat3.strictEquals = function strictEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
              };
              Mat3.equals = function equals(a, b, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return abs$3(a.m00 - b.m00) <= epsilon * max$7(1.0, abs$3(a.m00), abs$3(b.m00)) && abs$3(a.m01 - b.m01) <= epsilon * max$7(1.0, abs$3(a.m01), abs$3(b.m01)) && abs$3(a.m02 - b.m02) <= epsilon * max$7(1.0, abs$3(a.m02), abs$3(b.m02)) && abs$3(a.m03 - b.m03) <= epsilon * max$7(1.0, abs$3(a.m03), abs$3(b.m03)) && abs$3(a.m04 - b.m04) <= epsilon * max$7(1.0, abs$3(a.m04), abs$3(b.m04)) && abs$3(a.m05 - b.m05) <= epsilon * max$7(1.0, abs$3(a.m05), abs$3(b.m05)) && abs$3(a.m06 - b.m06) <= epsilon * max$7(1.0, abs$3(a.m06), abs$3(b.m06)) && abs$3(a.m07 - b.m07) <= epsilon * max$7(1.0, abs$3(a.m07), abs$3(b.m07)) && abs$3(a.m08 - b.m08) <= epsilon * max$7(1.0, abs$3(a.m08), abs$3(b.m08));
              };
              Mat3.toEuler = function toEuler(matrix, v) {
                var a00 = matrix.m00;
                var a01 = matrix.m01;
                matrix.m02;
                var a10 = matrix.m03;
                var a11 = matrix.m04;
                matrix.m05;
                var a20 = matrix.m06;
                var a21 = matrix.m07;
                var a22 = matrix.m08;
                if (a21 < 0.999) {
                  if (a21 > -0.999) {
                    v.x = Math.asin(-a21);
                    v.y = Math.atan2(a20, a22);
                    v.z = Math.atan2(a01, a11);
                    return true;
                  } else {
                    v.x = HALF_PI;
                    v.y = Math.atan2(a10, a00);
                    v.z = 0.0;
                    return false;
                  }
                } else {
                  v.x = -HALF_PI;
                  v.y = Math.atan2(-a10, a00);
                  v.z = 0.0;
                  return false;
                }
              };
              function Mat3(m00, m01, m02, m03, m04, m05, m06, m07, m08) {
                var _this;
                if (m00 === undefined) {
                  m00 = 1;
                }
                if (m01 === undefined) {
                  m01 = 0;
                }
                if (m02 === undefined) {
                  m02 = 0;
                }
                if (m03 === undefined) {
                  m03 = 0;
                }
                if (m04 === undefined) {
                  m04 = 1;
                }
                if (m05 === undefined) {
                  m05 = 0;
                }
                if (m06 === undefined) {
                  m06 = 0;
                }
                if (m07 === undefined) {
                  m07 = 0;
                }
                if (m08 === undefined) {
                  m08 = 1;
                }
                _this = _ValueType.call(this) || this;
                var self = _assertThisInitialized(_this);
                if (typeof m00 === 'object') {
                  self.m00 = m00.m00;
                  self.m01 = m00.m01;
                  self.m02 = m00.m02;
                  self.m03 = m00.m03;
                  self.m04 = m00.m04;
                  self.m05 = m00.m05;
                  self.m06 = m00.m06;
                  self.m07 = m00.m07;
                  self.m08 = m00.m08;
                } else {
                  self.m00 = m00;
                  self.m01 = m01;
                  self.m02 = m02;
                  self.m03 = m03;
                  self.m04 = m04;
                  self.m05 = m05;
                  self.m06 = m06;
                  self.m07 = m07;
                  self.m08 = m08;
                }
                return _this;
              }
              var _proto = Mat3.prototype;
              _proto.clone = function clone() {
                return new Mat3(this);
              };
              _proto.set = function set(m00, m01, m02, m03, m04, m05, m06, m07, m08) {
                if (m00 === undefined) {
                  m00 = 1;
                }
                if (m01 === undefined) {
                  m01 = 0;
                }
                if (m02 === undefined) {
                  m02 = 0;
                }
                if (m03 === undefined) {
                  m03 = 0;
                }
                if (m04 === undefined) {
                  m04 = 1;
                }
                if (m05 === undefined) {
                  m05 = 0;
                }
                if (m06 === undefined) {
                  m06 = 0;
                }
                if (m07 === undefined) {
                  m07 = 0;
                }
                if (m08 === undefined) {
                  m08 = 1;
                }
                var self = this;
                if (typeof m00 === 'object') {
                  self.m00 = m00.m00;
                  self.m01 = m00.m01;
                  self.m02 = m00.m02;
                  self.m03 = m00.m03;
                  self.m04 = m00.m04;
                  self.m05 = m00.m05;
                  self.m06 = m00.m06;
                  self.m07 = m00.m07;
                  self.m08 = m00.m08;
                } else {
                  self.m00 = m00;
                  self.m01 = m01;
                  self.m02 = m02;
                  self.m03 = m03;
                  self.m04 = m04;
                  self.m05 = m05;
                  self.m06 = m06;
                  self.m07 = m07;
                  self.m08 = m08;
                }
                return self;
              };
              _proto.equals = function equals(other, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return Mat3.equals(this, other, epsilon);
              };
              _proto.strictEquals = function strictEquals(other) {
                return Mat3.strictEquals(this, other);
              };
              _proto.toString = function toString() {
                var t = this;
                return "[\n" + t.m00 + ", " + t.m01 + ", " + t.m02 + ",\n" + t.m03 + ", " + t.m04 + ", " + t.m05 + ",\n" + t.m06 + ", " + t.m07 + ", " + t.m08 + "\n" + "]";
              };
              _proto.identity = function identity() {
                return Mat3.identity(this);
              };
              _proto.transpose = function transpose() {
                var self = this;
                var a01 = self.m01;
                var a02 = self.m02;
                var a12 = self.m05;
                self.m01 = self.m03;
                self.m02 = self.m06;
                self.m03 = a01;
                self.m05 = self.m07;
                self.m06 = a02;
                self.m07 = a12;
                return self;
              };
              _proto.invert = function invert() {
                return Mat3.invert(this, this);
              };
              _proto.determinant = function determinant() {
                return Mat3.determinant(this);
              };
              _proto.add = function add(mat) {
                var self = this;
                self.m00 += mat.m00;
                self.m01 += mat.m01;
                self.m02 += mat.m02;
                self.m03 += mat.m03;
                self.m04 += mat.m04;
                self.m05 += mat.m05;
                self.m06 += mat.m06;
                self.m07 += mat.m07;
                self.m08 += mat.m08;
                return self;
              };
              _proto.subtract = function subtract(mat) {
                var self = this;
                self.m00 -= mat.m00;
                self.m01 -= mat.m01;
                self.m02 -= mat.m02;
                self.m03 -= mat.m03;
                self.m04 -= mat.m04;
                self.m05 -= mat.m05;
                self.m06 -= mat.m06;
                self.m07 -= mat.m07;
                self.m08 -= mat.m08;
                return self;
              };
              _proto.multiply = function multiply(mat) {
                return Mat3.multiply(this, this, mat);
              };
              _proto.multiplyScalar = function multiplyScalar(scalar) {
                var self = this;
                self.m00 *= scalar;
                self.m01 *= scalar;
                self.m02 *= scalar;
                self.m03 *= scalar;
                self.m04 *= scalar;
                self.m05 *= scalar;
                self.m06 *= scalar;
                self.m07 *= scalar;
                self.m08 *= scalar;
                return self;
              };
              _proto.scale = function scale(vec) {
                var x = vec.x;
                var y = vec.y;
                var self = this;
                self.m00 *= x;
                self.m01 *= x;
                self.m02 *= x;
                self.m03 *= y;
                self.m04 *= y;
                self.m05 *= y;
                return self;
              };
              _proto.rotate = function rotate(rad) {
                var self = this;
                var a00 = self.m00;
                var a01 = self.m01;
                var a02 = self.m02;
                var a10 = self.m03;
                var a11 = self.m04;
                var a12 = self.m05;
                var a20 = self.m06;
                var a21 = self.m07;
                var a22 = self.m08;
                var s = Math.sin(rad);
                var c = Math.cos(rad);
                self.m00 = c * a00 + s * a10;
                self.m01 = c * a01 + s * a11;
                self.m02 = c * a02 + s * a12;
                self.m03 = c * a10 - s * a00;
                self.m04 = c * a11 - s * a01;
                self.m05 = c * a12 - s * a02;
                self.m06 = a20;
                self.m07 = a21;
                self.m08 = a22;
                return self;
              };
              _proto.fromQuat = function fromQuat(q) {
                var x = q.x;
                var y = q.y;
                var z = q.z;
                var w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var yx = y * x2;
                var yy = y * y2;
                var zx = z * x2;
                var zy = z * y2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                var self = this;
                self.m00 = 1 - yy - zz;
                self.m03 = yx - wz;
                self.m06 = zx + wy;
                self.m01 = yx + wz;
                self.m04 = 1 - xx - zz;
                self.m07 = zy - wx;
                self.m02 = zx - wy;
                self.m05 = zy + wx;
                self.m08 = 1 - xx - yy;
                return self;
              };
              return Mat3;
            }(ValueType));
            _class$V = Mat3;
            Mat3.IDENTITY = Object.freeze(new _class$V());
            var v3_1$6 = new Vec3();
            var v3_2$2 = new Vec3();
            CCClass.fastDefine('cc.Mat3', Mat3, {
              m00: 1,
              m01: 0,
              m02: 0,
              m03: 0,
              m04: 1,
              m05: 0,
              m06: 0,
              m07: 0,
              m08: 1
            });
            legacyCC.Mat3 = Mat3;

            var _class$U;
            var abs$2 = Math.abs;
            var max$6 = Math.max;
            var min$4 = Math.min;
            var PI$1 = Math.PI;
            var acos$2 = Math.acos;
            var sin$2 = Math.sin;
            var cos$3 = Math.cos;
            var sqrt$3 = Math.sqrt;
            var atan2$1 = Math.atan2;
            var asin = Math.asin;
            var sign = Math.sign;
            var Quat = exports("Quat", function (_ValueType) {
              _inheritsLoose(Quat, _ValueType);
              Quat.clone = function clone(a) {
                return new Quat(a.x, a.y, a.z, a.w);
              };
              Quat.copy = function copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                out.w = a.w;
                return out;
              };
              Quat.set = function set(out, x, y, z, w) {
                out.x = x;
                out.y = y;
                out.z = z;
                out.w = w;
                return out;
              };
              Quat.identity = function identity(out) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return out;
              };
              Quat.rotationTo = function rotationTo(out, a, b) {
                var dot = Vec3.dot(a, b);
                if (dot < -0.999999) {
                  Vec3.cross(v3_1$5, Vec3.UNIT_X, a);
                  if (v3_1$5.length() < 0.000001) {
                    Vec3.cross(v3_1$5, Vec3.UNIT_Y, a);
                  }
                  Vec3.normalize(v3_1$5, v3_1$5);
                  Quat.fromAxisAngle(out, v3_1$5, PI$1);
                  return out;
                } else if (dot > 0.999999) {
                  out.x = 0;
                  out.y = 0;
                  out.z = 0;
                  out.w = 1;
                  return out;
                } else {
                  Vec3.cross(v3_1$5, a, b);
                  out.x = v3_1$5.x;
                  out.y = v3_1$5.y;
                  out.z = v3_1$5.z;
                  out.w = 1 + dot;
                  return Quat.normalize(out, out);
                }
              };
              Quat.getAxisAngle = function getAxisAngle(outAxis, q) {
                var rad = acos$2(q.w) * 2.0;
                var s = sin$2(rad / 2.0);
                if (s !== 0.0) {
                  outAxis.x = q.x / s;
                  outAxis.y = q.y / s;
                  outAxis.z = q.z / s;
                } else {
                  outAxis.x = 1;
                  outAxis.y = 0;
                  outAxis.z = 0;
                }
                return rad;
              };
              Quat.multiply = function multiply(out, a, b) {
                var x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
                var y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
                var z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
                var w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
                out.x = x;
                out.y = y;
                out.z = z;
                out.w = w;
                return out;
              };
              Quat.multiplyScalar = function multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                out.z = a.z * b;
                out.w = a.w * b;
                return out;
              };
              Quat.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                out.z = a.z + b.z * scale;
                out.w = a.w + b.w * scale;
                return out;
              };
              Quat.rotateX = function rotateX(out, a, rad) {
                rad *= 0.5;
                var bx = sin$2(rad);
                var bw = cos$3(rad);
                var x = a.x,
                  y = a.y,
                  z = a.z,
                  w = a.w;
                out.x = x * bw + w * bx;
                out.y = y * bw + z * bx;
                out.z = z * bw - y * bx;
                out.w = w * bw - x * bx;
                return out;
              };
              Quat.rotateY = function rotateY(out, a, rad) {
                rad *= 0.5;
                var by = sin$2(rad);
                var bw = cos$3(rad);
                var x = a.x,
                  y = a.y,
                  z = a.z,
                  w = a.w;
                out.x = x * bw - z * by;
                out.y = y * bw + w * by;
                out.z = z * bw + x * by;
                out.w = w * bw - y * by;
                return out;
              };
              Quat.rotateZ = function rotateZ(out, a, rad) {
                rad *= 0.5;
                var bz = sin$2(rad);
                var bw = cos$3(rad);
                var x = a.x,
                  y = a.y,
                  z = a.z,
                  w = a.w;
                out.x = x * bw + y * bz;
                out.y = y * bw - x * bz;
                out.z = z * bw + w * bz;
                out.w = w * bw - z * bz;
                return out;
              };
              Quat.rotateAround = function rotateAround(out, rot, axis, rad) {
                Quat.invert(qt_1$1, rot);
                Vec3.transformQuat(v3_1$5, axis, qt_1$1);
                Quat.fromAxisAngle(qt_1$1, v3_1$5, rad);
                Quat.multiply(out, rot, qt_1$1);
                return out;
              };
              Quat.rotateAroundLocal = function rotateAroundLocal(out, rot, axis, rad) {
                Quat.fromAxisAngle(qt_1$1, axis, rad);
                Quat.multiply(out, rot, qt_1$1);
                return out;
              };
              Quat.calculateW = function calculateW(out, a) {
                out.x = a.x;
                out.y = a.y;
                out.z = a.z;
                out.w = sqrt$3(abs$2(1.0 - a.x * a.x - a.y * a.y - a.z * a.z));
                return out;
              };
              Quat.dot = function dot(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
              };
              Quat.lerp = function lerp(out, a, b, t) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                out.w = a.w + t * (b.w - a.w);
                return out;
              };
              Quat.slerp = function slerp(out, a, b, t) {
                var scale0 = 0;
                var scale1 = 0;
                var bx = b.x;
                var by = b.y;
                var bz = b.z;
                var bw = b.w;
                var cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
                if (cosom < 0.0) {
                  cosom = -cosom;
                  bx = -bx;
                  by = -by;
                  bz = -bz;
                  bw = -bw;
                }
                if (1.0 - cosom > 0.000001) {
                  var omega = acos$2(cosom);
                  var sinom = sin$2(omega);
                  scale0 = sin$2((1.0 - t) * omega) / sinom;
                  scale1 = sin$2(t * omega) / sinom;
                } else {
                  scale0 = 1.0 - t;
                  scale1 = t;
                }
                out.x = scale0 * a.x + scale1 * bx;
                out.y = scale0 * a.y + scale1 * by;
                out.z = scale0 * a.z + scale1 * bz;
                out.w = scale0 * a.w + scale1 * bw;
                return out;
              };
              Quat.sqlerp = function sqlerp(out, a, b, c, d, t) {
                Quat.slerp(qt_1$1, a, d, t);
                Quat.slerp(qt_2, b, c, t);
                Quat.slerp(out, qt_1$1, qt_2, 2 * t * (1 - t));
                return out;
              };
              Quat.invert = function invert(out, a) {
                var dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
                var invDot = dot ? 1.0 / dot : 0;
                out.x = -a.x * invDot;
                out.y = -a.y * invDot;
                out.z = -a.z * invDot;
                out.w = a.w * invDot;
                return out;
              };
              Quat.conjugate = function conjugate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                out.z = -a.z;
                out.w = a.w;
                return out;
              };
              Quat.len = function len(a) {
                return sqrt$3(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
              };
              Quat.lengthSqr = function lengthSqr(a) {
                return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
              };
              Quat.normalize = function normalize(out, a) {
                var len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
                if (len > 0) {
                  len = 1 / sqrt$3(len);
                  out.x = a.x * len;
                  out.y = a.y * len;
                  out.z = a.z * len;
                  out.w = a.w * len;
                } else {
                  out.x = 0;
                  out.y = 0;
                  out.z = 0;
                  out.w = 0;
                }
                return out;
              };
              Quat.fromAxes = function fromAxes(out, xAxis, yAxis, zAxis) {
                Mat3.set(m3_1$2, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
                return Quat.normalize(out, Quat.fromMat3(out, m3_1$2));
              };
              Quat.fromViewUp = function fromViewUp(out, view, up) {
                Mat3.fromViewUp(m3_1$2, view, up);
                return Quat.normalize(out, Quat.fromMat3(out, m3_1$2));
              };
              Quat.fromAxisAngle = function fromAxisAngle(out, axis, rad) {
                rad *= 0.5;
                var s = sin$2(rad);
                out.x = s * axis.x;
                out.y = s * axis.y;
                out.z = s * axis.z;
                out.w = cos$3(rad);
                return out;
              };
              Quat.fromMat3 = function fromMat3(out, m) {
                var m00 = m.m00,
                  m01 = m.m01,
                  m02 = m.m02,
                  m10 = m.m03,
                  m11 = m.m04,
                  m12 = m.m05,
                  m20 = m.m06,
                  m21 = m.m07,
                  m22 = m.m08;
                var fourXSquaredMinus1 = m00 - m11 - m22;
                var fourYSquaredMinus1 = m11 - m00 - m22;
                var fourZSquaredMinus1 = m22 - m00 - m11;
                var fourWSquaredMinus1 = m00 + m11 + m22;
                var biggestIndex = 0;
                var fourBiggestSquaredMinus1 = fourWSquaredMinus1;
                if (fourXSquaredMinus1 > fourBiggestSquaredMinus1) {
                  fourBiggestSquaredMinus1 = fourXSquaredMinus1;
                  biggestIndex = 1;
                }
                if (fourYSquaredMinus1 > fourBiggestSquaredMinus1) {
                  fourBiggestSquaredMinus1 = fourYSquaredMinus1;
                  biggestIndex = 2;
                }
                if (fourZSquaredMinus1 > fourBiggestSquaredMinus1) {
                  fourBiggestSquaredMinus1 = fourZSquaredMinus1;
                  biggestIndex = 3;
                }
                var biggestVal = sqrt$3(fourBiggestSquaredMinus1 + 1) * 0.5;
                var mult = 0.25 / biggestVal;
                switch (biggestIndex) {
                  case 0:
                    out.w = biggestVal;
                    out.x = (m12 - m21) * mult;
                    out.y = (m20 - m02) * mult;
                    out.z = (m01 - m10) * mult;
                    break;
                  case 1:
                    out.w = (m12 - m21) * mult;
                    out.x = biggestVal;
                    out.y = (m01 + m10) * mult;
                    out.z = (m20 + m02) * mult;
                    break;
                  case 2:
                    out.w = (m20 - m02) * mult;
                    out.x = (m01 + m10) * mult;
                    out.y = biggestVal;
                    out.z = (m12 + m21) * mult;
                    break;
                  case 3:
                    out.w = (m01 - m10) * mult;
                    out.x = (m20 + m02) * mult;
                    out.y = (m12 + m21) * mult;
                    out.z = biggestVal;
                    break;
                  default:
                    out.w = 1;
                    out.x = 0;
                    out.y = 0;
                    out.z = 0;
                    break;
                }
                return out;
              };
              Quat.fromEuler = function fromEuler(out, x, y, z) {
                x *= halfToRad;
                y *= halfToRad;
                z *= halfToRad;
                var sx = sin$2(x);
                var cx = cos$3(x);
                var sy = sin$2(y);
                var cy = cos$3(y);
                var sz = sin$2(z);
                var cz = cos$3(z);
                out.x = sx * cy * cz + cx * sy * sz;
                out.y = cx * sy * cz + sx * cy * sz;
                out.z = cx * cy * sz - sx * sy * cz;
                out.w = cx * cy * cz - sx * sy * sz;
                return out;
              };
              Quat.fromAngleZ = function fromAngleZ(out, z) {
                z *= halfToRad;
                out.x = out.y = 0;
                out.z = sin$2(z);
                out.w = cos$3(z);
                return out;
              };
              Quat.toAxisX = function toAxisX(out, q) {
                var fy = 2.0 * q.y;
                var fz = 2.0 * q.z;
                out.x = 1.0 - fy * q.y - fz * q.z;
                out.y = fy * q.x + fz * q.w;
                out.z = fz * q.x - fy * q.w;
                return out;
              };
              Quat.toAxisY = function toAxisY(out, q) {
                var fx = 2.0 * q.x;
                var fy = 2.0 * q.y;
                var fz = 2.0 * q.z;
                out.x = fy * q.x - fz * q.w;
                out.y = 1.0 - fx * q.x - fz * q.z;
                out.z = fz * q.y + fx * q.w;
                return out;
              };
              Quat.toAxisZ = function toAxisZ(out, q) {
                var fx = 2.0 * q.x;
                var fy = 2.0 * q.y;
                var fz = 2.0 * q.z;
                out.x = fz * q.x + fy * q.w;
                out.y = fz * q.y - fx * q.w;
                out.z = 1.0 - fx * q.x - fy * q.y;
                return out;
              };
              Quat.toEuler = function toEuler(out, q, outerZ) {
                var x = q.x,
                  y = q.y,
                  z = q.z,
                  w = q.w;
                var bank = 0;
                var heading = 0;
                var attitude = 0;
                var test = x * y + z * w;
                if (test > 0.499999) {
                  bank = 0;
                  heading = toDegree(2 * atan2$1(x, w));
                  attitude = 90;
                } else if (test < -0.499999) {
                  bank = 0;
                  heading = -toDegree(2 * atan2$1(x, w));
                  attitude = -90;
                } else {
                  var sqx = x * x;
                  var sqy = y * y;
                  var sqz = z * z;
                  bank = toDegree(atan2$1(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz));
                  heading = toDegree(atan2$1(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz));
                  attitude = toDegree(asin(2 * test));
                  if (outerZ) {
                    bank = -180 * sign(bank + 1e-6) + bank;
                    heading = -180 * sign(heading + 1e-6) + heading;
                    attitude = 180 * sign(attitude + 1e-6) - attitude;
                  }
                }
                out.x = bank;
                out.y = heading;
                out.z = attitude;
                return out;
              };
              Quat.toEulerInYXZOrder = function toEulerInYXZOrder(out, q) {
                Mat3.fromQuat(m3_1$2, q);
                Mat3.toEuler(m3_1$2, out);
                out.x = toDegree(out.x);
                out.y = toDegree(out.y);
                out.z = toDegree(out.z);
              };
              Quat.toArray = function toArray(out, q, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out[ofs + 0] = q.x;
                out[ofs + 1] = q.y;
                out[ofs + 2] = q.z;
                out[ofs + 3] = q.w;
                return out;
              };
              Quat.fromArray = function fromArray(out, arr, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                out.z = arr[ofs + 2];
                out.w = arr[ofs + 3];
                return out;
              };
              Quat.strictEquals = function strictEquals(a, b) {
                return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
              };
              Quat.equals = function equals(a, b, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return abs$2(a.x - b.x) <= epsilon * max$6(1.0, abs$2(a.x), abs$2(b.x)) && abs$2(a.y - b.y) <= epsilon * max$6(1.0, abs$2(a.y), abs$2(b.y)) && abs$2(a.z - b.z) <= epsilon * max$6(1.0, abs$2(a.z), abs$2(b.z)) && abs$2(a.w - b.w) <= epsilon * max$6(1.0, abs$2(a.w), abs$2(b.w));
              };
              Quat.angle = function angle(a, b) {
                var dot = min$4(abs$2(Quat.dot(a, b)), 1.0);
                return acos$2(dot) * 2.0;
              };
              Quat.rotateTowards = function rotateTowards(out, from, to, maxStep) {
                var angle = Quat.angle(from, to);
                if (angle === 0) {
                  out.x = to.x;
                  out.y = to.y;
                  out.z = to.z;
                  out.w = to.w;
                  return out;
                }
                var t = min$4(maxStep / toDegree(angle), 1.0);
                return Quat.slerp(out, from, to, t);
              };
              function Quat(x, y, z, w) {
                var _this;
                _this = _ValueType.call(this) || this;
                if (typeof x === 'object') {
                  _this.x = x.x;
                  _this.y = x.y;
                  _this.z = x.z;
                  _this.w = x.w;
                } else {
                  _this.x = x || 0;
                  _this.y = y || 0;
                  _this.z = z || 0;
                  _this.w = w !== null && w !== undefined ? w : 1;
                }
                return _this;
              }
              var _proto = Quat.prototype;
              _proto.clone = function clone() {
                return new Quat(this.x, this.y, this.z, this.w);
              };
              _proto.set = function set(x, y, z, w) {
                if (typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                  this.z = x.z;
                  this.w = x.w;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                  this.z = z || 0;
                  this.w = w !== null && w !== undefined ? w : 1;
                }
                return this;
              };
              _proto.equals = function equals(other, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return Quat.equals(this, other, epsilon);
              };
              _proto.strictEquals = function strictEquals(other) {
                return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
              };
              _proto.getEulerAngles = function getEulerAngles(out) {
                return Quat.toEuler(out, this);
              };
              _proto.lerp = function lerp(to, ratio) {
                var self = this;
                self.x += ratio * (to.x - self.x);
                self.y += ratio * (to.y - self.y);
                self.z += ratio * (to.z - self.z);
                self.w += ratio * (to.w - self.w);
                return self;
              };
              _proto.slerp = function slerp(to, ratio) {
                return Quat.slerp(this, this, to, ratio);
              };
              _proto.length = function length() {
                var self = this;
                var x = self.x,
                  y = self.y,
                  z = self.z,
                  w = self.w;
                return sqrt$3(x * x + y * y + z * z + w * w);
              };
              _proto.lengthSqr = function lengthSqr() {
                var self = this;
                var x = self.x,
                  y = self.y,
                  z = self.z,
                  w = self.w;
                return x * x + y * y + z * z + w * w;
              };
              _proto.toString = function toString() {
                return "(" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + ")";
              };
              return Quat;
            }(ValueType));
            _class$U = Quat;
            Quat.IDENTITY = Object.freeze(new _class$U());
            var qt_1$1 = new Quat();
            var qt_2 = new Quat();
            var v3_1$5 = new Vec3();
            var m3_1$2 = new Mat3();
            var halfToRad = 0.5 * PI$1 / 180.0;
            CCClass.fastDefine('cc.Quat', Quat, {
              x: 0,
              y: 0,
              z: 0,
              w: 1
            });
            legacyCC.Quat = Quat;
            function quat(x, y, z, w) {
              if (x === undefined) {
                x = 0;
              }
              if (y === undefined) {
                y = 0;
              }
              if (z === undefined) {
                z = 0;
              }
              if (w === undefined) {
                w = 1;
              }
              return new Quat(x, y, z, w);
            }
            legacyCC.quat = quat;

            var _class$T;
            var objectFreeze = Object.freeze;
            var preTransforms = exports("preTransforms", objectFreeze([objectFreeze([1, 0, 0, 1]), objectFreeze([0, 1, -1, 0]), objectFreeze([-1, 0, 0, -1]), objectFreeze([0, -1, 1, 0])]));
            var abs$1 = Math.abs;
            var max$5 = Math.max;
            var sqrt$2 = Math.sqrt;
            var sin$1 = Math.sin;
            var cos$2 = Math.cos;
            var tan = Math.tan;
            var Mat4 = exports("Mat4", function (_ValueType) {
              _inheritsLoose(Mat4, _ValueType);
              Mat4.clone = function clone(a) {
                return new Mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
              };
              Mat4.copy = function copy(out, a) {
                out.m00 = a.m00;
                out.m01 = a.m01;
                out.m02 = a.m02;
                out.m03 = a.m03;
                out.m04 = a.m04;
                out.m05 = a.m05;
                out.m06 = a.m06;
                out.m07 = a.m07;
                out.m08 = a.m08;
                out.m09 = a.m09;
                out.m10 = a.m10;
                out.m11 = a.m11;
                out.m12 = a.m12;
                out.m13 = a.m13;
                out.m14 = a.m14;
                out.m15 = a.m15;
                return out;
              };
              Mat4.set = function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
                out.m00 = m00;
                out.m01 = m01;
                out.m02 = m02;
                out.m03 = m03;
                out.m04 = m10;
                out.m05 = m11;
                out.m06 = m12;
                out.m07 = m13;
                out.m08 = m20;
                out.m09 = m21;
                out.m10 = m22;
                out.m11 = m23;
                out.m12 = m30;
                out.m13 = m31;
                out.m14 = m32;
                out.m15 = m33;
                return out;
              };
              Mat4.identity = function identity(out) {
                out.m00 = 1;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = 1;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = 1;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              };
              Mat4.zero = function zero(out) {
                out.m00 = 0;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = 0;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = 0;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 0;
                return out;
              };
              Mat4.transpose = function transpose(out, a) {
                if (out === a) {
                  var a01 = a.m01;
                  var a02 = a.m02;
                  var a03 = a.m03;
                  var a12 = a.m06;
                  var a13 = a.m07;
                  var a23 = a.m11;
                  out.m01 = a.m04;
                  out.m02 = a.m08;
                  out.m03 = a.m12;
                  out.m04 = a01;
                  out.m06 = a.m09;
                  out.m07 = a.m13;
                  out.m08 = a02;
                  out.m09 = a12;
                  out.m11 = a.m14;
                  out.m12 = a03;
                  out.m13 = a13;
                  out.m14 = a23;
                } else {
                  out.m00 = a.m00;
                  out.m01 = a.m04;
                  out.m02 = a.m08;
                  out.m03 = a.m12;
                  out.m04 = a.m01;
                  out.m05 = a.m05;
                  out.m06 = a.m09;
                  out.m07 = a.m13;
                  out.m08 = a.m02;
                  out.m09 = a.m06;
                  out.m10 = a.m10;
                  out.m11 = a.m14;
                  out.m12 = a.m03;
                  out.m13 = a.m07;
                  out.m14 = a.m11;
                  out.m15 = a.m15;
                }
                return out;
              };
              Mat4.invert = function invert(out, a) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a03 = a.m03;
                var a10 = a.m04;
                var a11 = a.m05;
                var a12 = a.m06;
                var a13 = a.m07;
                var a20 = a.m08;
                var a21 = a.m09;
                var a22 = a.m10;
                var a23 = a.m11;
                var a30 = a.m12;
                var a31 = a.m13;
                var a32 = a.m14;
                var a33 = a.m15;
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32;
                var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (det === 0) {
                  return Mat4.zero(out);
                }
                det = 1.0 / det;
                out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return out;
              };
              Mat4.determinant = function determinant(a) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a03 = a.m03;
                var a10 = a.m04;
                var a11 = a.m05;
                var a12 = a.m06;
                var a13 = a.m07;
                var a20 = a.m08;
                var a21 = a.m09;
                var a22 = a.m10;
                var a23 = a.m11;
                var a30 = a.m12;
                var a31 = a.m13;
                var a32 = a.m14;
                var a33 = a.m15;
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32;
                return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              };
              Mat4.multiply = function multiply(out, a, b) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a03 = a.m03;
                var a10 = a.m04;
                var a11 = a.m05;
                var a12 = a.m06;
                var a13 = a.m07;
                var a20 = a.m08;
                var a21 = a.m09;
                var a22 = a.m10;
                var a23 = a.m11;
                var a30 = a.m12;
                var a31 = a.m13;
                var a32 = a.m14;
                var a33 = a.m15;
                var b0 = b.m00;
                var b1 = b.m01;
                var b2 = b.m02;
                var b3 = b.m03;
                out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b.m04;
                b1 = b.m05;
                b2 = b.m06;
                b3 = b.m07;
                out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b.m08;
                b1 = b.m09;
                b2 = b.m10;
                b3 = b.m11;
                out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = b.m12;
                b1 = b.m13;
                b2 = b.m14;
                b3 = b.m15;
                out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return out;
              };
              Mat4.transform = function transform(out, a, v) {
                var x = v.x;
                var y = v.y;
                var z = v.z;
                if (a === out) {
                  out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
                  out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
                  out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
                  out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
                } else {
                  var a00 = a.m00;
                  var a01 = a.m01;
                  var a02 = a.m02;
                  var a03 = a.m03;
                  var a10 = a.m04;
                  var a11 = a.m05;
                  var a12 = a.m06;
                  var a13 = a.m07;
                  var a20 = a.m08;
                  var a21 = a.m09;
                  var a22 = a.m10;
                  var a23 = a.m11;
                  out.m00 = a00;
                  out.m01 = a01;
                  out.m02 = a02;
                  out.m03 = a03;
                  out.m04 = a10;
                  out.m05 = a11;
                  out.m06 = a12;
                  out.m07 = a13;
                  out.m08 = a20;
                  out.m09 = a21;
                  out.m10 = a22;
                  out.m11 = a23;
                  out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
                  out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
                  out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
                  out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
                }
                return out;
              };
              Mat4.translate = function translate(out, a, v) {
                if (a === out) {
                  out.m12 += v.x;
                  out.m13 += v.y;
                  out.m14 += v.z;
                } else {
                  out.m00 = a.m00;
                  out.m01 = a.m01;
                  out.m02 = a.m02;
                  out.m03 = a.m03;
                  out.m04 = a.m04;
                  out.m05 = a.m05;
                  out.m06 = a.m06;
                  out.m07 = a.m07;
                  out.m08 = a.m08;
                  out.m09 = a.m09;
                  out.m10 = a.m10;
                  out.m11 = a.m11;
                  out.m12 = a.m12 + v.x;
                  out.m13 = a.m13 + v.y;
                  out.m14 = a.m14 + v.z;
                  out.m15 = a.m15;
                }
                return out;
              };
              Mat4.scale = function scale(out, a, v) {
                var x = v.x;
                var y = v.y;
                var z = v.z;
                out.m00 = a.m00 * x;
                out.m01 = a.m01 * x;
                out.m02 = a.m02 * x;
                out.m03 = a.m03 * x;
                out.m04 = a.m04 * y;
                out.m05 = a.m05 * y;
                out.m06 = a.m06 * y;
                out.m07 = a.m07 * y;
                out.m08 = a.m08 * z;
                out.m09 = a.m09 * z;
                out.m10 = a.m10 * z;
                out.m11 = a.m11 * z;
                out.m12 = a.m12;
                out.m13 = a.m13;
                out.m14 = a.m14;
                out.m15 = a.m15;
                return out;
              };
              Mat4.rotate = function rotate(out, a, rad, axis) {
                var x = axis.x;
                var y = axis.y;
                var z = axis.z;
                var len = sqrt$2(x * x + y * y + z * z);
                if (abs$1(len) < EPSILON$1) {
                  return null;
                }
                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                var s = sin$1(rad);
                var c = cos$2(rad);
                var t = 1 - c;
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a03 = a.m03;
                var a10 = a.m04;
                var a11 = a.m05;
                var a12 = a.m06;
                var a13 = a.m07;
                var a20 = a.m08;
                var a21 = a.m09;
                var a22 = a.m10;
                var a23 = a.m11;
                var b00 = x * x * t + c;
                var b01 = y * x * t + z * s;
                var b02 = z * x * t - y * s;
                var b10 = x * y * t - z * s;
                var b11 = y * y * t + c;
                var b12 = z * y * t + x * s;
                var b20 = x * z * t + y * s;
                var b21 = y * z * t - x * s;
                var b22 = z * z * t + c;
                out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
                out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
                out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
                out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
                out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
                out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
                out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
                out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
                out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
                out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
                out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
                out.m11 = a03 * b20 + a13 * b21 + a23 * b22;
                if (a !== out) {
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }
                return out;
              };
              Mat4.rotateX = function rotateX(out, a, rad) {
                var s = sin$1(rad);
                var c = cos$2(rad);
                var a10 = a.m04;
                var a11 = a.m05;
                var a12 = a.m06;
                var a13 = a.m07;
                var a20 = a.m08;
                var a21 = a.m09;
                var a22 = a.m10;
                var a23 = a.m11;
                if (a !== out) {
                  out.m00 = a.m00;
                  out.m01 = a.m01;
                  out.m02 = a.m02;
                  out.m03 = a.m03;
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }
                out.m04 = a10 * c + a20 * s;
                out.m05 = a11 * c + a21 * s;
                out.m06 = a12 * c + a22 * s;
                out.m07 = a13 * c + a23 * s;
                out.m08 = a20 * c - a10 * s;
                out.m09 = a21 * c - a11 * s;
                out.m10 = a22 * c - a12 * s;
                out.m11 = a23 * c - a13 * s;
                return out;
              };
              Mat4.rotateY = function rotateY(out, a, rad) {
                var s = sin$1(rad);
                var c = cos$2(rad);
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a03 = a.m03;
                var a20 = a.m08;
                var a21 = a.m09;
                var a22 = a.m10;
                var a23 = a.m11;
                if (a !== out) {
                  out.m04 = a.m04;
                  out.m05 = a.m05;
                  out.m06 = a.m06;
                  out.m07 = a.m07;
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }
                out.m00 = a00 * c - a20 * s;
                out.m01 = a01 * c - a21 * s;
                out.m02 = a02 * c - a22 * s;
                out.m03 = a03 * c - a23 * s;
                out.m08 = a00 * s + a20 * c;
                out.m09 = a01 * s + a21 * c;
                out.m10 = a02 * s + a22 * c;
                out.m11 = a03 * s + a23 * c;
                return out;
              };
              Mat4.rotateZ = function rotateZ(out, a, rad) {
                var s = sin$1(rad);
                var c = cos$2(rad);
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a03 = a.m03;
                var a10 = a.m04;
                var a11 = a.m05;
                var a12 = a.m06;
                var a13 = a.m07;
                if (a !== out) {
                  out.m08 = a.m08;
                  out.m09 = a.m09;
                  out.m10 = a.m10;
                  out.m11 = a.m11;
                  out.m12 = a.m12;
                  out.m13 = a.m13;
                  out.m14 = a.m14;
                  out.m15 = a.m15;
                }
                out.m00 = a00 * c + a10 * s;
                out.m01 = a01 * c + a11 * s;
                out.m02 = a02 * c + a12 * s;
                out.m03 = a03 * c + a13 * s;
                out.m04 = a10 * c - a00 * s;
                out.m05 = a11 * c - a01 * s;
                out.m06 = a12 * c - a02 * s;
                out.m07 = a13 * c - a03 * s;
                return out;
              };
              Mat4.fromTranslation = function fromTranslation(out, v) {
                Mat4.identity(out);
                out.m12 = v.x;
                out.m13 = v.y;
                out.m14 = v.z;
                return out;
              };
              Mat4.fromScaling = function fromScaling(out, v) {
                Mat4.identity(out);
                out.m00 = v.x;
                out.m05 = v.y;
                out.m10 = v.z;
                return out;
              };
              Mat4.fromRotation = function fromRotation(out, rad, axis) {
                var x = axis.x;
                var y = axis.y;
                var z = axis.z;
                var len = sqrt$2(x * x + y * y + z * z);
                if (abs$1(len) < EPSILON$1) {
                  return null;
                }
                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                var s = sin$1(rad);
                var c = cos$2(rad);
                var t = 1 - c;
                out.m00 = x * x * t + c;
                out.m01 = y * x * t + z * s;
                out.m02 = z * x * t - y * s;
                out.m03 = 0;
                out.m04 = x * y * t - z * s;
                out.m05 = y * y * t + c;
                out.m06 = z * y * t + x * s;
                out.m07 = 0;
                out.m08 = x * z * t + y * s;
                out.m09 = y * z * t - x * s;
                out.m10 = z * z * t + c;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              };
              Mat4.fromXRotation = function fromXRotation(out, rad) {
                var s = sin$1(rad);
                var c = cos$2(rad);
                Mat4.identity(out);
                out.m05 = c;
                out.m06 = s;
                out.m09 = -s;
                out.m10 = c;
                return out;
              };
              Mat4.fromYRotation = function fromYRotation(out, rad) {
                var s = sin$1(rad);
                var c = cos$2(rad);
                Mat4.identity(out);
                out.m00 = c;
                out.m02 = -s;
                out.m08 = s;
                out.m10 = c;
                return out;
              };
              Mat4.fromZRotation = function fromZRotation(out, rad) {
                var s = sin$1(rad);
                var c = cos$2(rad);
                Mat4.identity(out);
                out.m00 = c;
                out.m01 = s;
                out.m04 = -s;
                out.m05 = c;
                return out;
              };
              Mat4.fromRT = function fromRT(out, q, v) {
                var x = q.x;
                var y = q.y;
                var z = q.z;
                var w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var xy = x * y2;
                var xz = x * z2;
                var yy = y * y2;
                var yz = y * z2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                out.m00 = 1 - (yy + zz);
                out.m01 = xy + wz;
                out.m02 = xz - wy;
                out.m03 = 0;
                out.m04 = xy - wz;
                out.m05 = 1 - (xx + zz);
                out.m06 = yz + wx;
                out.m07 = 0;
                out.m08 = xz + wy;
                out.m09 = yz - wx;
                out.m10 = 1 - (xx + yy);
                out.m11 = 0;
                out.m12 = v.x;
                out.m13 = v.y;
                out.m14 = v.z;
                out.m15 = 1;
                return out;
              };
              Mat4.getTranslation = function getTranslation(out, mat) {
                out.x = mat.m12;
                out.y = mat.m13;
                out.z = mat.m14;
                return out;
              };
              Mat4.getScaling = function getScaling(out, mat) {
                var m00 = m3_1$1.m00 = mat.m00;
                var m01 = m3_1$1.m01 = mat.m01;
                var m02 = m3_1$1.m02 = mat.m02;
                var m04 = m3_1$1.m03 = mat.m04;
                var m05 = m3_1$1.m04 = mat.m05;
                var m06 = m3_1$1.m05 = mat.m06;
                var m08 = m3_1$1.m06 = mat.m08;
                var m09 = m3_1$1.m07 = mat.m09;
                var m10 = m3_1$1.m08 = mat.m10;
                out.x = sqrt$2(m00 * m00 + m01 * m01 + m02 * m02);
                out.y = sqrt$2(m04 * m04 + m05 * m05 + m06 * m06);
                out.z = sqrt$2(m08 * m08 + m09 * m09 + m10 * m10);
                if (Mat3.determinant(m3_1$1) < 0) {
                  out.x *= -1;
                }
                return out;
              };
              Mat4.getRotation = function getRotation(out, mat) {
                var trace = mat.m00 + mat.m05 + mat.m10;
                var S = 0;
                if (trace > 0) {
                  S = sqrt$2(trace + 1.0) * 2;
                  out.w = 0.25 * S;
                  out.x = (mat.m06 - mat.m09) / S;
                  out.y = (mat.m08 - mat.m02) / S;
                  out.z = (mat.m01 - mat.m04) / S;
                } else if (mat.m00 > mat.m05 && mat.m00 > mat.m10) {
                  S = sqrt$2(1.0 + mat.m00 - mat.m05 - mat.m10) * 2;
                  out.w = (mat.m06 - mat.m09) / S;
                  out.x = 0.25 * S;
                  out.y = (mat.m01 + mat.m04) / S;
                  out.z = (mat.m08 + mat.m02) / S;
                } else if (mat.m05 > mat.m10) {
                  S = sqrt$2(1.0 + mat.m05 - mat.m00 - mat.m10) * 2;
                  out.w = (mat.m08 - mat.m02) / S;
                  out.x = (mat.m01 + mat.m04) / S;
                  out.y = 0.25 * S;
                  out.z = (mat.m06 + mat.m09) / S;
                } else {
                  S = sqrt$2(1.0 + mat.m10 - mat.m00 - mat.m05) * 2;
                  out.w = (mat.m01 - mat.m04) / S;
                  out.x = (mat.m08 + mat.m02) / S;
                  out.y = (mat.m06 + mat.m09) / S;
                  out.z = 0.25 * S;
                }
                return out;
              };
              Mat4.toRTS = function toRTS(m, q, v, s) {
                Mat4.toSRT(m, q, v, s);
              };
              Mat4.toSRT = function toSRT(m, q, v, s) {
                if (v) {
                  Vec3.set(v, m.m12, m.m13, m.m14);
                }
                var sx = Vec3.set(v3_1$4, m.m00, m.m01, m.m02).length();
                var sy = Vec3.set(v3_1$4, m.m04, m.m05, m.m06).length();
                var sz = Vec3.set(v3_1$4, m.m08, m.m09, m.m10).length();
                if (s) {
                  s.x = sx;
                  s.y = sy;
                  s.z = sz;
                }
                if (sx === 0 || sy === 0 || sz === 0) {
                  if (q) {
                    Quat.identity(q);
                  }
                  return;
                }
                m3_1$1.m00 = m.m00 / sx;
                m3_1$1.m01 = m.m01 / sx;
                m3_1$1.m02 = m.m02 / sx;
                m3_1$1.m03 = m.m04 / sy;
                m3_1$1.m04 = m.m05 / sy;
                m3_1$1.m05 = m.m06 / sy;
                m3_1$1.m06 = m.m08 / sz;
                m3_1$1.m07 = m.m09 / sz;
                m3_1$1.m08 = m.m10 / sz;
                var det = Mat3.determinant(m3_1$1);
                if (s) {
                  if (det < 0) {
                    s.x *= -1;
                  }
                }
                if (q) {
                  if (det < 0) {
                    m3_1$1.m00 *= -1;
                    m3_1$1.m01 *= -1;
                    m3_1$1.m02 *= -1;
                  }
                  Quat.fromMat3(q, m3_1$1);
                }
              };
              Mat4.toEuler = function toEuler(m, v) {
                Mat3.set(m3_1$1, m.m00, m.m01, m.m02, m.m04, m.m05, m.m06, m.m08, m.m09, m.m10);
                return Mat3.toEuler(m3_1$1, v);
              };
              Mat4.fromRTS = function fromRTS(out, q, v, s) {
                return Mat4.fromSRT(out, q, v, s);
              };
              Mat4.fromSRT = function fromSRT(out, q, v, s) {
                var x = q.x,
                  y = q.y,
                  z = q.z,
                  w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var xy = x * y2;
                var xz = x * z2;
                var yy = y * y2;
                var yz = y * z2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                var sx = s.x;
                var sy = s.y;
                var sz = s.z;
                out.m00 = (1 - (yy + zz)) * sx;
                out.m01 = (xy + wz) * sx;
                out.m02 = (xz - wy) * sx;
                out.m03 = 0;
                out.m04 = (xy - wz) * sy;
                out.m05 = (1 - (xx + zz)) * sy;
                out.m06 = (yz + wx) * sy;
                out.m07 = 0;
                out.m08 = (xz + wy) * sz;
                out.m09 = (yz - wx) * sz;
                out.m10 = (1 - (xx + yy)) * sz;
                out.m11 = 0;
                out.m12 = v.x;
                out.m13 = v.y;
                out.m14 = v.z;
                out.m15 = 1;
                return out;
              };
              Mat4.fromRTSOrigin = function fromRTSOrigin(out, q, v, s, o) {
                return Mat4.fromSRTOrigin(out, q, v, s, o);
              };
              Mat4.fromSRTOrigin = function fromSRTOrigin(out, q, v, s, o) {
                var x = q.x;
                var y = q.y;
                var z = q.z;
                var w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var xy = x * y2;
                var xz = x * z2;
                var yy = y * y2;
                var yz = y * z2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                var sx = s.x;
                var sy = s.y;
                var sz = s.z;
                var ox = o.x;
                var oy = o.y;
                var oz = o.z;
                out.m00 = (1 - (yy + zz)) * sx;
                out.m01 = (xy + wz) * sx;
                out.m02 = (xz - wy) * sx;
                out.m03 = 0;
                out.m04 = (xy - wz) * sy;
                out.m05 = (1 - (xx + zz)) * sy;
                out.m06 = (yz + wx) * sy;
                out.m07 = 0;
                out.m08 = (xz + wy) * sz;
                out.m09 = (yz - wx) * sz;
                out.m10 = (1 - (xx + yy)) * sz;
                out.m11 = 0;
                out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
                out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
                out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
                out.m15 = 1;
                return out;
              };
              Mat4.fromQuat = function fromQuat(out, q) {
                var x = q.x;
                var y = q.y;
                var z = q.z;
                var w = q.w;
                var x2 = x + x;
                var y2 = y + y;
                var z2 = z + z;
                var xx = x * x2;
                var yx = y * x2;
                var yy = y * y2;
                var zx = z * x2;
                var zy = z * y2;
                var zz = z * z2;
                var wx = w * x2;
                var wy = w * y2;
                var wz = w * z2;
                out.m00 = 1 - yy - zz;
                out.m01 = yx + wz;
                out.m02 = zx - wy;
                out.m03 = 0;
                out.m04 = yx - wz;
                out.m05 = 1 - xx - zz;
                out.m06 = zy + wx;
                out.m07 = 0;
                out.m08 = zx + wy;
                out.m09 = zy - wx;
                out.m10 = 1 - xx - yy;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              };
              Mat4.frustum = function frustum(out, left, right, bottom, top, near, far) {
                var rl = 1 / (right - left);
                var tb = 1 / (top - bottom);
                var nf = 1 / (near - far);
                out.m00 = near * 2 * rl;
                out.m01 = 0;
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = 0;
                out.m05 = near * 2 * tb;
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = (right + left) * rl;
                out.m09 = (top + bottom) * tb;
                out.m10 = (far + near) * nf;
                out.m11 = -1;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = far * near * 2 * nf;
                out.m15 = 0;
                return out;
              };
              Mat4.perspective = function perspective(out, fov, aspect, near, far, isFOVY, minClipZ, projectionSignY, orientation) {
                if (isFOVY === undefined) {
                  isFOVY = true;
                }
                if (minClipZ === undefined) {
                  minClipZ = -1;
                }
                if (projectionSignY === undefined) {
                  projectionSignY = 1;
                }
                if (orientation === undefined) {
                  orientation = 0;
                }
                var f = 1.0 / tan(fov / 2);
                var nf = 1 / (near - far);
                var x = isFOVY ? f / aspect : f;
                var y = (isFOVY ? f : f * aspect) * projectionSignY;
                var preTransform = preTransforms[orientation];
                out.m00 = x * preTransform[0];
                out.m01 = x * preTransform[1];
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = y * preTransform[2];
                out.m05 = y * preTransform[3];
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = (far - minClipZ * near) * nf;
                out.m11 = -1;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = far * near * nf * (1 - minClipZ);
                out.m15 = 0;
                return out;
              };
              Mat4.ortho = function ortho(out, left, right, bottom, top, near, far, minClipZ, projectionSignY, orientation) {
                if (minClipZ === undefined) {
                  minClipZ = -1;
                }
                if (projectionSignY === undefined) {
                  projectionSignY = 1;
                }
                if (orientation === undefined) {
                  orientation = 0;
                }
                var lr = 1 / (left - right);
                var bt = 1 / (bottom - top) * projectionSignY;
                var nf = 1 / (near - far);
                var x = -2 * lr;
                var y = -2 * bt;
                var dx = (left + right) * lr;
                var dy = (top + bottom) * bt;
                var preTransform = preTransforms[orientation];
                out.m00 = x * preTransform[0];
                out.m01 = x * preTransform[1];
                out.m02 = 0;
                out.m03 = 0;
                out.m04 = y * preTransform[2];
                out.m05 = y * preTransform[3];
                out.m06 = 0;
                out.m07 = 0;
                out.m08 = 0;
                out.m09 = 0;
                out.m10 = nf * (1 - minClipZ);
                out.m11 = 0;
                out.m12 = dx * preTransform[0] + dy * preTransform[2];
                out.m13 = dx * preTransform[1] + dy * preTransform[3];
                out.m14 = (near - minClipZ * far) * nf;
                out.m15 = 1;
                return out;
              };
              Mat4.lookAt = function lookAt(out, eye, center, up) {
                var eyex = eye.x;
                var eyey = eye.y;
                var eyez = eye.z;
                var upx = up.x;
                var upy = up.y;
                var upz = up.z;
                var centerx = center.x;
                var centery = center.y;
                var centerz = center.z;
                var z0 = eyex - centerx;
                var z1 = eyey - centery;
                var z2 = eyez - centerz;
                var len = 1 / sqrt$2(z0 * z0 + z1 * z1 + z2 * z2);
                z0 *= len;
                z1 *= len;
                z2 *= len;
                var x0 = upy * z2 - upz * z1;
                var x1 = upz * z0 - upx * z2;
                var x2 = upx * z1 - upy * z0;
                len = 1 / sqrt$2(x0 * x0 + x1 * x1 + x2 * x2);
                x0 *= len;
                x1 *= len;
                x2 *= len;
                var y0 = z1 * x2 - z2 * x1;
                var y1 = z2 * x0 - z0 * x2;
                var y2 = z0 * x1 - z1 * x0;
                out.m00 = x0;
                out.m01 = y0;
                out.m02 = z0;
                out.m03 = 0;
                out.m04 = x1;
                out.m05 = y1;
                out.m06 = z1;
                out.m07 = 0;
                out.m08 = x2;
                out.m09 = y2;
                out.m10 = z2;
                out.m11 = 0;
                out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out.m15 = 1;
                return out;
              };
              Mat4.inverseTranspose = function inverseTranspose(out, a) {
                var a00 = a.m00;
                var a01 = a.m01;
                var a02 = a.m02;
                var a03 = a.m03;
                var a10 = a.m04;
                var a11 = a.m05;
                var a12 = a.m06;
                var a13 = a.m07;
                var a20 = a.m08;
                var a21 = a.m09;
                var a22 = a.m10;
                var a23 = a.m11;
                var a30 = a.m12;
                var a31 = a.m13;
                var a32 = a.m14;
                var a33 = a.m15;
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32;
                var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) {
                  return null;
                }
                det = 1.0 / det;
                out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out.m03 = 0;
                out.m04 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out.m06 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out.m07 = 0;
                out.m08 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out.m09 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out.m11 = 0;
                out.m12 = 0;
                out.m13 = 0;
                out.m14 = 0;
                out.m15 = 1;
                return out;
              };
              Mat4.toArray = function toArray(out, m, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out[ofs + 0] = m.m00;
                out[ofs + 1] = m.m01;
                out[ofs + 2] = m.m02;
                out[ofs + 3] = m.m03;
                out[ofs + 4] = m.m04;
                out[ofs + 5] = m.m05;
                out[ofs + 6] = m.m06;
                out[ofs + 7] = m.m07;
                out[ofs + 8] = m.m08;
                out[ofs + 9] = m.m09;
                out[ofs + 10] = m.m10;
                out[ofs + 11] = m.m11;
                out[ofs + 12] = m.m12;
                out[ofs + 13] = m.m13;
                out[ofs + 14] = m.m14;
                out[ofs + 15] = m.m15;
                return out;
              };
              Mat4.fromArray = function fromArray(out, arr, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out.m00 = arr[ofs + 0];
                out.m01 = arr[ofs + 1];
                out.m02 = arr[ofs + 2];
                out.m03 = arr[ofs + 3];
                out.m04 = arr[ofs + 4];
                out.m05 = arr[ofs + 5];
                out.m06 = arr[ofs + 6];
                out.m07 = arr[ofs + 7];
                out.m08 = arr[ofs + 8];
                out.m09 = arr[ofs + 9];
                out.m10 = arr[ofs + 10];
                out.m11 = arr[ofs + 11];
                out.m12 = arr[ofs + 12];
                out.m13 = arr[ofs + 13];
                out.m14 = arr[ofs + 14];
                out.m15 = arr[ofs + 15];
                return out;
              };
              Mat4.add = function add(out, a, b) {
                out.m00 = a.m00 + b.m00;
                out.m01 = a.m01 + b.m01;
                out.m02 = a.m02 + b.m02;
                out.m03 = a.m03 + b.m03;
                out.m04 = a.m04 + b.m04;
                out.m05 = a.m05 + b.m05;
                out.m06 = a.m06 + b.m06;
                out.m07 = a.m07 + b.m07;
                out.m08 = a.m08 + b.m08;
                out.m09 = a.m09 + b.m09;
                out.m10 = a.m10 + b.m10;
                out.m11 = a.m11 + b.m11;
                out.m12 = a.m12 + b.m12;
                out.m13 = a.m13 + b.m13;
                out.m14 = a.m14 + b.m14;
                out.m15 = a.m15 + b.m15;
                return out;
              };
              Mat4.subtract = function subtract(out, a, b) {
                out.m00 = a.m00 - b.m00;
                out.m01 = a.m01 - b.m01;
                out.m02 = a.m02 - b.m02;
                out.m03 = a.m03 - b.m03;
                out.m04 = a.m04 - b.m04;
                out.m05 = a.m05 - b.m05;
                out.m06 = a.m06 - b.m06;
                out.m07 = a.m07 - b.m07;
                out.m08 = a.m08 - b.m08;
                out.m09 = a.m09 - b.m09;
                out.m10 = a.m10 - b.m10;
                out.m11 = a.m11 - b.m11;
                out.m12 = a.m12 - b.m12;
                out.m13 = a.m13 - b.m13;
                out.m14 = a.m14 - b.m14;
                out.m15 = a.m15 - b.m15;
                return out;
              };
              Mat4.multiplyScalar = function multiplyScalar(out, a, b) {
                out.m00 = a.m00 * b;
                out.m01 = a.m01 * b;
                out.m02 = a.m02 * b;
                out.m03 = a.m03 * b;
                out.m04 = a.m04 * b;
                out.m05 = a.m05 * b;
                out.m06 = a.m06 * b;
                out.m07 = a.m07 * b;
                out.m08 = a.m08 * b;
                out.m09 = a.m09 * b;
                out.m10 = a.m10 * b;
                out.m11 = a.m11 * b;
                out.m12 = a.m12 * b;
                out.m13 = a.m13 * b;
                out.m14 = a.m14 * b;
                out.m15 = a.m15 * b;
                return out;
              };
              Mat4.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
                out.m00 = a.m00 + b.m00 * scale;
                out.m01 = a.m01 + b.m01 * scale;
                out.m02 = a.m02 + b.m02 * scale;
                out.m03 = a.m03 + b.m03 * scale;
                out.m04 = a.m04 + b.m04 * scale;
                out.m05 = a.m05 + b.m05 * scale;
                out.m06 = a.m06 + b.m06 * scale;
                out.m07 = a.m07 + b.m07 * scale;
                out.m08 = a.m08 + b.m08 * scale;
                out.m09 = a.m09 + b.m09 * scale;
                out.m10 = a.m10 + b.m10 * scale;
                out.m11 = a.m11 + b.m11 * scale;
                out.m12 = a.m12 + b.m12 * scale;
                out.m13 = a.m13 + b.m13 * scale;
                out.m14 = a.m14 + b.m14 * scale;
                out.m15 = a.m15 + b.m15 * scale;
                return out;
              };
              Mat4.strictEquals = function strictEquals(a, b) {
                return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
              };
              Mat4.equals = function equals(a, b, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return abs$1(a.m00 - b.m00) <= epsilon * max$5(1.0, abs$1(a.m00), abs$1(b.m00)) && abs$1(a.m01 - b.m01) <= epsilon * max$5(1.0, abs$1(a.m01), abs$1(b.m01)) && abs$1(a.m02 - b.m02) <= epsilon * max$5(1.0, abs$1(a.m02), abs$1(b.m02)) && abs$1(a.m03 - b.m03) <= epsilon * max$5(1.0, abs$1(a.m03), abs$1(b.m03)) && abs$1(a.m04 - b.m04) <= epsilon * max$5(1.0, abs$1(a.m04), abs$1(b.m04)) && abs$1(a.m05 - b.m05) <= epsilon * max$5(1.0, abs$1(a.m05), abs$1(b.m05)) && abs$1(a.m06 - b.m06) <= epsilon * max$5(1.0, abs$1(a.m06), abs$1(b.m06)) && abs$1(a.m07 - b.m07) <= epsilon * max$5(1.0, abs$1(a.m07), abs$1(b.m07)) && abs$1(a.m08 - b.m08) <= epsilon * max$5(1.0, abs$1(a.m08), abs$1(b.m08)) && abs$1(a.m09 - b.m09) <= epsilon * max$5(1.0, abs$1(a.m09), abs$1(b.m09)) && abs$1(a.m10 - b.m10) <= epsilon * max$5(1.0, abs$1(a.m10), abs$1(b.m10)) && abs$1(a.m11 - b.m11) <= epsilon * max$5(1.0, abs$1(a.m11), abs$1(b.m11)) && abs$1(a.m12 - b.m12) <= epsilon * max$5(1.0, abs$1(a.m12), abs$1(b.m12)) && abs$1(a.m13 - b.m13) <= epsilon * max$5(1.0, abs$1(a.m13), abs$1(b.m13)) && abs$1(a.m14 - b.m14) <= epsilon * max$5(1.0, abs$1(a.m14), abs$1(b.m14)) && abs$1(a.m15 - b.m15) <= epsilon * max$5(1.0, abs$1(a.m15), abs$1(b.m15));
              };
              function Mat4(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15) {
                var _this;
                if (m00 === undefined) {
                  m00 = 1;
                }
                if (m01 === undefined) {
                  m01 = 0;
                }
                if (m02 === undefined) {
                  m02 = 0;
                }
                if (m03 === undefined) {
                  m03 = 0;
                }
                if (m04 === undefined) {
                  m04 = 0;
                }
                if (m05 === undefined) {
                  m05 = 1;
                }
                if (m06 === undefined) {
                  m06 = 0;
                }
                if (m07 === undefined) {
                  m07 = 0;
                }
                if (m08 === undefined) {
                  m08 = 0;
                }
                if (m09 === undefined) {
                  m09 = 0;
                }
                if (m10 === undefined) {
                  m10 = 1;
                }
                if (m11 === undefined) {
                  m11 = 0;
                }
                if (m12 === undefined) {
                  m12 = 0;
                }
                if (m13 === undefined) {
                  m13 = 0;
                }
                if (m14 === undefined) {
                  m14 = 0;
                }
                if (m15 === undefined) {
                  m15 = 1;
                }
                _this = _ValueType.call(this) || this;
                var self = _assertThisInitialized(_this);
                if (typeof m00 === 'object') {
                  self.m00 = m00.m00;
                  _this.m01 = m00.m01;
                  _this.m02 = m00.m02;
                  _this.m03 = m00.m03;
                  self.m04 = m00.m04;
                  _this.m05 = m00.m05;
                  _this.m06 = m00.m06;
                  _this.m07 = m00.m07;
                  self.m08 = m00.m08;
                  _this.m09 = m00.m09;
                  _this.m10 = m00.m10;
                  _this.m11 = m00.m11;
                  self.m12 = m00.m12;
                  _this.m13 = m00.m13;
                  _this.m14 = m00.m14;
                  _this.m15 = m00.m15;
                } else {
                  self.m00 = m00;
                  _this.m01 = m01;
                  _this.m02 = m02;
                  _this.m03 = m03;
                  self.m04 = m04;
                  _this.m05 = m05;
                  _this.m06 = m06;
                  _this.m07 = m07;
                  self.m08 = m08;
                  _this.m09 = m09;
                  _this.m10 = m10;
                  _this.m11 = m11;
                  self.m12 = m12;
                  _this.m13 = m13;
                  _this.m14 = m14;
                  _this.m15 = m15;
                }
                return _this;
              }
              var _proto = Mat4.prototype;
              _proto.clone = function clone() {
                return new Mat4(this.m00, this.m01, this.m02, this.m03, this.m04, this.m05, this.m06, this.m07, this.m08, this.m09, this.m10, this.m11, this.m12, this.m13, this.m14, this.m15);
              };
              _proto.set = function set(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15) {
                if (m00 === undefined) {
                  m00 = 1;
                }
                if (m01 === undefined) {
                  m01 = 0;
                }
                if (m02 === undefined) {
                  m02 = 0;
                }
                if (m03 === undefined) {
                  m03 = 0;
                }
                if (m04 === undefined) {
                  m04 = 0;
                }
                if (m05 === undefined) {
                  m05 = 1;
                }
                if (m06 === undefined) {
                  m06 = 0;
                }
                if (m07 === undefined) {
                  m07 = 0;
                }
                if (m08 === undefined) {
                  m08 = 0;
                }
                if (m09 === undefined) {
                  m09 = 0;
                }
                if (m10 === undefined) {
                  m10 = 1;
                }
                if (m11 === undefined) {
                  m11 = 0;
                }
                if (m12 === undefined) {
                  m12 = 0;
                }
                if (m13 === undefined) {
                  m13 = 0;
                }
                if (m14 === undefined) {
                  m14 = 0;
                }
                if (m15 === undefined) {
                  m15 = 1;
                }
                var self = this;
                if (typeof m00 === 'object') {
                  self.m01 = m00.m01;
                  self.m02 = m00.m02;
                  self.m03 = m00.m03;
                  self.m04 = m00.m04;
                  self.m05 = m00.m05;
                  self.m06 = m00.m06;
                  self.m07 = m00.m07;
                  self.m08 = m00.m08;
                  self.m09 = m00.m09;
                  self.m10 = m00.m10;
                  self.m11 = m00.m11;
                  self.m12 = m00.m12;
                  self.m13 = m00.m13;
                  self.m14 = m00.m14;
                  self.m15 = m00.m15;
                  self.m00 = m00.m00;
                } else {
                  self.m01 = m01;
                  self.m02 = m02;
                  self.m03 = m03;
                  self.m04 = m04;
                  self.m05 = m05;
                  self.m06 = m06;
                  self.m07 = m07;
                  self.m08 = m08;
                  self.m09 = m09;
                  self.m10 = m10;
                  self.m11 = m11;
                  self.m12 = m12;
                  self.m13 = m13;
                  self.m14 = m14;
                  self.m15 = m15;
                  self.m00 = m00;
                }
                return self;
              };
              _proto.equals = function equals(other, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                var inf = Infinity;
                var self = this;
                var m00 = self.m00;
                var m01 = self.m01;
                var m02 = self.m02;
                var m03 = self.m03;
                var m04 = self.m04;
                var m05 = self.m05;
                var m06 = self.m06;
                var m07 = self.m07;
                var m08 = self.m08;
                var m09 = self.m09;
                var m10 = self.m10;
                var m11 = self.m11;
                var m12 = self.m12;
                var m13 = self.m13;
                var m14 = self.m14;
                var m15 = self.m15;
                var hasInf = abs$1(m00) === inf || abs$1(m01) === inf || abs$1(m02) === inf || abs$1(m03) === inf || abs$1(m04) === inf || abs$1(m05) === inf || abs$1(m06) === inf || abs$1(m07) === inf || abs$1(m08) === inf || abs$1(m09) === inf || abs$1(m10) === inf || abs$1(m11) === inf || abs$1(m12) === inf || abs$1(m13) === inf || abs$1(m14) === inf || abs$1(m15) === inf;
                return !hasInf && abs$1(m00 - other.m00) <= epsilon * max$5(1.0, abs$1(m00), abs$1(other.m00)) && abs$1(m01 - other.m01) <= epsilon * max$5(1.0, abs$1(m01), abs$1(other.m01)) && abs$1(m02 - other.m02) <= epsilon * max$5(1.0, abs$1(m02), abs$1(other.m02)) && abs$1(m03 - other.m03) <= epsilon * max$5(1.0, abs$1(m03), abs$1(other.m03)) && abs$1(m04 - other.m04) <= epsilon * max$5(1.0, abs$1(m04), abs$1(other.m04)) && abs$1(m05 - other.m05) <= epsilon * max$5(1.0, abs$1(m05), abs$1(other.m05)) && abs$1(m06 - other.m06) <= epsilon * max$5(1.0, abs$1(m06), abs$1(other.m06)) && abs$1(m07 - other.m07) <= epsilon * max$5(1.0, abs$1(m07), abs$1(other.m07)) && abs$1(m08 - other.m08) <= epsilon * max$5(1.0, abs$1(m08), abs$1(other.m08)) && abs$1(m09 - other.m09) <= epsilon * max$5(1.0, abs$1(m09), abs$1(other.m09)) && abs$1(m10 - other.m10) <= epsilon * max$5(1.0, abs$1(m10), abs$1(other.m10)) && abs$1(m11 - other.m11) <= epsilon * max$5(1.0, abs$1(m11), abs$1(other.m11)) && abs$1(m12 - other.m12) <= epsilon * max$5(1.0, abs$1(m12), abs$1(other.m12)) && abs$1(m13 - other.m13) <= epsilon * max$5(1.0, abs$1(m13), abs$1(other.m13)) && abs$1(m14 - other.m14) <= epsilon * max$5(1.0, abs$1(m14), abs$1(other.m14)) && abs$1(m15 - other.m15) <= epsilon * max$5(1.0, abs$1(m15), abs$1(other.m15));
              };
              _proto.strictEquals = function strictEquals(other) {
                var self = this;
                return self.m00 === other.m00 && self.m01 === other.m01 && self.m02 === other.m02 && self.m03 === other.m03 && self.m04 === other.m04 && self.m05 === other.m05 && self.m06 === other.m06 && self.m07 === other.m07 && self.m08 === other.m08 && self.m09 === other.m09 && self.m10 === other.m10 && self.m11 === other.m11 && self.m12 === other.m12 && self.m13 === other.m13 && self.m14 === other.m14 && self.m15 === other.m15;
              };
              _proto.toString = function toString() {
                var t = this;
                return "[\n" + t.m00 + ", " + t.m01 + ", " + t.m02 + ", " + t.m03 + ",\n" + t.m04 + ", " + t.m05 + ", " + t.m06 + ", " + t.m07 + ",\n" + t.m08 + ", " + t.m09 + ", " + t.m10 + ", " + t.m11 + ",\n" + t.m12 + ", " + t.m13 + ", " + t.m14 + ", " + t.m15 + "\n" + ']';
              };
              _proto.identity = function identity() {
                return Mat4.identity(this);
              };
              _proto.zero = function zero() {
                return Mat4.zero(this);
              };
              _proto.transpose = function transpose() {
                var self = this;
                var a01 = self.m01;
                var a02 = self.m02;
                var a03 = self.m03;
                var a12 = self.m06;
                var a13 = self.m07;
                var a23 = self.m11;
                self.m01 = self.m04;
                self.m02 = self.m08;
                self.m03 = self.m12;
                self.m04 = a01;
                self.m06 = self.m09;
                self.m07 = self.m13;
                self.m08 = a02;
                self.m09 = a12;
                self.m11 = self.m14;
                self.m12 = a03;
                self.m13 = a13;
                self.m14 = a23;
                return self;
              };
              _proto.invert = function invert() {
                var self = this;
                var a00 = self.m00;
                var a01 = self.m01;
                var a02 = self.m02;
                var a03 = self.m03;
                var a10 = self.m04;
                var a11 = self.m05;
                var a12 = self.m06;
                var a13 = self.m07;
                var a20 = self.m08;
                var a21 = self.m09;
                var a22 = self.m10;
                var a23 = self.m11;
                var a30 = self.m12;
                var a31 = self.m13;
                var a32 = self.m14;
                var a33 = self.m15;
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32;
                var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (det === 0) {
                  self.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                  return self;
                }
                det = 1.0 / det;
                self.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                self.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                self.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                self.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                self.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                self.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                self.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                self.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                self.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                self.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                self.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                self.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                self.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                self.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                self.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                self.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return self;
              };
              _proto.determinant = function determinant() {
                var self = this;
                var a00 = self.m00;
                var a01 = self.m01;
                var a02 = self.m02;
                var a03 = self.m03;
                var a10 = self.m04;
                var a11 = self.m05;
                var a12 = self.m06;
                var a13 = self.m07;
                var a20 = self.m08;
                var a21 = self.m09;
                var a22 = self.m10;
                var a23 = self.m11;
                var a30 = self.m12;
                var a31 = self.m13;
                var a32 = self.m14;
                var a33 = self.m15;
                var b00 = a00 * a11 - a01 * a10;
                var b01 = a00 * a12 - a02 * a10;
                var b02 = a00 * a13 - a03 * a10;
                var b03 = a01 * a12 - a02 * a11;
                var b04 = a01 * a13 - a03 * a11;
                var b05 = a02 * a13 - a03 * a12;
                var b06 = a20 * a31 - a21 * a30;
                var b07 = a20 * a32 - a22 * a30;
                var b08 = a20 * a33 - a23 * a30;
                var b09 = a21 * a32 - a22 * a31;
                var b10 = a21 * a33 - a23 * a31;
                var b11 = a22 * a33 - a23 * a32;
                return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
              };
              _proto.add = function add(mat) {
                var self = this;
                self.m00 += mat.m00;
                self.m01 += mat.m01;
                self.m02 += mat.m02;
                self.m03 += mat.m03;
                self.m04 += mat.m04;
                self.m05 += mat.m05;
                self.m06 += mat.m06;
                self.m07 += mat.m07;
                self.m08 += mat.m08;
                self.m09 += mat.m09;
                self.m10 += mat.m10;
                self.m11 += mat.m11;
                self.m12 += mat.m12;
                self.m13 += mat.m13;
                self.m14 += mat.m14;
                self.m15 += mat.m15;
                return self;
              };
              _proto.subtract = function subtract(mat) {
                var self = this;
                self.m00 -= mat.m00;
                self.m01 -= mat.m01;
                self.m02 -= mat.m02;
                self.m03 -= mat.m03;
                self.m04 -= mat.m04;
                self.m05 -= mat.m05;
                self.m06 -= mat.m06;
                self.m07 -= mat.m07;
                self.m08 -= mat.m08;
                self.m09 -= mat.m09;
                self.m10 -= mat.m10;
                self.m11 -= mat.m11;
                self.m12 -= mat.m12;
                self.m13 -= mat.m13;
                self.m14 -= mat.m14;
                self.m15 -= mat.m15;
                return self;
              };
              _proto.multiply = function multiply(mat) {
                return Mat4.multiply(this, this, mat);
              };
              _proto.multiplyScalar = function multiplyScalar(scalar) {
                var self = this;
                self.m00 *= scalar;
                self.m01 *= scalar;
                self.m02 *= scalar;
                self.m03 *= scalar;
                self.m04 *= scalar;
                self.m05 *= scalar;
                self.m06 *= scalar;
                self.m07 *= scalar;
                self.m08 *= scalar;
                self.m09 *= scalar;
                self.m10 *= scalar;
                self.m11 *= scalar;
                self.m12 *= scalar;
                self.m13 *= scalar;
                self.m14 *= scalar;
                self.m15 *= scalar;
                return self;
              };
              _proto.translate = function translate(vec) {
                this.m12 += vec.x;
                this.m13 += vec.y;
                this.m14 += vec.z;
                return this;
              };
              _proto.transform = function transform(vec) {
                var x = vec.x,
                  y = vec.y,
                  z = vec.z;
                var self = this;
                var a00 = self.m00;
                var a01 = self.m01;
                var a02 = self.m02;
                var a03 = self.m03;
                var a10 = self.m04;
                var a11 = self.m05;
                var a12 = self.m06;
                var a13 = self.m07;
                var a20 = self.m08;
                var a21 = self.m09;
                var a22 = self.m10;
                var a23 = self.m11;
                self.m12 = a00 * x + a10 * y + a20 * z + self.m12;
                self.m13 = a01 * x + a11 * y + a21 * z + self.m13;
                self.m14 = a02 * x + a12 * y + a22 * z + self.m14;
                self.m15 = a03 * x + a13 * y + a23 * z + self.m15;
                return self;
              };
              _proto.scale = function scale(vec) {
                var x = vec.x,
                  y = vec.y,
                  z = vec.z;
                var self = this;
                self.m00 *= x;
                self.m01 *= x;
                self.m02 *= x;
                self.m03 *= x;
                self.m04 *= y;
                self.m05 *= y;
                self.m06 *= y;
                self.m07 *= y;
                self.m08 *= z;
                self.m09 *= z;
                self.m10 *= z;
                self.m11 *= z;
                return self;
              };
              _proto.rotate = function rotate(rad, axis) {
                var x = axis.x;
                var y = axis.y;
                var z = axis.z;
                var len = sqrt$2(x * x + y * y + z * z);
                if (abs$1(len) < EPSILON$1) {
                  return null;
                }
                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;
                var s = sin$1(rad);
                var c = cos$2(rad);
                var t = 1 - c;
                var self = this;
                var a00 = self.m00;
                var a01 = self.m01;
                var a02 = self.m02;
                var a03 = self.m03;
                var a10 = self.m04;
                var a11 = self.m05;
                var a12 = self.m06;
                var a13 = self.m07;
                var a20 = self.m08;
                var a21 = self.m09;
                var a22 = self.m10;
                var a23 = self.m11;
                var b00 = x * x * t + c;
                var b01 = y * x * t + z * s;
                var b02 = z * x * t - y * s;
                var b10 = x * y * t - z * s;
                var b11 = y * y * t + c;
                var b12 = z * y * t + x * s;
                var b20 = x * z * t + y * s;
                var b21 = y * z * t - x * s;
                var b22 = z * z * t + c;
                self.m00 = a00 * b00 + a10 * b01 + a20 * b02;
                self.m01 = a01 * b00 + a11 * b01 + a21 * b02;
                self.m02 = a02 * b00 + a12 * b01 + a22 * b02;
                self.m03 = a03 * b00 + a13 * b01 + a23 * b02;
                self.m04 = a00 * b10 + a10 * b11 + a20 * b12;
                self.m05 = a01 * b10 + a11 * b11 + a21 * b12;
                self.m06 = a02 * b10 + a12 * b11 + a22 * b12;
                self.m07 = a03 * b10 + a13 * b11 + a23 * b12;
                self.m08 = a00 * b20 + a10 * b21 + a20 * b22;
                self.m09 = a01 * b20 + a11 * b21 + a21 * b22;
                self.m10 = a02 * b20 + a12 * b21 + a22 * b22;
                self.m11 = a03 * b20 + a13 * b21 + a23 * b22;
                return self;
              };
              _proto.getTranslation = function getTranslation(out) {
                out.x = this.m12;
                out.y = this.m13;
                out.z = this.m14;
                return out;
              };
              _proto.getScale = function getScale(out) {
                var self = this;
                var m00 = m3_1$1.m00 = self.m00;
                var m01 = m3_1$1.m01 = self.m01;
                var m02 = m3_1$1.m02 = self.m02;
                var m04 = m3_1$1.m03 = self.m04;
                var m05 = m3_1$1.m04 = self.m05;
                var m06 = m3_1$1.m05 = self.m06;
                var m08 = m3_1$1.m06 = self.m08;
                var m09 = m3_1$1.m07 = self.m09;
                var m10 = m3_1$1.m08 = self.m10;
                out.x = sqrt$2(m00 * m00 + m01 * m01 + m02 * m02);
                out.y = sqrt$2(m04 * m04 + m05 * m05 + m06 * m06);
                out.z = sqrt$2(m08 * m08 + m09 * m09 + m10 * m10);
                if (Mat3.determinant(m3_1$1) < 0) {
                  out.x *= -1;
                }
                return out;
              };
              _proto.getRotation = function getRotation(out) {
                var self = this;
                var sx = Vec3.set(v3_1$4, self.m00, self.m01, self.m02).length();
                var sy = Vec3.set(v3_1$4, self.m04, self.m05, self.m06).length();
                var sz = Vec3.set(v3_1$4, self.m08, self.m09, self.m10).length();
                m3_1$1.m00 = self.m00 / sx;
                m3_1$1.m01 = self.m01 / sx;
                m3_1$1.m02 = self.m02 / sx;
                m3_1$1.m03 = self.m04 / sy;
                m3_1$1.m04 = self.m05 / sy;
                m3_1$1.m05 = self.m06 / sy;
                m3_1$1.m06 = self.m08 / sz;
                m3_1$1.m07 = self.m09 / sz;
                m3_1$1.m08 = self.m10 / sz;
                var det = Mat3.determinant(m3_1$1);
                if (det < 0) {
                  m3_1$1.m00 *= -1;
                  m3_1$1.m01 *= -1;
                  m3_1$1.m02 *= -1;
                }
                return Quat.fromMat3(out, m3_1$1);
              };
              _proto.fromRTS = function fromRTS(q, v, s) {
                return Mat4.fromSRT(this, q, v, s);
              };
              _proto.fromSRT = function fromSRT(q, v, s) {
                return Mat4.fromSRT(this, q, v, s);
              };
              _proto.fromQuat = function fromQuat(q) {
                return Mat4.fromQuat(this, q);
              };
              return Mat4;
            }(ValueType));
            _class$T = Mat4;
            Mat4.IDENTITY = Object.freeze(new _class$T());
            var v3_1$4 = new Vec3();
            var m3_1$1 = new Mat3();
            CCClass.fastDefine('cc.Mat4', Mat4, {
              m00: 1,
              m01: 0,
              m02: 0,
              m03: 0,
              m04: 0,
              m05: 1,
              m06: 0,
              m07: 0,
              m08: 0,
              m09: 0,
              m10: 1,
              m11: 0,
              m12: 0,
              m13: 0,
              m14: 0,
              m15: 1
            });
            legacyCC.Mat4 = Mat4;
            function mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
              return new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
            }
            legacyCC.mat4 = mat4;

            var abs = Math.abs;
            var _max$1 = Math.max;
            var _min$1 = Math.min;
            var PI = Math.PI;
            var acos$1 = Math.acos;
            var sin = Math.sin;
            var cos$1 = Math.cos;
            var sqrt$1 = Math.sqrt;
            var atan2 = Math.atan2;
            var _ceil = Math.ceil;
            var _floor = Math.floor;
            var _round = Math.round;
            function freezeVec2(x, y) {
              return Object.freeze(new Vec2(x, y));
            }
            var Vec2 = exports("Vec2", function (_ValueType) {
              _inheritsLoose(Vec2, _ValueType);
              Vec2.clone = function clone(a) {
                return new Vec2(a.x, a.y);
              };
              Vec2.copy = function copy(out, a) {
                out.x = a.x;
                out.y = a.y;
                return out;
              };
              Vec2.set = function set(out, x, y) {
                out.x = x;
                out.y = y;
                return out;
              };
              Vec2.add = function add(out, a, b) {
                out.x = a.x + b.x;
                out.y = a.y + b.y;
                return out;
              };
              Vec2.subtract = function subtract(out, a, b) {
                out.x = a.x - b.x;
                out.y = a.y - b.y;
                return out;
              };
              Vec2.multiply = function multiply(out, a, b) {
                out.x = a.x * b.x;
                out.y = a.y * b.y;
                return out;
              };
              Vec2.divide = function divide(out, a, b) {
                out.x = a.x / b.x;
                out.y = a.y / b.y;
                return out;
              };
              Vec2.ceil = function ceil(out, a) {
                out.x = _ceil(a.x);
                out.y = _ceil(a.y);
                return out;
              };
              Vec2.floor = function floor(out, a) {
                out.x = _floor(a.x);
                out.y = _floor(a.y);
                return out;
              };
              Vec2.min = function min(out, a, b) {
                out.x = _min$1(a.x, b.x);
                out.y = _min$1(a.y, b.y);
                return out;
              };
              Vec2.max = function max(out, a, b) {
                out.x = _max$1(a.x, b.x);
                out.y = _max$1(a.y, b.y);
                return out;
              };
              Vec2.round = function round(out, a) {
                out.x = _round(a.x);
                out.y = _round(a.y);
                return out;
              };
              Vec2.multiplyScalar = function multiplyScalar(out, a, b) {
                out.x = a.x * b;
                out.y = a.y * b;
                return out;
              };
              Vec2.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
                out.x = a.x + b.x * scale;
                out.y = a.y + b.y * scale;
                return out;
              };
              Vec2.distance = function distance(a, b) {
                var x = b.x - a.x;
                var y = b.y - a.y;
                return sqrt$1(x * x + y * y);
              };
              Vec2.squaredDistance = function squaredDistance(a, b) {
                var x = b.x - a.x;
                var y = b.y - a.y;
                return x * x + y * y;
              };
              Vec2.len = function len(a) {
                var x = a.x;
                var y = a.y;
                return sqrt$1(x * x + y * y);
              };
              Vec2.lengthSqr = function lengthSqr(a) {
                var x = a.x;
                var y = a.y;
                return x * x + y * y;
              };
              Vec2.negate = function negate(out, a) {
                out.x = -a.x;
                out.y = -a.y;
                return out;
              };
              Vec2.inverse = function inverse(out, a) {
                out.x = 1.0 / a.x;
                out.y = 1.0 / a.y;
                return out;
              };
              Vec2.inverseSafe = function inverseSafe(out, a) {
                var x = a.x;
                var y = a.y;
                if (abs(x) < EPSILON$1) {
                  out.x = 0;
                } else {
                  out.x = 1.0 / x;
                }
                if (abs(y) < EPSILON$1) {
                  out.y = 0;
                } else {
                  out.y = 1.0 / y;
                }
                return out;
              };
              Vec2.normalize = function normalize(out, a) {
                var x = a.x;
                var y = a.y;
                var len = x * x + y * y;
                if (len > 0) {
                  len = 1 / sqrt$1(len);
                  out.x = x * len;
                  out.y = y * len;
                } else {
                  out.x = 0;
                  out.y = 0;
                }
                return out;
              };
              Vec2.dot = function dot(a, b) {
                return a.x * b.x + a.y * b.y;
              };
              Vec2.cross = function cross(out, a, b) {
                if (out instanceof Vec3) {
                  out.x = out.y = 0;
                  out.z = a.x * b.y - a.y * b.x;
                  return out;
                } else {
                  return out.x * a.y - out.y * a.x;
                }
              };
              Vec2.lerp = function lerp(out, a, b, t) {
                var x = a.x;
                var y = a.y;
                out.x = x + t * (b.x - x);
                out.y = y + t * (b.y - y);
                return out;
              };
              Vec2.random = function random$1(out, scale) {
                scale = scale || 1.0;
                var r = random() * 2.0 * PI;
                out.x = cos$1(r) * scale;
                out.y = sin(r) * scale;
                return out;
              };
              Vec2.transformMat3 = function transformMat3(out, a, m) {
                var x = a.x;
                var y = a.y;
                out.x = m.m00 * x + m.m03 * y + m.m06;
                out.y = m.m01 * x + m.m04 * y + m.m07;
                return out;
              };
              Vec2.transformMat4 = function transformMat4(out, a, m) {
                var x = a.x;
                var y = a.y;
                out.x = m.m00 * x + m.m04 * y + m.m12;
                out.y = m.m01 * x + m.m05 * y + m.m13;
                return out;
              };
              Vec2.str = function str(a) {
                return "Vec2(" + a.x + ", " + a.y + ")";
              };
              Vec2.toArray = function toArray(out, v, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out[ofs + 0] = v.x;
                out[ofs + 1] = v.y;
                return out;
              };
              Vec2.fromArray = function fromArray(out, arr, ofs) {
                if (ofs === undefined) {
                  ofs = 0;
                }
                out.x = arr[ofs + 0];
                out.y = arr[ofs + 1];
                return out;
              };
              Vec2.strictEquals = function strictEquals(a, b) {
                return a.x === b.x && a.y === b.y;
              };
              Vec2.equals = function equals(a, b, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return abs(a.x - b.x) <= epsilon * _max$1(1.0, abs(a.x), abs(b.x)) && abs(a.y - b.y) <= epsilon * _max$1(1.0, abs(a.y), abs(b.y));
              };
              Vec2.angle = function angle(a, b) {
                var magSqr1 = a.x * a.x + a.y * a.y;
                var magSqr2 = b.x * b.x + b.y * b.y;
                if (magSqr1 === 0 || magSqr2 === 0) {
                  return 0.0;
                }
                var dot = a.x * b.x + a.y * b.y;
                var cosine = dot / sqrt$1(magSqr1 * magSqr2);
                cosine = clamp(cosine, -1, 1.0);
                return acos$1(cosine);
              };
              function Vec2(x, y) {
                var _this;
                _this = _ValueType.call(this) || this;
                if (typeof x === 'object') {
                  _this.x = x.x;
                  _this.y = x.y;
                } else {
                  _this.x = x || 0;
                  _this.y = y || 0;
                }
                return _this;
              }
              var _proto = Vec2.prototype;
              _proto.clone = function clone() {
                return new Vec2(this.x, this.y);
              };
              _proto.set = function set(x, y) {
                if (typeof x === 'object') {
                  this.x = x.x;
                  this.y = x.y;
                } else {
                  this.x = x || 0;
                  this.y = y || 0;
                }
                return this;
              };
              _proto.equals = function equals(other, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return Vec2.equals(this, other, epsilon);
              };
              _proto.equals2f = function equals2f(x, y, epsilon) {
                if (epsilon === undefined) {
                  epsilon = EPSILON$1;
                }
                return abs(this.x - x) <= epsilon * _max$1(1.0, abs(this.x), abs(x)) && abs(this.y - y) <= epsilon * _max$1(1.0, abs(this.y), abs(y));
              };
              _proto.strictEquals = function strictEquals(other) {
                return other && this.x === other.x && this.y === other.y;
              };
              _proto.strictEquals2f = function strictEquals2f(x, y) {
                return this.x === x && this.y === y;
              };
              _proto.toString = function toString() {
                return "(" + this.x + ", " + this.y + ")";
              };
              _proto.lerp = function lerp(to, ratio) {
                var x = this.x;
                var y = this.y;
                this.x = x + ratio * (to.x - x);
                this.y = y + ratio * (to.y - y);
                return this;
              };
              _proto.clampf = function clampf(minInclusive, maxInclusive) {
                this.x = clamp(this.x, minInclusive.x, maxInclusive.x);
                this.y = clamp(this.y, minInclusive.y, maxInclusive.y);
                return this;
              };
              _proto.add = function add(other) {
                this.x += other.x;
                this.y += other.y;
                return this;
              };
              _proto.add2f = function add2f(x, y) {
                this.x += x;
                this.y += y;
                return this;
              };
              _proto.subtract = function subtract(other) {
                this.x -= other.x;
                this.y -= other.y;
                return this;
              };
              _proto.subtract2f = function subtract2f(x, y) {
                this.x -= x;
                this.y -= y;
                return this;
              };
              _proto.multiplyScalar = function multiplyScalar(scalar) {
                if (typeof scalar === 'object') {
                  warnID(16359);
                }
                this.x *= scalar;
                this.y *= scalar;
                return this;
              };
              _proto.multiply = function multiply(other) {
                if (typeof other !== 'object') {
                  warnID(16360);
                }
                this.x *= other.x;
                this.y *= other.y;
                return this;
              };
              _proto.multiply2f = function multiply2f(x, y) {
                this.x *= x;
                this.y *= y;
                return this;
              };
              _proto.divide = function divide(other) {
                this.x /= other.x;
                this.y /= other.y;
                return this;
              };
              _proto.divide2f = function divide2f(x, y) {
                this.x /= x;
                this.y /= y;
                return this;
              };
              _proto.negative = function negative() {
                this.x = -this.x;
                this.y = -this.y;
                return this;
              };
              _proto.dot = function dot(other) {
                return this.x * other.x + this.y * other.y;
              };
              _proto.cross = function cross(other) {
                return this.x * other.y - this.y * other.x;
              };
              _proto.length = function length() {
                return sqrt$1(this.x * this.x + this.y * this.y);
              };
              _proto.lengthSqr = function lengthSqr() {
                return this.x * this.x + this.y * this.y;
              };
              _proto.normalize = function normalize() {
                var self = this;
                var x = self.x;
                var y = self.y;
                var len = x * x + y * y;
                if (len > 0) {
                  len = 1 / sqrt$1(len);
                  self.x *= len;
                  self.y *= len;
                }
                return self;
              };
              _proto.angle = function angle(other) {
                var magSqr1 = this.lengthSqr();
                var magSqr2 = other.lengthSqr();
                if (magSqr1 === 0 || magSqr2 === 0) {
                  return 0.0;
                }
                var dot = this.dot(other);
                var cosine = dot / sqrt$1(magSqr1 * magSqr2);
                cosine = clamp(cosine, -1, 1.0);
                return acos$1(cosine);
              };
              _proto.signAngle = function signAngle(other) {
                var cross = this.cross(other);
                var dot = this.dot(other);
                return atan2(cross, dot);
              };
              _proto.rotate = function rotate(radians) {
                var x = this.x;
                var y = this.y;
                var s = sin(radians);
                var c = cos$1(radians);
                this.x = c * x - s * y;
                this.y = s * x + c * y;
                return this;
              };
              _proto.project = function project(other) {
                var scalar = this.dot(other) / other.dot(other);
                this.x = other.x * scalar;
                this.y = other.y * scalar;
                return this;
              };
              _proto.transformMat4 = function transformMat4(matrix) {
                var x = this.x;
                var y = this.y;
                this.x = matrix.m00 * x + matrix.m04 * y + matrix.m12;
                this.y = matrix.m01 * x + matrix.m05 * y + matrix.m13;
                return this;
              };
              _proto.toVec3 = function toVec3() {
                return new Vec3(this.x, this.y, 0);
              };
              return Vec2;
            }(ValueType));
            Vec2.ZERO = freezeVec2(0, 0);
            Vec2.ONE = freezeVec2(1, 1);
            Vec2.NEG_ONE = freezeVec2(-1, -1);
            Vec2.UNIT_X = freezeVec2(1, 0);
            Vec2.UNIT_Y = freezeVec2(0, 1);
            CCClass.fastDefine('cc.Vec2', Vec2, {
              x: 0,
              y: 0
            });
            legacyCC.Vec2 = Vec2;
            function v2$1(x, y) {
              return new Vec2(x, y);
            }
            legacyCC.v2 = v2$1;

            replaceProperty(Vec2, 'Vec2', [{
              name: 'sub',
              newName: 'subtract',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'div',
              newName: 'divide',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'dist',
              newName: 'distance',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'sqrDist',
              newName: 'squaredDistance',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'mag',
              newName: 'len',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec2,
              targetName: 'Vec2'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec2,
              targetName: 'Vec2'
            }]);
            replaceProperty(Vec2.prototype, 'Vec2', [{
              name: 'mag',
              newName: 'length',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }, {
              name: 'magSqr',
              newName: 'lengthSqr',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec2.prototype,
              targetName: 'Vec2'
            }]);
            replaceProperty(Vec3, 'Vec3', [{
              name: 'sub',
              newName: 'subtract',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'div',
              newName: 'divide',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'dist',
              newName: 'distance',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'sqrDist',
              newName: 'squaredDistance',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'mag',
              newName: 'len',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec3,
              targetName: 'Vec3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec3,
              targetName: 'Vec3'
            }]);
            replaceProperty(Vec3.prototype, 'Vec3', [{
              name: 'mag',
              newName: 'length',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }, {
              name: 'magSqr',
              newName: 'lengthSqr',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec3.prototype,
              targetName: 'Vec3'
            }]);
            replaceProperty(Vec4, 'Vec4', [{
              name: 'sub',
              newName: 'subtract',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'div',
              newName: 'divide',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'dist',
              newName: 'distance',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'sqrDist',
              newName: 'squaredDistance',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'mag',
              newName: 'len',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec4,
              targetName: 'Vec4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec4,
              targetName: 'Vec4'
            }]);
            replaceProperty(Vec4.prototype, 'Vec4', [{
              name: 'mag',
              newName: 'length',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }, {
              name: 'magSqr',
              newName: 'lengthSqr',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Vec4.prototype,
              targetName: 'Vec4'
            }]);
            replaceProperty(Quat, 'Quat', [{
              name: 'mag',
              newName: 'len',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'sqrMag',
              newName: 'lengthSqr',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'scale',
              newName: 'multiplyScalar',
              target: Quat,
              targetName: 'Quat'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Quat,
              targetName: 'Quat'
            }]);
            replaceProperty(Quat.prototype, 'Quat', [{
              name: 'scale',
              newName: 'multiplyScalar',
              target: Quat.prototype,
              targetName: 'Quat'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Quat.prototype,
              targetName: 'Quat'
            }]);
            replaceProperty(Color, 'Color', [{
              name: 'sub',
              newName: 'subtract',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'div',
              newName: 'divide',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Color,
              targetName: 'Color'
            }, {
              name: 'fromHex',
              newName: 'fromHEX',
              customFunction: function customFunction() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var arg1 = args[1].toString(16);
                return legacyCC.Color.fromHEX(args[0], arg1);
              }
            }]);
            replaceProperty(Mat3, 'Mat3', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat3,
              targetName: 'Mat3'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat3,
              targetName: 'Mat3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat3,
              targetName: 'Mat3'
            }, {
              name: 'transfrom',
              newName: 'transform',
              target: Mat3,
              targetName: 'Mat3'
            }]);
            replaceProperty(Mat3.prototype, 'Mat3', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }, {
              name: 'mulScalar',
              newName: 'multiplyScalar',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat3.prototype,
              targetName: 'Mat3'
            }]);
            replaceProperty(Mat4, 'Mat4', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat4,
              targetName: 'Mat4'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat4,
              targetName: 'Mat4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat4,
              targetName: 'Mat4'
            }]);
            replaceProperty(Mat4.prototype, 'Mat4', [{
              name: 'sub',
              newName: 'subtract',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }, {
              name: 'mul',
              newName: 'multiply',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }, {
              name: 'mulScalar',
              newName: 'multiplyScalar',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }, {
              name: 'exactEquals',
              newName: 'strictEquals',
              target: Mat4.prototype,
              targetName: 'Mat4'
            }]);

            var _class$S;
            var Size = exports("Size", function (_ValueType) {
              _inheritsLoose(Size, _ValueType);
              Size.lerp = function lerp(out, from, to, ratio) {
                out.width = from.width + (to.width - from.width) * ratio;
                out.height = from.height + (to.height - from.height) * ratio;
                return out;
              };
              Size.equals = function equals(a, b) {
                return a.width === b.width && a.height === b.height;
              };
              function Size(width, height) {
                var _this;
                _this = _ValueType.call(this) || this;
                if (typeof width === 'object') {
                  _this.width = width.width;
                  _this.height = width.height;
                } else {
                  _this.width = width || 0;
                  _this.height = height || 0;
                }
                return _this;
              }
              var _proto = Size.prototype;
              _proto.clone = function clone() {
                return new Size(this.width, this.height);
              };
              _proto.set = function set(width, height) {
                if (typeof width === 'object') {
                  this.height = width.height;
                  this.width = width.width;
                } else {
                  this.width = width || 0;
                  this.height = height || 0;
                }
                return this;
              };
              _proto.equals = function equals(other) {
                return this.width === other.width && this.height === other.height;
              };
              _proto.lerp = function lerp(to, ratio) {
                this.width += (to.width - this.width) * ratio;
                this.height += (to.height - this.height) * ratio;
                return this;
              };
              _proto.toString = function toString() {
                return "(" + this.width + ", " + this.height + ")";
              };
              _createClass(Size, [{
                key: "x",
                get: function get() {
                  return this.width;
                },
                set: function set(val) {
                  this.width = val;
                }
              }, {
                key: "y",
                get: function get() {
                  return this.height;
                },
                set: function set(val) {
                  this.height = val;
                }
              }]);
              return Size;
            }(ValueType));
            _class$S = Size;
            Size.ZERO = Object.freeze(new _class$S(0, 0));
            Size.ONE = Object.freeze(new _class$S(1, 1));
            CCClass.fastDefine('cc.Size', Size, {
              width: 0,
              height: 0
            });
            function size(width, height) {
              if (width === undefined) {
                width = 0;
              }
              if (height === undefined) {
                height = 0;
              }
              return new Size(width, height);
            }
            legacyCC.size = size;
            legacyCC.Size = Size;

            var max$4 = Math.max;
            var min$3 = Math.min;
            var Rect = exports("Rect", function (_ValueType) {
              _inheritsLoose(Rect, _ValueType);
              Rect.fromMinMax = function fromMinMax(out, v1, v2) {
                var minX = min$3(v1.x, v2.x);
                var minY = min$3(v1.y, v2.y);
                var maxX = max$4(v1.x, v2.x);
                var maxY = max$4(v1.y, v2.y);
                out.x = minX;
                out.y = minY;
                out.width = maxX - minX;
                out.height = maxY - minY;
                return out;
              };
              Rect.lerp = function lerp(out, from, to, ratio) {
                var x = from.x;
                var y = from.y;
                var w = from.width;
                var h = from.height;
                out.x = x + (to.x - x) * ratio;
                out.y = y + (to.y - y) * ratio;
                out.width = w + (to.width - w) * ratio;
                out.height = h + (to.height - h) * ratio;
                return out;
              };
              Rect.intersection = function intersection(out, one, other) {
                var axMin = one.x;
                var ayMin = one.y;
                var axMax = one.x + one.width;
                var ayMax = one.y + one.height;
                var bxMin = other.x;
                var byMin = other.y;
                var bxMax = other.x + other.width;
                var byMax = other.y + other.height;
                out.x = max$4(axMin, bxMin);
                out.y = max$4(ayMin, byMin);
                out.width = min$3(axMax, bxMax) - out.x;
                out.height = min$3(ayMax, byMax) - out.y;
                return out;
              };
              Rect.union = function union(out, one, other) {
                var x = one.x;
                var y = one.y;
                var w = one.width;
                var h = one.height;
                var bx = other.x;
                var by = other.y;
                var bw = other.width;
                var bh = other.height;
                out.x = min$3(x, bx);
                out.y = min$3(y, by);
                out.width = max$4(x + w, bx + bw) - out.x;
                out.height = max$4(y + h, by + bh) - out.y;
                return out;
              };
              Rect.equals = function equals(a, b) {
                return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
              };
              function Rect(x, y, width, height) {
                var _this;
                _this = _ValueType.call(this) || this;
                if (typeof x === 'object') {
                  _this.x = x.x;
                  _this.y = x.y;
                  _this.width = x.width;
                  _this.height = x.height;
                } else {
                  _this.x = x || 0;
                  _this.y = y || 0;
                  _this.width = width || 0;
                  _this.height = height || 0;
                }
                return _this;
              }
              var _proto = Rect.prototype;
              _proto.clone = function clone() {
                return new Rect(this.x, this.y, this.width, this.height);
              };
              _proto.set = function set(x, y, width, height) {
                var self = this;
                if (typeof x === 'object') {
                  self.x = x.x;
                  self.y = x.y;
                  self.width = x.width;
                  self.height = x.height;
                } else {
                  self.x = x || 0;
                  self.y = y || 0;
                  self.width = width || 0;
                  self.height = height || 0;
                }
                return self;
              };
              _proto.equals = function equals(other) {
                var self = this;
                return self.x === other.x && self.y === other.y && self.width === other.width && self.height === other.height;
              };
              _proto.lerp = function lerp(to, ratio) {
                var self = this;
                var x = self.x;
                var y = self.y;
                var w = self.width;
                var h = self.height;
                self.x = x + (to.x - x) * ratio;
                self.y = y + (to.y - y) * ratio;
                self.width = w + (to.width - w) * ratio;
                self.height = h + (to.height - h) * ratio;
                return self;
              };
              _proto.toString = function toString() {
                var self = this;
                return "(" + self.x + ", " + self.y + ", " + self.width + ", " + self.height + ")";
              };
              _proto.intersects = function intersects(other) {
                var self = this;
                var maxax = self.x + self.width;
                var maxay = self.y + self.height;
                var maxbx = other.x + other.width;
                var maxby = other.y + other.height;
                return !(maxax < other.x || maxbx < self.x || maxay < other.y || maxby < self.y);
              };
              _proto.contains = function contains(point) {
                var self = this;
                return self.x <= point.x && self.x + self.width >= point.x && self.y <= point.y && self.y + self.height >= point.y;
              };
              _proto.containsRect = function containsRect(other) {
                var self = this;
                return self.x <= other.x && self.x + self.width >= other.x + other.width && self.y <= other.y && self.y + self.height >= other.y + other.height;
              };
              _proto.transformMat4 = function transformMat4(mat) {
                var self = this;
                var ol = self.x;
                var ob = self.y;
                var or = ol + self.width;
                var ot = ob + self.height;
                var lbx = mat.m00 * ol + mat.m04 * ob + mat.m12;
                var lby = mat.m01 * ol + mat.m05 * ob + mat.m13;
                var rbx = mat.m00 * or + mat.m04 * ob + mat.m12;
                var rby = mat.m01 * or + mat.m05 * ob + mat.m13;
                var ltx = mat.m00 * ol + mat.m04 * ot + mat.m12;
                var lty = mat.m01 * ol + mat.m05 * ot + mat.m13;
                var rtx = mat.m00 * or + mat.m04 * ot + mat.m12;
                var rty = mat.m01 * or + mat.m05 * ot + mat.m13;
                var minX = min$3(lbx, rbx, ltx, rtx);
                var maxX = max$4(lbx, rbx, ltx, rtx);
                var minY = min$3(lby, rby, lty, rty);
                var maxY = max$4(lby, rby, lty, rty);
                self.x = minX;
                self.y = minY;
                self.width = maxX - minX;
                self.height = maxY - minY;
                return self;
              };
              _proto.transformMat4ToPoints = function transformMat4ToPoints(mat, out_lb, out_lt, out_rt, out_rb) {
                var self = this;
                var ol = self.x;
                var ob = self.y;
                var or = ol + self.width;
                var ot = ob + self.height;
                out_lb.x = mat.m00 * ol + mat.m04 * ob + mat.m12;
                out_lb.y = mat.m01 * ol + mat.m05 * ob + mat.m13;
                out_rb.x = mat.m00 * or + mat.m04 * ob + mat.m12;
                out_rb.y = mat.m01 * or + mat.m05 * ob + mat.m13;
                out_lt.x = mat.m00 * ol + mat.m04 * ot + mat.m12;
                out_lt.y = mat.m01 * ol + mat.m05 * ot + mat.m13;
                out_rt.x = mat.m00 * or + mat.m04 * ot + mat.m12;
                out_rt.y = mat.m01 * or + mat.m05 * ot + mat.m13;
              };
              _createClass(Rect, [{
                key: "xMin",
                get: function get() {
                  return this.x;
                },
                set: function set(value) {
                  this.width += this.x - value;
                  this.x = value;
                }
              }, {
                key: "yMin",
                get: function get() {
                  return this.y;
                },
                set: function set(value) {
                  this.height += this.y - value;
                  this.y = value;
                }
              }, {
                key: "xMax",
                get: function get() {
                  return this.x + this.width;
                },
                set: function set(value) {
                  this.width = value - this.x;
                }
              }, {
                key: "yMax",
                get: function get() {
                  return this.y + this.height;
                },
                set: function set(value) {
                  this.height = value - this.y;
                }
              }, {
                key: "center",
                get: function get() {
                  return new Vec2(this.x + this.width * 0.5, this.y + this.height * 0.5);
                },
                set: function set(value) {
                  this.x = value.x - this.width * 0.5;
                  this.y = value.y - this.height * 0.5;
                }
              }, {
                key: "origin",
                get: function get() {
                  return new Vec2(this.x, this.y);
                },
                set: function set(value) {
                  this.x = value.x;
                  this.y = value.y;
                }
              }, {
                key: "size",
                get: function get() {
                  return new Size(this.width, this.height);
                },
                set: function set(value) {
                  this.width = value.width;
                  this.height = value.height;
                }
              }, {
                key: "z",
                get: function get() {
                  return this.width;
                },
                set: function set(val) {
                  this.width = val;
                }
              }, {
                key: "w",
                get: function get() {
                  return this.height;
                },
                set: function set(val) {
                  this.height = val;
                }
              }]);
              return Rect;
            }(ValueType));
            CCClass.fastDefine('cc.Rect', Rect, {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            });
            legacyCC.Rect = Rect;
            function rect(x, y, width, height) {
              if (x === undefined) {
                x = 0;
              }
              if (y === undefined) {
                y = 0;
              }
              if (width === undefined) {
                width = 0;
              }
              if (height === undefined) {
                height = 0;
              }
              return new Rect(x, y, width, height);
            }
            legacyCC.rect = rect;

            var MATH_FLOAT_ARRAY = exports("MATH_FLOAT_ARRAY", Float64Array);
            var MathBase = exports("MathBase", function (_ValueType) {
              _inheritsLoose(MathBase, _ValueType);
              function MathBase() {
                return _ValueType.apply(this, arguments) || this;
              }
              MathBase.createFloatArray = function createFloatArray(size) {
                return new MATH_FLOAT_ARRAY(size);
              };
              _createClass(MathBase, [{
                key: "array",
                get: function get() {
                  return this._array;
                }
              }]);
              return MathBase;
            }(ValueType));

            var math = /*#__PURE__*/Object.freeze({
                __proto__: null,
                Color: Color,
                EPSILON: EPSILON$1,
                HALF_PI: HALF_PI,
                MATH_FLOAT_ARRAY: MATH_FLOAT_ARRAY,
                Mat3: Mat3,
                Mat4: Mat4,
                MathBase: MathBase,
                Quat: Quat,
                Rect: Rect,
                Size: Size,
                TWO_PI: TWO_PI,
                Vec2: Vec2,
                Vec3: Vec3,
                Vec4: Vec4,
                absMax: absMax,
                absMaxComponent: absMaxComponent,
                approx: approx,
                bits: bits,
                clamp: clamp,
                clamp01: clamp01,
                color: color,
                enumerableProps: enumerableProps,
                equals: equals,
                floatToHalf: floatToHalf,
                halfToFloat: halfToFloat,
                inverseLerp: inverseLerp,
                lerp: lerp,
                mat4: mat4,
                nextPow2: nextPow2,
                pingPong: pingPong,
                preTransforms: preTransforms,
                pseudoRandom: pseudoRandom,
                pseudoRandomRange: pseudoRandomRange,
                pseudoRandomRangeInt: pseudoRandomRangeInt,
                quat: quat,
                random: random,
                randomRange: randomRange,
                randomRangeInt: randomRangeInt,
                rect: rect,
                repeat: repeat$2,
                setRandGenerator: setRandGenerator,
                size: size,
                toDegree: toDegree,
                toRadian: toRadian,
                v2: v2$1,
                v3: v3,
                v4: v4
            });
            exports("math", math);

            var X = new Vec3();
            var Y = new Vec3();
            var Z = new Vec3();
            var d = new Vec3();
            var min$2 = new Vec3();
            var max$3 = new Vec3();
            var u = new Array(3);
            var e = new Array(3);
            function point_plane(point, plane_) {
              return Vec3.dot(plane_.n, point) - plane_.d;
            }
            function pt_point_plane(out, point, plane_) {
              var t = point_plane(point, plane_);
              return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
            }
            function pt_point_aabb(out, point, aabb_) {
              Vec3.copy(out, point);
              Vec3.subtract(min$2, aabb_.center, aabb_.halfExtents);
              Vec3.add(max$3, aabb_.center, aabb_.halfExtents);
              out.x = out.x < min$2.x ? min$2.x : out.x;
              out.y = out.y < min$2.y ? min$2.y : out.y;
              out.z = out.z < min$2.z ? min$2.z : out.z;
              out.x = out.x > max$3.x ? max$3.x : out.x;
              out.y = out.y > max$3.y ? max$3.y : out.y;
              out.z = out.z > max$3.z ? max$3.z : out.z;
              return out;
            }
            function pt_point_obb(out, point, obb_) {
              Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02);
              Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05);
              Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08);
              u[0] = X;
              u[1] = Y;
              u[2] = Z;
              e[0] = obb_.halfExtents.x;
              e[1] = obb_.halfExtents.y;
              e[2] = obb_.halfExtents.z;
              Vec3.subtract(d, point, obb_.center);
              Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);
              for (var i = 0; i < 3; i++) {
                var dist = Vec3.dot(d, u[i]);
                if (dist > e[i]) {
                  dist = e[i];
                }
                if (dist < -e[i]) {
                  dist = -e[i];
                }
                out.x += dist * u[i].x;
                out.y += dist * u[i].y;
                out.z += dist * u[i].z;
              }
              return out;
            }
            function pt_point_line(out, point, linePointA, linePointB) {
              Vec3.subtract(X, linePointA, linePointB);
              var dir = X.clone();
              var dirSquaredLength = Vec3.lengthSqr(dir);
              if (dirSquaredLength === 0) {
                Vec3.copy(out, linePointA);
              } else {
                Vec3.subtract(X, point, linePointA);
                var t = Vec3.dot(X, dir) / dirSquaredLength;
                if (t < 0) {
                  Vec3.copy(out, linePointA);
                } else if (t > 1) {
                  Vec3.copy(out, linePointB);
                } else {
                  Vec3.scaleAndAdd(out, linePointA, dir, t);
                }
              }
            }

            var distance = /*#__PURE__*/Object.freeze({
                __proto__: null,
                point_plane: point_plane,
                pt_point_aabb: pt_point_aabb,
                pt_point_line: pt_point_line,
                pt_point_obb: pt_point_obb,
                pt_point_plane: pt_point_plane
            });

            var Line = function () {
              Line.create = function create(sx, sy, sz, ex, ey, ez) {
                return new Line(sx, sy, sz, ex, ey, ez);
              };
              Line.clone = function clone(a) {
                return new Line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
              };
              Line.copy = function copy(out, a) {
                Vec3.copy(out.s, a.s);
                Vec3.copy(out.e, a.e);
                return out;
              };
              Line.fromPoints = function fromPoints(out, start, end) {
                Vec3.copy(out.s, start);
                Vec3.copy(out.e, end);
                return out;
              };
              Line.set = function set(out, sx, sy, sz, ex, ey, ez) {
                out.s.x = sx;
                out.s.y = sy;
                out.s.z = sz;
                out.e.x = ex;
                out.e.y = ey;
                out.e.z = ez;
                return out;
              };
              Line.len = function len(a) {
                return Vec3.distance(a.s, a.e);
              };
              function Line(sx, sy, sz, ex, ey, ez) {
                if (sx === undefined) {
                  sx = 0;
                }
                if (sy === undefined) {
                  sy = 0;
                }
                if (sz === undefined) {
                  sz = 0;
                }
                if (ex === undefined) {
                  ex = 0;
                }
                if (ey === undefined) {
                  ey = 0;
                }
                if (ez === undefined) {
                  ez = -1;
                }
                this.s = undefined;
                this.e = undefined;
                this._type = undefined;
                this._type = 2;
                this.s = new Vec3(sx, sy, sz);
                this.e = new Vec3(ex, ey, ez);
              }
              var _proto = Line.prototype;
              _proto.length = function length() {
                return Vec3.distance(this.s, this.e);
              };
              _createClass(Line, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }]);
              return Line;
            }();

            var Ray = function () {
              Ray.create = function create(ox, oy, oz, dx, dy, dz) {
                if (ox === undefined) {
                  ox = 0;
                }
                if (oy === undefined) {
                  oy = 0;
                }
                if (oz === undefined) {
                  oz = 0;
                }
                if (dx === undefined) {
                  dx = 0;
                }
                if (dy === undefined) {
                  dy = 0;
                }
                if (dz === undefined) {
                  dz = 1;
                }
                return new Ray(ox, oy, oz, dx, dy, dz);
              };
              Ray.clone = function clone(a) {
                return new Ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
              };
              Ray.copy = function copy(out, a) {
                Vec3.copy(out.o, a.o);
                Vec3.copy(out.d, a.d);
                return out;
              };
              Ray.fromPoints = function fromPoints(out, origin, target) {
                Vec3.copy(out.o, origin);
                Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin));
                return out;
              };
              Ray.set = function set(out, ox, oy, oz, dx, dy, dz) {
                out.o.x = ox;
                out.o.y = oy;
                out.o.z = oz;
                out.d.x = dx;
                out.d.y = dy;
                out.d.z = dz;
                return out;
              };
              function Ray(ox, oy, oz, dx, dy, dz) {
                if (ox === undefined) {
                  ox = 0;
                }
                if (oy === undefined) {
                  oy = 0;
                }
                if (oz === undefined) {
                  oz = 0;
                }
                if (dx === undefined) {
                  dx = 0;
                }
                if (dy === undefined) {
                  dy = 0;
                }
                if (dz === undefined) {
                  dz = -1;
                }
                this._type = 1;
                this.o = new Vec3(ox, oy, oz);
                this.d = new Vec3(dx, dy, dz);
              }
              var _proto = Ray.prototype;
              _proto.computeHit = function computeHit(out, distance) {
                Vec3.normalize(out, this.d);
                Vec3.scaleAndAdd(out, this.o, out, distance);
              };
              _createClass(Ray, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }]);
              return Ray;
            }();

            var _v3_tmp$2 = new Vec3();
            var _offset = new Vec3();
            var _min = new Vec3();
            var _max = new Vec3();
            function maxComponent(v) {
              return Math.max(Math.max(v.x, v.y), v.z);
            }
            var Sphere = function () {
              Sphere.create = function create(cx, cy, cz, r) {
                return new Sphere(cx, cy, cz, r);
              };
              Sphere.clone = function clone(p) {
                return new Sphere(p.center.x, p.center.y, p.center.z, p.radius);
              };
              Sphere.copy = function copy(out, p) {
                Vec3.copy(out.center, p.center);
                out.radius = p.radius;
                return out;
              };
              Sphere.fromPoints = function fromPoints(out, minPos, maxPos) {
                Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), 0.5);
                out.radius = Vec3.subtract(_v3_tmp$2, maxPos, minPos).length() * 0.5;
                return out;
              };
              Sphere.set = function set(out, cx, cy, cz, r) {
                out.center.x = cx;
                out.center.y = cy;
                out.center.z = cz;
                out.radius = r;
                return out;
              };
              function Sphere(cx, cy, cz, r) {
                if (cx === undefined) {
                  cx = 0;
                }
                if (cy === undefined) {
                  cy = 0;
                }
                if (cz === undefined) {
                  cz = 0;
                }
                if (r === undefined) {
                  r = 1;
                }
                this._type = 4;
                this._center = new Vec3(cx, cy, cz);
                this._radius = r;
              }
              var _proto = Sphere.prototype;
              _proto.destroy = function destroy() {};
              _proto.clone = function clone() {
                return Sphere.clone(this);
              };
              _proto.copy = function copy(a) {
                return Sphere.copy(this, a);
              };
              _proto.getBoundary = function getBoundary(minPos, maxPos) {
                Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius);
                Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
              };
              _proto.transform = function transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m);
                out.radius = this.radius * maxComponent(scale);
              };
              _proto.translateAndRotate = function translateAndRotate(m, rot, out) {
                Vec3.transformMat4(out.center, this.center, m);
              };
              _proto.setScale = function setScale(scale, out) {
                out.radius = this.radius * maxComponent(scale);
              };
              _proto.mergePoint = function mergePoint(point) {
                if (this.radius < 0.0) {
                  this.center.set(point);
                  this.radius = 0.0;
                }
                Vec3.subtract(_offset, point, this.center);
                var dist = _offset.length();
                if (dist > this.radius) {
                  var half = (dist - this.radius) * 0.5;
                  this.radius += half;
                  Vec3.multiplyScalar(_offset, _offset, half / dist);
                  Vec3.add(this.center, this.center, _offset);
                }
              };
              _proto.mergePoints = function mergePoints(points) {
                var length = points.length;
                if (length < 1) return;
                this.radius = -1;
                for (var i = 0; i < length; i++) {
                  this.mergePoint(points[i]);
                }
              };
              _proto.mergeAABB = function mergeAABB(a) {
                a.getBoundary(_min, _max);
                this.mergePoint(_min);
                this.mergePoint(_max);
              };
              _createClass(Sphere, [{
                key: "center",
                get: function get() {
                  return this._center;
                },
                set: function set(val) {
                  this._center = val;
                }
              }, {
                key: "radius",
                get: function get() {
                  return this._radius;
                },
                set: function set(val) {
                  this._radius = val;
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                }
              }]);
              return Sphere;
            }();

            var vec3SquaredDistance = Vec3.squaredDistance;
            var vec3Subtract$1 = Vec3.subtract;
            var vec3Dot = Vec3.dot;
            var vec3Set$1 = Vec3.set;
            var vec3Cross = Vec3.cross;
            var vec3MultiplyScalar$2 = Vec3.multiplyScalar;
            var vec3Copy = Vec3.copy;
            var vec3Add$2 = Vec3.add;
            var vec3ScaleAndAdd = Vec3.scaleAndAdd;
            var mathMax = Math.max;
            var mathMin = Math.min;
            var mathAbs$2 = Math.abs;
            var rayPlane = function () {
              return function (ray, plane) {
                var denom = vec3Dot(ray.d, plane.n);
                if (mathAbs$2(denom) < Number.EPSILON) {
                  return 0;
                }
                var d = point_plane(ray.o, plane);
                var t = -d / denom;
                if (t < 0) {
                  return 0;
                }
                return t;
              };
            }();
            var rayTriangle = function () {
              var ab = v3();
              var ac = v3();
              var pvec = v3();
              var tvec = v3();
              var qvec = v3();
              return function (ray, triangle, doubleSided) {
                vec3Subtract$1(ab, triangle.b, triangle.a);
                vec3Subtract$1(ac, triangle.c, triangle.a);
                vec3Cross(pvec, ray.d, ac);
                var det = vec3Dot(ab, pvec);
                if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) {
                  return 0;
                }
                var inv_det = 1 / det;
                vec3Subtract$1(tvec, ray.o, triangle.a);
                var u = vec3Dot(tvec, pvec) * inv_det;
                if (u < 0 || u > 1) {
                  return 0;
                }
                vec3Cross(qvec, tvec, ab);
                var v = vec3Dot(ray.d, qvec) * inv_det;
                if (v < 0 || u + v > 1) {
                  return 0;
                }
                var t = vec3Dot(ac, qvec) * inv_det;
                return t < 0 ? 0 : t;
              };
            }();
            var raySphere = function () {
              var e = v3();
              return function (ray, sphere) {
                var r = sphere.radius;
                var c = sphere.center;
                var o = ray.o;
                var d = ray.d;
                var rSq = r * r;
                vec3Subtract$1(e, c, o);
                var eSq = e.lengthSqr();
                var aLength = vec3Dot(e, d);
                var fSq = rSq - (eSq - aLength * aLength);
                if (fSq < 0) {
                  return 0;
                }
                var f = Math.sqrt(fSq);
                var t = eSq < rSq ? aLength + f : aLength - f;
                if (t < 0) {
                  return 0;
                }
                return t;
              };
            }();
            var rayAABB = function () {
              var min = v3();
              var max = v3();
              return function (ray, aabb) {
                vec3Subtract$1(min, aabb.center, aabb.halfExtents);
                vec3Add$2(max, aabb.center, aabb.halfExtents);
                return rayAABB2$1(ray, min, max);
              };
            }();
            function rayAABB2$1(ray, min, max) {
              var o = ray.o;
              var d = ray.d;
              var ix = 1 / d.x;
              var iy = 1 / d.y;
              var iz = 1 / d.z;
              var t1 = (min.x - o.x) * ix;
              var t2 = (max.x - o.x) * ix;
              var t3 = (min.y - o.y) * iy;
              var t4 = (max.y - o.y) * iy;
              var t5 = (min.z - o.z) * iz;
              var t6 = (max.z - o.z) * iz;
              var tmin = mathMax(mathMax(mathMin(t1, t2), mathMin(t3, t4)), mathMin(t5, t6));
              var tmax = mathMin(mathMin(mathMax(t1, t2), mathMax(t3, t4)), mathMax(t5, t6));
              if (tmax < 0 || tmin > tmax) {
                return 0;
              }
              return tmin > 0 ? tmin : tmax;
            }
            var rayOBB = function () {
              var center = v3();
              var o = v3();
              var d = v3();
              var X = v3();
              var Y = v3();
              var Z = v3();
              var p = v3();
              var size = new Array(3);
              var f = new Array(3);
              var e = new Array(3);
              var t = new Array(6);
              return function (ray, obb) {
                var halfExtents = obb.halfExtents;
                var orientation = obb.orientation;
                size[0] = halfExtents.x;
                size[1] = halfExtents.y;
                size[2] = halfExtents.z;
                center = obb.center;
                o = ray.o;
                d = ray.d;
                vec3Set$1(X, orientation.m00, orientation.m01, orientation.m02);
                vec3Set$1(Y, orientation.m03, orientation.m04, orientation.m05);
                vec3Set$1(Z, orientation.m06, orientation.m07, orientation.m08);
                vec3Subtract$1(p, center, o);
                f[0] = vec3Dot(X, d);
                f[1] = vec3Dot(Y, d);
                f[2] = vec3Dot(Z, d);
                e[0] = vec3Dot(X, p);
                e[1] = vec3Dot(Y, p);
                e[2] = vec3Dot(Z, p);
                for (var i = 0; i < 3; ++i) {
                  if (f[i] === 0) {
                    if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) {
                      return 0;
                    }
                    f[i] = 0.0000001;
                  }
                  t[i * 2 + 0] = (e[i] + size[i]) / f[i];
                  t[i * 2 + 1] = (e[i] - size[i]) / f[i];
                }
                var tmin = mathMax(mathMax(mathMin(t[0], t[1]), mathMin(t[2], t[3])), mathMin(t[4], t[5]));
                var tmax = mathMin(mathMin(mathMax(t[0], t[1]), mathMax(t[2], t[3])), mathMax(t[4], t[5]));
                if (tmax < 0 || tmin > tmax) {
                  return 0;
                }
                return tmin > 0 ? tmin : tmax;
              };
            }();
            var rayCapsule = function () {
              var v3_0 = v3();
              var v3_1 = v3();
              var v3_2 = v3();
              var v3_3 = v3();
              var v3_4 = v3();
              var v3_5 = v3();
              var v3_6 = v3();
              var sphere_0 = new Sphere();
              return function (ray, capsule) {
                var A = capsule.ellipseCenter0;
                var B = capsule.ellipseCenter1;
                var BA = vec3Subtract$1(v3_1, B, A);
                if (BA.length() < EPSILON$1) {
                  sphere_0.radius = capsule.radius;
                  sphere_0.center.set(capsule.ellipseCenter0);
                  return intersect.raySphere(ray, sphere_0);
                }
                var O = ray.o;
                var OA = vec3Subtract$1(v3_2, O, A);
                var vRayNorm = Vec3.normalize(v3_0, ray.d);
                var VxBA = vec3Cross(v3_3, vRayNorm, BA);
                var a = VxBA.lengthSqr();
                if (a === 0) {
                  sphere_0.radius = capsule.radius;
                  var BO = vec3Subtract$1(v3_4, B, O);
                  if (OA.lengthSqr() < BO.lengthSqr()) {
                    sphere_0.center.set(A);
                  } else {
                    sphere_0.center.set(B);
                  }
                  return intersect.raySphere(ray, sphere_0);
                }
                var OAxBA = vec3Cross(v3_4, OA, BA);
                var ab2 = BA.lengthSqr();
                var b = 2 * vec3Dot(VxBA, OAxBA);
                var radiusSqr = capsule.radius * capsule.radius;
                var c = OAxBA.lengthSqr() - radiusSqr * ab2;
                var d = b * b - 4 * a * c;
                if (d < 0) {
                  return 0;
                }
                var t = (-b - Math.sqrt(d)) / (2 * a);
                if (t < 0) {
                  sphere_0.radius = capsule.radius;
                  var _BO = vec3Subtract$1(v3_5, B, O);
                  if (OA.lengthSqr() < _BO.lengthSqr()) {
                    sphere_0.center.set(capsule.ellipseCenter0);
                  } else {
                    sphere_0.center.set(capsule.ellipseCenter1);
                  }
                  return intersect.raySphere(ray, sphere_0);
                } else {
                  var iPos = vec3ScaleAndAdd(v3_5, ray.o, vRayNorm, t);
                  var iPosLen = vec3Subtract$1(v3_6, iPos, A);
                  var tLimit = vec3Dot(iPosLen, BA) / ab2;
                  if (tLimit >= 0 && tLimit <= 1) {
                    return t;
                  } else if (tLimit < 0) {
                    sphere_0.radius = capsule.radius;
                    sphere_0.center.set(capsule.ellipseCenter0);
                    return intersect.raySphere(ray, sphere_0);
                  } else if (tLimit > 1) {
                    sphere_0.radius = capsule.radius;
                    sphere_0.center.set(capsule.ellipseCenter1);
                    return intersect.raySphere(ray, sphere_0);
                  } else {
                    return 0;
                  }
                }
              };
            }();
            var linePlane = function () {
              var ab = v3();
              return function (line, plane) {
                vec3Subtract$1(ab, line.e, line.s);
                var t = -point_plane(line.s, plane) / vec3Dot(ab, plane.n);
                if (t < 0 || t > 1) {
                  return 0;
                }
                return t;
              };
            }();
            var lineTriangle = function () {
              var ab = v3();
              var ac = v3();
              var qp = v3();
              var ap = v3();
              var n = v3();
              var e = v3();
              return function (line, triangle, outPt) {
                vec3Subtract$1(ab, triangle.b, triangle.a);
                vec3Subtract$1(ac, triangle.c, triangle.a);
                vec3Subtract$1(qp, line.s, line.e);
                vec3Cross(n, ab, ac);
                var det = vec3Dot(qp, n);
                if (det <= 0.0) {
                  return 0;
                }
                vec3Subtract$1(ap, line.s, triangle.a);
                var t = vec3Dot(ap, n);
                if (t < 0 || t > det) {
                  return 0;
                }
                vec3Cross(e, qp, ap);
                var v = vec3Dot(ac, e);
                if (v < 0 || v > det) {
                  return 0;
                }
                var w = -vec3Dot(ab, e);
                if (w < 0.0 || v + w > det) {
                  return 0;
                }
                if (outPt) {
                  var invDet = 1.0 / det;
                  v *= invDet;
                  w *= invDet;
                  var u = 1.0 - v - w;
                  vec3Set$1(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
                }
                return 1;
              };
            }();
            var r_t = new Ray();
            function lineAABB(line, aabb) {
              r_t.o.set(line.s);
              vec3Subtract$1(r_t.d, line.e, line.s);
              r_t.d.normalize();
              var min = rayAABB(r_t, aabb);
              var len = line.length();
              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }
            function lineOBB(line, obb) {
              r_t.o.set(line.s);
              vec3Subtract$1(r_t.d, line.e, line.s);
              r_t.d.normalize();
              var min = rayOBB(r_t, obb);
              var len = line.length();
              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }
            function lineSphere(line, sphere) {
              r_t.o.set(line.s);
              vec3Subtract$1(r_t.d, line.e, line.s);
              r_t.d.normalize();
              var min = raySphere(r_t, sphere);
              var len = line.length();
              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }
            var aabbWithAABB = function () {
              var aMin = v3();
              var aMax = v3();
              var bMin = v3();
              var bMax = v3();
              return function (aabb1, aabb2) {
                vec3Subtract$1(aMin, aabb1.center, aabb1.halfExtents);
                vec3Add$2(aMax, aabb1.center, aabb1.halfExtents);
                vec3Subtract$1(bMin, aabb2.center, aabb2.halfExtents);
                vec3Add$2(bMax, aabb2.center, aabb2.halfExtents);
                return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
              };
            }();
            function getAABBVertices(min, max, out) {
              vec3Set$1(out[0], min.x, max.y, max.z);
              vec3Set$1(out[1], min.x, max.y, min.z);
              vec3Set$1(out[2], min.x, min.y, max.z);
              vec3Set$1(out[3], min.x, min.y, min.z);
              vec3Set$1(out[4], max.x, max.y, max.z);
              vec3Set$1(out[5], max.x, max.y, min.z);
              vec3Set$1(out[6], max.x, min.y, max.z);
              vec3Set$1(out[7], max.x, min.y, min.z);
            }
            function getOBBVertices(c, e, a1, a2, a3, out) {
              vec3Set$1(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z);
              vec3Set$1(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z);
              vec3Set$1(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z);
              vec3Set$1(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z);
              vec3Set$1(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z);
              vec3Set$1(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z);
              vec3Set$1(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z);
              vec3Set$1(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
            }
            function getInterval(vertices, axis) {
              var min = vec3Dot(axis, vertices[0]);
              var max = min;
              for (var i = 1; i < 8; ++i) {
                var projection = vec3Dot(axis, vertices[i]);
                min = projection < min ? projection : min;
                max = projection > max ? projection : max;
              }
              return [min, max];
            }
            var aabbWithOBB = function () {
              var test = new Array(15);
              for (var i = 0; i < 15; i++) {
                test[i] = v3();
              }
              var vertices = new Array(8);
              var vertices2 = new Array(8);
              for (var _i = 0; _i < 8; _i++) {
                vertices[_i] = v3();
                vertices2[_i] = v3();
              }
              var min = v3();
              var max = v3();
              return function (aabb, obb) {
                var orientation = obb.orientation;
                vec3Set$1(test[0], 1, 0, 0);
                vec3Set$1(test[1], 0, 1, 0);
                vec3Set$1(test[2], 0, 0, 1);
                vec3Set$1(test[3], orientation.m00, orientation.m01, orientation.m02);
                vec3Set$1(test[4], orientation.m03, orientation.m04, orientation.m05);
                vec3Set$1(test[5], orientation.m06, orientation.m07, orientation.m08);
                for (var _i2 = 0; _i2 < 3; ++_i2) {
                  vec3Cross(test[6 + _i2 * 3 + 0], test[_i2], test[3]);
                  vec3Cross(test[6 + _i2 * 3 + 1], test[_i2], test[4]);
                  vec3Cross(test[6 + _i2 * 3 + 1], test[_i2], test[5]);
                }
                vec3Subtract$1(min, aabb.center, aabb.halfExtents);
                vec3Add$2(max, aabb.center, aabb.halfExtents);
                getAABBVertices(min, max, vertices);
                getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);
                for (var j = 0; j < 15; ++j) {
                  var a = getInterval(vertices, test[j]);
                  var b = getInterval(vertices2, test[j]);
                  if (b[0] > a[1] || a[0] > b[1]) {
                    return 0;
                  }
                }
                return 1;
              };
            }();
            var aabbPlane = function aabbPlane(aabb, plane) {
              var aabbHalfExtents = aabb.halfExtents;
              var planeN = plane.n;
              var r = aabbHalfExtents.x * mathAbs$2(planeN.x) + aabbHalfExtents.y * mathAbs$2(planeN.y) + aabbHalfExtents.z * mathAbs$2(planeN.z);
              var dot = vec3Dot(planeN, aabb.center);
              if (dot + r < plane.d) {
                return -1;
              } else if (dot - r > plane.d) {
                return 0;
              }
              return 1;
            };
            var aabbFrustum = function aabbFrustum(aabb, frustum) {
              var frustumPlanes = frustum.planes;
              for (var i = 0; i < frustumPlanes.length; i++) {
                if (aabbPlane(aabb, frustumPlanes[i]) === -1) {
                  return 0;
                }
              }
              return 1;
            };
            var aabbFrustumCompletelyInside = function aabbFrustumCompletelyInside(aabb, frustum) {
              var frustumPlanes = frustum.planes;
              for (var i = 0; i < frustumPlanes.length; i++) {
                if (aabbPlane(aabb, frustumPlanes[i]) !== 0) {
                  return 0;
                }
              }
              return 1;
            };
            var aabbFrustumAccurate = function () {
              var tmp = new Array(8);
              var out1 = 0;
              var out2 = 0;
              for (var i = 0; i < tmp.length; i++) {
                tmp[i] = v3();
              }
              return function (aabb, frustum) {
                var frustumVertices = frustum.vertices;
                var aabbHalfExtents = aabb.halfExtents;
                var result = 0;
                var intersects = false;
                for (var _i3 = 0; _i3 < frustum.planes.length; _i3++) {
                  result = aabbPlane(aabb, frustum.planes[_i3]);
                  if (result === -1) return 0;else if (result === 1) {
                    intersects = true;
                  }
                }
                if (!intersects) {
                  return 1;
                }
                for (var _i4 = 0; _i4 < frustumVertices.length; _i4++) {
                  vec3Subtract$1(tmp[_i4], frustumVertices[_i4], aabb.center);
                }
                out1 = 0;
                out2 = 0;
                for (var _i5 = 0; _i5 < frustumVertices.length; _i5++) {
                  if (tmp[_i5].x > aabbHalfExtents.x) {
                    out1++;
                  } else if (tmp[_i5].x < -aabbHalfExtents.x) {
                    out2++;
                  }
                }
                if (out1 === frustumVertices.length || out2 === frustumVertices.length) {
                  return 0;
                }
                out1 = 0;
                out2 = 0;
                for (var _i6 = 0; _i6 < frustumVertices.length; _i6++) {
                  if (tmp[_i6].y > aabbHalfExtents.y) {
                    out1++;
                  } else if (tmp[_i6].y < -aabbHalfExtents.y) {
                    out2++;
                  }
                }
                if (out1 === frustumVertices.length || out2 === frustumVertices.length) {
                  return 0;
                }
                out1 = 0;
                out2 = 0;
                for (var _i7 = 0; _i7 < frustumVertices.length; _i7++) {
                  if (tmp[_i7].z > aabbHalfExtents.z) {
                    out1++;
                  } else if (tmp[_i7].z < -aabbHalfExtents.z) {
                    out2++;
                  }
                }
                if (out1 === frustumVertices.length || out2 === frustumVertices.length) {
                  return 0;
                }
                return 1;
              };
            }();
            var obbPoint = function () {
              var tmp = v3();
              var m3 = new Mat3();
              var lessThan = function lessThan(a, b) {
                return mathAbs$2(a.x) < b.x && mathAbs$2(a.y) < b.y && mathAbs$2(a.z) < b.z;
              };
              return function (obb, point) {
                vec3Subtract$1(tmp, point, obb.center);
                Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation));
                return lessThan(tmp, obb.halfExtents);
              };
            }();
            var obbPlane = function () {
              var absDot = function absDot(n, x, y, z) {
                return mathAbs$2(n.x * x + n.y * y + n.z * z);
              };
              return function (obb, plane) {
                var obbOrientation = obb.orientation;
                var obbHalfExtents = obb.halfExtents;
                var planeN = plane.n;
                var planeD = plane.d;
                var r = obbHalfExtents.x * absDot(planeN, obbOrientation.m00, obbOrientation.m01, obbOrientation.m02) + obbHalfExtents.y * absDot(planeN, obbOrientation.m03, obbOrientation.m04, obbOrientation.m05) + obbHalfExtents.z * absDot(planeN, obbOrientation.m06, obbOrientation.m07, obbOrientation.m08);
                var dot = vec3Dot(planeN, obb.center);
                if (dot + r < planeD) {
                  return -1;
                } else if (dot - r > planeD) {
                  return 0;
                }
                return 1;
              };
            }();
            var obbFrustum = function obbFrustum(obb, frustum) {
              var frustumPlanes = frustum.planes;
              for (var i = 0; i < frustumPlanes.length; i++) {
                if (obbPlane(obb, frustumPlanes[i]) === -1) {
                  return 0;
                }
              }
              return 1;
            };
            var obbFrustumAccurate = function () {
              var tmp = new Array(8);
              var dist = 0;
              var out1 = 0;
              var out2 = 0;
              for (var i = 0; i < tmp.length; i++) {
                tmp[i] = v3();
              }
              var dot = function dot(n, x, y, z) {
                return n.x * x + n.y * y + n.z * z;
              };
              return function (obb, frustum) {
                var obbOrientation = obb.orientation;
                var obbHalfExtents = obb.halfExtents;
                var frustumVertices = frustum.vertices;
                var frustumPlanes = frustum.planes;
                var result = 0;
                var intersects = false;
                for (var _i8 = 0; _i8 < frustumPlanes.length; _i8++) {
                  result = obbPlane(obb, frustumPlanes[_i8]);
                  if (result === -1) return 0;else if (result === 1) {
                    intersects = true;
                  }
                }
                if (!intersects) {
                  return 1;
                }
                for (var _i9 = 0; _i9 < frustumVertices.length; _i9++) {
                  vec3Subtract$1(tmp[_i9], frustumVertices[_i9], obb.center);
                }
                out1 = 0, out2 = 0;
                for (var _i10 = 0; _i10 < frustumVertices.length; _i10++) {
                  dist = dot(tmp[_i10], obbOrientation.m00, obbOrientation.m01, obbOrientation.m02);
                  if (dist > obbHalfExtents.x) {
                    out1++;
                  } else if (dist < -obbHalfExtents.x) {
                    out2++;
                  }
                }
                if (out1 === frustumVertices.length || out2 === frustumVertices.length) {
                  return 0;
                }
                out1 = 0;
                out2 = 0;
                for (var _i11 = 0; _i11 < frustumVertices.length; _i11++) {
                  dist = dot(tmp[_i11], obbOrientation.m03, obbOrientation.m04, obbOrientation.m05);
                  if (dist > obbHalfExtents.y) {
                    out1++;
                  } else if (dist < -obbHalfExtents.y) {
                    out2++;
                  }
                }
                if (out1 === frustumVertices.length || out2 === frustumVertices.length) {
                  return 0;
                }
                out1 = 0;
                out2 = 0;
                for (var _i12 = 0; _i12 < frustumVertices.length; _i12++) {
                  dist = dot(tmp[_i12], obbOrientation.m06, obbOrientation.m07, obbOrientation.m08);
                  if (dist > obbHalfExtents.z) {
                    out1++;
                  } else if (dist < -obbHalfExtents.z) {
                    out2++;
                  }
                }
                if (out1 === frustumVertices.length || out2 === frustumVertices.length) {
                  return 0;
                }
                return 1;
              };
            }();
            var obbWithOBB = function () {
              var test = new Array(15);
              for (var i = 0; i < 15; i++) {
                test[i] = v3();
              }
              var vertices = new Array(8);
              var vertices2 = new Array(8);
              for (var _i13 = 0; _i13 < 8; _i13++) {
                vertices[_i13] = v3();
                vertices2[_i13] = v3();
              }
              return function (obb1, obb2) {
                var obb1Orientation = obb1.orientation;
                var obb2Orientation = obb2.orientation;
                vec3Set$1(test[0], obb1Orientation.m00, obb1Orientation.m01, obb1Orientation.m02);
                vec3Set$1(test[1], obb1Orientation.m03, obb1Orientation.m04, obb1Orientation.m05);
                vec3Set$1(test[2], obb1Orientation.m06, obb1Orientation.m07, obb1Orientation.m08);
                vec3Set$1(test[3], obb2Orientation.m00, obb2Orientation.m01, obb2Orientation.m02);
                vec3Set$1(test[4], obb2Orientation.m03, obb2Orientation.m04, obb2Orientation.m05);
                vec3Set$1(test[5], obb2Orientation.m06, obb2Orientation.m07, obb2Orientation.m08);
                for (var _i14 = 0; _i14 < 3; ++_i14) {
                  vec3Cross(test[6 + _i14 * 3 + 0], test[_i14], test[3]);
                  vec3Cross(test[6 + _i14 * 3 + 1], test[_i14], test[4]);
                  vec3Cross(test[6 + _i14 * 3 + 2], test[_i14], test[5]);
                }
                getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices);
                getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);
                for (var _i15 = 0; _i15 < 15; ++_i15) {
                  var a = getInterval(vertices, test[_i15]);
                  var b = getInterval(vertices2, test[_i15]);
                  if (b[0] > a[1] || a[0] > b[1]) {
                    return 0;
                  }
                }
                return 1;
              };
            }();
            var obbCapsule = function () {
              var sphere_0 = new Sphere();
              var v3_0 = v3();
              var v3_1 = v3();
              var v3_2 = v3();
              var v3_verts8 = new Array(8);
              for (var i = 0; i < 8; i++) {
                v3_verts8[i] = v3();
              }
              var v3_axis8 = new Array(8);
              for (var _i16 = 0; _i16 < 8; _i16++) {
                v3_axis8[_i16] = v3();
              }
              return function (obb, capsule) {
                var capsuleEllipseCenter0 = capsule.ellipseCenter0;
                var capsuleEllipseCenter1 = capsule.ellipseCenter1;
                var capsuleRadius = capsule.radius;
                var h = vec3SquaredDistance(capsuleEllipseCenter0, capsuleEllipseCenter1);
                if (h === 0) {
                  sphere_0.radius = capsule.radius;
                  sphere_0.center.set(capsuleEllipseCenter0);
                  return intersect.sphereOBB(sphere_0, obb);
                } else {
                  var orientation = obb.orientation;
                  v3_0.x = orientation.m00;
                  v3_0.y = orientation.m01;
                  v3_0.z = orientation.m02;
                  v3_1.x = orientation.m03;
                  v3_1.y = orientation.m04;
                  v3_1.z = orientation.m05;
                  v3_2.x = orientation.m06;
                  v3_2.y = orientation.m07;
                  v3_2.z = orientation.m08;
                  getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
                  var axes = v3_axis8;
                  var a0 = vec3Copy(axes[0], v3_0);
                  var a1 = vec3Copy(axes[1], v3_1);
                  var a2 = vec3Copy(axes[2], v3_2);
                  var C = vec3Subtract$1(axes[3], capsule.center, obb.center);
                  C.normalize();
                  var B = vec3Subtract$1(axes[4], capsuleEllipseCenter0, capsuleEllipseCenter1);
                  B.normalize();
                  vec3Cross(axes[5], a0, B);
                  vec3Cross(axes[6], a1, B);
                  vec3Cross(axes[7], a2, B);
                  for (var _i17 = 0; _i17 < 8; ++_i17) {
                    var a = getInterval(v3_verts8, axes[_i17]);
                    var d0 = vec3Dot(axes[_i17], capsuleEllipseCenter0);
                    var d1 = vec3Dot(axes[_i17], capsuleEllipseCenter1);
                    var max_d = mathMax(d0, d1);
                    var min_d = mathMin(d0, d1);
                    var d_min = min_d - capsuleRadius;
                    var d_max = max_d + capsuleRadius;
                    if (d_min > a[1] || a[0] > d_max) {
                      return 0;
                    }
                  }
                  return 1;
                }
              };
            }();
            var spherePlane = function spherePlane(sphere, plane) {
              var dot = vec3Dot(plane.n, sphere.center);
              var r = sphere.radius * plane.n.length();
              if (dot + r < plane.d) {
                return -1;
              } else if (dot - r > plane.d) {
                return 0;
              }
              return 1;
            };
            var sphereFrustum = function sphereFrustum(sphere, frustum) {
              var frustumPlanes = frustum.planes;
              for (var i = 0; i < frustumPlanes.length; i++) {
                if (spherePlane(sphere, frustumPlanes[i]) === -1) {
                  return 0;
                }
              }
              return 1;
            };
            var sphereFrustumAccurate = function () {
              var pt = v3();
              var map = [1, -1, 1, -1, 1, -1];
              return function (sphere, frustum) {
                for (var i = 0; i < 6; i++) {
                  var _plane = frustum.planes[i];
                  var _r = sphere.radius;
                  var c = sphere.center;
                  var n = _plane.n;
                  var d = _plane.d;
                  var dot = vec3Dot(n, c);
                  if (dot + _r < d) return 0;else if (dot - _r > d) {
                    continue;
                  }
                  vec3Add$2(pt, c, vec3MultiplyScalar$2(pt, n, _r));
                  for (var j = 0; j < 6; j++) {
                    if (j === i || j === i + map[i]) {
                      continue;
                    }
                    var test = frustum.planes[j];
                    if (vec3Dot(test.n, pt) < test.d) {
                      return 0;
                    }
                  }
                }
                return 1;
              };
            }();
            var sphereWithSphere = function sphereWithSphere(sphere0, sphere1) {
              var r = sphere0.radius + sphere1.radius;
              return vec3SquaredDistance(sphere0.center, sphere1.center) < r * r;
            };
            var sphereAABB = function () {
              var pt = v3();
              return function (sphere, aabb) {
                var sphereRadius = sphere.radius;
                pt_point_aabb(pt, sphere.center, aabb);
                return vec3SquaredDistance(sphere.center, pt) < sphereRadius * sphereRadius;
              };
            }();
            var sphereOBB = function () {
              var pt = v3();
              return function (sphere, obb) {
                var sphereRadius = sphere.radius;
                pt_point_obb(pt, sphere.center, obb);
                return vec3SquaredDistance(sphere.center, pt) < sphereRadius * sphereRadius;
              };
            }();
            var sphereCapsule = function () {
              var v3_0 = v3();
              var v3_1 = v3();
              return function (sphere, capsule) {
                var capsuleEllipseCenter0 = capsule.ellipseCenter0;
                var capsuleEllipseCenter1 = capsule.ellipseCenter1;
                var sphereCenter = sphere.center;
                var r = sphere.radius + capsule.radius;
                var squaredR = r * r;
                var h = vec3SquaredDistance(capsuleEllipseCenter0, capsuleEllipseCenter1);
                if (h === 0) {
                  return vec3SquaredDistance(sphereCenter, capsule.center) < squaredR;
                } else {
                  vec3Subtract$1(v3_0, sphereCenter, capsuleEllipseCenter0);
                  vec3Subtract$1(v3_1, capsuleEllipseCenter1, capsuleEllipseCenter0);
                  var t = vec3Dot(v3_0, v3_1) / h;
                  if (t < 0) {
                    return vec3SquaredDistance(sphereCenter, capsuleEllipseCenter0) < squaredR;
                  } else if (t > 1) {
                    return vec3SquaredDistance(sphereCenter, capsuleEllipseCenter1) < squaredR;
                  } else {
                    vec3ScaleAndAdd(v3_0, capsuleEllipseCenter0, v3_1, t);
                    return vec3SquaredDistance(sphereCenter, v3_0) < squaredR;
                  }
                }
              };
            }();
            var capsuleWithCapsule = function () {
              var v3_0 = v3();
              var v3_1 = v3();
              var v3_2 = v3();
              var v3_3 = v3();
              var v3_4 = v3();
              var v3_5 = v3();
              return function capsuleWithCapsule(capsuleA, capsuleB) {
                var capsuleAEllipseCenter0 = capsuleA.ellipseCenter0;
                var capsuleAEllipseCenter1 = capsuleA.ellipseCenter1;
                var capsuleBEllipseCenter1 = capsuleB.ellipseCenter1;
                var capsuleBEllipseCenter0 = capsuleB.ellipseCenter0;
                var u = vec3Subtract$1(v3_0, capsuleAEllipseCenter1, capsuleAEllipseCenter0);
                var v = vec3Subtract$1(v3_1, capsuleBEllipseCenter1, capsuleBEllipseCenter0);
                var w = vec3Subtract$1(v3_2, capsuleAEllipseCenter0, capsuleBEllipseCenter0);
                var a = vec3Dot(u, u);
                var b = vec3Dot(u, v);
                var c = vec3Dot(v, v);
                var d = vec3Dot(u, w);
                var e = vec3Dot(v, w);
                var D = a * c - b * b;
                var sN;
                var sD = D;
                var tN;
                var tD = D;
                if (D < EPSILON$1) {
                  sN = 0.0;
                  sD = 1.0;
                  tN = e;
                  tD = c;
                } else {
                  sN = b * e - c * d;
                  tN = a * e - b * d;
                  if (sN < 0.0) {
                    sN = 0.0;
                    tN = e;
                    tD = c;
                  } else if (sN > sD) {
                    sN = sD;
                    tN = e + b;
                    tD = c;
                  }
                }
                if (tN < 0.0) {
                  tN = 0.0;
                  if (-d < 0.0) {
                    sN = 0.0;
                  } else if (-d > a) {
                    sN = sD;
                  } else {
                    sN = -d;
                    sD = a;
                  }
                } else if (tN > tD) {
                  tN = tD;
                  if (-d + b < 0.0) {
                    sN = 0;
                  } else if (-d + b > a) {
                    sN = sD;
                  } else {
                    sN = -d + b;
                    sD = a;
                  }
                }
                var sc = mathAbs$2(sN) < EPSILON$1 ? 0.0 : sN / sD;
                var tc = mathAbs$2(tN) < EPSILON$1 ? 0.0 : tN / tD;
                var dP = v3_3;
                dP.set(w);
                dP.add(vec3MultiplyScalar$2(v3_4, u, sc));
                dP.subtract(vec3MultiplyScalar$2(v3_5, v, tc));
                var radius = capsuleA.radius + capsuleB.radius;
                return dP.lengthSqr() < radius * radius;
              };
            }();
            var intersect = {
              raySphere: raySphere,
              rayAABB: rayAABB,
              rayOBB: rayOBB,
              rayPlane: rayPlane,
              rayTriangle: rayTriangle,
              rayCapsule: rayCapsule,
              raySubMesh: null,
              rayMesh: null,
              rayModel: null,
              lineSphere: lineSphere,
              lineAABB: lineAABB,
              lineOBB: lineOBB,
              linePlane: linePlane,
              lineTriangle: lineTriangle,
              sphereWithSphere: sphereWithSphere,
              sphereAABB: sphereAABB,
              sphereOBB: sphereOBB,
              spherePlane: spherePlane,
              sphereFrustum: sphereFrustum,
              sphereFrustumAccurate: sphereFrustumAccurate,
              sphereCapsule: sphereCapsule,
              aabbWithAABB: aabbWithAABB,
              aabbWithOBB: aabbWithOBB,
              aabbPlane: aabbPlane,
              aabbFrustum: aabbFrustum,
              aabbFrustumAccurate: aabbFrustumAccurate,
              obbWithOBB: obbWithOBB,
              obbPlane: obbPlane,
              obbFrustum: obbFrustum,
              obbFrustumAccurate: obbFrustumAccurate,
              obbPoint: obbPoint,
              obbCapsule: obbCapsule,
              aabbFrustumCompletelyInside: aabbFrustumCompletelyInside,
              capsuleWithCapsule: capsuleWithCapsule,
              resolve: function resolve(g1, g2, outPt) {
                if (outPt === undefined) {
                  outPt = null;
                }
                var type1 = g1._type;
                var type2 = g2._type;
                var resolver = this[type1 | type2];
                return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
              }
            };
            intersect[1 | 4] = raySphere;
            intersect[1 | 8] = rayAABB;
            intersect[1 | 16] = rayOBB;
            intersect[1 | 32] = rayPlane;
            intersect[1 | 64] = rayTriangle;
            intersect[1 | 512] = rayCapsule;
            intersect[2 | 4] = lineSphere;
            intersect[2 | 8] = lineAABB;
            intersect[2 | 16] = lineOBB;
            intersect[2 | 32] = linePlane;
            intersect[2 | 64] = lineTriangle;
            intersect[4] = sphereWithSphere;
            intersect[4 | 8] = sphereAABB;
            intersect[4 | 16] = sphereOBB;
            intersect[4 | 32] = spherePlane;
            intersect[4 | 128] = sphereFrustum;
            intersect[4 | 256] = sphereFrustumAccurate;
            intersect[4 | 512] = sphereCapsule;
            intersect[8] = aabbWithAABB;
            intersect[8 | 16] = aabbWithOBB;
            intersect[8 | 32] = aabbPlane;
            intersect[8 | 128] = aabbFrustum;
            intersect[8 | 256] = aabbFrustumAccurate;
            intersect[16] = obbWithOBB;
            intersect[16 | 32] = obbPlane;
            intersect[16 | 128] = obbFrustum;
            intersect[16 | 256] = obbFrustumAccurate;
            intersect[16 | 512] = obbCapsule;
            intersect[512] = capsuleWithCapsule;

            replaceProperty(Line.prototype, 'line', [{
              name: 'mag',
              newName: 'len'
            }, {
              name: 'magnitude',
              newName: 'len'
            }]);
            removeProperty(intersect, 'intersect', [{
              name: 'line_quad'
            }]);

            var v1 = new Vec3(0, 0, 0);
            var v2 = new Vec3(0, 0, 0);
            var temp_mat = mat4();
            var temp_vec4 = v4();
            var Plane = function () {
              Plane.create = function create(nx, ny, nz, d) {
                return new Plane(nx, ny, nz, d);
              };
              Plane.clone = function clone(p) {
                return new Plane(p.n.x, p.n.y, p.n.z, p.d);
              };
              Plane.copy = function copy(out, p) {
                Vec3.copy(out.n, p.n);
                out.d = p.d;
                return out;
              };
              Plane.fromPoints = function fromPoints(out, a, b, c) {
                Vec3.subtract(v1, b, a);
                Vec3.subtract(v2, c, a);
                Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2));
                out.d = Vec3.dot(out.n, a);
                return out;
              };
              Plane.set = function set(out, nx, ny, nz, d) {
                out.n.x = nx;
                out.n.y = ny;
                out.n.z = nz;
                out.d = d;
                return out;
              };
              Plane.fromNormalAndPoint = function fromNormalAndPoint(out, normal, point) {
                Vec3.copy(out.n, normal);
                out.d = Vec3.dot(normal, point);
                return out;
              };
              Plane.normalize = function normalize(out, a) {
                var len = a.n.length();
                Vec3.normalize(out.n, a.n);
                if (len > 0) {
                  out.d = a.d / len;
                }
                return out;
              };
              function Plane(nx, ny, nz, d) {
                if (nx === undefined) {
                  nx = 0;
                }
                if (ny === undefined) {
                  ny = 1;
                }
                if (nz === undefined) {
                  nz = 0;
                }
                if (d === undefined) {
                  d = 0;
                }
                this._type = 32;
                this.n = new Vec3(nx, ny, nz);
                this.d = d;
              }
              var _proto = Plane.prototype;
              _proto.transform = function transform(mat) {
                Mat4.invert(temp_mat, mat);
                Mat4.transpose(temp_mat, temp_mat);
                Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, -this.d);
                Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat);
                Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z);
                this.d = -temp_vec4.w;
              };
              _createClass(Plane, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }, {
                key: "x",
                get: function get() {
                  return this.n.x;
                },
                set: function set(val) {
                  this.n.x = val;
                }
              }, {
                key: "y",
                get: function get() {
                  return this.n.y;
                },
                set: function set(val) {
                  this.n.y = val;
                }
              }, {
                key: "z",
                get: function get() {
                  return this.n.z;
                },
                set: function set(val) {
                  this.n.z = val;
                }
              }, {
                key: "w",
                get: function get() {
                  return this.d;
                },
                set: function set(val) {
                  this.d = val;
                }
              }]);
              return Plane;
            }();

            var Triangle = function () {
              Triangle.create = function create(ax, ay, az, bx, by, bz, cx, cy, cz) {
                if (ax === undefined) {
                  ax = 1;
                }
                if (ay === undefined) {
                  ay = 0;
                }
                if (az === undefined) {
                  az = 0;
                }
                if (bx === undefined) {
                  bx = 0;
                }
                if (by === undefined) {
                  by = 0;
                }
                if (bz === undefined) {
                  bz = 0;
                }
                if (cx === undefined) {
                  cx = 0;
                }
                if (cy === undefined) {
                  cy = 0;
                }
                if (cz === undefined) {
                  cz = 1;
                }
                return new Triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
              };
              Triangle.clone = function clone(t) {
                return new Triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
              };
              Triangle.copy = function copy(out, t) {
                Vec3.copy(out.a, t.a);
                Vec3.copy(out.b, t.b);
                Vec3.copy(out.c, t.c);
                return out;
              };
              Triangle.fromPoints = function fromPoints(out, a, b, c) {
                Vec3.copy(out.a, a);
                Vec3.copy(out.b, b);
                Vec3.copy(out.c, c);
                return out;
              };
              Triangle.set = function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
                out.a.x = ax;
                out.a.y = ay;
                out.a.z = az;
                out.b.x = bx;
                out.b.y = by;
                out.b.z = bz;
                out.c.x = cx;
                out.c.y = cy;
                out.c.z = cz;
                return out;
              };
              function Triangle(ax, ay, az, bx, by, bz, cx, cy, cz) {
                if (ax === undefined) {
                  ax = 0;
                }
                if (ay === undefined) {
                  ay = 0;
                }
                if (az === undefined) {
                  az = 0;
                }
                if (bx === undefined) {
                  bx = 1;
                }
                if (by === undefined) {
                  by = 0;
                }
                if (bz === undefined) {
                  bz = 0;
                }
                if (cx === undefined) {
                  cx = 0;
                }
                if (cy === undefined) {
                  cy = 1;
                }
                if (cz === undefined) {
                  cz = 0;
                }
                this._type = 64;
                this.a = new Vec3(ax, ay, az);
                this.b = new Vec3(bx, by, bz);
                this.c = new Vec3(cx, cy, cz);
              }
              _createClass(Triangle, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }]);
              return Triangle;
            }();

            deprecateModuleExportedName({
              replaceProperty: {
                since: '3.6.0',
                removed: false
              },
              removeProperty: {
                since: '3.6.0',
                removed: false
              },
              markAsWarning: {
                since: '3.6.0',
                removed: false
              },
              setDefaultLogTimes: {
                since: '3.6.0',
                removed: false
              }
            });

            var ScalableContainer = function () {
              function ScalableContainer() {
                this._poolHandle = -1;
                scalableContainerManager.addContainer(this);
              }
              var _proto = ScalableContainer.prototype;
              _proto.destroy = function destroy() {
                scalableContainerManager.removeContainer(this);
              };
              return ScalableContainer;
            }();
            var ScalableContainerManager = function () {
              function ScalableContainerManager() {
                this._pools = [];
                this._lastShrinkPassed = 0;
                this.shrinkTimeSpan = 5;
              }
              var _proto2 = ScalableContainerManager.prototype;
              _proto2.addContainer = function addContainer(pool) {
                if (pool._poolHandle !== -1) return;
                pool._poolHandle = this._pools.length;
                this._pools.push(pool);
              };
              _proto2.removeContainer = function removeContainer(pool) {
                if (pool._poolHandle === -1) return;
                this._pools[this._pools.length - 1]._poolHandle = pool._poolHandle;
                fastRemoveAt$2(this._pools, pool._poolHandle);
                pool._poolHandle = -1;
              };
              _proto2.tryShrink = function tryShrink() {
                for (var i = 0; i < this._pools.length; i++) {
                  this._pools[i].tryShrink();
                }
              };
              _proto2.update = function update(dt) {
                this._lastShrinkPassed += dt;
                if (this._lastShrinkPassed > this.shrinkTimeSpan) {
                  this.tryShrink();
                  this._lastShrinkPassed -= this.shrinkTimeSpan;
                }
              };
              return ScalableContainerManager;
            }();
            var scalableContainerManager = new ScalableContainerManager();

            var Pool = exports("Pool", function (_ScalableContainer) {
              _inheritsLoose(Pool, _ScalableContainer);
              function Pool(ctor, elementsPerBatch, dtor, shrinkThreshold) {
                var _this;
                _this = _ScalableContainer.call(this) || this;
                _this._freePool = [];
                _this._ctor = ctor;
                _this._dtor = dtor || null;
                _this._elementsPerBatch = Math.max(elementsPerBatch, 1);
                _this._shrinkThreshold = shrinkThreshold ? max$8(shrinkThreshold, 1) : _this._elementsPerBatch;
                _this._nextAvail = _this._elementsPerBatch - 1;
                for (var i = 0; i < _this._elementsPerBatch; ++i) {
                  _this._freePool.push(ctor());
                }
                return _this;
              }
              var _proto = Pool.prototype;
              _proto.alloc = function alloc() {
                if (this._nextAvail < 0) {
                  this._freePool.length = this._elementsPerBatch;
                  for (var i = 0; i < this._elementsPerBatch; i++) {
                    this._freePool[i] = this._ctor();
                  }
                  this._nextAvail = this._elementsPerBatch - 1;
                }
                return this._freePool[this._nextAvail--];
              };
              _proto.free = function free(obj) {
                this._freePool[++this._nextAvail] = obj;
              };
              _proto.freeArray = function freeArray(objs) {
                this._freePool.length = this._nextAvail + 1;
                Array.prototype.push.apply(this._freePool, objs);
                this._nextAvail += objs.length;
              };
              _proto.tryShrink = function tryShrink() {
                var freeObjectNumber = this._nextAvail + 1;
                if (freeObjectNumber <= this._shrinkThreshold) {
                  return;
                }
                var objectNumberToShrink = 0;
                if (freeObjectNumber >> 1 >= this._shrinkThreshold) {
                  objectNumberToShrink = freeObjectNumber >> 1;
                } else {
                  objectNumberToShrink = Math.floor((freeObjectNumber - this._shrinkThreshold + 1) / 2);
                }
                if (this._dtor) {
                  for (var i = this._nextAvail - objectNumberToShrink + 1; i <= this._nextAvail; ++i) {
                    this._dtor(this._freePool[i]);
                  }
                }
                this._nextAvail -= objectNumberToShrink;
                this._freePool.length = this._nextAvail + 1;
              };
              _proto.destroy = function destroy() {
                var dtor = arguments.length > 0 ? arguments[0] : null;
                if (dtor) {
                  warnID(14100);
                }
                var readDtor = dtor || this._dtor;
                if (readDtor) {
                  for (var i = 0; i <= this._nextAvail; i++) {
                    readDtor(this._freePool[i]);
                  }
                }
                this._freePool.length = 0;
                this._nextAvail = -1;
                _ScalableContainer.prototype.destroy.call(this);
              };
              return Pool;
            }(ScalableContainer));

            var RecyclePool = exports("RecyclePool", function (_ScalableContainer) {
              _inheritsLoose(RecyclePool, _ScalableContainer);
              function RecyclePool(fn, size, dtor) {
                var _this;
                _this = _ScalableContainer.call(this) || this;
                _this._count = 0;
                _this._fn = fn;
                _this._dtor = dtor || null;
                _this._data = new Array(size);
                _this._initSize = size;
                for (var i = 0; i < size; ++i) {
                  _this._data[i] = fn();
                }
                return _this;
              }
              var _proto = RecyclePool.prototype;
              _proto.reset = function reset() {
                this._count = 0;
              };
              _proto.resize = function resize(size) {
                if (size > this._data.length) {
                  for (var i = this._data.length; i < size; ++i) {
                    this._data[i] = this._fn();
                  }
                }
              };
              _proto.add = function add() {
                if (this._count >= this._data.length) {
                  this.resize(this._data.length << 1);
                }
                return this._data[this._count++];
              };
              _proto.destroy = function destroy() {
                if (this._dtor) {
                  for (var i = 0; i < this._data.length; i++) {
                    this._dtor(this._data[i]);
                  }
                }
                this._data.length = 0;
                this._count = 0;
                _ScalableContainer.prototype.destroy.call(this);
              };
              _proto.tryShrink = function tryShrink() {
                if (this._data.length >> 2 > this._count) {
                  var length = Math.max(this._initSize, this._data.length >> 1);
                  if (this._dtor) {
                    for (var i = length; i < this._data.length; i++) {
                      this._dtor(this._data[i]);
                    }
                  }
                  this._data.length = length;
                }
              };
              _proto.removeAt = function removeAt(idx) {
                if (idx >= this._count) {
                  return;
                }
                var last = this._count - 1;
                var tmp = this._data[idx];
                this._data[idx] = this._data[last];
                this._data[last] = tmp;
                this._count -= 1;
              };
              _createClass(RecyclePool, [{
                key: "length",
                get: function get() {
                  return this._count;
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }]);
              return RecyclePool;
            }(ScalableContainer));

            var CachedArray = exports("CachedArray", function (_ScalableContainer) {
              _inheritsLoose(CachedArray, _ScalableContainer);
              function CachedArray(length, compareFn) {
                var _this;
                _this = _ScalableContainer.call(this) || this;
                _this.length = 0;
                _this._initSize = 0;
                _this.array = new Array(length);
                _this._initSize = length;
                _this._compareFn = compareFn;
                return _this;
              }
              var _proto = CachedArray.prototype;
              _proto.push = function push(item) {
                this.array[this.length++] = item;
              };
              _proto.pop = function pop() {
                return this.array[--this.length];
              };
              _proto.get = function get(idx) {
                return this.array[idx];
              };
              _proto.clear = function clear() {
                this.length = 0;
              };
              _proto.destroy = function destroy() {
                this.length = 0;
                this.array.length = 0;
                _ScalableContainer.prototype.destroy.call(this);
              };
              _proto.tryShrink = function tryShrink() {
                if (this.array.length >> 2 > this.length) {
                  this.array.length = Math.max(this._initSize, this.array.length >> 1);
                }
              };
              _proto.sort = function sort() {
                this.array.length = this.length;
                this.array.sort(this._compareFn);
              };
              _proto.concat = function concat(array) {
                for (var i = 0; i < array.length; ++i) {
                  this.array[this.length++] = array[i];
                }
              };
              _proto.fastRemove = function fastRemove(idx) {
                if (idx >= this.length || idx < 0) {
                  return;
                }
                var last = --this.length;
                this.array[idx] = this.array[last];
              };
              _proto.indexOf = function indexOf(val) {
                for (var i = 0, len = this.length; i < len; ++i) {
                  if (this.array[i] === val) {
                    return i;
                  }
                }
                return -1;
              };
              return CachedArray;
            }(ScalableContainer));

            var index$2 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                CachedArray: CachedArray,
                Pool: Pool,
                RecyclePool: RecyclePool
            });
            exports("memop", index$2);

            var editorExtrasTag = exports("editorExtrasTag", '__editorExtras__');

            var CCObjectFlags = exports("CCObjectFlags", {
              Destroyed: 1,
              RealDestroyed: 2,
              ToDestroy: 4,
              DontSave: 8,
              EditorOnly: 16,
              Dirty: 32,
              DontDestroy: 64,
              Destroying: 128,
              Deactivating: 256,
              LockedInEditor: 512,
              HideInHierarchy: 1024,
              IsOnEnableCalled: 2048,
              IsEditorOnEnableCalled: 4096,
              IsPreloadStarted: 8192,
              IsOnLoadCalled: 16384,
              IsOnLoadStarted: 32768,
              IsStartCalled: 65536,
              IsRotationLocked: 131072,
              IsScaleLocked: 262144,
              IsAnchorLocked: 524288,
              IsSizeLocked: 1048576,
              IsPositionLocked: 2097152,
              IsSkipTransformUpdate: 16777216,
              PersistentMask: -4192741,
              AllHideMasks: 1560
            });
            var objectsToDestroy = [];
            function compileDestruct(obj, ctor) {
              var shouldSkipId = obj instanceof legacyCC.Node || obj instanceof legacyCC.Component;
              var idToSkip = shouldSkipId ? '_id' : null;
              var key;
              var propsToReset = {};
              for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                  if (key === idToSkip) {
                    continue;
                  }
                  switch (typeof obj[key]) {
                    case 'string':
                      propsToReset[key] = '';
                      break;
                    case 'object':
                    case 'function':
                      propsToReset[key] = null;
                      break;
                  }
                }
              }
              if (CCClass._isCCClass(ctor)) {
                var attrs = legacyCC.Class.Attr.getClassAttrs(ctor);
                var propList = ctor.__props__;
                for (var i = 0; i < propList.length; i++) {
                  key = propList[i];
                  var attrKey = "" + key;
                  if (attrKey in attrs) {
                    if (shouldSkipId && key === '_id') {
                      continue;
                    }
                    switch (typeof attrs[attrKey]) {
                      case 'string':
                        propsToReset[key] = '';
                        break;
                      case 'object':
                      case 'function':
                        propsToReset[key] = null;
                        break;
                      case 'undefined':
                        propsToReset[key] = undefined;
                        break;
                    }
                  }
                }
              }
              {
                var func = '';
                for (key in propsToReset) {
                  var statement = undefined;
                  if (CCClass.IDENTIFIER_RE.test(key)) {
                    statement = "o." + key + "=";
                  } else {
                    statement = "o[" + CCClass.escapeForJS(key) + "]=";
                  }
                  var val = propsToReset[key];
                  if (val === '') {
                    val = '""';
                  }
                  func += statement + val + ";\n";
                }
                return Function('o', func);
              }
            }
            var CCObject = exports("CCObject", function () {
              CCObject._deferredDestroy = function _deferredDestroy() {
                var deleteCount = objectsToDestroy.length;
                for (var i = 0; i < deleteCount; ++i) {
                  var obj = objectsToDestroy[i];
                  if (!(obj._objFlags & 1)) {
                    obj._destroyImmediate();
                  }
                }
                if (deleteCount === objectsToDestroy.length) {
                  objectsToDestroy.length = 0;
                } else {
                  objectsToDestroy.splice(0, deleteCount);
                }
              };
              function CCObject(name) {
                if (name === undefined) {
                  name = '';
                }
                this._objFlags = 0;
                this._name = name;
              }
              var _proto = CCObject.prototype;
              _proto.destroy = function destroy() {
                if (this._objFlags & 1) {
                  warnID(5000);
                  return false;
                }
                if (this._objFlags & 4) {
                  return false;
                }
                this._objFlags |= 4;
                objectsToDestroy.push(this);
                return true;
              };
              _proto._destruct = function _destruct() {
                var ctor = this.constructor;
                var destruct;
                if (Object.prototype.hasOwnProperty.call(ctor, '__destruct__')) {
                  destruct = ctor.__destruct__;
                } else {
                  destruct = compileDestruct(this, ctor);
                  value(ctor, '__destruct__', destruct, true);
                }
                destruct(this);
              };
              _proto._destroyImmediate = function _destroyImmediate() {
                var _onPreDestroy, _ref;
                if (this._objFlags & 1) {
                  errorID(5000);
                  return;
                }
                (_onPreDestroy = (_ref = this)._onPreDestroy) == null ? undefined : _onPreDestroy.call(_ref);
                {
                  this._destruct();
                }
                this._objFlags |= 1;
              };
              _createClass(CCObject, [{
                key: "name",
                get: function get() {
                  return this._name;
                },
                set: function set(value) {
                  this._name = value;
                }
              }, {
                key: "hideFlags",
                get: function get() {
                  return this._objFlags & 1560;
                },
                set: function set(hideFlags) {
                  var flags = hideFlags & 1560;
                  this._objFlags = this._objFlags & -1561 | flags;
                }
              }, {
                key: "isValid",
                get: function get() {
                  return !(this._objFlags & 1);
                }
              }]);
              return CCObject;
            }());
            var prototype = CCObject.prototype;
            prototype._deserialize = null;
            {
              CCClass.fastDefine('cc.Object', CCObject, {
                _name: '',
                _objFlags: 0
              });
            }
            var CCObjectFlagsEnum = {};
            for (var key in CCObjectFlags) {
              if (typeof key === 'string' && typeof CCObjectFlags[key] === 'number') {
                CCObjectFlagsEnum[key] = CCObjectFlags[key];
              }
            }
            value(CCObject, 'Flags', CCObjectFlagsEnum);
            function isCCObject(object) {
              return object instanceof CCObject;
            }
            function isValid(value, strictMode) {
              if (typeof value === 'object') {
                return !!value && !(value._objFlags & (strictMode ? 1 | 4 : 1));
              } else {
                return typeof value !== 'undefined';
              }
            }
            legacyCC.isValid = isValid;
            legacyCC.Object = CCObject;

            var fastRemoveAt$1 = fastRemoveAt$2;
            function empty() {}
            var CallbackInfo = function () {
              function CallbackInfo() {
                this.callback = empty;
                this.target = undefined;
                this.once = false;
              }
              var _proto = CallbackInfo.prototype;
              _proto.set = function set(callback, target, once) {
                this.callback = callback || empty;
                this.target = target;
                this.once = !!once;
              };
              _proto.reset = function reset() {
                this.target = undefined;
                this.callback = empty;
                this.once = false;
              };
              _proto.check = function check() {
                if (isCCObject(this.target) && !isValid(this.target, true)) {
                  return false;
                } else {
                  return true;
                }
              };
              return CallbackInfo;
            }();
            var callbackInfoPool = new Pool(function () {
              return new CallbackInfo();
            }, 32);
            var CallbackList = function () {
              function CallbackList() {
                this.callbackInfos = [];
                this.isInvoking = false;
                this.containCanceled = false;
              }
              var _proto2 = CallbackList.prototype;
              _proto2.removeByCallback = function removeByCallback(cb) {
                for (var i = 0; i < this.callbackInfos.length; ++i) {
                  var info = this.callbackInfos[i];
                  if (info && info.callback === cb) {
                    info.reset();
                    callbackInfoPool.free(info);
                    fastRemoveAt$1(this.callbackInfos, i);
                    --i;
                  }
                }
              };
              _proto2.removeByTarget = function removeByTarget(target) {
                for (var i = 0; i < this.callbackInfos.length; ++i) {
                  var info = this.callbackInfos[i];
                  if (info && info.target === target) {
                    info.reset();
                    callbackInfoPool.free(info);
                    fastRemoveAt$1(this.callbackInfos, i);
                    --i;
                  }
                }
              };
              _proto2.cancel = function cancel(index) {
                var info = this.callbackInfos[index];
                if (info) {
                  info.reset();
                  if (this.isInvoking) {
                    this.callbackInfos[index] = null;
                  } else {
                    fastRemoveAt$1(this.callbackInfos, index);
                  }
                  callbackInfoPool.free(info);
                }
                this.containCanceled = true;
              };
              _proto2.cancelAll = function cancelAll() {
                for (var i = 0; i < this.callbackInfos.length; i++) {
                  var info = this.callbackInfos[i];
                  if (info) {
                    info.reset();
                    callbackInfoPool.free(info);
                    this.callbackInfos[i] = null;
                  }
                }
                this.containCanceled = true;
              };
              _proto2.purgeCanceled = function purgeCanceled() {
                for (var i = this.callbackInfos.length - 1; i >= 0; --i) {
                  var info = this.callbackInfos[i];
                  if (!info) {
                    fastRemoveAt$1(this.callbackInfos, i);
                  }
                }
                this.containCanceled = false;
              };
              _proto2.clear = function clear() {
                this.cancelAll();
                this.callbackInfos.length = 0;
                this.isInvoking = false;
                this.containCanceled = false;
              };
              return CallbackList;
            }();
            var MAX_SIZE = 16;
            var callbackListPool = new Pool(function () {
              return new CallbackList();
            }, MAX_SIZE);
            var CallbacksInvoker = exports("CallbacksInvoker", function () {
              function CallbacksInvoker() {
                this._callbackTable = createMap(true);
                this._offCallback = undefined;
              }
              var _proto3 = CallbacksInvoker.prototype;
              _proto3.on = function on(key, callback, target, once) {
                if (!this.hasEventListener(key, callback, target)) {
                  var list = this._callbackTable[key];
                  if (!list) {
                    list = this._callbackTable[key] = callbackListPool.alloc();
                  }
                  var info = callbackInfoPool.alloc();
                  info.set(callback, target, once);
                  list.callbackInfos.push(info);
                }
                return callback;
              };
              _proto3.hasEventListener = function hasEventListener(key, callback, target) {
                var list = this._callbackTable && this._callbackTable[key];
                if (!list) {
                  return false;
                }
                var infos = list.callbackInfos;
                if (!callback) {
                  if (list.isInvoking) {
                    for (var i = 0; i < infos.length; ++i) {
                      if (infos[i]) {
                        return true;
                      }
                    }
                    return false;
                  } else {
                    return infos.length > 0;
                  }
                }
                for (var _i = 0; _i < infos.length; ++_i) {
                  var info = infos[_i];
                  if (info && info.check() && info.callback === callback && info.target === target) {
                    return true;
                  }
                }
                return false;
              };
              _proto3.removeAll = function removeAll(keyOrTarget) {
                var type = typeof keyOrTarget;
                if (type === 'string' || type === 'number') {
                  var list = this._callbackTable && this._callbackTable[keyOrTarget];
                  if (list) {
                    if (list.isInvoking) {
                      list.cancelAll();
                    } else {
                      list.clear();
                      callbackListPool.free(list);
                      delete this._callbackTable[keyOrTarget];
                    }
                  }
                } else if (keyOrTarget) {
                  for (var key in this._callbackTable) {
                    var _list = this._callbackTable[key];
                    if (_list.isInvoking) {
                      var infos = _list.callbackInfos;
                      for (var i = 0; i < infos.length; ++i) {
                        var info = infos[i];
                        if (info && info.target === keyOrTarget) {
                          _list.cancel(i);
                        }
                      }
                    } else {
                      _list.removeByTarget(keyOrTarget);
                    }
                  }
                }
              };
              _proto3.off = function off(key, callback, target) {
                var _this$_offCallback;
                var list = this._callbackTable && this._callbackTable[key];
                if (list) {
                  var infos = list.callbackInfos;
                  if (callback) {
                    for (var i = 0; i < infos.length; ++i) {
                      var info = infos[i];
                      if (info && info.callback === callback && info.target === target) {
                        list.cancel(i);
                        break;
                      }
                    }
                  } else {
                    this.removeAll(key);
                  }
                }
                (_this$_offCallback = this._offCallback) == null ? undefined : _this$_offCallback.call(this);
              };
              _proto3.emit = function emit(key, arg0, arg1, arg2, arg3, arg4) {
                var list = this._callbackTable && this._callbackTable[key];
                if (list) {
                  var rootInvoker = !list.isInvoking;
                  list.isInvoking = true;
                  var infos = list.callbackInfos;
                  for (var i = 0, len = infos.length; i < len; ++i) {
                    var info = infos[i];
                    if (info) {
                      var callback = info.callback;
                      var target = info.target;
                      if (info.once) {
                        this.off(key, callback, target);
                      }
                      if (!info.check()) {
                        this.off(key, callback, target);
                      } else if (target) {
                        callback.call(target, arg0, arg1, arg2, arg3, arg4);
                      } else {
                        callback(arg0, arg1, arg2, arg3, arg4);
                      }
                    }
                  }
                  if (rootInvoker) {
                    list.isInvoking = false;
                    if (list.containCanceled) {
                      list.purgeCanceled();
                    }
                  }
                }
              };
              _proto3.clear = function clear() {
                for (var key in this._callbackTable) {
                  var list = this._callbackTable[key];
                  if (list) {
                    list.clear();
                    callbackListPool.free(list);
                    delete this._callbackTable[key];
                  }
                }
              };
              _proto3._registerOffCallback = function _registerOffCallback(cb) {
                this._offCallback = cb;
              };
              return CallbacksInvoker;
            }());

            function Eventify(base) {
              var Eventified = function (_ref) {
                _inheritsLoose(Eventified, _ref);
                function Eventified() {
                  var _this;
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  _this = _ref.call.apply(_ref, [this].concat(args)) || this;
                  _this._callbackTable = createMap(true);
                  return _this;
                }
                var _proto = Eventified.prototype;
                _proto.once = function once(type, callback, target) {
                  return this.on(type, callback, target, true);
                };
                _proto.targetOff = function targetOff(typeOrTarget) {
                  this.removeAll(typeOrTarget);
                };
                return Eventified;
              }(base);
              var callbacksInvokerPrototype = CallbacksInvoker.prototype;
              var propertyKeys = Object.getOwnPropertyNames(callbacksInvokerPrototype).concat(Object.getOwnPropertySymbols(callbacksInvokerPrototype));
              for (var iPropertyKey = 0; iPropertyKey < propertyKeys.length; ++iPropertyKey) {
                var propertyKey = propertyKeys[iPropertyKey];
                if (!(propertyKey in Eventified.prototype)) {
                  var propertyDescriptor = Object.getOwnPropertyDescriptor(callbacksInvokerPrototype, propertyKey);
                  if (propertyDescriptor) {
                    Object.defineProperty(Eventified.prototype, propertyKey, propertyDescriptor);
                  }
                }
              }
              return Eventified;
            }

            var Empty$1 = function Empty() {};
            var EventTarget = exports("EventTarget", Eventify(Empty$1));
            legacyCC.EventTarget = EventTarget;

            var AsyncDelegate = exports("AsyncDelegate", function () {
              function AsyncDelegate() {
                this._delegates = [];
              }
              var _proto = AsyncDelegate.prototype;
              _proto.add = function add(callback) {
                if (!this._delegates.includes(callback)) {
                  this._delegates.push(callback);
                }
              };
              _proto.hasListener = function hasListener(callback) {
                return this._delegates.includes(callback);
              };
              _proto.remove = function remove(callback) {
                fastRemove(this._delegates, callback);
              };
              _proto.dispatch = function dispatch() {
                var _arguments = arguments;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return Promise.all(this._delegates.map(function (func) {
                  return func.apply(undefined, _arguments);
                }).filter(Boolean));
              };
              return AsyncDelegate;
            }());

            var BrowserType;
            (function (BrowserType) {
              BrowserType["UNKNOWN"] = "unknown";
              BrowserType["WECHAT"] = "wechat";
              BrowserType["ANDROID"] = "androidbrowser";
              BrowserType["IE"] = "ie";
              BrowserType["EDGE"] = "edge";
              BrowserType["QQ"] = "qqbrowser";
              BrowserType["MOBILE_QQ"] = "mqqbrowser";
              BrowserType["UC"] = "ucbrowser";
              BrowserType["UCBS"] = "ucbs";
              BrowserType["BROWSER_360"] = "360browser";
              BrowserType["BAIDU_APP"] = "baiduboxapp";
              BrowserType["BAIDU"] = "baidubrowser";
              BrowserType["MAXTHON"] = "maxthon";
              BrowserType["OPERA"] = "opera";
              BrowserType["OUPENG"] = "oupeng";
              BrowserType["MIUI"] = "miuibrowser";
              BrowserType["FIREFOX"] = "firefox";
              BrowserType["SAFARI"] = "safari";
              BrowserType["CHROME"] = "chrome";
              BrowserType["LIEBAO"] = "liebao";
              BrowserType["QZONE"] = "qzone";
              BrowserType["SOUGOU"] = "sogou";
              BrowserType["HUAWEI"] = "huawei";
            })(BrowserType || (BrowserType = {}));

            var Language;
            (function (Language) {
              Language["UNKNOWN"] = "unknown";
              Language["ENGLISH"] = "en";
              Language["CHINESE"] = "zh";
              Language["FRENCH"] = "fr";
              Language["ITALIAN"] = "it";
              Language["GERMAN"] = "de";
              Language["SPANISH"] = "es";
              Language["DUTCH"] = "du";
              Language["RUSSIAN"] = "ru";
              Language["KOREAN"] = "ko";
              Language["JAPANESE"] = "ja";
              Language["HUNGARIAN"] = "hu";
              Language["PORTUGUESE"] = "pt";
              Language["ARABIC"] = "ar";
              Language["NORWEGIAN"] = "no";
              Language["POLISH"] = "pl";
              Language["TURKISH"] = "tr";
              Language["UKRAINIAN"] = "uk";
              Language["ROMANIAN"] = "ro";
              Language["BULGARIAN"] = "bg";
              Language["HINDI"] = "hi";
            })(Language || (Language = {}));

            var NetworkType;
            (function (NetworkType) {
              NetworkType[NetworkType["NONE"] = 0] = "NONE";
              NetworkType[NetworkType["LAN"] = 1] = "LAN";
              NetworkType[NetworkType["WWAN"] = 2] = "WWAN";
            })(NetworkType || (NetworkType = {}));

            var OS;
            (function (OS) {
              OS["UNKNOWN"] = "Unknown";
              OS["IOS"] = "iOS";
              OS["ANDROID"] = "Android";
              OS["WINDOWS"] = "Windows";
              OS["LINUX"] = "Linux";
              OS["OSX"] = "OS X";
              OS["OHOS"] = "OHOS";
              OS["OPENHARMONY"] = "OpenHarmony";
            })(OS || (OS = {}));

            var Platform;
            (function (Platform) {
              Platform["UNKNOWN"] = "UNKNOWN";
              Platform["EDITOR_PAGE"] = "EDITOR_PAGE";
              Platform["EDITOR_CORE"] = "EDITOR_CORE";
              Platform["MOBILE_BROWSER"] = "MOBILE_BROWSER";
              Platform["DESKTOP_BROWSER"] = "DESKTOP_BROWSER";
              Platform["WIN32"] = "WIN32";
              Platform["ANDROID"] = "ANDROID";
              Platform["IOS"] = "IOS";
              Platform["MACOS"] = "MACOS";
              Platform["OHOS"] = "OHOS";
              Platform["OPENHARMONY"] = "OPENHARMONY";
              Platform["WECHAT_GAME"] = "WECHAT_GAME";
              Platform["WECHAT_MINI_PROGRAM"] = "WECHAT_MINI_PROGRAM";
              Platform["XIAOMI_QUICK_GAME"] = "XIAOMI_QUICK_GAME";
              Platform["ALIPAY_MINI_GAME"] = "ALIPAY_MINI_GAME";
              Platform["TAOBAO_CREATIVE_APP"] = "TAOBAO_CREATIVE_APP";
              Platform["TAOBAO_MINI_GAME"] = "TAOBAO_MINI_GAME";
              Platform["BYTEDANCE_MINI_GAME"] = "BYTEDANCE_MINI_GAME";
              Platform["OPPO_MINI_GAME"] = "OPPO_MINI_GAME";
              Platform["VIVO_MINI_GAME"] = "VIVO_MINI_GAME";
              Platform["HUAWEI_QUICK_GAME"] = "HUAWEI_QUICK_GAME";
              Platform["MIGU_MINI_GAME"] = "MIGU_MINI_GAME";
              Platform["HONOR_MINI_GAME"] = "HONOR_MINI_GAME";
            })(Platform || (Platform = {}));

            var Feature;
            (function (Feature) {
              Feature["WEBP"] = "WEBP";
              Feature["IMAGE_BITMAP"] = "IMAGE_BITMAP";
              Feature["WEB_VIEW"] = "WEB_VIEW";
              Feature["VIDEO_PLAYER"] = "VIDEO_PLAYER";
              Feature["SAFE_AREA"] = "SAFE_AREA";
              Feature["HPE"] = "HPE";
              Feature["INPUT_TOUCH"] = "INPUT_TOUCH";
              Feature["EVENT_KEYBOARD"] = "EVENT_KEYBOARD";
              Feature["EVENT_MOUSE"] = "EVENT_MOUSE";
              Feature["EVENT_TOUCH"] = "EVENT_TOUCH";
              Feature["EVENT_ACCELEROMETER"] = "EVENT_ACCELEROMETER";
              Feature["EVENT_GAMEPAD"] = "EVENT_GAMEPAD";
              Feature["EVENT_HANDLE"] = "EVENT_HANDLE";
              Feature["EVENT_HMD"] = "EVENT_HMD";
              Feature["EVENT_HANDHELD"] = "EVENT_HANDHELD";
              Feature["WASM"] = "WASM";
            })(Feature || (Feature = {}));

            var SystemInfo = function (_EventTarget) {
              _inheritsLoose(SystemInfo, _EventTarget);
              function SystemInfo() {
                var _this$_featureMap;
                var _this;
                _this = _EventTarget.call(this) || this;
                _this._battery = null;
                _this._initPromise = [];
                var nav = window.navigator;
                var ua = nav.userAgent.toLowerCase();
                nav.getBattery == null ? undefined : nav.getBattery().then(function (battery) {
                  _this._battery = battery;
                });
                _this.networkType = NetworkType.LAN;
                _this.isNative = false;
                _this.isBrowser = true;
                {
                  _this.isMobile = /mobile|android|iphone|ipad/.test(ua);
                  _this.platform = _this.isMobile ? Platform.MOBILE_BROWSER : Platform.DESKTOP_BROWSER;
                }
                _this.isLittleEndian = function () {
                  var buffer = new ArrayBuffer(2);
                  new DataView(buffer).setInt16(0, 256, true);
                  return new Int16Array(buffer)[0] === 256;
                }();
                var currLanguage = nav.language;
                _this.nativeLanguage = currLanguage.toLowerCase();
                currLanguage = currLanguage || nav.browserLanguage;
                currLanguage = currLanguage ? currLanguage.split('-')[0] : Language.ENGLISH;
                _this.language = currLanguage;
                var isAndroid = false;
                var iOS = false;
                var osVersion = '';
                var osMajorVersion = 0;
                var uaResult = /android\s*(\d+(?:\.\d+)*)/i.exec(ua) || /android\s*(\d+(?:\.\d+)*)/i.exec(nav.platform);
                if (uaResult) {
                  isAndroid = true;
                  osVersion = uaResult[1] || '';
                  osMajorVersion = parseInt(osVersion) || 0;
                }
                uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua);
                if (uaResult) {
                  iOS = true;
                  osVersion = uaResult[2] || '';
                  osMajorVersion = parseInt(osVersion) || 0;
                } else if (/(iPhone|iPad|iPod)/.exec(nav.platform) || nav.platform === 'MacIntel' && nav.maxTouchPoints && nav.maxTouchPoints > 1) {
                  iOS = true;
                  osVersion = '';
                  osMajorVersion = 0;
                }
                var osName = OS.UNKNOWN;
                if (nav.appVersion.indexOf('Win') !== -1) {
                  osName = OS.WINDOWS;
                } else if (iOS) {
                  osName = OS.IOS;
                } else if (nav.appVersion.indexOf('Mac') !== -1) {
                  osName = OS.OSX;
                } else if (nav.appVersion.indexOf('X11') !== -1 && nav.appVersion.indexOf('Linux') === -1) {
                  osName = OS.LINUX;
                } else if (isAndroid) {
                  osName = OS.ANDROID;
                } else if (nav.appVersion.indexOf('Linux') !== -1 || ua.indexOf('ubuntu') !== -1) {
                  osName = OS.LINUX;
                }
                _this.os = osName;
                _this.osVersion = osVersion;
                _this.osMainVersion = osMajorVersion;
                _this.browserType = BrowserType.UNKNOWN;
                var typeReg0 = /wechat|weixin|micromessenger/i;
                var typeReg1 = /mqqbrowser|micromessenger|qqbrowser|sogou|qzone|liebao|maxthon|ucbs|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i;
                var typeReg2 = /qq|qqbrowser|ucbrowser|ubrowser|edge|HuaweiBrowser/i;
                var typeReg3 = /chrome|safari|firefox|trident|opera|opr\/|oupeng/i;
                var browserTypes = typeReg0.exec(ua) || typeReg1.exec(ua) || typeReg2.exec(ua) || typeReg3.exec(ua);
                var browserType = browserTypes ? browserTypes[0].toLowerCase() : OS.UNKNOWN;
                if (browserType === 'safari' && isAndroid) {
                  browserType = BrowserType.ANDROID;
                } else if (browserType === 'qq' && /android.*applewebkit/i.test(ua)) {
                  browserType = BrowserType.ANDROID;
                }
                var typeMap = {
                  micromessenger: BrowserType.WECHAT,
                  wechat: BrowserType.WECHAT,
                  weixin: BrowserType.WECHAT,
                  trident: BrowserType.IE,
                  edge: BrowserType.EDGE,
                  '360 aphone': BrowserType.BROWSER_360,
                  mxbrowser: BrowserType.MAXTHON,
                  'opr/': BrowserType.OPERA,
                  ubrowser: BrowserType.UC,
                  huaweibrowser: BrowserType.HUAWEI
                };
                _this.browserType = typeMap[browserType] || browserType;
                _this.browserVersion = '';
                var versionReg1 = /(mqqbrowser|micromessenger|qqbrowser|sogou|qzone|liebao|maxthon|uc|ucbs|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui(?:.hybrid)?)(mobile)?(browser)?\/?([\d.]+)/i;
                var versionReg2 = /(qq|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i;
                var tmp = versionReg1.exec(ua);
                if (!tmp) {
                  tmp = versionReg2.exec(ua);
                }
                _this.browserVersion = tmp ? tmp[4] : '';
                _this.isXR = false;
                var _tmpCanvas1 = document.createElement('canvas');
                !!_tmpCanvas1.getContext('2d');
                var supportWebp;
                try {
                  supportWebp = TEST ? false : _tmpCanvas1.toDataURL('image/webp').startsWith('data:image/webp');
                } catch (e) {
                  supportWebp = false;
                }
                if (_this.os === OS.IOS) {
                  var _exec;
                  var result = (_exec = / applewebkit\/(\d+)/.exec(ua)) == null ? undefined : _exec[1];
                  if (typeof result === 'string') {
                    if (Number.parseInt(result) >= 604) {
                      supportWebp = true;
                    }
                  }
                } else if (_this.browserType === BrowserType.SAFARI) {
                  var _exec2;
                  var _result = (_exec2 = / version\/(\d+)/.exec(ua)) == null ? undefined : _exec2[1];
                  if (typeof _result === 'string') {
                    if (Number.parseInt(_result) >= 14) {
                      supportWebp = true;
                    }
                  }
                }
                var supportTouch = document.documentElement.ontouchstart !== undefined || document.ontouchstart !== undefined || EDITOR;
                var supportMouse = document.documentElement.onmouseup !== undefined || EDITOR;
                var supportXR = typeof navigator.xr !== 'undefined';
                var supportWasm = function () {
                  var isSafari_15_4 = (_this.os === OS.IOS || _this.os === OS.OSX) && /(OS 15_4)|(Version\/15.4)/.test(window.navigator.userAgent);
                  if (isSafari_15_4) {
                    return false;
                  }
                  try {
                    if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
                      var module = new WebAssembly.Module(new Uint8Array([0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00]));
                      if (module instanceof WebAssembly.Module) {
                        return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
                      }
                    }
                  } catch (e) {
                    return false;
                  }
                  return false;
                }();
                _this._featureMap = (_this$_featureMap = {}, _this$_featureMap[Feature.WEBP] = supportWebp, _this$_featureMap[Feature.IMAGE_BITMAP] = false, _this$_featureMap[Feature.WEB_VIEW] = true, _this$_featureMap[Feature.VIDEO_PLAYER] = true, _this$_featureMap[Feature.SAFE_AREA] = false, _this$_featureMap[Feature.HPE] = false, _this$_featureMap[Feature.INPUT_TOUCH] = supportTouch, _this$_featureMap[Feature.EVENT_KEYBOARD] = document.documentElement.onkeyup !== undefined || EDITOR, _this$_featureMap[Feature.EVENT_MOUSE] = supportMouse, _this$_featureMap[Feature.EVENT_TOUCH] = supportTouch || supportMouse, _this$_featureMap[Feature.EVENT_ACCELEROMETER] = window.DeviceMotionEvent !== undefined || window.DeviceOrientationEvent !== undefined, _this$_featureMap[Feature.EVENT_GAMEPAD] = navigator.getGamepads !== undefined || navigator.webkitGetGamepads !== undefined || supportXR, _this$_featureMap[Feature.EVENT_HANDLE] = PREVIEW, _this$_featureMap[Feature.EVENT_HMD] = supportXR, _this$_featureMap[Feature.EVENT_HANDHELD] = supportXR, _this$_featureMap[Feature.WASM] = supportWasm, _this$_featureMap);
                _this._initPromise.push(_this._supportsImageBitmapPromise());
                _this._registerEvent();
                return _this;
              }
              var _proto = SystemInfo.prototype;
              _proto._supportsImageBitmapPromise = function _supportsImageBitmapPromise() {
                var _this2 = this;
                if (typeof createImageBitmap !== 'undefined' && typeof Blob !== 'undefined') {
                  var canvas = document.createElement('canvas');
                  canvas.width = canvas.height = 2;
                  var promise = createImageBitmap(canvas);
                  if (promise instanceof Promise) {
                    return promise.then(function (imageBitmap) {
                      if (imageBitmap && imageBitmap.close) {
                        _this2._setFeature(Feature.IMAGE_BITMAP, true);
                        imageBitmap.close();
                      }
                    });
                  } else {
                    warn('The return value of createImageBitmap is not Promise.');
                  }
                }
                return Promise.resolve();
              };
              _proto._registerEvent = function _registerEvent() {
                var _this3 = this;
                var hiddenPropName;
                if (typeof document.hidden !== 'undefined') {
                  hiddenPropName = 'hidden';
                } else if (typeof document.mozHidden !== 'undefined') {
                  hiddenPropName = 'mozHidden';
                } else if (typeof document.msHidden !== 'undefined') {
                  hiddenPropName = 'msHidden';
                } else if (typeof document.webkitHidden !== 'undefined') {
                  hiddenPropName = 'webkitHidden';
                } else {
                  hiddenPropName = 'hidden';
                }
                var hidden = false;
                var onHidden = function onHidden() {
                  if (!hidden) {
                    hidden = true;
                    _this3.emit('hide');
                  }
                };
                var onShown = function onShown(arg0, arg1, arg2, arg3, arg4) {
                  if (hidden) {
                    hidden = false;
                    _this3.emit('show', arg0, arg1, arg2, arg3, arg4);
                  }
                };
                if (hiddenPropName) {
                  var changeList = ['visibilitychange', 'mozvisibilitychange', 'msvisibilitychange', 'webkitvisibilitychange', 'qbrowserVisibilityChange'];
                  for (var i = 0; i < changeList.length; i++) {
                    document.addEventListener(changeList[i], function (event) {
                      var visible = document[hiddenPropName];
                      visible = visible || event.hidden;
                      if (visible) {
                        onHidden();
                      } else {
                        onShown();
                      }
                    });
                  }
                } else {
                  window.addEventListener('blur', onHidden);
                  window.addEventListener('focus', onShown);
                }
                if (window.navigator.userAgent.indexOf('MicroMessenger') > -1) {
                  window.onfocus = onShown;
                }
                if ('onpageshow' in window && 'onpagehide' in window) {
                  window.addEventListener('pagehide', onHidden);
                  window.addEventListener('pageshow', onShown);
                  document.addEventListener('pagehide', onHidden);
                  document.addEventListener('pageshow', onShown);
                }
              };
              _proto._setFeature = function _setFeature(feature, value) {
                return this._featureMap[feature] = value;
              };
              _proto.init = function init() {
                return Promise.all(this._initPromise);
              };
              _proto.hasFeature = function hasFeature(feature) {
                return this._featureMap[feature];
              };
              _proto.getBatteryLevel = function getBatteryLevel() {
                if (this._battery) {
                  return this._battery.level;
                } else {
                  {
                    warn('getBatteryLevel is not supported');
                  }
                  return 1;
                }
              };
              _proto.triggerGC = function triggerGC() {
                {
                  warn('triggerGC is not supported.');
                }
              };
              _proto.openURL = function openURL(url) {
                window.open(url);
              };
              _proto.now = function now() {
                if (Date.now) {
                  return Date.now();
                }
                return +new Date();
              };
              _proto.restartJSVM = function restartJSVM() {
                {
                  warn('restartJSVM is not supported.');
                }
              };
              _proto.exit = function exit() {
                window.close();
              };
              _proto.close = function close() {
                this.emit('close');
              };
              return SystemInfo;
            }(EventTarget);
            var systemInfo = new SystemInfo();

            var EXTNAME_RE = /(\.[^./?\\]*)(\?.*)?$/;
            var DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
            var NORMALIZE_RE = /[^./]+\/\.\.\//;
            function join() {
              var result = '';
              for (var _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) {
                segments[_key] = arguments[_key];
              }
              segments.forEach(function (segment) {
                result = (result + (result === '' ? '' : '/') + segment).replace(/(\/|\\\\)$/, '');
              });
              return result;
            }
            function extname(path) {
              var temp = EXTNAME_RE.exec(path);
              return temp ? temp[1] : '';
            }
            function mainFileName(fileName) {
              if (fileName) {
                var idx = fileName.lastIndexOf('.');
                if (idx !== -1) {
                  return fileName.substring(0, idx);
                }
              }
              return fileName;
            }
            function basename(path, extName) {
              var index = path.indexOf('?');
              if (index > 0) {
                path = path.substring(0, index);
              }
              var reg = /(\/|\\)([^/\\]+)$/g;
              var result = reg.exec(path.replace(/(\/|\\)$/, ''));
              if (!result) {
                return path;
              }
              var baseName = result[2];
              if (extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase()) {
                return baseName.substring(0, baseName.length - extName.length);
              }
              return baseName;
            }
            function dirname(path) {
              var temp = DIRNAME_RE.exec(path);
              return temp ? temp[2] : '';
            }
            function changeExtname(path, extName) {
              extName = extName || '';
              var index = path.indexOf('?');
              var tempStr = '';
              if (index > 0) {
                tempStr = path.substring(index);
                path = path.substring(0, index);
              }
              index = path.lastIndexOf('.');
              if (index < 0) {
                return path + extName + tempStr;
              }
              return path.substring(0, index) + extName + tempStr;
            }
            function changeBasename(path, newBaseName, keepExt) {
              if (newBaseName.indexOf('.') === 0) {
                return changeExtname(path, newBaseName);
              }
              var index = path.indexOf('?');
              var tempStr = '';
              var ext = keepExt ? extname(path) : '';
              if (index > 0) {
                tempStr = path.substring(index);
                path = path.substring(0, index);
              }
              index = path.lastIndexOf('/');
              index = index <= 0 ? 0 : index + 1;
              return path.substring(0, index) + newBaseName + ext + tempStr;
            }
            function _normalize(url) {
              var oldUrl = url = String(url);
              do {
                oldUrl = url;
                url = url.replace(NORMALIZE_RE, '');
              } while (oldUrl.length !== url.length);
              return url;
            }
            function stripSep(path) {
              return path.replace(/[/\\]$/, '');
            }
            function getSeperator() {
              return systemInfo.os === OS.WINDOWS ? '\\' : '/';
            }

            var path = /*#__PURE__*/Object.freeze({
                __proto__: null,
                _normalize: _normalize,
                basename: basename,
                changeBasename: changeBasename,
                changeExtname: changeExtname,
                dirname: dirname,
                extname: extname,
                getSeperator: getSeperator,
                join: join,
                mainFileName: mainFileName,
                stripSep: stripSep
            });
            exports("path", path);

            var _vec3 = new Vec3();
            function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
              if (!out) {
                out = new Vec3();
              }
              mainCamera.convertToUINode(wpos, uiNode, out);
              var pos = uiNode.position;
              out.add(pos);
              return out;
            }
            function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
              if (!out) {
                out = new Vec3();
              }
              mainCamera.worldToScreen(wpos, out);
              out.x /= legacyCC.view.getScaleX();
              out.y /= legacyCC.view.getScaleY();
              return out;
            }
            var convertUtils = exports("convertUtils", {
              WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
              WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI
            });
            legacyCC.pipelineUtils = convertUtils;
            replaceProperty(legacyCC.pipelineUtils, 'cc.pipelineUtils', [{
              name: 'WorldNode3DToLocalNodeUI',
              newName: 'convertToUINode',
              targetName: 'cc.Camera.prototype',
              customFunction: function customFunction() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var camera = args[0];
                var out = args[3] || _vec3;
                camera.convertToUINode(args[1], args[2], out);
                out.add(args[2].position);
                return args[3] || out.clone();
              }
            }]);

            var EVENT_TIMEOUT = 200;
            var orientationMap$2 = {
              auto: Orientation.AUTO,
              landscape: Orientation.LANDSCAPE,
              portrait: Orientation.PORTRAIT
            };
            var WindowType;
            (function (WindowType) {
              WindowType[WindowType["Unknown"] = 0] = "Unknown";
              WindowType[WindowType["SubFrame"] = 1] = "SubFrame";
              WindowType[WindowType["BrowserWindow"] = 2] = "BrowserWindow";
              WindowType[WindowType["Fullscreen"] = 3] = "Fullscreen";
            })(WindowType || (WindowType = {}));
            var ScreenAdapter = function (_EventTarget) {
              _inheritsLoose(ScreenAdapter, _EventTarget);
              var _proto = ScreenAdapter.prototype;
              _proto._updateFrame = function _updateFrame() {
                this._updateFrameState();
                this._resizeFrame();
              };
              function ScreenAdapter() {
                var _this;
                _this = _EventTarget.call(this) || this;
                _this.isFrameRotated = false;
                _this.handleResizeEvent = true;
                _this._gameFrame = undefined;
                _this._gameContainer = undefined;
                _this._gameCanvas = undefined;
                _this._isProportionalToFrame = false;
                _this._cachedFrameStyle = {
                  width: '0px',
                  height: '0px'
                };
                _this._cachedContainerStyle = {
                  width: '0px',
                  height: '0px'
                };
                _this._cbToUpdateFrameBuffer = undefined;
                _this._supportFullScreen = false;
                _this._touchEventName = undefined;
                _this._onFullscreenChange = undefined;
                _this._onFullscreenError = undefined;
                _this._orientationChangeTimeoutId = -1;
                _this._cachedFrameSize = new Size(0, 0);
                _this._exactFitScreen = false;
                _this._isHeadlessMode = false;
                _this._fn = {};
                _this._fnGroup = [['requestFullscreen', 'exitFullscreen', 'fullscreenchange', 'fullscreenEnabled', 'fullscreenElement', 'fullscreenerror'], ['requestFullScreen', 'exitFullScreen', 'fullScreenchange', 'fullScreenEnabled', 'fullScreenElement', 'fullscreenerror'], ['webkitRequestFullScreen', 'webkitCancelFullScreen', 'webkitfullscreenchange', 'webkitIsFullScreen', 'webkitCurrentFullScreenElement', 'webkitfullscreenerror'], ['mozRequestFullScreen', 'mozCancelFullScreen', 'mozfullscreenchange', 'mozFullScreen', 'mozFullScreenElement', 'mozfullscreenerror'], ['msRequestFullscreen', 'msExitFullscreen', 'MSFullscreenChange', 'msFullscreenEnabled', 'msFullscreenElement', 'msfullscreenerror']];
                _this._resolutionScale = 1;
                _this._orientation = Orientation.AUTO;
                _this._orientationDevice = Orientation.AUTO;
                _this._gameFrame = document.getElementById('GameDiv');
                _this._gameContainer = document.getElementById('Cocos3dGameContainer');
                _this._gameCanvas = document.getElementById('GameCanvas');
                {
                  if (!_this._gameFrame) {
                    var _this$_gameCanvas, _this$_gameCanvas$par;
                    _this._gameFrame = document.createElement('div');
                    _this._gameFrame.setAttribute('id', 'GameDiv');
                    (_this$_gameCanvas = _this._gameCanvas) == null ? undefined : (_this$_gameCanvas$par = _this$_gameCanvas.parentNode) == null ? undefined : _this$_gameCanvas$par.insertBefore(_this._gameFrame, _this._gameCanvas);
                    _this._gameFrame.appendChild(_this._gameCanvas);
                  }
                  if (!_this._gameContainer) {
                    var _this$_gameCanvas2, _this$_gameCanvas2$pa;
                    _this._gameContainer = document.createElement('div');
                    _this._gameContainer.setAttribute('id', 'Cocos3dGameContainer');
                    (_this$_gameCanvas2 = _this._gameCanvas) == null ? undefined : (_this$_gameCanvas2$pa = _this$_gameCanvas2.parentNode) == null ? undefined : _this$_gameCanvas2$pa.insertBefore(_this._gameContainer, _this._gameCanvas);
                    _this._gameContainer.appendChild(_this._gameCanvas);
                  }
                }
                var fnList;
                var fnGroup = _this._fnGroup;
                for (var i = 0; i < fnGroup.length; i++) {
                  fnList = fnGroup[i];
                  if (typeof document[fnList[1]] !== 'undefined') {
                    for (var _i = 0; _i < fnList.length; _i++) {
                      _this._fn[fnGroup[0][_i]] = fnList[_i];
                    }
                    break;
                  }
                }
                _this._supportFullScreen = _this._fn.requestFullscreen !== undefined;
                _this._touchEventName = 'ontouchstart' in window ? 'touchend' : 'mousedown';
                _this._registerEvent();
                return _this;
              }
              _proto.init = function init(options, cbToRebuildFrameBuffer) {
                this._cbToUpdateFrameBuffer = cbToRebuildFrameBuffer;
                this.orientation = orientationMap$2[options.configOrientation];
                this._exactFitScreen = options.exactFitScreen;
                this._isHeadlessMode = options.isHeadlessMode;
                this._resizeFrame();
              };
              _proto.requestFullScreen = function requestFullScreen() {
                var _this2 = this;
                return new Promise(function (resolve, reject) {
                  if (_this2.isFullScreen) {
                    resolve();
                    return;
                  }
                  _this2._cachedFrameSize = _this2.windowSize;
                  _this2._doRequestFullScreen().then(function () {
                    resolve();
                  })["catch"](function () {
                    var fullscreenTarget = _this2._getFullscreenTarget();
                    if (!fullscreenTarget) {
                      reject(new Error('Cannot access fullscreen target'));
                      return;
                    }
                    fullscreenTarget.addEventListener(_this2._touchEventName, function () {
                      _this2._doRequestFullScreen().then(function () {
                        resolve();
                      })["catch"](reject);
                    }, {
                      once: true,
                      capture: true
                    });
                  });
                });
              };
              _proto.exitFullScreen = function exitFullScreen() {
                var _this3 = this;
                return new Promise(function (resolve, reject) {
                  var requestPromise = document[_this3._fn.exitFullscreen]();
                  if (window.Promise && requestPromise instanceof Promise) {
                    requestPromise.then(function () {
                      _this3.windowSize = _this3._cachedFrameSize;
                      resolve();
                    })["catch"](reject);
                    return;
                  }
                  _this3.windowSize = _this3._cachedFrameSize;
                  resolve();
                });
              };
              _proto._registerEvent = function _registerEvent() {
                var _this4 = this;
                document.addEventListener(this._fn.fullscreenerror, function () {
                  _this4._onFullscreenError == null ? undefined : _this4._onFullscreenError();
                });
                window.addEventListener('resize', function () {
                  _this4._updateFrame();
                });
                var notifyOrientationChange = function notifyOrientationChange(orientation) {
                  if (orientation === _this4._orientationDevice) {
                    return;
                  }
                  _this4._orientationDevice = orientation;
                  _this4._updateFrame();
                  _this4.emit('orientation-change', orientation);
                };
                var getOrientation = function getOrientation() {
                  var tmpOrientation = Orientation.PORTRAIT;
                  switch (window.orientation) {
                    case 0:
                      tmpOrientation = Orientation.PORTRAIT;
                      break;
                    case 90:
                      tmpOrientation = Orientation.LANDSCAPE_RIGHT;
                      break;
                    case -90:
                      tmpOrientation = Orientation.LANDSCAPE_LEFT;
                      break;
                    case 180:
                      tmpOrientation = Orientation.PORTRAIT_UPSIDE_DOWN;
                      break;
                    default:
                      tmpOrientation = _this4._orientationDevice;
                      break;
                  }
                  return tmpOrientation;
                };
                var handleOrientationChange;
                var orientationChangeCallback = function orientationChangeCallback() {
                  if (_this4._orientationChangeTimeoutId !== -1) {
                    clearTimeout(_this4._orientationChangeTimeoutId);
                  }
                  _this4._orientationChangeTimeoutId = setTimeout(function () {
                    handleOrientationChange();
                  }, EVENT_TIMEOUT);
                };
                if (typeof window.matchMedia === 'function') {
                  var updateDPRChangeListener = function updateDPRChangeListener() {
                    var dpr = window.devicePixelRatio;
                    var mediaQueryResolution = window.matchMedia("(resolution: " + dpr + "dppx)");
                    if (mediaQueryResolution.addEventListener) {
                      mediaQueryResolution.addEventListener('change', function () {
                        _this4.emit('window-resize', _this4.windowSize.width, _this4.windowSize.height);
                        updateDPRChangeListener();
                      }, {
                        once: true
                      });
                    } else if (mediaQueryResolution.addListener) {
                      mediaQueryResolution.addListener(function () {
                        _this4.emit('window-resize', _this4.windowSize.width, _this4.windowSize.height);
                      });
                    }
                  };
                  updateDPRChangeListener();
                  var mediaQueryPortrait = window.matchMedia('(orientation: portrait)');
                  var mediaQueryLandscape = window.matchMedia('(orientation: landscape)');
                  var hasScreeOrientation = screen.orientation;
                  handleOrientationChange = function handleOrientationChange() {
                    var tmpOrientation = _this4._orientationDevice;
                    if (mediaQueryPortrait.matches) {
                      tmpOrientation = Orientation.PORTRAIT;
                      if (hasScreeOrientation) {
                        var orientationType = screen.orientation.type;
                        if (orientationType === 'portrait-primary') {
                          tmpOrientation = Orientation.PORTRAIT;
                        } else {
                          tmpOrientation = Orientation.PORTRAIT_UPSIDE_DOWN;
                        }
                      }
                    } else if (mediaQueryLandscape.matches) {
                      tmpOrientation = Orientation.LANDSCAPE;
                      if (hasScreeOrientation) {
                        var _orientationType = screen.orientation.type;
                        if (_orientationType === 'landscape-primary') {
                          tmpOrientation = Orientation.LANDSCAPE_LEFT;
                        } else {
                          tmpOrientation = Orientation.LANDSCAPE_RIGHT;
                        }
                      }
                    }
                    notifyOrientationChange(tmpOrientation);
                  };
                  if (mediaQueryPortrait.addEventListener) {
                    mediaQueryPortrait.addEventListener('change', orientationChangeCallback);
                    mediaQueryLandscape.addEventListener('change', orientationChangeCallback);
                  } else if (mediaQueryPortrait.addListener) {
                    mediaQueryPortrait.addListener(orientationChangeCallback);
                    mediaQueryLandscape.addListener(orientationChangeCallback);
                  }
                } else {
                  handleOrientationChange = function handleOrientationChange() {
                    var tmpOrientation = getOrientation();
                    notifyOrientationChange(tmpOrientation);
                  };
                  window.addEventListener('orientationchange', orientationChangeCallback);
                }
                document.addEventListener(this._fn.fullscreenchange, function () {
                  _this4._onFullscreenChange == null ? undefined : _this4._onFullscreenChange();
                  _this4.emit('fullscreen-change', _this4.windowSize.width, _this4.windowSize.height);
                });
              };
              _proto._convertToSizeInCssPixels = function _convertToSizeInCssPixels(size) {
                var clonedSize = size.clone();
                var dpr = this.devicePixelRatio;
                clonedSize.width /= dpr;
                clonedSize.height /= dpr;
                return clonedSize;
              };
              _proto._resizeFrame = function _resizeFrame(sizeInCssPixels) {
                if (!this._gameFrame) {
                  return;
                }
                this._gameFrame.style.display = 'flex';
                this._gameFrame.style['justify-content'] = 'center';
                this._gameFrame.style['align-items'] = 'center';
                if (this._windowType === WindowType.SubFrame) {
                  if (!sizeInCssPixels) {
                    this._updateContainer();
                    return;
                  }
                  this._gameFrame.style.width = sizeInCssPixels.width + "px";
                  this._gameFrame.style.height = sizeInCssPixels.height + "px";
                } else {
                  var winWidth = window.innerWidth;
                  var winHeight = window.innerHeight;
                  var inputHeight = document.body.scrollHeight - winHeight;
                  if (systemInfo.os === OS.ANDROID && winHeight < inputHeight) {
                    winHeight += inputHeight;
                  }
                  if (this.isFrameRotated) {
                    this._gameFrame.style['-webkit-transform'] = 'rotate(90deg)';
                    this._gameFrame.style.transform = 'rotate(90deg)';
                    this._gameFrame.style['-webkit-transform-origin'] = '0px 0px 0px';
                    this._gameFrame.style.transformOrigin = '0px 0px 0px';
                    this._gameFrame.style.margin = "0 0 0 " + winWidth + "px";
                    this._gameFrame.style.width = winHeight + "px";
                    this._gameFrame.style.height = winWidth + "px";
                  } else {
                    this._gameFrame.style['-webkit-transform'] = 'rotate(0deg)';
                    this._gameFrame.style.transform = 'rotate(0deg)';
                    this._gameFrame.style.margin = '0px auto';
                    this._gameFrame.style.width = winWidth + "px";
                    this._gameFrame.style.height = winHeight + "px";
                  }
                }
                this._updateContainer();
              };
              _proto._getFullscreenTarget = function _getFullscreenTarget() {
                var windowType = this._windowType;
                if (windowType === WindowType.Fullscreen) {
                  return document[this._fn.fullscreenElement];
                }
                if (windowType === WindowType.SubFrame) {
                  return this._gameFrame;
                }
                return document.body;
              };
              _proto._doRequestFullScreen = function _doRequestFullScreen() {
                var _this5 = this;
                return new Promise(function (resolve, reject) {
                  if (!_this5._supportFullScreen) {
                    reject(new Error('fullscreen is not supported'));
                    return;
                  }
                  var fullscreenTarget = _this5._getFullscreenTarget();
                  if (!fullscreenTarget) {
                    reject(new Error('Cannot access fullscreen target'));
                    return;
                  }
                  _this5._onFullscreenChange = undefined;
                  _this5._onFullscreenError = undefined;
                  var requestPromise = fullscreenTarget[_this5._fn.requestFullscreen]();
                  if (window.Promise && requestPromise instanceof Promise) {
                    requestPromise.then(resolve)["catch"](reject);
                  } else {
                    _this5._onFullscreenChange = resolve;
                    _this5._onFullscreenError = reject;
                  }
                });
              };
              _proto._updateFrameState = function _updateFrameState() {
                var orientation = this.orientation;
                var width = window.innerWidth;
                var height = window.innerHeight;
                var isBrowserLandscape = width > height;
                this.isFrameRotated = systemInfo.isMobile && (isBrowserLandscape && orientation === Orientation.PORTRAIT || !isBrowserLandscape && orientation === Orientation.LANDSCAPE);
              };
              _proto._updateContainer = function _updateContainer() {
                if (!this._gameContainer) {
                  warnID(9201);
                  return;
                }
                if (this.isProportionalToFrame) {
                  if (!this._gameFrame) {
                    warnID(9201);
                    return;
                  }
                  var designedResolution = legacyCC.view.getDesignResolutionSize();
                  var frame = this._gameFrame;
                  var frameW = frame.clientWidth;
                  var frameH = frame.clientHeight;
                  var designW = designedResolution.width;
                  var designH = designedResolution.height;
                  var scaleX = frameW / designW;
                  var scaleY = frameH / designH;
                  var containerStyle = this._gameContainer.style;
                  var containerW;
                  var containerH;
                  if (scaleX < scaleY) {
                    containerW = frameW;
                    containerH = designH * scaleX;
                  } else {
                    containerW = designW * scaleY;
                    containerH = frameH;
                  }
                  containerStyle.width = containerW + "px";
                  containerStyle.height = containerH + "px";
                } else {
                  var _containerStyle = this._gameContainer.style;
                  _containerStyle.width = '100%';
                  _containerStyle.height = '100%';
                }
                if (this._gameFrame && (this._cachedFrameStyle.width !== this._gameFrame.style.width || this._cachedFrameStyle.height !== this._gameFrame.style.height || this._cachedContainerStyle.width !== this._gameContainer.style.width || this._cachedContainerStyle.height !== this._gameContainer.style.height)) {
                  this.emit('window-resize', this.windowSize.width, this.windowSize.height);
                  this._cachedFrameStyle.width = this._gameFrame.style.width;
                  this._cachedFrameStyle.height = this._gameFrame.style.height;
                  this._cachedContainerStyle.width = this._gameContainer.style.width;
                  this._cachedContainerStyle.height = this._gameContainer.style.height;
                }
              };
              _createClass(ScreenAdapter, [{
                key: "supportFullScreen",
                get: function get() {
                  return this._supportFullScreen;
                }
              }, {
                key: "isFullScreen",
                get: function get() {
                  if (!this._supportFullScreen) {
                    return false;
                  }
                  return !!document[this._fn.fullscreenElement];
                }
              }, {
                key: "devicePixelRatio",
                get: function get() {
                  var _window$devicePixelRa;
                  return Math.min((_window$devicePixelRa = window.devicePixelRatio) !== null && _window$devicePixelRa !== undefined ? _window$devicePixelRa : 1, 2);
                }
              }, {
                key: "windowSize",
                get: function get() {
                  var result = this._windowSizeInCssPixels;
                  var dpr = this.devicePixelRatio;
                  result.width *= dpr;
                  result.height *= dpr;
                  return result;
                },
                set: function set(size) {
                  if (this._windowType !== WindowType.SubFrame) {
                    warnID(9202);
                    return;
                  }
                  this._resizeFrame(this._convertToSizeInCssPixels(size));
                }
              }, {
                key: "resolution",
                get: function get() {
                  var windowSize = this.windowSize;
                  var resolutionScale = this.resolutionScale;
                  return new Size(windowSize.width * resolutionScale, windowSize.height * resolutionScale);
                }
              }, {
                key: "resolutionScale",
                get: function get() {
                  return this._resolutionScale;
                },
                set: function set(v) {
                  var _this$_cbToUpdateFram;
                  if (v === this._resolutionScale) {
                    return;
                  }
                  this._resolutionScale = v;
                  (_this$_cbToUpdateFram = this._cbToUpdateFrameBuffer) == null ? undefined : _this$_cbToUpdateFram.call(this);
                }
              }, {
                key: "orientation",
                get: function get() {
                  return this._orientation;
                },
                set: function set(value) {
                  if (this._orientation === value) {
                    return;
                  }
                  this._orientation = value;
                  this._updateFrame();
                }
              }, {
                key: "safeAreaEdge",
                get: function get() {
                  var dpr = this.devicePixelRatio;
                  var _top = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-top') || '0') * dpr;
                  var _bottom = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom') || '0') * dpr;
                  var _left = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-left') || '0') * dpr;
                  var _right = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-right') || '0') * dpr;
                  return {
                    top: _top,
                    bottom: _bottom,
                    left: _left,
                    right: _right
                  };
                }
              }, {
                key: "isProportionalToFrame",
                get: function get() {
                  return this._isProportionalToFrame;
                },
                set: function set(v) {
                  if (this._isProportionalToFrame === v) {
                    return;
                  }
                  this._isProportionalToFrame = v;
                  this._updateContainer();
                }
              }, {
                key: "_windowSizeInCssPixels",
                get: function get() {
                  if (this.isProportionalToFrame) {
                    if (!this._gameContainer) {
                      warnID(9201);
                      return new Size(0, 0);
                    }
                    return new Size(this._gameContainer.clientWidth, this._gameContainer.clientHeight);
                  }
                  var fullscreenTarget;
                  var width;
                  var height;
                  switch (this._windowType) {
                    case WindowType.SubFrame:
                      if (!this._gameFrame) {
                        warnID(9201);
                        return new Size(0, 0);
                      }
                      return new Size(this._gameFrame.clientWidth, this._gameFrame.clientHeight);
                    case WindowType.Fullscreen:
                      fullscreenTarget = this._getFullscreenTarget();
                      width = this.isFrameRotated ? fullscreenTarget.clientHeight : fullscreenTarget.clientWidth;
                      height = this.isFrameRotated ? fullscreenTarget.clientWidth : fullscreenTarget.clientHeight;
                      return new Size(width, height);
                    case WindowType.BrowserWindow:
                      width = this.isFrameRotated ? window.innerHeight : window.innerWidth;
                      height = this.isFrameRotated ? window.innerWidth : window.innerHeight;
                      return new Size(width, height);
                    case WindowType.Unknown:
                    default:
                      return new Size(1, 1);
                  }
                }
              }, {
                key: "_windowType",
                get: function get() {
                  if (this._isHeadlessMode) {
                    return WindowType.Unknown;
                  }
                  if (this.isFullScreen) {
                    return WindowType.Fullscreen;
                  }
                  if (!this._gameFrame) {
                    warnID(9201);
                    return WindowType.Unknown;
                  }
                  if (this._exactFitScreen) {
                    return WindowType.BrowserWindow;
                  }
                  return WindowType.SubFrame;
                }
              }]);
              return ScreenAdapter;
            }(EventTarget);
            var screenAdapter = new ScreenAdapter();

            var Screen = function () {
              function Screen() {}
              var _proto = Screen.prototype;
              _proto.init = function init() {
                var _settings$querySettin, _settings$querySettin2;
                var exactFitScreen = (_settings$querySettin = settings.querySettings("screen", 'exactFitScreen')) !== null && _settings$querySettin !== undefined ? _settings$querySettin : true;
                var orientation = (_settings$querySettin2 = settings.querySettings("screen", 'orientation')) !== null && _settings$querySettin2 !== undefined ? _settings$querySettin2 : 'auto';
                var isHeadlessMode = settings.querySettings("rendering", 'renderMode') === 3;
                screenAdapter.init({
                  exactFitScreen: exactFitScreen,
                  configOrientation: orientation,
                  isHeadlessMode: isHeadlessMode
                }, function () {
                  var _director$root;
                  var director = legacyCC.director;
                  if (!((_director$root = director.root) != null && _director$root.pipeline)) {
                    warnID(1220);
                    return;
                  }
                  director.root.pipeline.shadingScale = screenAdapter.resolutionScale;
                });
              };
              _proto.fullScreen = function fullScreen() {
                return screenAdapter.isFullScreen;
              };
              _proto.requestFullScreen = function requestFullScreen(element, onFullScreenChange, onFullScreenError) {
                if (arguments.length > 0) {
                  warnID(1400, 'screen.requestFullScreen(element, onFullScreenChange?, onFullScreenError?)', 'screen.requestFullScreen(): Promise');
                }
                return screenAdapter.requestFullScreen().then(function () {
                  onFullScreenChange == null ? undefined : onFullScreenChange.call(document);
                })["catch"](function (err) {
                  error(err);
                  onFullScreenError == null ? undefined : onFullScreenError.call(document);
                });
              };
              _proto.exitFullScreen = function exitFullScreen() {
                return screenAdapter.exitFullScreen();
              };
              _proto.autoFullScreen = function autoFullScreen(element, onFullScreenChange) {
                var _this$requestFullScre;
                (_this$requestFullScre = this.requestFullScreen(element, onFullScreenChange)) == null ? undefined : _this$requestFullScre["catch"](function (e) {
                  warn(e);
                });
              };
              _proto.disableAutoFullScreen = function disableAutoFullScreen(element) {};
              _proto.on = function on(type, callback, target) {
                screenAdapter.on(type, callback, target);
              };
              _proto.once = function once(type, callback, target) {
                screenAdapter.once(type, callback, target);
              };
              _proto.off = function off(type, callback, target) {
                screenAdapter.off(type, callback, target);
              };
              _createClass(Screen, [{
                key: "devicePixelRatio",
                get: function get() {
                  return screenAdapter.devicePixelRatio;
                }
              }, {
                key: "windowSize",
                get: function get() {
                  return screenAdapter.windowSize;
                },
                set: function set(size) {
                  screenAdapter.windowSize = size;
                }
              }, {
                key: "resolution",
                get: function get() {
                  return screenAdapter.resolution;
                }
              }, {
                key: "supportsFullScreen",
                get: function get() {
                  return screenAdapter.supportFullScreen;
                }
              }]);
              return Screen;
            }();
            var screen$1 = exports("screen", new Screen());
            legacyCC.screen = screen$1;

            var sys = exports("sys", {
              Feature: Feature,
              hasFeature: function hasFeature(feature) {
                return systemInfo.hasFeature(feature);
              },
              NetworkType: NetworkType,
              Language: Language,
              OS: OS,
              Platform: Platform,
              BrowserType: BrowserType,
              isNative: systemInfo.isNative,
              isBrowser: systemInfo.isBrowser,
              isMobile: systemInfo.isMobile,
              isLittleEndian: systemInfo.isLittleEndian,
              platform: systemInfo.platform,
              language: systemInfo.language,
              languageCode: systemInfo.nativeLanguage,
              os: systemInfo.os,
              osVersion: systemInfo.osVersion,
              osMainVersion: systemInfo.osMainVersion,
              browserType: systemInfo.browserType,
              browserVersion: systemInfo.browserVersion,
              isXR: systemInfo.isXR,
              windowPixelResolution: screen$1.windowSize,
              capabilities: {
                canvas: true,
                opengl: true,
                webp: systemInfo.hasFeature(Feature.WEBP),
                imageBitmap: systemInfo.hasFeature(Feature.IMAGE_BITMAP),
                touches: systemInfo.hasFeature(Feature.INPUT_TOUCH),
                mouse: systemInfo.hasFeature(Feature.EVENT_MOUSE),
                keyboard: systemInfo.hasFeature(Feature.EVENT_KEYBOARD),
                accelerometer: systemInfo.hasFeature(Feature.EVENT_ACCELEROMETER)
              },
              localStorage: {},
              getNetworkType: function getNetworkType() {
                return systemInfo.networkType;
              },
              getBatteryLevel: function getBatteryLevel() {
                return systemInfo.getBatteryLevel();
              },
              garbageCollect: function garbageCollect() {
                systemInfo.triggerGC();
              },
              isObjectValid: function isObjectValid(obj) {
                if (obj === null || obj === undefined) {
                  return false;
                }
                return true;
              },
              __isWebIOS14OrIPadOS14Env: false,
              dump: function dump() {
                var str = '';
                str += "isMobile : " + this.isMobile + "\r\n";
                str += "language : " + this.language + "\r\n";
                str += "browserType : " + this.browserType + "\r\n";
                str += "browserVersion : " + this.browserVersion + "\r\n";
                str += "supports webp: " + sys.hasFeature(Feature.WEBP) + "\r\n";
                str += "supports bitmap: " + sys.hasFeature(Feature.IMAGE_BITMAP) + "\r\n";
                str += "supports touches: " + sys.hasFeature(Feature.INPUT_TOUCH) + "\r\n";
                str += "supports mouse: " + sys.hasFeature(Feature.EVENT_MOUSE) + "\r\n";
                str += "supports keyboard: " + sys.hasFeature(Feature.EVENT_KEYBOARD) + "\r\n";
                str += "supports accelerometer: " + sys.hasFeature(Feature.EVENT_ACCELEROMETER) + "\r\n";
                str += "os : " + this.os + "\r\n";
                str += "osVersion : " + this.osVersion + "\r\n";
                str += "platform : " + this.platform + "\r\n";
                str += "Using " + (legacyCC.game.renderType === legacyCC.game.RENDER_TYPE_WEBGL ? 'WEBGL' : 'CANVAS') + " renderer.\r\n";
                log(str);
              },
              openURL: function openURL(url) {
                systemInfo.openURL(url);
              },
              init: function init() {
                var _this = this;
                return Promise.resolve().then(function () {
                  return systemInfo.init();
                }).then(function () {
                  try {
                    var localStorage = sys.localStorage = window.localStorage;
                    localStorage.setItem('storage', '');
                    localStorage.removeItem('storage');
                    localStorage = null;
                  } catch (e) {
                    var warn = function warn() {
                      warnID(5200);
                    };
                    _this.localStorage = {
                      getItem: warn,
                      setItem: warn,
                      clear: warn,
                      removeItem: warn,
                      key: warn,
                      length: 0
                    };
                  }
                  {
                    _this.__isWebIOS14OrIPadOS14Env = (sys.os === OS.IOS || sys.os === OS.OSX) && systemInfo.isBrowser && /(OS 14)|(Version\/14)/.test(window.navigator.userAgent);
                  }
                });
              },
              now: function now() {
                return systemInfo.now();
              },
              restartVM: function restartVM() {
                systemInfo.restartJSVM();
              },
              getSafeAreaRect: function getSafeAreaRect(symmetric) {
                if (symmetric === undefined) {
                  symmetric = true;
                }
                var locView = legacyCC.view;
                var edge = screenAdapter.safeAreaEdge;
                if (symmetric) {
                  if (screenAdapter.orientation === macro.ORIENTATION_PORTRAIT) {
                    if (edge.top < edge.bottom) {
                      edge.top = edge.bottom;
                    } else {
                      edge.bottom = edge.top;
                    }
                  } else if (edge.left < edge.right) {
                    edge.left = edge.right;
                  } else {
                    edge.right = edge.left;
                  }
                }
                var windowSize = screenAdapter.windowSize;
                var leftBottom = new Vec2(edge.left, edge.bottom);
                var rightTop = new Vec2(windowSize.width - edge.right, windowSize.height - edge.top);
                locView._convertToUISpace(leftBottom);
                locView._convertToUISpace(rightTop);
                var x = leftBottom.x;
                var y = leftBottom.y;
                var width = rightTop.x - leftBottom.x;
                var height = rightTop.y - leftBottom.y;
                return new Rect(x, y, width, height);
              }
            });
            legacyCC.sys = sys;

            markAsWarning(legacyCC, 'cc', [{
              name: 'winSize',
              suggest: 'please use view.getVisibleSize() instead.'
            }]);
            markAsWarning(sys, 'sys', [{
              name: 'capabilities',
              suggest: 'please use sys.hasFeature() method instead.'
            }]);
            replaceProperty(sys, 'sys', ['UNKNOWN', 'ENGLISH', 'CHINESE', 'FRENCH', 'ITALIAN', 'GERMAN', 'SPANISH', 'DUTCH', 'RUSSIAN', 'KOREAN', 'JAPANESE', 'HUNGARIAN', 'PORTUGUESE', 'ARABIC', 'NORWEGIAN', 'POLISH', 'TURKISH', 'UKRAINIAN', 'ROMANIAN', 'BULGARIAN'].map(function (item) {
              return {
                name: "LANGUAGE_" + item,
                newName: item,
                target: sys.Language,
                targetName: 'sys.Language'
              };
            }));
            replaceProperty(sys, 'sys', ['UNKNOWN', 'IOS', 'ANDROID', 'WINDOWS', 'LINUX', 'OSX'].map(function (item) {
              return {
                name: "OS_" + item,
                newName: item,
                target: sys.OS,
                targetName: 'sys.OS'
              };
            }));
            replaceProperty(sys, 'sys', ['UNKNOWN', 'WECHAT', 'ANDROID', 'IE', 'EDGE', 'QQ', 'MOBILE_QQ', 'UC', 'UCBS', 'BAIDU_APP', 'BAIDU', 'MAXTHON', 'OPERA', 'OUPENG', 'MIUI', 'FIREFOX', 'SAFARI', 'CHROME', 'LIEBAO', 'QZONE', 'SOUGOU', 'HUAWEI'].map(function (item) {
              return {
                name: "BROWSER_TYPE_" + item,
                newName: item,
                target: sys.BrowserType,
                targetName: 'sys.BrowserType'
              };
            }));
            replaceProperty(sys, 'sys', [{
              name: 'BROWSER_TYPE_360',
              newName: 'BROWSER_360',
              target: sys.BrowserType,
              targetName: 'sys.BrowserType'
            }]);
            replaceProperty(sys, 'sys', ['UNKNOWN', 'EDITOR_PAGE', 'EDITOR_CORE', 'MOBILE_BROWSER', 'DESKTOP_BROWSER', 'WIN32', 'MACOS', 'IOS', 'ANDROID', 'OHOS', 'WECHAT_GAME', 'XIAOMI_QUICK_GAME', 'ALIPAY_MINI_GAME', 'BYTEDANCE_MINI_GAME', 'OPPO_MINI_GAME', 'VIVO_MINI_GAME', 'HUAWEI_QUICK_GAME'].map(function (item) {
              return {
                name: item,
                target: sys.Platform,
                targetName: 'sys.Platform'
              };
            }));
            replaceProperty(sys, 'sys', [{
              name: 'IPHONE',
              newName: 'IOS',
              target: sys.Platform,
              targetName: 'sys.Platform'
            }, {
              name: 'IPAD',
              newName: 'IOS',
              target: sys.Platform,
              targetName: 'sys.Platform'
            }]);
            removeProperty(sys, 'sys', ['LINUX', 'BLACKBERRY', 'NACL', 'EMSCRIPTEN', 'TIZEN', 'WINRT', 'WP8', 'QQ_PLAY', 'FB_PLAYABLE_ADS'].map(function (item) {
              return {
                name: item
              };
            }));
            replaceProperty(sys, 'sys', [{
              name: 'windowPixelResolution',
              target: screen$1,
              targetName: 'screen',
              newName: 'windowSize'
            }]);
            markAsWarning(screen$1, 'screen', [{
              name: 'autoFullScreen',
              suggest: 'please use screen.requestFullScreen() instead.'
            }, {
              name: 'disableAutoFullScreen'
            }]);

            var visibleRect = exports("visibleRect", {
              topLeft: legacyCC.v2(0, 0),
              topRight: legacyCC.v2(0, 0),
              top: legacyCC.v2(0, 0),
              bottomLeft: legacyCC.v2(0, 0),
              bottomRight: legacyCC.v2(0, 0),
              bottom: legacyCC.v2(0, 0),
              center: legacyCC.v2(0, 0),
              left: legacyCC.v2(0, 0),
              right: legacyCC.v2(0, 0),
              width: 0,
              height: 0,
              init: function init(visibleRect_) {
                var w = this.width = visibleRect_.width;
                var h = this.height = visibleRect_.height;
                var l = visibleRect_.x;
                var b = visibleRect_.y;
                var t = b + h;
                var r = l + w;
                this.topLeft.x = l;
                this.topLeft.y = t;
                this.topRight.x = r;
                this.topRight.y = t;
                this.top.x = l + w / 2;
                this.top.y = t;
                this.bottomLeft.x = l;
                this.bottomLeft.y = b;
                this.bottomRight.x = r;
                this.bottomRight.y = b;
                this.bottom.x = l + w / 2;
                this.bottom.y = b;
                this.center.x = l + w / 2;
                this.center.y = b + h / 2;
                this.left.x = l;
                this.left.y = b + h / 2;
                this.right.x = r;
                this.right.y = b + h / 2;
              }
            });
            legacyCC.visibleRect = visibleRect;

            var _v3_tmp$1 = new Vec3();
            var _v3_tmp2$1 = new Vec3();
            var _v3_tmp3 = new Vec3();
            var _v3_tmp4 = new Vec3();
            var _m3_tmp$1 = new Mat3();
            var mathAbs$1 = Math.abs;
            var transform_extent_m4 = function transform_extent_m4(out, extent, m4) {
              _m3_tmp$1.m00 = mathAbs$1(m4.m00);
              _m3_tmp$1.m01 = mathAbs$1(m4.m01);
              _m3_tmp$1.m02 = mathAbs$1(m4.m02);
              _m3_tmp$1.m03 = mathAbs$1(m4.m04);
              _m3_tmp$1.m04 = mathAbs$1(m4.m05);
              _m3_tmp$1.m05 = mathAbs$1(m4.m06);
              _m3_tmp$1.m06 = mathAbs$1(m4.m08);
              _m3_tmp$1.m07 = mathAbs$1(m4.m09);
              _m3_tmp$1.m08 = mathAbs$1(m4.m10);
              Vec3.transformMat3(out, extent, _m3_tmp$1);
            };
            var AABB = function () {
              AABB.create = function create(px, py, pz, hw, hh, hl) {
                return new AABB(px, py, pz, hw, hh, hl);
              };
              AABB.clone = function clone(a) {
                {
                  warn('The static method AABB.clone has been deprecated. Please use the corresponding instance method instead.');
                }
                return new AABB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
              };
              AABB.copy = function copy(out, a) {
                {
                  warn('The static method AABB.copy has been deprecated. Please use the corresponding instance method instead.');
                }
                Vec3.copy(out.center, a.center);
                Vec3.copy(out.halfExtents, a.halfExtents);
                return out;
              };
              AABB.fromPoints = function fromPoints(out, minPos, maxPos) {
                Vec3.add(_v3_tmp$1, maxPos, minPos);
                Vec3.subtract(_v3_tmp2$1, maxPos, minPos);
                Vec3.multiplyScalar(out.center, _v3_tmp$1, 0.5);
                Vec3.multiplyScalar(out.halfExtents, _v3_tmp2$1, 0.5);
                return out;
              };
              AABB.set = function set(out, px, py, pz, hw, hh, hl) {
                out.center.set(px, py, pz);
                out.halfExtents.set(hw, hh, hl);
                return out;
              };
              AABB.merge = function merge(out, a, b) {
                Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents);
                Vec3.subtract(_v3_tmp2$1, b.center, b.halfExtents);
                Vec3.add(_v3_tmp3, a.center, a.halfExtents);
                Vec3.add(_v3_tmp4, b.center, b.halfExtents);
                Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4);
                Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2$1);
                return AABB.fromPoints(out, _v3_tmp3, _v3_tmp4);
              };
              AABB.toBoundingSphere = function toBoundingSphere(out, a) {
                out.center.set(a.center);
                out.radius = a.halfExtents.length();
                return out;
              };
              AABB.transform = function transform(out, a, matrix) {
                Vec3.transformMat4(out.center, a.center, matrix);
                transform_extent_m4(out.halfExtents, a.halfExtents, matrix);
                return out;
              };
              function AABB(px, py, pz, hw, hh, hl) {
                if (px === undefined) {
                  px = 0;
                }
                if (py === undefined) {
                  py = 0;
                }
                if (pz === undefined) {
                  pz = 0;
                }
                if (hw === undefined) {
                  hw = 1;
                }
                if (hh === undefined) {
                  hh = 1;
                }
                if (hl === undefined) {
                  hl = 1;
                }
                this.center = undefined;
                this.halfExtents = undefined;
                this._type = undefined;
                this._type = 8;
                this.center = new Vec3(px, py, pz);
                this.halfExtents = new Vec3(hw, hh, hl);
              }
              var _proto = AABB.prototype;
              _proto.getBoundary = function getBoundary(minPos, maxPos) {
                Vec3.subtract(minPos, this.center, this.halfExtents);
                Vec3.add(maxPos, this.center, this.halfExtents);
              };
              _proto.transform = function transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m);
                transform_extent_m4(out.halfExtents, this.halfExtents, m);
              };
              _proto.clone = function clone() {
                var center = this.center;
                var halfExtents = this.halfExtents;
                return new AABB(center.x, center.y, center.z, halfExtents.x, halfExtents.y, halfExtents.z);
              };
              _proto.copy = function copy(a) {
                Vec3.copy(this.center, a.center);
                Vec3.copy(this.halfExtents, a.halfExtents);
                return this;
              };
              _proto.mergePoint = function mergePoint(point) {
                this.getBoundary(_v3_tmp$1, _v3_tmp2$1);
                if (point.x < _v3_tmp$1.x) {
                  _v3_tmp$1.x = point.x;
                }
                if (point.y < _v3_tmp$1.y) {
                  _v3_tmp$1.y = point.y;
                }
                if (point.z < _v3_tmp$1.z) {
                  _v3_tmp$1.z = point.z;
                }
                if (point.x > _v3_tmp2$1.x) {
                  _v3_tmp2$1.x = point.x;
                }
                if (point.y > _v3_tmp2$1.y) {
                  _v3_tmp2$1.y = point.y;
                }
                if (point.z > _v3_tmp2$1.z) {
                  _v3_tmp2$1.z = point.z;
                }
                Vec3.add(_v3_tmp3, _v3_tmp$1, _v3_tmp2$1);
                this.center.set(Vec3.multiplyScalar(_v3_tmp3, _v3_tmp3, 0.5));
                this.halfExtents.set(_v3_tmp2$1.x - _v3_tmp3.x, _v3_tmp2$1.y - _v3_tmp3.y, _v3_tmp2$1.z - _v3_tmp3.z);
              };
              _proto.mergePoints = function mergePoints(points) {
                if (points.length < 1) {
                  return;
                }
                for (var i = 0; i < points.length; i++) {
                  this.mergePoint(points[i]);
                }
              };
              _proto.mergeFrustum = function mergeFrustum(frustum) {
                this.mergePoints(frustum.vertices);
              };
              _createClass(AABB, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }]);
              return AABB;
            }();

            var Capsule = function () {
              function Capsule(radius, halfHeight, axis) {
                if (radius === undefined) {
                  radius = 0.5;
                }
                if (halfHeight === undefined) {
                  halfHeight = 0.5;
                }
                if (axis === undefined) {
                  axis = 1;
                }
                this._type = undefined;
                this.radius = undefined;
                this.halfHeight = undefined;
                this.axis = undefined;
                this.center = undefined;
                this.rotation = undefined;
                this.ellipseCenter0 = undefined;
                this.ellipseCenter1 = undefined;
                this._type = 512;
                this.radius = radius;
                this.halfHeight = halfHeight;
                this.axis = axis;
                this.center = new Vec3();
                this.rotation = new Quat();
                this.ellipseCenter0 = new Vec3(0, halfHeight, 0);
                this.ellipseCenter1 = new Vec3(0, -halfHeight, 0);
                this.updateCache();
              }
              var _proto = Capsule.prototype;
              _proto.transform = function transform(m, pos, rot, scale, out) {
                var ws = scale;
                var s = absMaxComponent(ws);
                out.radius = this.radius * Math.abs(s);
                var halfTotalWorldHeight = (this.halfHeight + this.radius) * Math.abs(ws.y);
                var halfWorldHeight = halfTotalWorldHeight - out.radius;
                if (halfWorldHeight < 0) halfWorldHeight = 0;
                out.halfHeight = halfWorldHeight;
                Vec3.transformMat4(out.center, this.center, m);
                Quat.multiply(out.rotation, this.rotation, rot);
                out.updateCache();
              };
              _proto.updateCache = function updateCache() {
                this.updateLocalCenter();
                Vec3.transformQuat(this.ellipseCenter0, this.ellipseCenter0, this.rotation);
                Vec3.transformQuat(this.ellipseCenter1, this.ellipseCenter1, this.rotation);
                this.ellipseCenter0.add(this.center);
                this.ellipseCenter1.add(this.center);
              };
              _proto.updateLocalCenter = function updateLocalCenter() {
                var halfHeight = this.halfHeight;
                var axis = this.axis;
                switch (axis) {
                  case 0:
                    this.ellipseCenter0.set(halfHeight, 0, 0);
                    this.ellipseCenter1.set(-halfHeight, 0, 0);
                    break;
                  case 1:
                    this.ellipseCenter0.set(0, halfHeight, 0);
                    this.ellipseCenter1.set(0, -halfHeight, 0);
                    break;
                  case 2:
                    this.ellipseCenter0.set(0, 0, halfHeight);
                    this.ellipseCenter1.set(0, 0, -halfHeight);
                    break;
                }
              };
              _createClass(Capsule, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }]);
              return Capsule;
            }();

            var _v = new Array(8);
            _v[0] = v3(1, 1, 1);
            _v[1] = v3(-1, 1, 1);
            _v[2] = v3(-1, -1, 1);
            _v[3] = v3(1, -1, 1);
            _v[4] = v3(1, 1, -1);
            _v[5] = v3(-1, 1, -1);
            _v[6] = v3(-1, -1, -1);
            _v[7] = v3(1, -1, -1);
            var _nearTemp = v3();
            var _farTemp = v3();
            var _temp_v3 = v3();
            var planeFromPoints = Plane.fromPoints;
            var vec3Set = Vec3.set;
            var vec3TransformMat4$2 = Vec3.transformMat4;
            var Frustum = function () {
              Frustum.createOrthographic = function createOrthographic(out, width, height, near, far, transform) {
                var halfWidth = width / 2;
                var halfHeight = height / 2;
                vec3Set(_temp_v3, halfWidth, halfHeight, -near);
                vec3TransformMat4$2(out.vertices[0], _temp_v3, transform);
                vec3Set(_temp_v3, -halfWidth, halfHeight, -near);
                vec3TransformMat4$2(out.vertices[1], _temp_v3, transform);
                vec3Set(_temp_v3, -halfWidth, -halfHeight, -near);
                vec3TransformMat4$2(out.vertices[2], _temp_v3, transform);
                vec3Set(_temp_v3, halfWidth, -halfHeight, -near);
                vec3TransformMat4$2(out.vertices[3], _temp_v3, transform);
                vec3Set(_temp_v3, halfWidth, halfHeight, -far);
                vec3TransformMat4$2(out.vertices[4], _temp_v3, transform);
                vec3Set(_temp_v3, -halfWidth, halfHeight, -far);
                vec3TransformMat4$2(out.vertices[5], _temp_v3, transform);
                vec3Set(_temp_v3, -halfWidth, -halfHeight, -far);
                vec3TransformMat4$2(out.vertices[6], _temp_v3, transform);
                vec3Set(_temp_v3, halfWidth, -halfHeight, -far);
                vec3TransformMat4$2(out.vertices[7], _temp_v3, transform);
                out.updatePlanes();
              };
              Frustum.createOrtho = function createOrtho(out, width, height, near, far, transform) {
                return Frustum.createOrthographic(out, width, height, near, far, transform);
              };
              Frustum.createPerspective = function createPerspective(out, aspect, fov, near, far, transform) {
                var h = Math.tan(fov * 0.5);
                var w = h * aspect;
                _nearTemp.set(near * w, near * h, near);
                _farTemp.set(far * w, far * h, far);
                var vertexes = out.vertices;
                _temp_v3.set(_nearTemp.x, _nearTemp.y, -_nearTemp.z);
                vec3TransformMat4$2(vertexes[0], _temp_v3, transform);
                _temp_v3.set(-_nearTemp.x, _nearTemp.y, -_nearTemp.z);
                vec3TransformMat4$2(vertexes[1], _temp_v3, transform);
                _temp_v3.set(-_nearTemp.x, -_nearTemp.y, -_nearTemp.z);
                vec3TransformMat4$2(vertexes[2], _temp_v3, transform);
                _temp_v3.set(_nearTemp.x, -_nearTemp.y, -_nearTemp.z);
                vec3TransformMat4$2(vertexes[3], _temp_v3, transform);
                _temp_v3.set(_farTemp.x, _farTemp.y, -_farTemp.z);
                vec3TransformMat4$2(vertexes[4], _temp_v3, transform);
                _temp_v3.set(-_farTemp.x, _farTemp.y, -_farTemp.z);
                vec3TransformMat4$2(vertexes[5], _temp_v3, transform);
                _temp_v3.set(-_farTemp.x, -_farTemp.y, -_farTemp.z);
                vec3TransformMat4$2(vertexes[6], _temp_v3, transform);
                _temp_v3.set(_farTemp.x, -_farTemp.y, -_farTemp.z);
                vec3TransformMat4$2(vertexes[7], _temp_v3, transform);
                out.updatePlanes();
              };
              Frustum.createFromAABB = function createFromAABB(out, aabb) {
                var vec3_min = new Vec3();
                var vec3_max = new Vec3();
                Vec3.subtract(vec3_min, aabb.center, aabb.halfExtents);
                Vec3.add(vec3_max, aabb.center, aabb.halfExtents);
                var vertices = out.vertices;
                vertices[0].set(vec3_max.x, vec3_max.y, -vec3_min.z);
                vertices[1].set(vec3_min.x, vec3_max.y, -vec3_min.z);
                vertices[2].set(vec3_min.x, vec3_min.y, -vec3_min.z);
                vertices[3].set(vec3_max.x, vec3_min.y, -vec3_min.z);
                vertices[4].set(vec3_max.x, vec3_max.y, -vec3_max.z);
                vertices[5].set(vec3_min.x, vec3_max.y, -vec3_max.z);
                vertices[6].set(vec3_min.x, vec3_min.y, -vec3_max.z);
                vertices[7].set(vec3_max.x, vec3_min.y, -vec3_max.z);
                out.updatePlanes();
                return out;
              };
              var _proto = Frustum.prototype;
              _proto.split = function split(start, end, aspect, fov, m) {
                return Frustum.createPerspective(this, aspect, fov, start, end, m);
              };
              Frustum.create = function create() {
                return new Frustum();
              };
              Frustum.clone = function clone(f) {
                return Frustum.copy(new Frustum(), f);
              };
              Frustum.copy = function copy(out, f) {
                out._type = f.type;
                for (var i = 0; i < 6; ++i) {
                  Plane.copy(out.planes[i], f.planes[i]);
                }
                for (var _i = 0; _i < 8; ++_i) {
                  Vec3.copy(out.vertices[_i], f.vertices[_i]);
                }
                return out;
              };
              function Frustum() {
                this.planes = undefined;
                this.vertices = undefined;
                this._type = undefined;
                this._type = 128;
                this.planes = new Array(6);
                for (var i = 0; i < 6; ++i) {
                  this.planes[i] = Plane.create(0, 0, 0, 0);
                }
                this.vertices = new Array(8);
                for (var _i2 = 0; _i2 < 8; ++_i2) {
                  this.vertices[_i2] = new Vec3();
                }
              }
              _proto.update = function update(m, inv) {
                var planes = this.planes;
                vec3Set(planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08);
                planes[0].d = -(m.m15 + m.m12);
                vec3Set(planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08);
                planes[1].d = -(m.m15 - m.m12);
                vec3Set(planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09);
                planes[2].d = -(m.m15 + m.m13);
                vec3Set(planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09);
                planes[3].d = -(m.m15 - m.m13);
                vec3Set(planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10);
                planes[4].d = -(m.m15 + m.m14);
                vec3Set(planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10);
                planes[5].d = -(m.m15 - m.m14);
                for (var i = 0; i < 6; i++) {
                  var pl = planes[i];
                  var invDist = 1 / pl.n.length();
                  Vec3.multiplyScalar(pl.n, pl.n, invDist);
                  pl.d *= invDist;
                }
                for (var _i3 = 0; _i3 < 8; _i3++) {
                  vec3TransformMat4$2(this.vertices[_i3], _v[_i3], inv);
                }
              };
              _proto.transform = function transform(mat) {
                for (var i = 0; i < 8; i++) {
                  vec3TransformMat4$2(this.vertices[i], this.vertices[i], mat);
                }
                this.updatePlanes();
              };
              _proto.zero = function zero() {
                for (var i = 0; i < 8; i++) {
                  this.vertices[i].set(0.0, 0.0, 0.0);
                }
                for (var _i4 = 0; _i4 < 6; _i4++) {
                  Plane.set(this.planes[_i4], 0, 0, 0, 0);
                }
              };
              _proto.updatePlanes = function updatePlanes() {
                var planes = this.planes;
                var vertices = this.vertices;
                planeFromPoints(planes[0], vertices[1], vertices[6], vertices[5]);
                planeFromPoints(planes[1], vertices[3], vertices[4], vertices[7]);
                planeFromPoints(planes[2], vertices[6], vertices[3], vertices[7]);
                planeFromPoints(planes[3], vertices[0], vertices[5], vertices[4]);
                planeFromPoints(planes[4], vertices[2], vertices[0], vertices[3]);
                planeFromPoints(planes[5], vertices[7], vertices[5], vertices[6]);
              };
              _createClass(Frustum, [{
                key: "accurate",
                set: function set(b) {
                  this._type = b ? 256 : 128;
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                }
              }]);
              return Frustum;
            }();

            var ShapeType = {
              SHAPE_RAY: 1,
              SHAPE_LINE: 2,
              SHAPE_SPHERE: 4,
              SHAPE_AABB: 8,
              SHAPE_OBB: 16,
              SHAPE_PLANE: 32,
              SHAPE_TRIANGLE: 64,
              SHAPE_FRUSTUM: 128,
              SHAPE_FRUSTUM_ACCURATE: 256,
              SHAPE_CAPSULE: 512,
              SHAPE_SPLINE: 1024
            };

            var _v3_tmp = new Vec3();
            var _v3_tmp2 = new Vec3();
            var _m3_tmp = new Mat3();
            var mathAbs = Math.abs;
            var transform_extent_m3 = function transform_extent_m3(out, extent, m3) {
              _m3_tmp.m00 = mathAbs(m3.m00);
              _m3_tmp.m01 = mathAbs(m3.m01);
              _m3_tmp.m02 = mathAbs(m3.m02);
              _m3_tmp.m03 = mathAbs(m3.m03);
              _m3_tmp.m04 = mathAbs(m3.m04);
              _m3_tmp.m05 = mathAbs(m3.m05);
              _m3_tmp.m06 = mathAbs(m3.m06);
              _m3_tmp.m07 = mathAbs(m3.m07);
              _m3_tmp.m08 = mathAbs(m3.m08);
              Vec3.transformMat3(out, extent, _m3_tmp);
            };
            var OBB = function () {
              OBB.create = function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                return new OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
              };
              OBB.clone = function clone(a) {
                return new OBB(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
              };
              OBB.copy = function copy(out, a) {
                Vec3.copy(out.center, a.center);
                Vec3.copy(out.halfExtents, a.halfExtents);
                Mat3.copy(out.orientation, a.orientation);
                return out;
              };
              OBB.fromPoints = function fromPoints(out, minPos, maxPos) {
                Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), 0.5);
                Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2, maxPos, minPos), 0.5);
                Mat3.identity(out.orientation);
                return out;
              };
              OBB.set = function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                Vec3.set(out.center, cx, cy, cz);
                Vec3.set(out.halfExtents, hw, hh, hl);
                Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
                return out;
              };
              function OBB(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                if (cx === undefined) {
                  cx = 0;
                }
                if (cy === undefined) {
                  cy = 0;
                }
                if (cz === undefined) {
                  cz = 0;
                }
                if (hw === undefined) {
                  hw = 1;
                }
                if (hh === undefined) {
                  hh = 1;
                }
                if (hl === undefined) {
                  hl = 1;
                }
                if (ox_1 === undefined) {
                  ox_1 = 1;
                }
                if (ox_2 === undefined) {
                  ox_2 = 0;
                }
                if (ox_3 === undefined) {
                  ox_3 = 0;
                }
                if (oy_1 === undefined) {
                  oy_1 = 0;
                }
                if (oy_2 === undefined) {
                  oy_2 = 1;
                }
                if (oy_3 === undefined) {
                  oy_3 = 0;
                }
                if (oz_1 === undefined) {
                  oz_1 = 0;
                }
                if (oz_2 === undefined) {
                  oz_2 = 0;
                }
                if (oz_3 === undefined) {
                  oz_3 = 1;
                }
                this.center = undefined;
                this.halfExtents = undefined;
                this.orientation = undefined;
                this._type = undefined;
                this._type = 16;
                this.center = new Vec3(cx, cy, cz);
                this.halfExtents = new Vec3(hw, hh, hl);
                this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
              }
              var _proto = OBB.prototype;
              _proto.getBoundary = function getBoundary(minPos, maxPos) {
                transform_extent_m3(_v3_tmp, this.halfExtents, this.orientation);
                Vec3.subtract(minPos, this.center, _v3_tmp);
                Vec3.add(maxPos, this.center, _v3_tmp);
              };
              _proto.transform = function transform(m, pos, rot, scale, out) {
                Vec3.transformMat4(out.center, this.center, m);
                Mat3.fromQuat(out.orientation, rot);
                Vec3.multiply(out.halfExtents, this.halfExtents, scale);
              };
              _proto.translateAndRotate = function translateAndRotate(m, rot, out) {
                Vec3.transformMat4(out.center, this.center, m);
                Mat3.fromQuat(out.orientation, rot);
              };
              _proto.setScale = function setScale(scale, out) {
                Vec3.multiply(out.halfExtents, this.halfExtents, scale);
              };
              _createClass(OBB, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }]);
              return OBB;
            }();

            function binarySearch(array, value) {
              return binarySearchEpsilon(array, value, 0);
            }
            function binarySearchEpsilon(array, value, EPSILON) {
              if (EPSILON === undefined) {
                EPSILON = 1e-6;
              }
              var low = 0;
              var high = array.length - 1;
              var middle = high >>> 1;
              for (; low <= high; middle = low + high >>> 1) {
                var test = array[middle];
                if (test > value + EPSILON) {
                  high = middle - 1;
                } else if (test < value - EPSILON) {
                  low = middle + 1;
                } else {
                  return middle;
                }
              }
              return ~low;
            }
            function binarySearchBy(array, value, lessThan) {
              var low = 0;
              var high = array.length - 1;
              var middle = high >>> 1;
              for (; low <= high; middle = low + high >>> 1) {
                var test = array[middle];
                if (lessThan(test, value) < 0) {
                  high = middle - 1;
                } else if (lessThan(test, value) > 0) {
                  low = middle + 1;
                } else {
                  return middle;
                }
              }
              return ~low;
            }

            var _Symbol$iterator$1;
            _Symbol$iterator$1 = Symbol.iterator;
            var KeyframeCurve = function () {
              function KeyframeCurve() {
                this._times = [];
                this._values = [];
              }
              var _proto = KeyframeCurve.prototype;
              _proto[_Symbol$iterator$1] = function () {
                var _this = this;
                var index = 0;
                return {
                  next: function next() {
                    if (index >= _this._times.length) {
                      return {
                        done: true,
                        value: undefined
                      };
                    } else {
                      var value = [_this._times[index], _this._values[index]];
                      ++index;
                      return {
                        done: false,
                        value: value
                      };
                    }
                  }
                };
              };
              _proto.keyframes = function keyframes() {
                return this;
              };
              _proto.times = function times() {
                return this._times;
              };
              _proto.values = function values() {
                return this._values;
              };
              _proto.getKeyframeTime = function getKeyframeTime(index) {
                return this._times[index];
              };
              _proto.getKeyframeValue = function getKeyframeValue(index) {
                return this._values[index];
              };
              _proto.addKeyFrame = function addKeyFrame(time, keyframeValue) {
                return this._insertNewKeyframe(time, keyframeValue);
              };
              _proto.removeKeyframe = function removeKeyframe(index) {
                this._times.splice(index, 1);
                this._values.splice(index, 1);
              };
              _proto.indexOfKeyframe = function indexOfKeyframe(time) {
                return binarySearchEpsilon(this._times, time);
              };
              _proto.updateTime = function updateTime(index, time) {
                var value = this._values[index];
                this.removeKeyframe(index);
                this._insertNewKeyframe(time, value);
              };
              _proto.assignSorted = function assignSorted(times, values) {
                if (values !== undefined) {
                  assertIsTrue(Array.isArray(times));
                  this.setKeyframes(times.slice(), values.slice());
                } else {
                  var _keyframes = Array.from(times);
                  this.setKeyframes(_keyframes.map(function (_ref) {
                    var time = _ref[0];
                    return time;
                  }), _keyframes.map(function (_ref2) {
                    var value = _ref2[1];
                    return value;
                  }));
                }
              };
              _proto.clear = function clear() {
                this._times.length = 0;
                this._values.length = 0;
              };
              _proto.searchKeyframe = function searchKeyframe(time) {
                return binarySearchEpsilon(this._times, time);
              };
              _proto.setKeyframes = function setKeyframes(times, values) {
                assertIsTrue(times.length === values.length);
                assertIsTrue(isSorted(times));
                this._times = times;
                this._values = values;
              };
              _proto._insertNewKeyframe = function _insertNewKeyframe(time, value) {
                var times = this._times;
                var values = this._values;
                var nFrames = times.length;
                var index = binarySearchEpsilon(times, time);
                if (index >= 0) {
                  return index;
                }
                var iNext = ~index;
                if (iNext === 0) {
                  times.unshift(time);
                  values.unshift(value);
                } else if (iNext === nFrames) {
                  times.push(time);
                  values.push(value);
                } else {
                  assertIsTrue(nFrames > 1);
                  times.splice(iNext - 1, 0, time);
                  values.splice(iNext - 1, 0, value);
                }
                return iNext;
              };
              _createClass(KeyframeCurve, [{
                key: "keyFramesCount",
                get: function get() {
                  return this._times.length;
                }
              }, {
                key: "rangeMin",
                get: function get() {
                  return this._times[0];
                }
              }, {
                key: "rangeMax",
                get: function get() {
                  return this._times[this._values.length - 1];
                }
              }]);
              return KeyframeCurve;
            }();
            CCClass.fastDefine('cc.KeyframeCurve', KeyframeCurve, {
              _times: [],
              _values: []
            });
            function isSorted(values) {
              return values.every(function (value, index, array) {
                return index === 0 || value > array[index - 1] || approx(value, array[index - 1], 1e-6);
              });
            }

            var RealInterpolationMode = exports("RealInterpolationMode", {
              LINEAR: 0,
              CONSTANT: 1,
              CUBIC: 2
            });
            var ExtrapolationMode = exports("ExtrapolationMode", {
              LINEAR: 0,
              CLAMP: 1,
              LOOP: 2,
              PING_PONG: 3
            });
            var TangentWeightMode = exports("TangentWeightMode", {
              NONE: 0,
              LEFT: 1,
              RIGHT: 2,
              BOTH: 3
            });

            function solveCubic(coeff0, coeff1, coeff2, coeff3, solutions) {
              var a = coeff2 / coeff3;
              var b = coeff1 / coeff3;
              var c = coeff0 / coeff3;
              var sqrA = a * a;
              var p = 1.0 / 3.0 * (-1 / 3 * sqrA + b);
              var q = 1.0 / 2.0 * (2.0 / 27.0 * a * sqrA - 1.0 / 3 * a * b + c);
              var cubicP = p * p * p;
              var d = q * q + cubicP;
              var nSolutions = 0;
              if (isZero(d)) {
                if (isZero(q)) {
                  solutions[0] = 0;
                  return 1;
                } else {
                  var u = Math.cbrt(-q);
                  solutions[0] = 2 * u;
                  solutions[1] = -u;
                  return 2;
                }
              } else if (d < 0) {
                var phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cubicP));
                var t = 2 * Math.sqrt(-p);
                solutions[0] = t * Math.cos(phi);
                solutions[1] = -t * Math.cos(phi + Math.PI / 3);
                solutions[2] = -t * Math.cos(phi - Math.PI / 3);
                nSolutions = 3;
              } else {
                var sqrtD = Math.sqrt(d);
                var _u = Math.cbrt(sqrtD - q);
                var v = -Math.cbrt(sqrtD + q);
                solutions[0] = _u + v;
                nSolutions = 1;
              }
              var sub = 1.0 / 3 * a;
              for (var i = 0; i < nSolutions; ++i) {
                solutions[i] -= sub;
              }
              return nSolutions;
            }
            var EQN_EPS = 1e-9;
            function isZero(x) {
              return x > -1e-9 && x < EQN_EPS;
            }

            function applyDecoratedInitializer(target, property, decorators, initializer) {
              return decorators.slice().reverse().reduce(function (decoratedInitializer, decorator) {
                return decorator(target, property, decoratedInitializer) || decoratedInitializer;
              }, initializer);
            }

            var emptyDecorator = function emptyDecorator() {};
            var emptyDecoratorFn = function emptyDecoratorFn() {
              return emptyDecorator;
            };
            var emptySmartClassDecorator = makeSmartClassDecorator(function () {});
            function makeSmartClassDecorator(decorate) {
              return proxyFn;
              function proxyFn(target) {
                if (typeof target === 'function') {
                  return decorate(target);
                } else {
                  return function (constructor) {
                    return decorate(constructor, target);
                  };
                }
              }
            }
            function writeEditorClassProperty(constructor, propertyName, value) {
              var cache = getClassCache(constructor);
              if (cache) {
                var proto = getSubDict(cache, 'proto');
                getSubDict(proto, 'editor')[propertyName] = value;
              }
            }
            function makeEditorClassDecoratorFn(propertyName) {
              return function (value) {
                return function (constructor) {
                  writeEditorClassProperty(constructor, propertyName, value);
                };
              };
            }
            var CACHE_KEY = '__ccclassCache__';
            function getClassCache(ctor, decoratorName) {
              return getSubDict(ctor, CACHE_KEY);
            }
            function getSubDict(obj, key) {
              return obj[key] || (obj[key] = {});
            }

            var ccclass$6 = makeSmartClassDecorator(function (constructor, name) {
              var base = getSuper(constructor);
              if (base === Object) {
                base = null;
              }
              var proto = {
                name: name,
                "extends": base,
                ctor: constructor
              };
              var cache = constructor[CACHE_KEY];
              if (cache) {
                var decoratedProto = cache.proto;
                if (decoratedProto) {
                  mixin(proto, decoratedProto);
                }
                constructor[CACHE_KEY] = undefined;
              }
              var res = CCClass(proto);
              return res;
            });

            var requireComponent = makeEditorClassDecoratorFn('requireComponent');
            var executionOrder$1 = makeEditorClassDecoratorFn('executionOrder');
            var disallowMultiple$1 = emptySmartClassDecorator;

            function property$3(target, propertyKey, descriptorOrInitializer) {
              var options = null;
              function normalized(target, propertyKey, descriptorOrInitializer) {
                var classStash = getOrCreateClassStash(target);
                var propertyStash = getOrCreateEmptyPropertyStash(target, propertyKey);
                var classConstructor = target.constructor;
                mergePropertyOptions(classStash, propertyStash, classConstructor, propertyKey, options, descriptorOrInitializer);
              }
              if (target === undefined) {
                return property$3({
                  type: undefined
                });
              } else if (typeof propertyKey === 'undefined') {
                options = target;
                return normalized;
              } else {
                normalized(target, propertyKey, descriptorOrInitializer);
                return undefined;
              }
            }
            function getDefaultFromInitializer(initializer) {
              var value;
              try {
                value = initializer();
              } catch (e) {
                return initializer;
              }
              if (typeof value !== 'object' || value === null) {
                return value;
              } else {
                return initializer;
              }
            }
            function extractActualDefaultValues(classConstructor) {
              var dummyObj;
              try {
                dummyObj = new classConstructor();
              } catch (e) {
                return {};
              }
              return dummyObj;
            }
            function getOrCreateClassStash(target) {
              var cache = getClassCache(target.constructor);
              return cache;
            }
            function getOrCreateEmptyPropertyStash(target, propertyKey) {
              var _ref, _properties$_ref;
              var classStash = getClassCache(target.constructor);
              var ccclassProto = getSubDict(classStash, 'proto');
              var properties = getSubDict(ccclassProto, 'properties');
              var propertyStash = (_properties$_ref = properties[_ref = propertyKey]) !== null && _properties$_ref !== undefined ? _properties$_ref : properties[_ref] = {};
              return propertyStash;
            }
            function getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer) {
              var _ref2, _properties$_ref2;
              var classStash = getClassCache(target.constructor);
              var ccclassProto = getSubDict(classStash, 'proto');
              var properties = getSubDict(ccclassProto, 'properties');
              var propertyStash = (_properties$_ref2 = properties[_ref2 = propertyKey]) !== null && _properties$_ref2 !== undefined ? _properties$_ref2 : properties[_ref2] = {};
              propertyStash.__internalFlags |= 1;
              if (descriptorOrInitializer && typeof descriptorOrInitializer !== 'function' && (descriptorOrInitializer.get || descriptorOrInitializer.set)) {
                if (descriptorOrInitializer.get) {
                  propertyStash.get = descriptorOrInitializer.get;
                }
                if (descriptorOrInitializer.set) {
                  propertyStash.set = descriptorOrInitializer.set;
                }
              } else {
                setDefaultValue(classStash, propertyStash, target.constructor, propertyKey, descriptorOrInitializer);
              }
              return propertyStash;
            }
            function mergePropertyOptions(cache, propertyStash, ctor, propertyKey, options, descriptorOrInitializer) {
              var fullOptions;
              var isGetset = descriptorOrInitializer && typeof descriptorOrInitializer !== 'function' && (descriptorOrInitializer.get || descriptorOrInitializer.set);
              if (options) {
                fullOptions = getFullFormOfProperty(options, isGetset);
              }
              var propertyRecord = mixin(propertyStash, fullOptions || options || {});
              if (isGetset) {
                if (descriptorOrInitializer.get) {
                  propertyRecord.get = descriptorOrInitializer.get;
                }
                if (descriptorOrInitializer.set) {
                  propertyRecord.set = descriptorOrInitializer.set;
                }
              } else {
                setDefaultValue(cache, propertyRecord, ctor, propertyKey, descriptorOrInitializer);
              }
            }
            function setDefaultValue(classStash, propertyStash, classConstructor, propertyKey, descriptorOrInitializer) {
              if (descriptorOrInitializer !== undefined) {
                if (typeof descriptorOrInitializer === 'function') {
                  propertyStash["default"] = getDefaultFromInitializer(descriptorOrInitializer);
                } else if (descriptorOrInitializer === null) ; else if (descriptorOrInitializer.initializer) {
                  propertyStash["default"] = getDefaultFromInitializer(descriptorOrInitializer.initializer);
                }
              } else {
                var actualDefaultValues = classStash["default"] || (classStash["default"] = extractActualDefaultValues(classConstructor));
                if (actualDefaultValues.hasOwnProperty(propertyKey)) {
                  propertyStash["default"] = actualDefaultValues[propertyKey];
                }
              }
            }

            var sMetadataTag = Symbol('cc:SerializationMetadata');
            function getSerializationMetadata(constructor) {
              return constructor[sMetadataTag];
            }
            function getOrCreateSerializationMetadata(constructor) {
              var _ref, _ref$sMetadataTag;
              return (_ref$sMetadataTag = (_ref = constructor)[sMetadataTag]) !== null && _ref$sMetadataTag !== undefined ? _ref$sMetadataTag : _ref[sMetadataTag] = {};
            }

            var serializable$5 = exports("serializable", function serializable(target, propertyKey, descriptorOrInitializer) {
              var propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
              setImplicitSerializable(propertyStash);
            });
            function formerlySerializedAs$3(name) {
              return function (target, propertyKey, descriptorOrInitializer) {
                var propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
                propertyStash.formerlySerializedAs = name;
                setImplicitSerializable(propertyStash);
              };
            }
            var editorOnly = function editorOnly(target, propertyKey, descriptorOrInitializer) {
              var propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
              propertyStash.editorOnly = true;
              setImplicitSerializable(propertyStash);
            };
            function setImplicitSerializable(propertyStash) {
              propertyStash.__internalFlags |= 4;
            }
            var uniquelyReferenced = emptyDecorator ;

            var executeInEditMode = emptySmartClassDecorator;
            var menu = emptyDecoratorFn;
            var playOnFocus = emptySmartClassDecorator;
            var inspector = emptyDecoratorFn;
            var icon = emptyDecoratorFn;
            var help = emptyDecoratorFn;
            var editable = exports("editable", emptyDecorator );
            var visible = exports("visible", emptyDecoratorFn );
            var displayName = exports("displayName", emptyDecoratorFn );
            var tooltip = exports("tooltip", emptyDecoratorFn );
            var range = exports("range", emptyDecoratorFn );
            var rangeStep = exports("rangeStep", emptyDecoratorFn );
            var slide = exports("slide", emptyDecorator );
            var displayOrder = exports("displayOrder", emptyDecoratorFn );
            var disallowAnimation = exports("disallowAnimation", emptyDecorator );

            var integer = type$5(CCInteger);
            var _float = type$5(CCFloat);
            var _boolean = type$5(CCBoolean);
            var string = type$5(CCString);
            function type$5(type) {
              return property$3({
                type: type
              });
            }

            var override = exports("override", function override(target, propertyKey, descriptorOrInitializer) {
              var propertyStash = getOrCreatePropertyStash(target, propertyKey, descriptorOrInitializer);
              propertyStash.override = true;
            });

            var Empty = function Empty() {};
            var EditorExtendable = exports("EditorExtendable", editorExtendableInternal());
            assertIsTrue(editorExtrasTag === '__editorExtras__', 'editorExtrasTag needs to be updated.');
            function editorExtendableInternal(Base, className) {
              {
                return Empty;
              }
            }

            var _decorator = /*#__PURE__*/Object.freeze({
                __proto__: null,
                boolean: _boolean,
                ccclass: ccclass$6,
                disallowAnimation: disallowAnimation,
                disallowMultiple: disallowMultiple$1,
                displayName: displayName,
                displayOrder: displayOrder,
                editable: editable,
                executeInEditMode: executeInEditMode,
                executionOrder: executionOrder$1,
                float: _float,
                formerlySerializedAs: formerlySerializedAs$3,
                help: help,
                icon: icon,
                inspector: inspector,
                integer: integer,
                menu: menu,
                override: override,
                playOnFocus: playOnFocus,
                property: property$3,
                range: range,
                rangeStep: rangeStep,
                requireComponent: requireComponent,
                serializable: serializable$5,
                slide: slide,
                string: string,
                tooltip: tooltip,
                type: type$5,
                uniquelyReferenced: uniquelyReferenced,
                visible: visible
            });
            exports("_decorator", _decorator);

            var _dec$Q, _class$R, _class2$K, _initializer$F, _initializer2$w, _initializer3$q, _initializer4$l, _class3$g, _BuiltinElementTypeTr;
            var StorageUnit = {
              Uint8: 0,
              Uint16: 1,
              Uint32: 2,
              Int8: 3,
              Int16: 4,
              Int32: 5,
              Float32: 6,
              Float64: 7
            };
            var ElementType = {
              Scalar: 0,
              Vec2: 1,
              Vec3: 2,
              Vec4: 3,
              Quat: 4,
              Mat4: 5
            };
            var elementTypeBits = 3;
            function combineStorageUnitElementType(unit, elementType) {
              return (elementType << elementTypeBits) + unit;
            }
            function extractStorageUnitElementType(combined) {
              return {
                storageUnit: 7 & combined,
                elementType: combined >> elementTypeBits
              };
            }
            var CompactValueTypeArray = exports("CompactValueTypeArray", (_dec$Q = ccclass$6('cc.CompactValueTypeArray'), _dec$Q(_class$R = (_class2$K = (_class3$g = function () {
              function CompactValueTypeArray() {
                this._byteOffset = _initializer$F && _initializer$F();
                this._unitCount = _initializer2$w && _initializer2$w();
                this._unitElement = _initializer3$q && _initializer3$q();
                this._length = _initializer4$l && _initializer4$l();
              }
              CompactValueTypeArray.lengthFor = function lengthFor(values, elementType, unit) {
                var elementTraits = getElementTraits(elementType);
                return elementTraits.requiredUnits * values.length * getStorageConstructor(unit).BYTES_PER_ELEMENT;
              };
              CompactValueTypeArray.compress = function compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
                var elementTraits = getElementTraits(elementType);
                var storageConstructor = getStorageConstructor(unit);
                var unitCount = elementTraits.requiredUnits * values.length;
                var storage = new storageConstructor(arrayBuffer, byteOffset, unitCount);
                for (var i = 0; i < values.length; ++i) {
                  elementTraits.compress(storage, i, values[i]);
                }
                var result = new CompactValueTypeArray();
                result._unitElement = combineStorageUnitElementType(unit, elementType);
                result._byteOffset = presumedByteOffset;
                result._unitCount = unitCount;
                result._length = values.length;
                return result;
              };
              var _proto = CompactValueTypeArray.prototype;
              _proto.decompress = function decompress(arrayBuffer) {
                var _extractStorageUnitEl = extractStorageUnitElementType(this._unitElement),
                  storageUnit = _extractStorageUnitEl.storageUnit,
                  elementType = _extractStorageUnitEl.elementType;
                var elementTraits = getElementTraits(elementType);
                var storageConstructor = getStorageConstructor(storageUnit);
                var storage = new storageConstructor(arrayBuffer, this._byteOffset, this._unitCount);
                var result = new Array(this._length);
                for (var i = 0; i < this._length; ++i) {
                  result[i] = elementTraits.decompress(storage, i);
                }
                return result;
              };
              return CompactValueTypeArray;
            }(), _class3$g.StorageUnit = StorageUnit, _class3$g.ElementType = ElementType, _class3$g), (_initializer$F = applyDecoratedInitializer(_class2$K.prototype, "_byteOffset", [serializable$5], function () {
              return 0;
            }), _initializer2$w = applyDecoratedInitializer(_class2$K.prototype, "_unitCount", [serializable$5], function () {
              return 0;
            }), _initializer3$q = applyDecoratedInitializer(_class2$K.prototype, "_unitElement", [serializable$5], function () {
              return combineStorageUnitElementType(0, 0);
            }), _initializer4$l = applyDecoratedInitializer(_class2$K.prototype, "_length", [serializable$5], function () {
              return 0;
            })), _class2$K)) || _class$R));
            function getElementTraits(elementType) {
              return BuiltinElementTypeTraits[elementType];
            }
            function getStorageConstructor(unit) {
              switch (unit) {
                case 0:
                  return Uint8Array;
                case 1:
                  return Uint16Array;
                case 2:
                  return Uint32Array;
                case 3:
                  return Int8Array;
                case 4:
                  return Int16Array;
                case 5:
                  return Int32Array;
                case 6:
                  return Float32Array;
                case 7:
                  return Float64Array;
              }
            }
            var BuiltinElementTypeTraits = (_BuiltinElementTypeTr = {}, _BuiltinElementTypeTr[0] = {
              requiredUnits: 1,
              compress: function compress(storage, index, value) {
                storage[index] = value;
              },
              decompress: function decompress(storage, index) {
                return storage[index];
              }
            }, _BuiltinElementTypeTr[1] = {
              requiredUnits: 2,
              compress: function compress(storage, index, value) {
                storage[index * 2] = value.x;
                storage[index * 2 + 1] = value.y;
              },
              decompress: function decompress(storage, index) {
                return new Vec3(storage[index * 2], storage[index * 2 + 1]);
              }
            }, _BuiltinElementTypeTr[2] = {
              requiredUnits: 3,
              compress: function compress(storage, index, value) {
                storage[index * 3] = value.x;
                storage[index * 3 + 1] = value.y;
                storage[index * 3 + 2] = value.z;
              },
              decompress: function decompress(storage, index) {
                return new Vec3(storage[index * 3], storage[index * 3 + 1], storage[index * 3 + 2]);
              }
            }, _BuiltinElementTypeTr[3] = {
              requiredUnits: 4,
              compress: function compress(storage, index, value) {
                storage[index * 4] = value.x;
                storage[index * 4 + 1] = value.y;
                storage[index * 4 + 2] = value.z;
                storage[index * 4 + 3] = value.w;
              },
              decompress: function decompress(storage, index) {
                return new Vec4(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
              }
            }, _BuiltinElementTypeTr[4] = {
              requiredUnits: 4,
              compress: function compress(storage, index, value) {
                storage[index * 4] = value.x;
                storage[index * 4 + 1] = value.y;
                storage[index * 4 + 2] = value.z;
                storage[index * 4 + 3] = value.w;
              },
              decompress: function decompress(storage, index) {
                return new Quat(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
              }
            }, _BuiltinElementTypeTr[5] = {
              requiredUnits: 16,
              compress: function compress(storage, index, value) {
                Mat4.toArray(storage, value, index * 16);
              },
              decompress: function decompress(storage, index) {
                return Mat4.fromArray(new Mat4(), storage, index * 16);
              }
            }, _BuiltinElementTypeTr);

            var serializeTag = exports("serializeTag", Symbol('[[Serialize]]'));
            var deserializeTag = exports("deserializeTag", Symbol('[[Deserialize]]'));

            legacyCC._decorator = _decorator;

            function constant() {
              return 0;
            }
            function linear(k) {
              return k;
            }
            function quadIn(k) {
              return k * k;
            }
            function quadOut(k) {
              return k * (2 - k);
            }
            function quadInOut(k) {
              k *= 2;
              if (k < 1) {
                return 0.5 * k * k;
              }
              return -0.5 * (--k * (k - 2) - 1);
            }
            function cubicIn(k) {
              return k * k * k;
            }
            function cubicOut(k) {
              return --k * k * k + 1;
            }
            function cubicInOut(k) {
              k *= 2;
              if (k < 1) {
                return 0.5 * k * k * k;
              }
              return 0.5 * ((k -= 2) * k * k + 2);
            }
            function quartIn(k) {
              return k * k * k * k;
            }
            function quartOut(k) {
              return 1 - --k * k * k * k;
            }
            function quartInOut(k) {
              k *= 2;
              if (k < 1) {
                return 0.5 * k * k * k * k;
              }
              return -0.5 * ((k -= 2) * k * k * k - 2);
            }
            function quintIn(k) {
              return k * k * k * k * k;
            }
            function quintOut(k) {
              return --k * k * k * k * k + 1;
            }
            function quintInOut(k) {
              k *= 2;
              if (k < 1) {
                return 0.5 * k * k * k * k * k;
              }
              return 0.5 * ((k -= 2) * k * k * k * k + 2);
            }
            function sineIn(k) {
              if (k === 1) {
                return 1;
              }
              return 1 - Math.cos(k * Math.PI / 2);
            }
            function sineOut(k) {
              return Math.sin(k * Math.PI / 2);
            }
            function sineInOut(k) {
              return 0.5 * (1 - Math.cos(Math.PI * k));
            }
            function expoIn(k) {
              return k === 0 ? 0 : Math.pow(1024, k - 1);
            }
            function expoOut(k) {
              return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
            }
            function expoInOut(k) {
              if (k === 0) {
                return 0;
              }
              if (k === 1) {
                return 1;
              }
              k *= 2;
              if (k < 1) {
                return 0.5 * Math.pow(1024, k - 1);
              }
              return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            }
            function circIn(k) {
              return 1 - Math.sqrt(1 - k * k);
            }
            function circOut(k) {
              return Math.sqrt(1 - --k * k);
            }
            function circInOut(k) {
              k *= 2;
              if (k < 1) {
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
              }
              return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            }
            function elasticIn(k) {
              var s;
              var a = 0.1;
              var p = 0.4;
              if (k === 0) {
                return 0;
              }
              if (k === 1) {
                return 1;
              }
              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              }
              return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            }
            function elasticOut(k) {
              var s;
              var a = 0.1;
              var p = 0.4;
              if (k === 0) {
                return 0;
              }
              if (k === 1) {
                return 1;
              }
              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              }
              return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
            }
            function elasticInOut(k) {
              var s;
              var a = 0.1;
              var p = 0.4;
              if (k === 0) {
                return 0;
              }
              if (k === 1) {
                return 1;
              }
              if (!a || a < 1) {
                a = 1;
                s = p / 4;
              } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
              }
              k *= 2;
              if (k < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
              }
              return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
            }
            function backIn(k) {
              if (k === 1) {
                return 1;
              }
              var s = 1.70158;
              return k * k * ((s + 1) * k - s);
            }
            function backOut(k) {
              if (k === 0) {
                return 0;
              }
              var s = 1.70158;
              return --k * k * ((s + 1) * k + s) + 1;
            }
            function backInOut(k) {
              var s = 1.70158 * 1.525;
              k *= 2;
              if (k < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
              }
              return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            }
            function bounceIn(k) {
              return 1 - bounceOut(1 - k);
            }
            function bounceOut(k) {
              if (k < 1 / 2.75) {
                return 7.5625 * k * k;
              } else if (k < 2 / 2.75) {
                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
              } else if (k < 2.5 / 2.75) {
                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
              } else {
                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
              }
            }
            function bounceInOut(k) {
              if (k < 0.5) {
                return bounceIn(k * 2) * 0.5;
              }
              return bounceOut(k * 2 - 1) * 0.5 + 0.5;
            }
            function smooth(k) {
              if (k <= 0) {
                return 0;
              }
              if (k >= 1) {
                return 1;
              }
              return k * k * (3 - 2 * k);
            }
            function fade(k) {
              if (k <= 0) {
                return 0;
              }
              if (k >= 1) {
                return 1;
              }
              return k * k * k * (k * (k * 6 - 15) + 10);
            }
            var quadOutIn = _makeOutIn(quadIn, quadOut);
            var cubicOutIn = _makeOutIn(cubicIn, cubicOut);
            var quartOutIn = _makeOutIn(quartIn, quartOut);
            var quintOutIn = _makeOutIn(quintIn, quintOut);
            var sineOutIn = _makeOutIn(sineIn, sineOut);
            var expoOutIn = _makeOutIn(expoIn, expoOut);
            var circOutIn = _makeOutIn(circIn, circOut);
            var elasticOutIn = _makeOutIn(elasticIn, elasticOut);
            var backOutIn = _makeOutIn(backIn, backOut);
            var bounceOutIn = _makeOutIn(bounceIn, bounceOut);
            function _makeOutIn(fnIn, fnOut) {
              return function (k) {
                if (k < 0.5) {
                  return fnOut(k * 2) / 2;
                }
                return fnIn(2 * k - 1) / 2 + 0.5;
              };
            }

            var easing = /*#__PURE__*/Object.freeze({
                __proto__: null,
                backIn: backIn,
                backInOut: backInOut,
                backOut: backOut,
                backOutIn: backOutIn,
                bounceIn: bounceIn,
                bounceInOut: bounceInOut,
                bounceOut: bounceOut,
                bounceOutIn: bounceOutIn,
                circIn: circIn,
                circInOut: circInOut,
                circOut: circOut,
                circOutIn: circOutIn,
                constant: constant,
                cubicIn: cubicIn,
                cubicInOut: cubicInOut,
                cubicOut: cubicOut,
                cubicOutIn: cubicOutIn,
                elasticIn: elasticIn,
                elasticInOut: elasticInOut,
                elasticOut: elasticOut,
                elasticOutIn: elasticOutIn,
                expoIn: expoIn,
                expoInOut: expoInOut,
                expoOut: expoOut,
                expoOutIn: expoOutIn,
                fade: fade,
                linear: linear,
                quadIn: quadIn,
                quadInOut: quadInOut,
                quadOut: quadOut,
                quadOutIn: quadOutIn,
                quartIn: quartIn,
                quartInOut: quartInOut,
                quartOut: quartOut,
                quartOutIn: quartOutIn,
                quintIn: quintIn,
                quintInOut: quintInOut,
                quintOut: quintOut,
                quintOutIn: quintOutIn,
                sineIn: sineIn,
                sineInOut: sineInOut,
                sineOut: sineOut,
                sineOutIn: sineOutIn,
                smooth: smooth
            });
            exports("easing", easing);

            var _easingMethodFnMap;
            var EasingMethod = exports("EasingMethod", {
              LINEAR: 0,
              CONSTANT: 1,
              QUAD_IN: 2,
              QUAD_OUT: 3,
              QUAD_IN_OUT: 4,
              QUAD_OUT_IN: 5,
              CUBIC_IN: 6,
              CUBIC_OUT: 7,
              CUBIC_IN_OUT: 8,
              CUBIC_OUT_IN: 9,
              QUART_IN: 10,
              QUART_OUT: 11,
              QUART_IN_OUT: 12,
              QUART_OUT_IN: 13,
              QUINT_IN: 14,
              QUINT_OUT: 15,
              QUINT_IN_OUT: 16,
              QUINT_OUT_IN: 17,
              SINE_IN: 18,
              SINE_OUT: 19,
              SINE_IN_OUT: 20,
              SINE_OUT_IN: 21,
              EXPO_IN: 22,
              EXPO_OUT: 23,
              EXPO_IN_OUT: 24,
              EXPO_OUT_IN: 25,
              CIRC_IN: 26,
              CIRC_OUT: 27,
              CIRC_IN_OUT: 28,
              CIRC_OUT_IN: 29,
              ELASTIC_IN: 30,
              ELASTIC_OUT: 31,
              ELASTIC_IN_OUT: 32,
              ELASTIC_OUT_IN: 33,
              BACK_IN: 34,
              BACK_OUT: 35,
              BACK_IN_OUT: 36,
              BACK_OUT_IN: 37,
              BOUNCE_IN: 38,
              BOUNCE_OUT: 39,
              BOUNCE_IN_OUT: 40,
              BOUNCE_OUT_IN: 41,
              SMOOTH: 42,
              FADE: 43
            });
            var easingMethodFnMap = (_easingMethodFnMap = {}, _easingMethodFnMap[1] = constant, _easingMethodFnMap[0] = linear, _easingMethodFnMap[2] = quadIn, _easingMethodFnMap[3] = quadOut, _easingMethodFnMap[4] = quadInOut, _easingMethodFnMap[5] = quadOutIn, _easingMethodFnMap[6] = cubicIn, _easingMethodFnMap[7] = cubicOut, _easingMethodFnMap[8] = cubicInOut, _easingMethodFnMap[9] = cubicOutIn, _easingMethodFnMap[10] = quartIn, _easingMethodFnMap[11] = quartOut, _easingMethodFnMap[12] = quartInOut, _easingMethodFnMap[13] = quartOutIn, _easingMethodFnMap[14] = quintIn, _easingMethodFnMap[15] = quintOut, _easingMethodFnMap[16] = quintInOut, _easingMethodFnMap[17] = quintOutIn, _easingMethodFnMap[18] = sineIn, _easingMethodFnMap[19] = sineOut, _easingMethodFnMap[20] = sineInOut, _easingMethodFnMap[21] = sineOutIn, _easingMethodFnMap[22] = expoIn, _easingMethodFnMap[23] = expoOut, _easingMethodFnMap[24] = expoInOut, _easingMethodFnMap[25] = expoOutIn, _easingMethodFnMap[26] = circIn, _easingMethodFnMap[27] = circOut, _easingMethodFnMap[28] = circInOut, _easingMethodFnMap[29] = circOutIn, _easingMethodFnMap[30] = elasticIn, _easingMethodFnMap[31] = elasticOut, _easingMethodFnMap[32] = elasticInOut, _easingMethodFnMap[33] = elasticOutIn, _easingMethodFnMap[34] = backIn, _easingMethodFnMap[35] = backOut, _easingMethodFnMap[36] = backInOut, _easingMethodFnMap[37] = backOutIn, _easingMethodFnMap[38] = bounceIn, _easingMethodFnMap[39] = bounceOut, _easingMethodFnMap[40] = bounceInOut, _easingMethodFnMap[41] = bounceOutIn, _easingMethodFnMap[42] = smooth, _easingMethodFnMap[43] = fade, _easingMethodFnMap);
            function getEasingFn(easingMethod) {
              assertIsTrue(easingMethod in easingMethodFnMap);
              return easingMethodFnMap[easingMethod];
            }

            var _CCClass$fastDefine;
            var REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START = 0;
            var REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
            var REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START = 8;
            var REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
            var REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START = 16;
            var REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK = 0xFF << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
            assertIsTrue(REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START === REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START + popCount(REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK));
            assertIsTrue(REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START === REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START + popCount(REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK));
            var REAL_KEYFRAME_VALUE_DEFAULT_FLAGS = 0 << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START | 0 << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START | 0 << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
            var RealKeyframeValue = function (_EditorExtendable) {
              _inheritsLoose(RealKeyframeValue, _EditorExtendable);
              function RealKeyframeValue() {
                var _this;
                _this = _EditorExtendable.call(this) || this;
                _this.value = 0.0;
                _this.rightTangent = 0.0;
                _this.rightTangentWeight = 0.0;
                _this.leftTangent = 0.0;
                _this.leftTangentWeight = 0.0;
                _this._flags = REAL_KEYFRAME_VALUE_DEFAULT_FLAGS;
                return _this;
              }
              _createClass(RealKeyframeValue, [{
                key: "interpolationMode",
                get: function get() {
                  return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
                },
                set: function set(value) {
                  this._flags &= -256;
                  this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_INTERPOLATION_MODE_START;
                }
              }, {
                key: "tangentWeightMode",
                get: function get() {
                  return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
                },
                set: function set(value) {
                  this._flags &= -65281;
                  this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_TANGENT_WEIGHT_MODE_START;
                }
              }, {
                key: "easingMethod",
                get: function get() {
                  return (this._flags & REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_MASK) >> REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
                },
                set: function set(value) {
                  this._flags &= -16711681;
                  this._flags |= value << REAL_KEYFRAME_VALUE_FLAGS_EASING_METHOD_START;
                }
              }]);
              return RealKeyframeValue;
            }(EditorExtendable);
            CCClass.fastDefine('cc.RealKeyframeValue', RealKeyframeValue, (_CCClass$fastDefine = {
              interpolationMode: 0,
              tangentWeightMode: 0,
              value: 0.0,
              rightTangent: 0.0,
              rightTangentWeight: 0.0,
              leftTangent: 0.0,
              leftTangentWeight: 0.0,
              easingMethod: 0
            }, _CCClass$fastDefine[editorExtrasTag] = undefined, _CCClass$fastDefine));
            CCClass.Attr.setClassAttr(RealKeyframeValue, editorExtrasTag, 'editorOnly', true);
            getOrCreateSerializationMetadata(RealKeyframeValue).uniquelyReferenced = true;
            function createRealKeyframeValue(params) {
              var realKeyframeValue = new RealKeyframeValue();
              if (typeof params === 'number') {
                realKeyframeValue.value = params;
              } else {
                var interpolationMode = params.interpolationMode,
                  tangentWeightMode = params.tangentWeightMode,
                  value = params.value,
                  rightTangent = params.rightTangent,
                  rightTangentWeight = params.rightTangentWeight,
                  leftTangent = params.leftTangent,
                  leftTangentWeight = params.leftTangentWeight,
                  easingMethod = params.easingMethod,
                  editorExtras = params[editorExtrasTag];
                realKeyframeValue.value = value !== null && value !== undefined ? value : realKeyframeValue.value;
                realKeyframeValue.rightTangent = rightTangent !== null && rightTangent !== undefined ? rightTangent : realKeyframeValue.rightTangent;
                realKeyframeValue.rightTangentWeight = rightTangentWeight !== null && rightTangentWeight !== undefined ? rightTangentWeight : realKeyframeValue.rightTangentWeight;
                realKeyframeValue.leftTangent = leftTangent !== null && leftTangent !== undefined ? leftTangent : realKeyframeValue.leftTangent;
                realKeyframeValue.leftTangentWeight = leftTangentWeight !== null && leftTangentWeight !== undefined ? leftTangentWeight : realKeyframeValue.leftTangentWeight;
                realKeyframeValue.interpolationMode = interpolationMode !== null && interpolationMode !== undefined ? interpolationMode : realKeyframeValue.interpolationMode;
                realKeyframeValue.tangentWeightMode = tangentWeightMode !== null && tangentWeightMode !== undefined ? tangentWeightMode : realKeyframeValue.tangentWeightMode;
                realKeyframeValue.easingMethod = easingMethod !== null && easingMethod !== undefined ? easingMethod : realKeyframeValue.easingMethod;
                if (editorExtras) {
                  realKeyframeValue[editorExtrasTag] = editorExtras;
                }
              }
              return realKeyframeValue;
            }
            var RealCurve = exports("RealCurve", function (_KeyframeCurve) {
              _inheritsLoose(RealCurve, _KeyframeCurve);
              function RealCurve() {
                var _this2;
                _this2 = _KeyframeCurve.call(this) || this;
                _this2.preExtrapolation = 1;
                _this2.postExtrapolation = 1;
                return _this2;
              }
              var _proto = RealCurve.prototype;
              _proto.evaluate = function evaluate(time) {
                var times = this._times,
                  values = this._values;
                var nFrames = times.length;
                if (nFrames === 0) {
                  return 0.0;
                }
                var firstTime = times[0];
                var lastTime = times[nFrames - 1];
                if (time < firstTime) {
                  var preExtrapolation = this.preExtrapolation;
                  var _preValue = values[0];
                  if (preExtrapolation === 1 || nFrames < 2) {
                    return _preValue.value;
                  }
                  switch (preExtrapolation) {
                    case 0:
                      return linearTrend(firstTime, values[0].value, times[1], values[1].value, time);
                    case 2:
                      time = wrapRepeat(time, firstTime, lastTime);
                      break;
                    case 3:
                      time = wrapPingPong(time, firstTime, lastTime);
                      break;
                    default:
                      return _preValue.value;
                  }
                } else if (time > lastTime) {
                  var postExtrapolation = this.postExtrapolation;
                  var preFrame = values[nFrames - 1];
                  if (postExtrapolation === 1 || nFrames < 2) {
                    return preFrame.value;
                  }
                  switch (postExtrapolation) {
                    case 0:
                      return linearTrend(lastTime, preFrame.value, times[nFrames - 2], values[nFrames - 2].value, time);
                    case 2:
                      time = wrapRepeat(time, firstTime, lastTime);
                      break;
                    case 3:
                      time = wrapPingPong(time, firstTime, lastTime);
                      break;
                    default:
                      return preFrame.value;
                  }
                }
                var index = binarySearchEpsilon(times, time);
                if (index >= 0) {
                  return values[index].value;
                }
                var iNext = ~index;
                {
                  assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
                }
                var iPre = iNext - 1;
                var preTime = times[iPre];
                var preValue = values[iPre];
                var nextTime = times[iNext];
                var nextValue = values[iNext];
                {
                  assertIsTrue(nextTime > time && time > preTime);
                }
                var dt = nextTime - preTime;
                var ratio = (time - preTime) / dt;
                return evalBetweenTwoKeyFrames(preTime, preValue, nextTime, nextValue, ratio);
              };
              _proto.addKeyFrame = function addKeyFrame(time, value) {
                return _KeyframeCurve.prototype.addKeyFrame.call(this, time, createRealKeyframeValue(value));
              };
              _proto.assignSorted = function assignSorted(times, values) {
                if (values !== undefined) {
                  assertIsTrue(Array.isArray(times));
                  this.setKeyframes(times.slice(), values.map(function (value) {
                    return createRealKeyframeValue(value);
                  }));
                } else {
                  var _keyframes = Array.from(times);
                  this.setKeyframes(_keyframes.map(function (_ref) {
                    var time = _ref[0];
                    return time;
                  }), _keyframes.map(function (_ref2) {
                    var value = _ref2[1];
                    return createRealKeyframeValue(value);
                  }));
                }
              };
              _proto.isConstant = function isConstant(tolerance) {
                if (this._values.length <= 1) {
                  return true;
                }
                var firstVal = this._values[0].value;
                return this._values.every(function (frame) {
                  return approx(frame.value, firstVal, tolerance);
                });
              };
              _proto[serializeTag] = function (output, context) {
                if (!context.toCCON) {
                  output.writeThis();
                  return;
                }
                var times = this._times,
                  keyframeValues = this._values;
                var nKeyframes = times.length;
                var dataSize = 0 + OVERFLOW_BYTES + OVERFLOW_BYTES + FRAME_COUNT_BYTES$1 + TIME_BYTES$1 * nKeyframes + REAL_KEY_FRAME_VALUE_MAX_SIZE * nKeyframes;
                var dataView = new DataView(new ArrayBuffer(dataSize));
                var currentOffset = 0;
                dataView.setUint8(currentOffset, this.preExtrapolation);
                currentOffset += OVERFLOW_BYTES;
                dataView.setUint8(currentOffset, this.postExtrapolation);
                currentOffset += OVERFLOW_BYTES;
                dataView.setUint32(currentOffset, nKeyframes, true);
                currentOffset += FRAME_COUNT_BYTES$1;
                times.forEach(function (time, index) {
                  return dataView.setFloat32(currentOffset + TIME_BYTES$1 * index, time, true);
                });
                currentOffset += TIME_BYTES$1 * nKeyframes;
                for (var _iterator = _createForOfIteratorHelperLoose(keyframeValues), _step; !(_step = _iterator()).done;) {
                  var keyframeValue = _step.value;
                  currentOffset = saveRealKeyFrameValue(dataView, keyframeValue, currentOffset);
                }
                var bytes = new Uint8Array(dataView.buffer, 0, currentOffset);
                output.writeProperty('bytes', bytes);
                var keyframeValueEditorExtras = keyframeValues.map(function (keyframeValue) {
                  return keyframeValue[editorExtrasTag];
                });
                if (keyframeValueEditorExtras.some(function (extras) {
                  return extras !== undefined;
                })) {
                  output.writeProperty("keyframeValueEditorExtras", keyframeValueEditorExtras);
                }
              };
              _proto[deserializeTag] = function (input, context) {
                if (!context.fromCCON) {
                  input.readThis();
                  return;
                }
                var bytes = input.readProperty('bytes');
                var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
                var currentOffset = 0;
                this.preExtrapolation = dataView.getUint8(currentOffset);
                currentOffset += OVERFLOW_BYTES;
                this.postExtrapolation = dataView.getUint8(currentOffset);
                currentOffset += OVERFLOW_BYTES;
                var nKeyframes = dataView.getUint32(currentOffset, true);
                currentOffset += FRAME_COUNT_BYTES$1;
                var times = Array.from({
                  length: nKeyframes
                }, function (_, index) {
                  return dataView.getFloat32(currentOffset + TIME_BYTES$1 * index, true);
                });
                currentOffset += TIME_BYTES$1 * nKeyframes;
                var keyframeValues = new Array(nKeyframes);
                for (var iKeyFrame = 0; iKeyFrame < nKeyframes; ++iKeyFrame) {
                  var keyframeValue = createRealKeyframeValue({});
                  currentOffset = loadRealKeyFrameValue(dataView, keyframeValue, currentOffset);
                  keyframeValues[iKeyFrame] = keyframeValue;
                }
                assertIsTrue(currentOffset === bytes.byteLength);
                var keyframeValueEditorExtras = input.readProperty("keyframeValueEditorExtras");
                if (keyframeValueEditorExtras) {
                  assertIsTrue(keyframeValueEditorExtras.length === nKeyframes);
                  keyframeValueEditorExtras.forEach(function (extras, index) {
                    return keyframeValues[index][editorExtrasTag] = extras;
                  });
                }
                this._times = times;
                this._values = keyframeValues;
              };
              return RealCurve;
            }(KeyframeCurve));
            CCClass.fastDefine('cc.RealCurve', RealCurve, {
              _times: [],
              _values: [],
              preExtrapolation: 1,
              postExtrapolation: 1
            });
            var FLAGS_EASING_METHOD_BITS_START = 8;
            var FLAG_EASING_METHOD_MASK = 0xFF << FLAGS_EASING_METHOD_BITS_START;
            var OVERFLOW_BYTES = 1;
            var FRAME_COUNT_BYTES$1 = 4;
            var TIME_BYTES$1 = 4;
            var KEY_FRAME_VALUE_FLAGS_BYTES = 4;
            var VALUE_BYTES$1 = 4;
            var INTERPOLATION_MODE_BYTES$1 = 1;
            var TANGENT_WEIGHT_MODE_BYTES = 1;
            var LEFT_TANGENT_BYTES = 4;
            var LEFT_TANGENT_WEIGHT_BYTES = 4;
            var RIGHT_TANGENT_BYTES = 4;
            var RIGHT_TANGENT_WEIGHT_BYTES = 4;
            var _createRealKeyframeVa = createRealKeyframeValue({}),
              DEFAULT_INTERPOLATION_MODE = _createRealKeyframeVa.interpolationMode,
              DEFAULT_TANGENT_WEIGHT_MODE = _createRealKeyframeVa.tangentWeightMode,
              DEFAULT_LEFT_TANGENT = _createRealKeyframeVa.leftTangent,
              DEFAULT_LEFT_TANGENT_WEIGHT = _createRealKeyframeVa.leftTangentWeight,
              DEFAULT_RIGHT_TANGENT = _createRealKeyframeVa.rightTangent,
              DEFAULT_RIGHT_TANGENT_WEIGHT = _createRealKeyframeVa.rightTangentWeight;
            var REAL_KEY_FRAME_VALUE_MAX_SIZE = KEY_FRAME_VALUE_FLAGS_BYTES + VALUE_BYTES$1 + INTERPOLATION_MODE_BYTES$1 + TANGENT_WEIGHT_MODE_BYTES + LEFT_TANGENT_BYTES + LEFT_TANGENT_WEIGHT_BYTES + RIGHT_TANGENT_BYTES + RIGHT_TANGENT_WEIGHT_BYTES + 0;
            function saveRealKeyFrameValue(dataView, keyframeValue, offset) {
              var flags = 0;
              var currentOffset = offset;
              var pFlags = currentOffset;
              currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
              var value = keyframeValue.value,
                interpolationMode = keyframeValue.interpolationMode,
                tangentWeightMode = keyframeValue.tangentWeightMode,
                rightTangent = keyframeValue.rightTangent,
                rightTangentWeight = keyframeValue.rightTangentWeight,
                leftTangent = keyframeValue.leftTangent,
                leftTangentWeight = keyframeValue.leftTangentWeight,
                easingMethod = keyframeValue.easingMethod;
              dataView.setFloat32(currentOffset, value, true);
              currentOffset += VALUE_BYTES$1;
              if (interpolationMode !== DEFAULT_INTERPOLATION_MODE) {
                flags |= 2;
                dataView.setUint8(currentOffset, interpolationMode);
                currentOffset += INTERPOLATION_MODE_BYTES$1;
              }
              if (tangentWeightMode !== DEFAULT_TANGENT_WEIGHT_MODE) {
                flags |= 4;
                dataView.setUint8(currentOffset, tangentWeightMode);
                currentOffset += TANGENT_WEIGHT_MODE_BYTES;
              }
              if (leftTangent !== DEFAULT_LEFT_TANGENT) {
                flags |= 8;
                dataView.setFloat32(currentOffset, leftTangent, true);
                currentOffset += LEFT_TANGENT_BYTES;
              }
              if (leftTangentWeight !== DEFAULT_LEFT_TANGENT_WEIGHT) {
                flags |= 16;
                dataView.setFloat32(currentOffset, leftTangentWeight, true);
                currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
              }
              if (rightTangent !== DEFAULT_RIGHT_TANGENT) {
                flags |= 32;
                dataView.setFloat32(currentOffset, rightTangent, true);
                currentOffset += RIGHT_TANGENT_BYTES;
              }
              if (rightTangentWeight !== DEFAULT_RIGHT_TANGENT_WEIGHT) {
                flags |= 64;
                dataView.setFloat32(currentOffset, rightTangentWeight, true);
                currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
              }
              flags |= easingMethod << FLAGS_EASING_METHOD_BITS_START;
              dataView.setUint32(pFlags, flags, true);
              return currentOffset;
            }
            function loadRealKeyFrameValue(dataView, keyframeValue, offset) {
              var currentOffset = offset;
              var flags = dataView.getUint32(currentOffset, true);
              currentOffset += KEY_FRAME_VALUE_FLAGS_BYTES;
              keyframeValue.value = dataView.getFloat32(currentOffset, true);
              currentOffset += VALUE_BYTES$1;
              if (flags & 2) {
                keyframeValue.interpolationMode = dataView.getUint8(currentOffset);
                currentOffset += INTERPOLATION_MODE_BYTES$1;
              }
              if (flags & 4) {
                keyframeValue.tangentWeightMode = dataView.getUint8(currentOffset);
                currentOffset += TANGENT_WEIGHT_MODE_BYTES;
              }
              if (flags & 8) {
                keyframeValue.leftTangent = dataView.getFloat32(currentOffset, true);
                currentOffset += LEFT_TANGENT_BYTES;
              }
              if (flags & 16) {
                keyframeValue.leftTangentWeight = dataView.getFloat32(currentOffset, true);
                currentOffset += LEFT_TANGENT_WEIGHT_BYTES;
              }
              if (flags & 32) {
                keyframeValue.rightTangent = dataView.getFloat32(currentOffset, true);
                currentOffset += RIGHT_TANGENT_BYTES;
              }
              if (flags & 64) {
                keyframeValue.rightTangentWeight = dataView.getFloat32(currentOffset, true);
                currentOffset += RIGHT_TANGENT_WEIGHT_BYTES;
              }
              var easingMethod = (flags & FLAG_EASING_METHOD_MASK) >> FLAGS_EASING_METHOD_BITS_START;
              keyframeValue.easingMethod = easingMethod;
              return currentOffset;
            }
            function wrapRepeat(time, prevTime, nextTime) {
              return prevTime + repeat$2(time - prevTime, nextTime - prevTime);
            }
            function wrapPingPong(time, prevTime, nextTime) {
              return prevTime + pingPong(time - prevTime, nextTime - prevTime);
            }
            function linearTrend(prevTime, prevValue, nextTime, nextValue, time) {
              var slope = (nextValue - prevValue) / (nextTime - prevTime);
              return prevValue + (time - prevTime) * slope;
            }
            function evalBetweenTwoKeyFrames(prevTime, prevValue, nextTime, nextValue, ratio) {
              var dt = nextTime - prevTime;
              switch (prevValue.interpolationMode) {
                default:
                case 1:
                  return prevValue.value;
                case 0:
                  {
                    var transformedRatio = prevValue.easingMethod === 0 ? ratio : getEasingFn(prevValue.easingMethod)(ratio);
                    return lerp(prevValue.value, nextValue.value, transformedRatio);
                  }
                case 2:
                  {
                    var ONE_THIRD = 1.0 / 3.0;
                    var prevTangent = prevValue.rightTangent,
                      prevTangentWeightSpecified = prevValue.rightTangentWeight;
                    var prevTangentWeightEnabled = isRightTangentWeightEnabled(prevValue.tangentWeightMode);
                    var nextTangent = nextValue.leftTangent,
                      nextTangentWeightSpecified = nextValue.leftTangentWeight;
                    var nextTangentWeightEnabled = isLeftTangentWeightEnabled(nextValue.tangentWeightMode);
                    if (!prevTangentWeightEnabled && !nextTangentWeightEnabled) {
                      var p1 = prevValue.value + ONE_THIRD * prevTangent * dt;
                      var p2 = nextValue.value - ONE_THIRD * nextTangent * dt;
                      return bezierInterpolate(prevValue.value, p1, p2, nextValue.value, ratio);
                    } else {
                      var prevTangentWeight = 0.0;
                      if (prevTangentWeightEnabled) {
                        prevTangentWeight = prevTangentWeightSpecified;
                      } else {
                        var x = dt;
                        var _y = dt * prevTangent;
                        prevTangentWeight = Math.sqrt(x * x + _y * _y) * ONE_THIRD;
                      }
                      var angle0 = Math.atan(prevTangent);
                      var tx0 = Math.cos(angle0) * prevTangentWeight + prevTime;
                      var ty0 = Math.sin(angle0) * prevTangentWeight + prevValue.value;
                      var nextTangentWeight = 0.0;
                      if (nextTangentWeightEnabled) {
                        nextTangentWeight = nextTangentWeightSpecified;
                      } else {
                        var _x = dt;
                        var _y2 = dt * nextTangent;
                        nextTangentWeight = Math.sqrt(_x * _x + _y2 * _y2) * ONE_THIRD;
                      }
                      var angle1 = Math.atan(nextTangent);
                      var tx1 = -Math.cos(angle1) * nextTangentWeight + nextTime;
                      var ty1 = -Math.sin(angle1) * nextTangentWeight + nextValue.value;
                      var dx = dt;
                      var u0x = (tx0 - prevTime) / dx;
                      var u1x = (tx1 - prevTime) / dx;
                      var u0y = ty0;
                      var u1y = ty1;
                      var coeff0 = 0.0;
                      var coeff1 = 3.0 * u0x;
                      var coeff2 = 3.0 * u1x - 6.0 * u0x;
                      var coeff3 = 3.0 * (u0x - u1x) + 1.0;
                      var solutions = [0.0, 0.0, 0.0];
                      var nSolutions = solveCubic(coeff0 - ratio, coeff1, coeff2, coeff3, solutions);
                      var param = getParamFromCubicSolution(solutions, nSolutions, ratio);
                      var y = bezierInterpolate(prevValue.value, u0y, u1y, nextValue.value, param);
                      return y;
                    }
                  }
              }
            }
            function isLeftTangentWeightEnabled(tangentWeightMode) {
              return (tangentWeightMode & 1) !== 0;
            }
            function isRightTangentWeightEnabled(tangentWeightMode) {
              return (tangentWeightMode & 2) !== 0;
            }
            function bezierInterpolate(p0, p1, p2, p3, t) {
              var u = 1 - t;
              var coeff0 = u * u * u;
              var coeff1 = 3 * u * u * t;
              var coeff2 = 3 * u * t * t;
              var coeff3 = t * t * t;
              return coeff0 * p0 + coeff1 * p1 + coeff2 * p2 + coeff3 * p3;
            }
            function getParamFromCubicSolution(solutions, solutionsCount, x) {
              var param = x;
              if (solutionsCount === 1) {
                param = solutions[0];
              } else {
                param = -Infinity;
                for (var iSolution = 0; iSolution < solutionsCount; ++iSolution) {
                  var solution = solutions[iSolution];
                  if (solution >= 0.0 && solution <= 1.0) {
                    if (solution > param) {
                      param = solution;
                    }
                  }
                }
                if (param === -Infinity) {
                  param = 0.0;
                }
              }
              return param;
            }

            function bezier$1(C1, C2, C3, C4, t) {
              var t1 = 1 - t;
              return t1 * (t1 * (C1 + (C2 * 3 - C1) * t) + C3 * 3 * t * t) + C4 * t * t * t;
            }
            legacyCC.bezier = bezier$1;
            var cos = Math.cos;
            var acos = Math.acos;
            var max$2 = Math.max;
            var pi = Math.PI;
            var tau = 2 * pi;
            var sqrt = Math.sqrt;
            function crt(v) {
              if (v < 0) {
                return -Math.pow(-v, 1 / 3);
              } else {
                return Math.pow(v, 1 / 3);
              }
            }
            function cardano(curve, x) {
              var pa = x - 0;
              var pb = x - curve[0];
              var pc = x - curve[2];
              var pd = x - 1;
              var pa3 = pa * 3;
              var pb3 = pb * 3;
              var pc3 = pc * 3;
              var d = -pa + pb3 - pc3 + pd;
              var rd = 1 / d;
              var r3 = 1 / 3;
              var a = (pa3 - 6 * pb + pc3) * rd;
              var a3 = a * r3;
              var b = (-pa3 + pb3) * rd;
              var c = pa * rd;
              var p = (3 * b - a * a) * r3;
              var p3 = p * r3;
              var q = (2 * a * a * a - 9 * a * b + 27 * c) / 27;
              var q2 = q / 2;
              var discriminant = q2 * q2 + p3 * p3 * p3;
              var u1;
              var v1;
              var x1;
              var x2;
              var x3;
              if (discriminant < 0) {
                var mp3 = -p * r3;
                var mp33 = mp3 * mp3 * mp3;
                var r = sqrt(mp33);
                var t = -q / (2 * r);
                var cosphi = t < -1 ? -1 : t > 1 ? 1 : t;
                var phi = acos(cosphi);
                var crtr = crt(r);
                var t1 = 2 * crtr;
                x1 = t1 * cos(phi * r3) - a3;
                x2 = t1 * cos((phi + tau) * r3) - a3;
                x3 = t1 * cos((phi + 2 * tau) * r3) - a3;
                if (x1 >= 0 && x1 <= 1) {
                  if (x2 >= 0 && x2 <= 1) {
                    if (x3 >= 0 && x3 <= 1) {
                      return max$2(x1, x2, x3);
                    } else {
                      return max$2(x1, x2);
                    }
                  } else if (x3 >= 0 && x3 <= 1) {
                    return max$2(x1, x3);
                  } else {
                    return x1;
                  }
                } else if (x2 >= 0 && x2 <= 1) {
                  if (x3 >= 0 && x3 <= 1) {
                    return max$2(x2, x3);
                  } else {
                    return x2;
                  }
                } else {
                  return x3;
                }
              } else if (discriminant === 0) {
                u1 = q2 < 0 ? crt(-q2) : -crt(q2);
                x1 = 2 * u1 - a3;
                x2 = -u1 - a3;
                if (x1 >= 0 && x1 <= 1) {
                  if (x2 >= 0 && x2 <= 1) {
                    return max$2(x1, x2);
                  } else {
                    return x1;
                  }
                } else {
                  return x2;
                }
              } else {
                var sd = sqrt(discriminant);
                u1 = crt(-q2 + sd);
                v1 = crt(q2 + sd);
                x1 = u1 - v1 - a3;
                return x1;
              }
            }
            function bezierByTime(controlPoints, x) {
              var percent = cardano(controlPoints, x);
              var p1y = controlPoints[1];
              var p2y = controlPoints[3];
              return ((1 - percent) * (p1y + (p2y - p1y) * percent) * 3 + percent * percent) * percent;
            }
            legacyCC.bezierByTime = bezierByTime;

            var _dec$P, _class$Q, _class2$J, _initializer$E, _initializer2$v, _initializer3$p, _dec2$t, _class4$7, _class5$7, _initializer4$k, _initializer5$h;
            var QuatInterpolationMode = exports("QuatInterpolationMode", {
              SLERP: 0,
              CONSTANT: 1
            });
            var QuatKeyframeValue = (_dec$P = ccclass$6('cc.QuatKeyframeValue'), _dec$P(_class$Q = uniquelyReferenced(_class$Q = (_class2$J = function QuatKeyframeValue(_temp) {
              var _ref = _temp === undefined ? {} : _temp,
                value = _ref.value,
                interpolationMode = _ref.interpolationMode,
                easingMethod = _ref.easingMethod;
              this.interpolationMode = _initializer$E && _initializer$E();
              this.value = _initializer2$v && _initializer2$v();
              this.easingMethod = _initializer3$p && _initializer3$p();
              this.value = value ? Quat.clone(value) : this.value;
              this.interpolationMode = interpolationMode !== null && interpolationMode !== undefined ? interpolationMode : this.interpolationMode;
              this.easingMethod = easingMethod !== null && easingMethod !== undefined ? easingMethod : this.easingMethod;
            }, (_initializer$E = applyDecoratedInitializer(_class2$J.prototype, "interpolationMode", [serializable$5], function () {
              return 0;
            }), _initializer2$v = applyDecoratedInitializer(_class2$J.prototype, "value", [serializable$5], function () {
              return Quat.clone(Quat.IDENTITY);
            }), _initializer3$p = applyDecoratedInitializer(_class2$J.prototype, "easingMethod", [serializable$5], function () {
              return 0;
            })), _class2$J)) || _class$Q) || _class$Q);
            function createQuatKeyframeValue(params) {
              return new QuatKeyframeValue(params);
            }
            var QuatCurve = exports("QuatCurve", (_dec2$t = ccclass$6('cc.QuatCurve'), _dec2$t(_class4$7 = (_class5$7 = function (_KeyframeCurve) {
              _inheritsLoose(QuatCurve, _KeyframeCurve);
              function QuatCurve() {
                var _this;
                _this = _KeyframeCurve.call(this) || this;
                _this.preExtrapolation = _initializer4$k && _initializer4$k();
                _this.postExtrapolation = _initializer5$h && _initializer5$h();
                return _this;
              }
              var _proto = QuatCurve.prototype;
              _proto.evaluate = function evaluate(time, quat) {
                var _quat;
                (_quat = quat) !== null && _quat !== undefined ? _quat : quat = new Quat();
                var times = this._times,
                  values = this._values,
                  postExtrapolation = this.postExtrapolation,
                  preExtrapolation = this.preExtrapolation;
                var nFrames = times.length;
                if (nFrames === 0) {
                  return quat;
                }
                var firstTime = times[0];
                var lastTime = times[nFrames - 1];
                if (time < firstTime) {
                  var _preValue = values[0];
                  switch (preExtrapolation) {
                    case 2:
                      time = firstTime + repeat$2(time - firstTime, lastTime - firstTime);
                      break;
                    case 3:
                      time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                      break;
                    case 1:
                    default:
                      return Quat.copy(quat, _preValue.value);
                  }
                } else if (time > lastTime) {
                  var _preValue2 = values[nFrames - 1];
                  switch (postExtrapolation) {
                    case 2:
                      time = firstTime + repeat$2(time - firstTime, lastTime - firstTime);
                      break;
                    case 3:
                      time = firstTime + pingPong(time - firstTime, lastTime - firstTime);
                      break;
                    case 1:
                    default:
                      return Quat.copy(quat, _preValue2.value);
                  }
                }
                var index = binarySearchEpsilon(times, time);
                if (index >= 0) {
                  return Quat.copy(quat, values[index].value);
                }
                var iNext = ~index;
                assertIsTrue(iNext !== 0 && iNext !== nFrames && nFrames > 1);
                var iPre = iNext - 1;
                var preTime = times[iPre];
                var preValue = values[iPre];
                var nextTime = times[iNext];
                var nextValue = values[iNext];
                assertIsTrue(nextTime > time && time > preTime);
                var dt = nextTime - preTime;
                var ratio = (time - preTime) / dt;
                switch (preValue.interpolationMode) {
                  default:
                  case 1:
                    return Quat.copy(quat, preValue.value);
                  case 0:
                    {
                      var easingMethod = preValue.easingMethod;
                      var transformedRatio = easingMethod === 0 ? ratio : Array.isArray(easingMethod) ? bezierByTime(easingMethod, ratio) : getEasingFn(easingMethod)(ratio);
                      return Quat.slerp(quat, preValue.value, nextValue.value, transformedRatio);
                    }
                }
              };
              _proto.addKeyFrame = function addKeyFrame(time, value) {
                var keyframeValue = new QuatKeyframeValue(value);
                return _KeyframeCurve.prototype.addKeyFrame.call(this, time, keyframeValue);
              };
              _proto.assignSorted = function assignSorted(times, values) {
                if (values !== undefined) {
                  assertIsTrue(Array.isArray(times));
                  this.setKeyframes(times.slice(), values.map(function (value) {
                    return createQuatKeyframeValue(value);
                  }));
                } else {
                  var _keyframes = Array.from(times);
                  this.setKeyframes(_keyframes.map(function (_ref2) {
                    var time = _ref2[0];
                    return time;
                  }), _keyframes.map(function (_ref3) {
                    var value = _ref3[1];
                    return createQuatKeyframeValue(value);
                  }));
                }
              };
              _proto[serializeTag] = function (output, context) {
                if (!context.toCCON) {
                  output.writeThis();
                  return;
                }
                var times = this._times,
                  keyframeValues = this._values;
                var interpolationModeRepeated = true;
                keyframeValues.forEach(function (keyframeValue, _index, _ref4) {
                  var firstKeyframeValue = _ref4[0];
                  if (interpolationModeRepeated && keyframeValue.interpolationMode !== firstKeyframeValue.interpolationMode) {
                    interpolationModeRepeated = false;
                  }
                });
                var nKeyframes = times.length;
                var nFrames = nKeyframes;
                var interpolationModesSize = INTERPOLATION_MODE_BYTES * (interpolationModeRepeated ? 1 : nFrames);
                var easingMethodsSize = keyframeValues.reduce(function (result, _ref5) {
                  var easingMethod = _ref5.easingMethod;
                  return result += Array.isArray(easingMethod) ? EASING_METHOD_BYTES + EASING_METHOD_BEZIER_COMPONENT_BYTES * 4 : EASING_METHOD_BYTES;
                }, 0);
                var dataSize = 0;
                dataSize += FLAGS_BYTES + FRAME_COUNT_BYTES + TIME_BYTES * nFrames + VALUE_BYTES * 4 * nFrames + easingMethodsSize + interpolationModesSize + 0;
                var dataView = new DataView(new ArrayBuffer(dataSize));
                var P = 0;
                var flags = 0;
                if (interpolationModeRepeated) {
                  flags |= 1;
                }
                dataView.setUint32(P, flags, true);
                P += FLAGS_BYTES;
                dataView.setUint32(P, nFrames, true);
                P += FRAME_COUNT_BYTES;
                times.forEach(function (time, index) {
                  return dataView.setFloat32(P + TIME_BYTES * index, time, true);
                });
                P += TIME_BYTES * nFrames;
                keyframeValues.forEach(function (_ref6, index) {
                  var _ref6$value = _ref6.value,
                    x = _ref6$value.x,
                    y = _ref6$value.y,
                    z = _ref6$value.z,
                    w = _ref6$value.w;
                  var pQuat = P + VALUE_BYTES * 4 * index;
                  dataView.setFloat32(pQuat + VALUE_BYTES * 0, x, true);
                  dataView.setFloat32(pQuat + VALUE_BYTES * 1, y, true);
                  dataView.setFloat32(pQuat + VALUE_BYTES * 2, z, true);
                  dataView.setFloat32(pQuat + VALUE_BYTES * 3, w, true);
                });
                P += VALUE_BYTES * 4 * nFrames;
                keyframeValues.forEach(function (_ref7, index) {
                  var easingMethod = _ref7.easingMethod;
                  if (!Array.isArray(easingMethod)) {
                    dataView.setUint8(P, easingMethod);
                    ++P;
                  } else {
                    dataView.setUint8(P, EASING_METHOD_BEZIER_TAG);
                    ++P;
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, easingMethod[0], true);
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, easingMethod[1], true);
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, easingMethod[2], true);
                    dataView.setFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, easingMethod[3], true);
                    P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
                  }
                });
                var INTERPOLATION_MODES_START = P;
                P += interpolationModesSize;
                var pInterpolationMode = INTERPOLATION_MODES_START;
                keyframeValues.forEach(function (_ref8) {
                  var interpolationMode = _ref8.interpolationMode;
                  dataView.setUint8(pInterpolationMode, interpolationMode);
                  if (!interpolationModeRepeated) {
                    pInterpolationMode += INTERPOLATION_MODE_BYTES;
                  }
                });
                var bytes = new Uint8Array(dataView.buffer);
                output.writeProperty('bytes', bytes);
              };
              _proto[deserializeTag] = function (input, context) {
                if (!context.fromCCON) {
                  input.readThis();
                  return;
                }
                var bytes = input.readProperty('bytes');
                var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
                var P = 0;
                var flags = dataView.getUint32(P, true);
                P += FLAGS_BYTES;
                var interpolationModeRepeated = flags & 1;
                var nFrames = dataView.getUint32(P, true);
                P += FRAME_COUNT_BYTES;
                var times = Array.from({
                  length: nFrames
                }, function (_, index) {
                  return dataView.getFloat32(P + TIME_BYTES * index, true);
                });
                P += TIME_BYTES * nFrames;
                var P_VALUES = P;
                P += VALUE_BYTES * 4 * nFrames;
                var keyframeValues = Array.from({
                  length: nFrames
                }, function (_, index) {
                  var pQuat = P_VALUES + VALUE_BYTES * 4 * index;
                  var x = dataView.getFloat32(pQuat + VALUE_BYTES * 0, true);
                  var y = dataView.getFloat32(pQuat + VALUE_BYTES * 1, true);
                  var z = dataView.getFloat32(pQuat + VALUE_BYTES * 2, true);
                  var w = dataView.getFloat32(pQuat + VALUE_BYTES * 3, true);
                  var easingMethod = dataView.getUint8(P);
                  ++P;
                  var keyframeValue = createQuatKeyframeValue({
                    value: {
                      x: x,
                      y: y,
                      z: z,
                      w: w
                    }
                  });
                  if (easingMethod !== EASING_METHOD_BEZIER_TAG) {
                    keyframeValue.easingMethod = easingMethod;
                  } else {
                    keyframeValue.easingMethod = [dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 0, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 1, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 2, true), dataView.getFloat32(P + EASING_METHOD_BEZIER_COMPONENT_BYTES * 3, true)];
                    P += EASING_METHOD_BEZIER_COMPONENT_BYTES * 4;
                  }
                  return keyframeValue;
                });
                if (interpolationModeRepeated) {
                  var interpolationMode = dataView.getUint8(P);
                  ++P;
                  for (var iKeyframe = 0; iKeyframe < nFrames; ++iKeyframe) {
                    keyframeValues[iKeyframe].interpolationMode = interpolationMode;
                  }
                } else {
                  for (var _iKeyframe = 0; _iKeyframe < nFrames; ++_iKeyframe) {
                    var _interpolationMode = dataView.getUint8(P + _iKeyframe);
                    keyframeValues[_iKeyframe].interpolationMode = _interpolationMode;
                  }
                  P += nFrames;
                }
                this._times = times;
                this._values = keyframeValues;
              };
              return QuatCurve;
            }(KeyframeCurve), (_initializer4$k = applyDecoratedInitializer(_class5$7.prototype, "preExtrapolation", [serializable$5], function () {
              return 1;
            }), _initializer5$h = applyDecoratedInitializer(_class5$7.prototype, "postExtrapolation", [serializable$5], function () {
              return 1;
            })), _class5$7)) || _class4$7));
            var FLAGS_BYTES = 1;
            var FRAME_COUNT_BYTES = 4;
            var TIME_BYTES = 4;
            var VALUE_BYTES = 4;
            var INTERPOLATION_MODE_BYTES = 1;
            var EASING_METHOD_BYTES = 1;
            var EASING_METHOD_BEZIER_TAG = 255;
            var EASING_METHOD_BEZIER_COMPONENT_BYTES = 4;

            var _dec$O, _class$P;
            var ObjectCurve = exports("ObjectCurve", (_dec$O = ccclass$6('cc.ObjectCurve'), _dec$O(_class$P = function (_KeyframeCurve) {
              _inheritsLoose(ObjectCurve, _KeyframeCurve);
              function ObjectCurve() {
                return _KeyframeCurve.apply(this, arguments) || this;
              }
              var _proto = ObjectCurve.prototype;
              _proto.evaluate = function evaluate(time) {
                var iSearch = this.searchKeyframe(time);
                if (iSearch >= 0) {
                  return this._values[iSearch];
                }
                var iPrev = clamp(~iSearch - 1, 0, this._values.length - 1);
                return this._values[iPrev];
              };
              return ObjectCurve;
            }(KeyframeCurve)) || _class$P));

            var GradientMode = {
              Blend: 0,
              Fixed: 1
            };
            Enum(GradientMode);
            var ColorKey = exports("ColorKey", function ColorKey() {
              this.color = Color.WHITE.clone();
              this.time = 0;
            });
            CCClass.fastDefine('cc.ColorKey', ColorKey, {
              color: Color.WHITE.clone(),
              time: 0
            });
            CCClass.Attr.setClassAttr(ColorKey, 'color', 'visible', true);
            CCClass.Attr.setClassAttr(ColorKey, 'time', 'visible', true);
            var AlphaKey = exports("AlphaKey", function AlphaKey() {
              this.alpha = 1;
              this.time = 0;
            });
            CCClass.fastDefine('cc.AlphaKey', AlphaKey, {
              alpha: 1,
              time: 0
            });
            CCClass.Attr.setClassAttr(AlphaKey, 'alpha', 'visible', true);
            CCClass.Attr.setClassAttr(AlphaKey, 'time', 'visible', true);
            var Gradient = exports("Gradient", function () {
              function Gradient() {
                this.colorKeys = [];
                this.alphaKeys = [];
                this.mode = 0;
              }
              var _proto = Gradient.prototype;
              _proto.setKeys = function setKeys(colorKeys, alphaKeys) {
                this.colorKeys = colorKeys;
                this.alphaKeys = alphaKeys;
              };
              _proto.sortKeys = function sortKeys() {
                if (this.colorKeys.length > 1) {
                  this.colorKeys.sort(function (a, b) {
                    return a.time - b.time;
                  });
                }
                if (this.alphaKeys.length > 1) {
                  this.alphaKeys.sort(function (a, b) {
                    return a.time - b.time;
                  });
                }
              };
              _proto.evaluate = function evaluate(time) {
                return this.evaluateFast(new Color(), time);
              };
              _proto.evaluateFast = function evaluateFast(out, time) {
                this.getRGB(out, time);
                out.a = this.getAlpha(time);
                return out;
              };
              _proto.randomColor = function randomColor() {
                return this.getRandomColor(new Color());
              };
              _proto.getRandomColor = function getRandomColor(out) {
                var c = this.colorKeys[Math.trunc(random() * this.colorKeys.length)];
                var a = this.alphaKeys[Math.trunc(random() * this.alphaKeys.length)];
                out.set(c.color);
                out.a = a.alpha;
                return out;
              };
              _proto.getRGB = function getRGB(out, time) {
                var colorKeys = this.colorKeys;
                var length = colorKeys.length;
                if (length > 1) {
                  time = repeat$2(time, 1.0 + EPSILON$1);
                  for (var i = 1; i < length; ++i) {
                    var preTime = colorKeys[i - 1].time;
                    var curTime = colorKeys[i].time;
                    if (time >= preTime && time < curTime) {
                      if (this.mode === 1) {
                        Color.copy(out, colorKeys[i].color);
                        return out;
                      }
                      var factor = (time - preTime) / (curTime - preTime);
                      Color.lerp(out, colorKeys[i - 1].color, colorKeys[i].color, factor);
                      return out;
                    }
                  }
                  var lastIndex = length - 1;
                  if (approx(time, colorKeys[lastIndex].time, EPSILON$1)) {
                    Color.copy(out, colorKeys[lastIndex].color);
                  } else if (time < colorKeys[0].time) {
                    Color.lerp(out, Color.BLACK, colorKeys[0].color, time / colorKeys[0].time);
                  } else if (time > colorKeys[lastIndex].time) {
                    Color.lerp(out, colorKeys[lastIndex].color, Color.BLACK, (time - colorKeys[lastIndex].time) / (1 - colorKeys[lastIndex].time));
                  }
                } else if (length === 1) {
                  Color.copy(out, colorKeys[0].color);
                } else {
                  Color.copy(out, Color.WHITE);
                }
                return out;
              };
              _proto.getAlpha = function getAlpha(time) {
                var basicAlpha = 0;
                var alphaKeys = this.alphaKeys;
                var length = alphaKeys.length;
                if (length > 1) {
                  time = repeat$2(time, 1.0 + EPSILON$1);
                  for (var i = 1; i < length; ++i) {
                    var preTime = alphaKeys[i - 1].time;
                    var curTime = alphaKeys[i].time;
                    if (time >= preTime && time < curTime) {
                      if (this.mode === 1) {
                        return alphaKeys[i].alpha;
                      }
                      var factor = (time - preTime) / (curTime - preTime);
                      return lerp(alphaKeys[i - 1].alpha, alphaKeys[i].alpha, factor);
                    }
                  }
                  var lastIndex = length - 1;
                  if (approx(time, alphaKeys[lastIndex].time, EPSILON$1)) {
                    return alphaKeys[lastIndex].alpha;
                  } else if (time < alphaKeys[0].time) {
                    return lerp(basicAlpha, alphaKeys[0].alpha, time / alphaKeys[0].time);
                  } else if (time > alphaKeys[lastIndex].time) {
                    return lerp(alphaKeys[lastIndex].alpha, basicAlpha, (time - alphaKeys[lastIndex].time) / (1 - alphaKeys[lastIndex].time));
                  }
                  return 255;
                } else if (length === 1) {
                  return alphaKeys[0].alpha;
                } else {
                  return 255;
                }
              };
              return Gradient;
            }());
            Gradient.Mode = GradientMode;
            CCClass.fastDefine('cc.Gradient', Gradient, {
              colorKeys: [],
              alphaKeys: [],
              mode: 0
            });
            CCClass.Attr.setClassAttr(Gradient, 'colorKeys', 'visible', true);
            CCClass.Attr.setClassAttr(Gradient, 'alphaKeys', 'visible', true);
            CCClass.Attr.setClassAttr(Gradient, 'mode', 'visible', true);

            var LOOK_FORWARD = 3;
            var Keyframe = function Keyframe() {
              this.time = 0;
              this.value = 0;
              this.inTangent = 0;
              this.outTangent = 0;
            };
            CCClass.fastDefine('cc.Keyframe', Keyframe, {
              time: 0,
              value: 0,
              inTangent: 0,
              outTangent: 0
            });
            var OptimizedKey = function () {
              function OptimizedKey() {
                this.index = undefined;
                this.time = undefined;
                this.endTime = undefined;
                this.coefficient = undefined;
                this.index = -1;
                this.time = 0;
                this.endTime = 0;
                this.coefficient = new Float32Array(4);
              }
              var _proto = OptimizedKey.prototype;
              _proto.evaluate = function evaluate(T) {
                var t = T - this.time;
                return evalOptCurve(t, this.coefficient);
              };
              return OptimizedKey;
            }();
            function evalOptCurve(t, coefs) {
              return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
            }
            var AnimationCurve = function () {
              function AnimationCurve(keyFrames) {
                if (keyFrames === undefined) {
                  keyFrames = null;
                }
                this._curve = undefined;
                this.cachedKey = undefined;
                if (keyFrames instanceof RealCurve) {
                  this._curve = keyFrames;
                } else {
                  var curve = new RealCurve();
                  this._curve = curve;
                  curve.preExtrapolation = 2;
                  curve.postExtrapolation = 1;
                  if (!keyFrames) {
                    curve.assignSorted([[0.0, {
                      interpolationMode: 2,
                      value: 1.0
                    }], [1.0, {
                      interpolationMode: 2,
                      value: 1.0
                    }]]);
                  } else {
                    curve.assignSorted(keyFrames.map(function (legacyKeyframe) {
                      return [legacyKeyframe.time, {
                        interpolationMode: 2,
                        value: legacyKeyframe.value,
                        leftTangent: legacyKeyframe.inTangent,
                        rightTangent: legacyKeyframe.outTangent
                      }];
                    }));
                  }
                }
                this.cachedKey = new OptimizedKey();
              }
              var _proto2 = AnimationCurve.prototype;
              _proto2.addKey = function addKey(keyFrame) {
                if (!keyFrame) {
                  this._curve.clear();
                } else {
                  this._curve.addKeyFrame(keyFrame.time, {
                    interpolationMode: 2,
                    value: keyFrame.value,
                    leftTangent: keyFrame.inTangent,
                    rightTangent: keyFrame.outTangent
                  });
                }
              };
              _proto2.evaluate_slow = function evaluate_slow(time) {
                return this._curve.evaluate(time);
              };
              _proto2.evaluate = function evaluate(time) {
                var cachedKey = this.cachedKey,
                  curve = this._curve;
                var nKeyframes = curve.keyFramesCount;
                var lastKeyframeIndex = nKeyframes - 1;
                var wrappedTime = time;
                var extrapolationMode = time < 0 ? curve.preExtrapolation : curve.postExtrapolation;
                var startTime = curve.getKeyframeTime(0);
                var endTime = curve.getKeyframeTime(lastKeyframeIndex);
                switch (extrapolationMode) {
                  case 2:
                    wrappedTime = repeat$2(time - startTime, endTime - startTime) + startTime;
                    break;
                  case 3:
                    wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                    break;
                  case 1:
                  default:
                    wrappedTime = clamp(time, startTime, endTime);
                    break;
                }
                if (wrappedTime >= cachedKey.time && wrappedTime < cachedKey.endTime) {
                  return cachedKey.evaluate(wrappedTime);
                }
                var leftIndex = this.findIndex(cachedKey, wrappedTime);
                var rightIndex = Math.min(leftIndex + 1, lastKeyframeIndex);
                this.calcOptimizedKey(cachedKey, leftIndex, rightIndex);
                return cachedKey.evaluate(wrappedTime);
              };
              _proto2.calcOptimizedKey = function calcOptimizedKey(optKey, leftIndex, rightIndex) {
                var lhsTime = this._curve.getKeyframeTime(leftIndex);
                var rhsTime = this._curve.getKeyframeTime(rightIndex);
                var _this$_curve$getKeyfr = this._curve.getKeyframeValue(leftIndex),
                  lhsValue = _this$_curve$getKeyfr.value,
                  lhsOutTangent = _this$_curve$getKeyfr.leftTangent;
                var _this$_curve$getKeyfr2 = this._curve.getKeyframeValue(rightIndex),
                  rhsValue = _this$_curve$getKeyfr2.value,
                  rhsInTangent = _this$_curve$getKeyfr2.rightTangent;
                optKey.index = leftIndex;
                optKey.time = lhsTime;
                optKey.endTime = rhsTime;
                var dx = rhsTime - lhsTime;
                var dy = rhsValue - lhsValue;
                var length = 1 / (dx * dx);
                var d1 = lhsOutTangent * dx;
                var d2 = rhsInTangent * dx;
                optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx;
                optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length;
                optKey.coefficient[2] = lhsOutTangent;
                optKey.coefficient[3] = lhsValue;
              };
              _proto2.findIndex = function findIndex(optKey, t) {
                var curve = this._curve;
                var nKeyframes = curve.keyFramesCount;
                var cachedIndex = optKey.index;
                if (cachedIndex !== -1) {
                  var cachedTime = curve.getKeyframeTime(cachedIndex);
                  if (t > cachedTime) {
                    for (var i = 0; i < LOOK_FORWARD; i++) {
                      var currIndex = cachedIndex + i;
                      if (currIndex + 1 < nKeyframes && curve.getKeyframeTime(currIndex + 1) > t) {
                        return currIndex;
                      }
                    }
                  } else {
                    for (var _i = 0; _i < LOOK_FORWARD; _i++) {
                      var _currIndex = cachedIndex - _i;
                      if (_currIndex >= 0 && curve.getKeyframeTime(_currIndex - 1) <= t) {
                        return _currIndex - 1;
                      }
                    }
                  }
                }
                var left = 0;
                var right = nKeyframes;
                var mid;
                while (right - left > 1) {
                  mid = Math.floor((left + right) / 2);
                  if (curve.getKeyframeTime(mid) >= t) {
                    right = mid;
                  } else {
                    left = mid;
                  }
                }
                return left;
              };
              _createClass(AnimationCurve, [{
                key: "_internalCurve",
                get: function get() {
                  return this._curve;
                }
              }, {
                key: "keyFrames",
                get: function get() {
                  return Array.from(this._curve.keyframes()).map(function (_ref) {
                    var time = _ref[0],
                      value = _ref[1];
                    var legacyKeyframe = new Keyframe();
                    legacyKeyframe.time = time;
                    legacyKeyframe.value = value.value;
                    legacyKeyframe.inTangent = value.leftTangent;
                    legacyKeyframe.outTangent = value.rightTangent;
                    return legacyKeyframe;
                  });
                },
                set: function set(value) {
                  this._curve.assignSorted(value.map(function (legacyCurve) {
                    return [legacyCurve.time, {
                      interpolationMode: 2,
                      value: legacyCurve.value,
                      leftTangent: legacyCurve.inTangent,
                      rightTangent: legacyCurve.outTangent
                    }];
                  }));
                }
              }, {
                key: "preWrapMode",
                get: function get() {
                  return toLegacyWrapMode(this._curve.preExtrapolation);
                },
                set: function set(value) {
                  this._curve.preExtrapolation = fromLegacyWrapMode(value);
                }
              }, {
                key: "postWrapMode",
                get: function get() {
                  return toLegacyWrapMode(this._curve.postExtrapolation);
                },
                set: function set(value) {
                  this._curve.postExtrapolation = fromLegacyWrapMode(value);
                }
              }]);
              return AnimationCurve;
            }();
            AnimationCurve.defaultKF = [{
              time: 0,
              value: 1,
              inTangent: 0,
              outTangent: 0
            }, {
              time: 1,
              value: 1,
              inTangent: 0,
              outTangent: 0
            }];
            CCClass.fastDefine('cc.AnimationCurve', AnimationCurve, {
              _curve: null
            });
            var WrapModeMask = {
              Default: 0,
              Normal: 1,
              Loop: 2,
              ShouldWrap: 4,
              Clamp: 8,
              PingPong: 22,
              Reverse: 36
            };
            function fromLegacyWrapMode(legacyWrapMode) {
              switch (legacyWrapMode) {
                default:
                case 0:
                case 1:
                case 8:
                  return 1;
                case 22:
                  return 3;
                case 2:
                  return 2;
              }
            }
            function toLegacyWrapMode(extrapolationMode) {
              switch (extrapolationMode) {
                default:
                case 0:
                case 1:
                  return 8;
                case 3:
                  return 22;
                case 2:
                  return 2;
              }
            }
            function constructLegacyCurveAndConvert() {
              var curve = new RealCurve();
              curve.assignSorted([[0.0, {
                interpolationMode: 2,
                value: 1.0
              }], [1.0, {
                interpolationMode: 2,
                value: 1.0
              }]]);
              return curve;
            }

            var vec3MultiplyScalar$1 = Vec3.multiplyScalar;
            var vec3Add$1 = Vec3.add;
            var SplineMode = {
              LINEAR: 0,
              BEZIER: 1,
              CATMULL_ROM: 2
            };
            var SPLINE_WHOLE_INDEX = 0xffffffff;
            var _v0 = v3();
            var _v1 = v3();
            var _v2 = v3();
            var _v3$2 = v3();
            var Spline = function () {
              function Spline(mode, knots) {
                if (mode === undefined) {
                  mode = 2;
                }
                if (knots === undefined) {
                  knots = [];
                }
                this._type = undefined;
                this._knots = [];
                this._type = 1024;
                this._mode = mode;
                for (var i = 0; i < knots.length; i++) {
                  this._knots[i] = v3(knots[i]);
                }
              }
              Spline.create = function create(mode, knots) {
                if (knots === undefined) {
                  knots = [];
                }
                return new Spline(mode, knots);
              };
              Spline.clone = function clone(s) {
                return new Spline(s.mode, s.knots);
              };
              Spline.copy = function copy(out, s) {
                out._mode = s.mode;
                out._knots.length = 0;
                var knots = s.knots;
                var length = knots.length;
                for (var i = 0; i < length; i++) {
                  out._knots[i] = v3(knots[i]);
                }
                return out;
              };
              var _proto = Spline.prototype;
              _proto.setModeAndKnots = function setModeAndKnots(mode, knots) {
                this._mode = mode;
                this._knots.length = 0;
                for (var i = 0; i < knots.length; i++) {
                  this._knots[i] = v3(knots[i]);
                }
              };
              _proto.clearKnots = function clearKnots() {
                this._knots.length = 0;
              };
              _proto.getKnotCount = function getKnotCount() {
                return this._knots.length;
              };
              _proto.addKnot = function addKnot(knot) {
                this._knots.push(v3(knot));
              };
              _proto.insertKnot = function insertKnot(index, knot) {
                var item = v3(knot);
                if (index >= this._knots.length) {
                  this._knots.push(item);
                  return;
                }
                this._knots.splice(index, 0, item);
              };
              _proto.removeKnot = function removeKnot(index) {
                assertsArrayIndex(this._knots, index);
                this._knots.splice(index, 1);
              };
              _proto.setKnot = function setKnot(index, knot) {
                assertsArrayIndex(this._knots, index);
                this._knots[index].set(knot);
              };
              _proto.getKnot = function getKnot(index) {
                assertsArrayIndex(this._knots, index);
                return this._knots[index];
              };
              _proto.getPoint = function getPoint(t, index) {
                if (index === undefined) {
                  index = SPLINE_WHOLE_INDEX;
                }
                t = clamp(t, 0.0, 1.0);
                var segments = this.getSegments();
                if (segments === 0) {
                  return v3();
                }
                if (index === SPLINE_WHOLE_INDEX) {
                  var deltaT = 1.0 / segments;
                  index = Math.floor(t / deltaT);
                  t = t % deltaT / deltaT;
                }
                var knots = this._knots;
                if (index >= segments) {
                  return v3(knots[knots.length - 1]);
                }
                switch (this._mode) {
                  case 0:
                    return Spline.calcLinear(knots[index], knots[index + 1], t);
                  case 1:
                    {
                      var start = index * 4;
                      return Spline.calcBezier(knots[start], knots[start + 1], knots[start + 2], knots[start + 3], t);
                    }
                  case 2:
                    {
                      var v0 = index > 0 ? knots[index - 1] : knots[index];
                      var _v = index + 2 < knots.length ? knots[index + 2] : knots[index + 1];
                      return Spline.calcCatmullRom(v0, knots[index], knots[index + 1], _v, t);
                    }
                  default:
                    return v3();
                }
              };
              _proto.getPoints = function getPoints(num, index) {
                if (index === undefined) {
                  index = SPLINE_WHOLE_INDEX;
                }
                if (num === 0) {
                  return [];
                }
                if (num === 1) {
                  var point = this.getPoint(0.0, index);
                  return [point];
                }
                var points = [];
                var deltaT = 1.0 / (num - 1.0);
                for (var i = 0; i < num; i++) {
                  var t = i * deltaT;
                  var _point = this.getPoint(t, index);
                  points.push(_point);
                }
                return points;
              };
              _proto.getSegments = function getSegments() {
                var count = this._knots.length;
                switch (this._mode) {
                  case 0:
                  case 2:
                    if (count < 2) {
                      warnID(14300);
                      return 0;
                    }
                    return count - 1;
                  case 1:
                    if (count < 4 || count % 4 !== 0) {
                      warnID(14301);
                      return 0;
                    }
                    return count / 4;
                  default:
                    assertID(false, 16407);
                    return 0;
                }
              };
              Spline.calcLinear = function calcLinear(v0, v1, t) {
                var result = new Vec3();
                vec3MultiplyScalar$1(_v0, v0, 1.0 - t);
                vec3MultiplyScalar$1(_v1, v1, t);
                vec3Add$1(result, _v0, _v1);
                return result;
              };
              Spline.calcBezier = function calcBezier(v0, v1, v2, v3, t) {
                var result = new Vec3();
                var s = 1.0 - t;
                vec3MultiplyScalar$1(_v0, v0, s * s * s);
                vec3MultiplyScalar$1(_v1, v1, 3.0 * t * s * s);
                vec3MultiplyScalar$1(_v2, v2, 3.0 * t * t * s);
                vec3MultiplyScalar$1(_v3$2, v3, t * t * t);
                vec3Add$1(_v0, _v0, _v1);
                vec3Add$1(_v2, _v2, _v3$2);
                vec3Add$1(result, _v0, _v2);
                return result;
              };
              Spline.calcCatmullRom = function calcCatmullRom(v0, v1, v2, v3, t) {
                var result = new Vec3();
                var t2 = t * t;
                var t3 = t2 * t;
                vec3MultiplyScalar$1(_v0, v0, -0.5 * t3 + t2 - 0.5 * t);
                vec3MultiplyScalar$1(_v1, v1, 1.5 * t3 - 2.5 * t2 + 1.0);
                vec3MultiplyScalar$1(_v2, v2, -1.5 * t3 + 2.0 * t2 + 0.5 * t);
                vec3MultiplyScalar$1(_v3$2, v3, 0.5 * t3 - 0.5 * t2);
                vec3Add$1(_v0, _v0, _v1);
                vec3Add$1(_v2, _v2, _v3$2);
                vec3Add$1(result, _v0, _v2);
                return result;
              };
              _createClass(Spline, [{
                key: "type",
                get: function get() {
                  return this._type;
                }
              }, {
                key: "mode",
                get: function get() {
                  return this._mode;
                }
              }, {
                key: "knots",
                get: function get() {
                  return this._knots;
                }
              }]);
              return Spline;
            }();

            var ERaycastMode = {
              ALL: 0,
              CLOSEST: 1,
              ANY: 2
            };

            replaceProperty(intersect, 'intersect', [{
              name: 'ray_aabb',
              newName: 'rayAABB'
            }, {
              name: 'ray_plane',
              newName: 'rayPlane'
            }, {
              name: 'ray_triangle',
              newName: 'rayTriangle'
            }, {
              name: 'ray_sphere',
              newName: 'raySphere'
            }, {
              name: 'ray_obb',
              newName: 'rayOBB'
            }, {
              name: 'ray_capsule',
              newName: 'rayCapsule'
            }, {
              name: 'ray_subMesh',
              newName: 'raySubMesh'
            }, {
              name: 'ray_mesh',
              newName: 'rayMesh'
            }, {
              name: 'ray_model',
              newName: 'rayModel'
            }, {
              name: 'line_plane',
              newName: 'linePlane'
            }, {
              name: 'line_triangle',
              newName: 'lineTriangle'
            }, {
              name: 'line_aabb',
              newName: 'lineAABB'
            }, {
              name: 'line_obb',
              newName: 'lineOBB'
            }, {
              name: 'line_sphere',
              newName: 'lineSphere'
            }, {
              name: 'aabb_aabb',
              newName: 'aabbWithAABB'
            }, {
              name: 'aabb_obb',
              newName: 'aabbWithOBB'
            }, {
              name: 'aabb_plane',
              newName: 'aabbPlane'
            }, {
              name: 'aabb_frustum',
              newName: 'aabbFrustum'
            }, {
              name: 'aabbFrustum_accurate',
              newName: 'aabbFrustumAccurate'
            }, {
              name: 'obb_point',
              newName: 'obbPoint'
            }, {
              name: 'obb_plane',
              newName: 'obbPlane'
            }, {
              name: 'obb_frustum',
              newName: 'obbFrustum'
            }, {
              name: 'obbFrustum_accurate',
              newName: 'obbFrustumAccurate'
            }, {
              name: 'obb_obb',
              newName: 'obbWithOBB'
            }, {
              name: 'obb_capsule',
              newName: 'obbCapsule'
            }, {
              name: 'sphere_plane',
              newName: 'spherePlane'
            }, {
              name: 'sphere_frustum',
              newName: 'sphereFrustum'
            }, {
              name: 'sphereFrustum_accurate',
              newName: 'sphereFrustumAccurate'
            }, {
              name: 'sphere_sphere',
              newName: 'sphereWithSphere'
            }, {
              name: 'sphere_aabb',
              newName: 'sphereAABB'
            }, {
              name: 'sphere_obb',
              newName: 'sphereOBB'
            }, {
              name: 'sphere_capsule',
              newName: 'sphereCapsule'
            }, {
              name: 'capsule_capsule',
              newName: 'capsuleWithCapsule'
            }]);
            function deprecatedClassMessage(oldClassName, newClassName) {
              warn(oldClassName + " is deprecated, please use " + newClassName + " instead.");
            }
            var line = function (_Line) {
              _inheritsLoose(line, _Line);
              function line() {
                var _this;
                _this = _Line.call(this) || this;
                deprecatedClassMessage('line', 'Line');
                return _this;
              }
              return line;
            }(Line);
            var plane = function (_Plane) {
              _inheritsLoose(plane, _Plane);
              function plane() {
                var _this2;
                _this2 = _Plane.call(this) || this;
                deprecatedClassMessage('plane', 'Plane');
                return _this2;
              }
              return plane;
            }(Plane);
            var ray = function (_Ray) {
              _inheritsLoose(ray, _Ray);
              function ray() {
                var _this3;
                _this3 = _Ray.call(this) || this;
                deprecatedClassMessage('ray', 'Ray');
                return _this3;
              }
              return ray;
            }(Ray);
            var triangle = function (_Triangle) {
              _inheritsLoose(triangle, _Triangle);
              function triangle() {
                var _this4;
                _this4 = _Triangle.call(this) || this;
                deprecatedClassMessage('triangle', 'Triangle');
                return _this4;
              }
              return triangle;
            }(Triangle);
            var sphere = function (_Sphere) {
              _inheritsLoose(sphere, _Sphere);
              function sphere() {
                var _this5;
                _this5 = _Sphere.call(this) || this;
                deprecatedClassMessage('sphere', 'Sphere');
                return _this5;
              }
              return sphere;
            }(Sphere);
            var aabb = function (_AABB) {
              _inheritsLoose(aabb, _AABB);
              function aabb() {
                var _this6;
                _this6 = _AABB.call(this) || this;
                deprecatedClassMessage('aabb', 'AABB');
                return _this6;
              }
              return aabb;
            }(AABB);
            var obb = function (_OBB) {
              _inheritsLoose(obb, _OBB);
              function obb() {
                var _this7;
                _this7 = _OBB.call(this) || this;
                deprecatedClassMessage('obb', 'OBB');
                return _this7;
              }
              return obb;
            }(OBB);
            var capsule = function (_Capsule) {
              _inheritsLoose(capsule, _Capsule);
              function capsule() {
                var _this8;
                _this8 = _Capsule.call(this) || this;
                deprecatedClassMessage('capsule', 'Capsule');
                return _this8;
              }
              return capsule;
            }(Capsule);
            var frustum = function (_Frustum) {
              _inheritsLoose(frustum, _Frustum);
              function frustum() {
                var _this9;
                _this9 = _Frustum.call(this) || this;
                deprecatedClassMessage('frustum', 'Frustum');
                return _this9;
              }
              return frustum;
            }(Frustum);

            var geometry = /*#__PURE__*/Object.freeze({
                __proto__: null,
                AABB: AABB,
                AnimationCurve: AnimationCurve,
                Capsule: Capsule,
                ERaycastMode: ERaycastMode,
                Frustum: Frustum,
                Keyframe: Keyframe,
                Line: Line,
                OBB: OBB,
                OptimizedKey: OptimizedKey,
                Plane: Plane,
                Ray: Ray,
                Sphere: Sphere,
                Spline: Spline,
                SplineMode: SplineMode,
                Triangle: Triangle,
                WrapModeMask: WrapModeMask,
                aabb: aabb,
                capsule: capsule,
                constructLegacyCurveAndConvert: constructLegacyCurveAndConvert,
                distance: distance,
                enums: ShapeType,
                evalOptCurve: evalOptCurve,
                frustum: frustum,
                intersect: intersect,
                line: line,
                obb: obb,
                plane: plane,
                ray: ray,
                sphere: sphere,
                triangle: triangle
            });
            exports("geometry", geometry);

            var SystemPriority = exports("SystemPriority", {
              LOW: 0,
              MEDIUM: 100,
              HIGH: 200,
              SCHEDULER: 2147483648
            });
            var System = exports("System", function () {
              function System() {
                this._id = '';
                this._priority = 0;
                this._executeInEditMode = false;
              }
              System.sortByPriority = function sortByPriority(a, b) {
                if (a._priority < b._priority) {
                  return 1;
                } else if (a._priority > b.priority) {
                  return -1;
                } else {
                  return 0;
                }
              };
              var _proto = System.prototype;
              _proto.init = function init() {};
              _proto.update = function update(dt) {};
              _proto.postUpdate = function postUpdate(dt) {};
              _proto.destroy = function destroy() {};
              _createClass(System, [{
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(value) {
                  this._priority = value;
                }
              }, {
                key: "id",
                get: function get() {
                  return this._id;
                },
                set: function set(id) {
                  this._id = id;
                }
              }]);
              return System;
            }());
            System.Priority = Enum({
              LOW: 0,
              MEDIUM: 100,
              HIGH: 200,
              SCHEDULER: 2147483648
            });

            var MAX_POOL_SIZE$1 = 20;
            var idGenerator$3 = new IDGenerator('Scheduler');
            var ListEntry = function () {
              ListEntry.get = function get(target, priority, paused, markedForDeletion) {
                var result = ListEntry._listEntries.pop();
                if (result) {
                  result.target = target;
                  result.priority = priority;
                  result.paused = paused;
                  result.markedForDeletion = markedForDeletion;
                } else {
                  result = new ListEntry(target, priority, paused, markedForDeletion);
                }
                return result;
              };
              ListEntry.put = function put(entry) {
                if (ListEntry._listEntries.length < MAX_POOL_SIZE$1) {
                  entry.target = null;
                  ListEntry._listEntries.push(entry);
                }
              };
              function ListEntry(target, priority, paused, markedForDeletion) {
                this.target = undefined;
                this.priority = undefined;
                this.paused = undefined;
                this.markedForDeletion = undefined;
                this.target = target;
                this.priority = priority;
                this.paused = paused;
                this.markedForDeletion = markedForDeletion;
              }
              return ListEntry;
            }();
            ListEntry._listEntries = [];
            var HashUpdateEntry = function () {
              HashUpdateEntry.get = function get(list, entry, target, callback) {
                var result = HashUpdateEntry._hashUpdateEntries.pop();
                if (result) {
                  result.list = list;
                  result.entry = entry;
                  result.target = target;
                  result.callback = callback;
                } else {
                  result = new HashUpdateEntry(list, entry, target, callback);
                }
                return result;
              };
              HashUpdateEntry.put = function put(entry) {
                if (HashUpdateEntry._hashUpdateEntries.length < MAX_POOL_SIZE$1) {
                  entry.list = entry.entry = entry.target = entry.callback = null;
                  HashUpdateEntry._hashUpdateEntries.push(entry);
                }
              };
              function HashUpdateEntry(list, entry, target, callback) {
                this.list = undefined;
                this.entry = undefined;
                this.target = undefined;
                this.callback = undefined;
                this.list = list;
                this.entry = entry;
                this.target = target;
                this.callback = callback;
              }
              return HashUpdateEntry;
            }();
            HashUpdateEntry._hashUpdateEntries = [];
            var HashTimerEntry = function () {
              HashTimerEntry.get = function get(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
                var result = HashTimerEntry._hashTimerEntries.pop();
                if (result) {
                  result.timers = timers;
                  result.target = target;
                  result.timerIndex = timerIndex;
                  result.currentTimer = currentTimer;
                  result.currentTimerSalvaged = currentTimerSalvaged;
                  result.paused = paused;
                } else {
                  result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
                }
                return result;
              };
              HashTimerEntry.put = function put(entry) {
                if (HashTimerEntry._hashTimerEntries.length < MAX_POOL_SIZE$1) {
                  entry.timers = entry.target = entry.currentTimer = null;
                  HashTimerEntry._hashTimerEntries.push(entry);
                }
              };
              function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
                this.timers = undefined;
                this.target = undefined;
                this.timerIndex = undefined;
                this.currentTimer = undefined;
                this.currentTimerSalvaged = undefined;
                this.paused = undefined;
                this.timers = timers;
                this.target = target;
                this.timerIndex = timerIndex;
                this.currentTimer = currentTimer;
                this.currentTimerSalvaged = currentTimerSalvaged;
                this.paused = paused;
              }
              return HashTimerEntry;
            }();
            HashTimerEntry._hashTimerEntries = [];
            var CallbackTimer = function () {
              CallbackTimer.get = function get() {
                return CallbackTimer._timers.pop() || new CallbackTimer();
              };
              CallbackTimer.put = function put(timer) {
                if (CallbackTimer._timers.length < MAX_POOL_SIZE$1 && !timer._lock) {
                  timer._scheduler = timer._target = timer._callback = null;
                  CallbackTimer._timers.push(timer);
                }
              };
              function CallbackTimer() {
                this._lock = undefined;
                this._scheduler = undefined;
                this._elapsed = undefined;
                this._runForever = undefined;
                this._useDelay = undefined;
                this._timesExecuted = undefined;
                this._repeat = undefined;
                this._delay = undefined;
                this._interval = undefined;
                this._target = undefined;
                this._callback = undefined;
                this._lock = false;
                this._scheduler = null;
                this._elapsed = -1;
                this._runForever = false;
                this._useDelay = false;
                this._timesExecuted = 0;
                this._repeat = 0;
                this._delay = 0;
                this._interval = 0;
                this._target = null;
              }
              var _proto = CallbackTimer.prototype;
              _proto.initWithCallback = function initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
                this._lock = false;
                this._scheduler = scheduler;
                this._target = target;
                this._callback = callback;
                this._timesExecuted = 0;
                this._elapsed = -1;
                this._interval = seconds;
                this._delay = delay;
                this._useDelay = this._delay > 0;
                this._repeat = repeat;
                this._runForever = this._repeat === legacyCC.macro.REPEAT_FOREVER;
                return true;
              };
              _proto.getInterval = function getInterval() {
                return this._interval;
              };
              _proto.setInterval = function setInterval(interval) {
                this._interval = interval;
              };
              _proto.update = function update(dt) {
                if (this._elapsed === -1) {
                  this._elapsed = 0;
                  this._timesExecuted = 0;
                } else {
                  this._elapsed += dt;
                  if (this._runForever && !this._useDelay) {
                    if (this._elapsed >= this._interval) {
                      this.trigger();
                      this._elapsed = 0;
                    }
                  } else {
                    if (this._useDelay) {
                      if (this._elapsed >= this._delay) {
                        this.trigger();
                        this._elapsed -= this._delay;
                        this._timesExecuted += 1;
                        this._useDelay = false;
                      }
                    } else if (this._elapsed >= this._interval) {
                      this.trigger();
                      this._elapsed = 0;
                      this._timesExecuted += 1;
                    }
                    if (this._callback && !this._runForever && this._timesExecuted > this._repeat) {
                      this.cancel();
                    }
                  }
                }
              };
              _proto.getCallback = function getCallback() {
                return this._callback;
              };
              _proto.trigger = function trigger() {
                if (this._target && this._callback) {
                  this._lock = true;
                  this._callback.call(this._target, this._elapsed);
                  this._lock = false;
                }
              };
              _proto.cancel = function cancel() {
                if (this._scheduler && this._callback && this._target) {
                  this._scheduler.unscheduleForTimer(this, this._target);
                }
              };
              return CallbackTimer;
            }();
            CallbackTimer._timers = [];
            var Scheduler = exports("Scheduler", function (_System) {
              _inheritsLoose(Scheduler, _System);
              Scheduler.enableForTarget = function enableForTarget(target) {
                var found = false;
                if (target.uuid) {
                  found = true;
                } else if (target.id) {
                  found = true;
                }
                if (!found) {
                  target.id = idGenerator$3.getNewId();
                }
              };
              function Scheduler() {
                var _this;
                _this = _System.call(this) || this;
                _this._timeScale = undefined;
                _this._updatesNegList = undefined;
                _this._updates0List = undefined;
                _this._updatesPosList = undefined;
                _this._hashForUpdates = undefined;
                _this._hashForTimers = undefined;
                _this._currentTarget = undefined;
                _this._currentTargetSalvaged = undefined;
                _this._updateHashLocked = undefined;
                _this._arrayForTimers = undefined;
                _this._timeScale = 1.0;
                _this._updatesNegList = [];
                _this._updates0List = [];
                _this._updatesPosList = [];
                _this._hashForUpdates = createMap(true);
                _this._hashForTimers = createMap(true);
                _this._currentTarget = null;
                _this._currentTargetSalvaged = false;
                _this._updateHashLocked = false;
                _this._arrayForTimers = [];
                return _this;
              }
              var _proto2 = Scheduler.prototype;
              _proto2.setTimeScale = function setTimeScale(timeScale) {
                this._timeScale = timeScale;
              };
              _proto2.getTimeScale = function getTimeScale() {
                return this._timeScale;
              };
              _proto2.update = function update(dt) {
                this._updateHashLocked = true;
                if (this._timeScale !== 1) {
                  dt *= this._timeScale;
                }
                var i;
                var list;
                var len;
                var entry;
                for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
                  entry = list[i];
                  if (!entry.paused && !entry.markedForDeletion && entry.target) {
                    entry.target.update == null ? undefined : entry.target.update(dt);
                  }
                }
                for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
                  entry = list[i];
                  if (!entry.paused && !entry.markedForDeletion && entry.target) {
                    entry.target.update == null ? undefined : entry.target.update(dt);
                  }
                }
                for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
                  entry = list[i];
                  if (!entry.paused && !entry.markedForDeletion && entry.target) {
                    entry.target.update == null ? undefined : entry.target.update(dt);
                  }
                }
                var elt;
                var arr = this._arrayForTimers;
                for (i = 0; i < arr.length; i++) {
                  var _this$_currentTarget$;
                  elt = arr[i];
                  this._currentTarget = elt;
                  this._currentTargetSalvaged = false;
                  if (!elt.paused && elt.timers) {
                    for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
                      elt.currentTimer = elt.timers[elt.timerIndex];
                      elt.currentTimerSalvaged = false;
                      elt.currentTimer.update(dt);
                      elt.currentTimer = null;
                    }
                  }
                  if (this._currentTargetSalvaged && ((_this$_currentTarget$ = this._currentTarget.timers) == null ? undefined : _this$_currentTarget$.length) === 0) {
                    this._removeHashElement(this._currentTarget);
                    --i;
                  }
                }
                for (i = 0, list = this._updatesNegList; i < list.length;) {
                  entry = list[i];
                  if (entry.markedForDeletion) {
                    this._removeUpdateFromHash(entry);
                  } else {
                    i++;
                  }
                }
                for (i = 0, list = this._updates0List; i < list.length;) {
                  entry = list[i];
                  if (entry.markedForDeletion) {
                    this._removeUpdateFromHash(entry);
                  } else {
                    i++;
                  }
                }
                for (i = 0, list = this._updatesPosList; i < list.length;) {
                  entry = list[i];
                  if (entry.markedForDeletion) {
                    this._removeUpdateFromHash(entry);
                  } else {
                    i++;
                  }
                }
                this._updateHashLocked = false;
                this._currentTarget = null;
              };
              _proto2.schedule = function schedule(callbackTmp, targetTmp, interval, repeat, delay, paused) {
                var _repeat, _delay;
                var callback;
                var target;
                if (typeof callbackTmp !== 'function') {
                  warnID(1514);
                  callback = targetTmp;
                  target = callbackTmp;
                } else {
                  callback = callbackTmp;
                  target = targetTmp;
                }
                if (arguments.length === 3 || arguments.length === 4 || arguments.length === 5) {
                  paused = !!repeat;
                  repeat = legacyCC.macro.REPEAT_FOREVER;
                  delay = 0;
                }
                assertID(Boolean(target), 1502);
                var targetId = target.uuid || target.id;
                if (!targetId) {
                  errorID(1510);
                  return;
                }
                var element = this._hashForTimers[targetId];
                if (!element) {
                  element = HashTimerEntry.get(null, target, 0, null, false, Boolean(paused));
                  this._arrayForTimers.push(element);
                  this._hashForTimers[targetId] = element;
                } else if (element.paused !== paused) {
                  warnID(1511);
                }
                var timer;
                var i;
                if (element.timers == null) {
                  element.timers = [];
                } else {
                  for (i = 0; i < element.timers.length; ++i) {
                    timer = element.timers[i];
                    if (timer && callback === timer.getCallback()) {
                      logID(1507, timer.getInterval(), interval);
                      timer.setInterval(interval);
                      return;
                    }
                  }
                }
                timer = CallbackTimer.get();
                timer.initWithCallback(this, callback, target, interval, (_repeat = repeat) !== null && _repeat !== undefined ? _repeat : 0, (_delay = delay) !== null && _delay !== undefined ? _delay : 0);
                element.timers.push(timer);
                if (this._currentTarget === element && this._currentTargetSalvaged) {
                  this._currentTargetSalvaged = false;
                }
              };
              _proto2.scheduleUpdate = function scheduleUpdate(target, priority, paused) {
                var targetId = target.uuid || target.id;
                if (!targetId) {
                  errorID(1510);
                  return;
                }
                var hashElement = this._hashForUpdates[targetId];
                if (hashElement && hashElement.entry) {
                  if (hashElement.entry.priority !== priority) {
                    if (this._updateHashLocked) {
                      logID(1506);
                      hashElement.entry.markedForDeletion = false;
                      hashElement.entry.paused = paused;
                      return;
                    } else {
                      this.unscheduleUpdate(target);
                    }
                  } else {
                    hashElement.entry.markedForDeletion = false;
                    hashElement.entry.paused = paused;
                    return;
                  }
                }
                var listElement = ListEntry.get(target, priority, paused, false);
                var ppList;
                if (priority === 0) {
                  ppList = this._updates0List;
                  this._appendIn(ppList, listElement);
                } else {
                  ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;
                  this._priorityIn(ppList, listElement, priority);
                }
                this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
              };
              _proto2.unschedule = function unschedule(callback, target) {
                if (!target || !callback) {
                  return;
                }
                var targetId = target.uuid || target.id;
                if (!targetId) {
                  errorID(1510);
                  return;
                }
                var element = this._hashForTimers[targetId];
                if (element) {
                  var timers = element.timers;
                  if (!timers) {
                    return;
                  }
                  for (var i = 0, li = timers.length; i < li; i++) {
                    var timer = timers[i];
                    if (callback === timer.getCallback()) {
                      if (timer === element.currentTimer && !element.currentTimerSalvaged) {
                        element.currentTimerSalvaged = true;
                      }
                      timers.splice(i, 1);
                      CallbackTimer.put(timer);
                      if (element.timerIndex >= i) {
                        element.timerIndex--;
                      }
                      if (timers.length === 0) {
                        if (this._currentTarget === element) {
                          this._currentTargetSalvaged = true;
                        } else {
                          this._removeHashElement(element);
                        }
                      }
                      return;
                    }
                  }
                }
              };
              _proto2.unscheduleForTimer = function unscheduleForTimer(timerToUnschedule, target) {
                var targetId = target.uuid || target.id;
                var element = this._hashForTimers[targetId];
                var timers = element.timers;
                if (!timers || timers.length === 0) {
                  return;
                }
                for (var i = timers.length - 1; i >= 0; i--) {
                  var timer = timers[i];
                  if (timer === timerToUnschedule) {
                    timers.splice(i, 1);
                    CallbackTimer.put(timer);
                    if (element.timerIndex >= i) {
                      element.timerIndex--;
                    }
                    if (timers.length === 0) {
                      this._currentTargetSalvaged = true;
                    }
                    return;
                  }
                }
              };
              _proto2.unscheduleUpdate = function unscheduleUpdate(target) {
                if (!target) {
                  return;
                }
                var targetId = target.uuid || target.id;
                if (!targetId) {
                  errorID(1510);
                  return;
                }
                var element = this._hashForUpdates[targetId];
                if (element != null && element.entry) {
                  if (this._updateHashLocked) {
                    element.entry.markedForDeletion = true;
                  } else {
                    this._removeUpdateFromHash(element.entry);
                  }
                }
              };
              _proto2.unscheduleAllForTarget = function unscheduleAllForTarget(target) {
                if (!target) {
                  return;
                }
                var targetId = target.uuid || target.id;
                if (!targetId) {
                  errorID(1510);
                  return;
                }
                var element = this._hashForTimers[targetId];
                if (element != null && element.timers) {
                  var timers = element.timers;
                  if (element.currentTimer && timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged) {
                    element.currentTimerSalvaged = true;
                  }
                  for (var i = 0, l = timers.length; i < l; i++) {
                    CallbackTimer.put(timers[i]);
                  }
                  timers.length = 0;
                  if (this._currentTarget === element) {
                    this._currentTargetSalvaged = true;
                  } else {
                    this._removeHashElement(element);
                  }
                }
                this.unscheduleUpdate(target);
              };
              _proto2.unscheduleAll = function unscheduleAll() {
                this.unscheduleAllWithMinPriority(2147483648);
              };
              _proto2.unscheduleAllWithMinPriority = function unscheduleAllWithMinPriority(minPriority) {
                var i;
                var element;
                var arr = this._arrayForTimers;
                for (i = arr.length - 1; i >= 0; i--) {
                  element = arr[i];
                  if (element.target) {
                    this.unscheduleAllForTarget(element.target);
                  }
                }
                var entry;
                var temp_length = 0;
                if (minPriority < 0) {
                  for (i = 0; i < this._updatesNegList.length;) {
                    var _entry;
                    temp_length = this._updatesNegList.length;
                    entry = this._updatesNegList[i];
                    if ((_entry = entry) != null && _entry.target && entry.priority >= minPriority) {
                      this.unscheduleUpdate(entry.target);
                    }
                    if (temp_length === this._updatesNegList.length) {
                      i++;
                    }
                  }
                }
                if (minPriority <= 0) {
                  for (i = 0; i < this._updates0List.length;) {
                    var _entry2;
                    temp_length = this._updates0List.length;
                    entry = this._updates0List[i];
                    if ((_entry2 = entry) != null && _entry2.target) {
                      this.unscheduleUpdate(entry.target);
                    }
                    if (temp_length === this._updates0List.length) {
                      i++;
                    }
                  }
                }
                for (i = 0; i < this._updatesPosList.length;) {
                  var _entry3;
                  temp_length = this._updatesPosList.length;
                  entry = this._updatesPosList[i];
                  if ((_entry3 = entry) != null && _entry3.target && entry.priority >= minPriority) {
                    this.unscheduleUpdate(entry.target);
                  }
                  if (temp_length === this._updatesPosList.length) {
                    i++;
                  }
                }
              };
              _proto2.isScheduled = function isScheduled(callback, target) {
                assertID(Boolean(callback), 1508);
                assertID(Boolean(target), 1509);
                var targetId = target.uuid || target.id;
                if (!targetId) {
                  errorID(1510);
                  return false;
                }
                var element = this._hashForTimers[targetId];
                if (!element) {
                  return false;
                }
                if (element.timers == null) {
                  return false;
                } else {
                  var timers = element.timers;
                  for (var i = 0; i < timers.length; ++i) {
                    var timer = timers[i];
                    if (callback === timer.getCallback()) {
                      return true;
                    }
                  }
                  return false;
                }
              };
              _proto2.pauseAllTargets = function pauseAllTargets() {
                return this.pauseAllTargetsWithMinPriority(2147483648);
              };
              _proto2.pauseAllTargetsWithMinPriority = function pauseAllTargetsWithMinPriority(minPriority) {
                var idsWithSelectors = [];
                var element;
                var locArrayForTimers = this._arrayForTimers;
                var i;
                var li;
                for (i = 0, li = locArrayForTimers.length; i < li; i++) {
                  var _element;
                  element = locArrayForTimers[i];
                  if ((_element = element) != null && _element.target) {
                    element.paused = true;
                    idsWithSelectors.push(element.target);
                  }
                }
                var entry;
                if (minPriority < 0) {
                  for (i = 0; i < this._updatesNegList.length; i++) {
                    var _entry4;
                    entry = this._updatesNegList[i];
                    if ((_entry4 = entry) != null && _entry4.target) {
                      if (entry.priority >= minPriority) {
                        entry.paused = true;
                        idsWithSelectors.push(entry.target);
                      }
                    }
                  }
                }
                if (minPriority <= 0) {
                  for (i = 0; i < this._updates0List.length; i++) {
                    var _entry5;
                    entry = this._updates0List[i];
                    if ((_entry5 = entry) != null && _entry5.target) {
                      entry.paused = true;
                      idsWithSelectors.push(entry.target);
                    }
                  }
                }
                for (i = 0; i < this._updatesPosList.length; i++) {
                  var _entry6;
                  entry = this._updatesPosList[i];
                  if ((_entry6 = entry) != null && _entry6.target) {
                    if (entry.priority >= minPriority) {
                      entry.paused = true;
                      idsWithSelectors.push(entry.target);
                    }
                  }
                }
                return idsWithSelectors;
              };
              _proto2.resumeTargets = function resumeTargets(targetsToResume) {
                if (!targetsToResume) {
                  return;
                }
                for (var i = 0; i < targetsToResume.length; i++) {
                  this.resumeTarget(targetsToResume[i]);
                }
              };
              _proto2.pauseTarget = function pauseTarget(target) {
                assertID(Boolean(target), 1503);
                var targetId = target.uuid || target.id;
                if (!targetId) {
                  errorID(1510);
                  return;
                }
                var element = this._hashForTimers[targetId];
                if (element) {
                  element.paused = true;
                }
                var elementUpdate = this._hashForUpdates[targetId];
                if (elementUpdate != null && elementUpdate.entry) {
                  elementUpdate.entry.paused = true;
                }
              };
              _proto2.resumeTarget = function resumeTarget(target) {
                assertID(Boolean(target), 1504);
                var targetId = target.uuid || target.id;
                if (!targetId) {
                  errorID(1510);
                  return;
                }
                var element = this._hashForTimers[targetId];
                if (element) {
                  element.paused = false;
                }
                var elementUpdate = this._hashForUpdates[targetId];
                if (elementUpdate != null && elementUpdate.entry) {
                  elementUpdate.entry.paused = false;
                }
              };
              _proto2.isTargetPaused = function isTargetPaused(target) {
                assertID(Boolean(target), 1505);
                var targetId = target.uuid || target.id;
                if (!targetId) {
                  errorID(1510);
                  return false;
                }
                var element = this._hashForTimers[targetId];
                if (element) {
                  return element.paused;
                }
                var elementUpdate = this._hashForUpdates[targetId];
                if (elementUpdate != null && elementUpdate.entry) {
                  return elementUpdate.entry.paused;
                }
                return false;
              };
              _proto2._removeHashElement = function _removeHashElement(element) {
                if (!element.target) {
                  return;
                }
                var targetId = element.target.uuid || element.target.id;
                if (typeof targetId === 'undefined') {
                  return;
                }
                delete this._hashForTimers[targetId];
                var arr = this._arrayForTimers;
                for (var i = 0, l = arr.length; i < l; i++) {
                  if (arr[i] === element) {
                    arr.splice(i, 1);
                    break;
                  }
                }
                HashTimerEntry.put(element);
              };
              _proto2._removeUpdateFromHash = function _removeUpdateFromHash(entry) {
                if (!entry.target) {
                  return;
                }
                var targetId = entry.target.uuid || entry.target.id;
                if (typeof targetId === 'undefined') {
                  return;
                }
                var element = this._hashForUpdates[targetId];
                if (element) {
                  var list = element.list;
                  var listEntry = element.entry;
                  if (list) {
                    for (var i = 0, l = list.length; i < l; i++) {
                      if (list[i] === listEntry) {
                        list.splice(i, 1);
                        break;
                      }
                    }
                  }
                  delete this._hashForUpdates[targetId];
                  if (listEntry) {
                    ListEntry.put(listEntry);
                  }
                  HashUpdateEntry.put(element);
                }
              };
              _proto2._priorityIn = function _priorityIn(ppList, listElement, priority) {
                for (var i = 0; i < ppList.length; i++) {
                  if (priority < ppList[i].priority) {
                    ppList.splice(i, 0, listElement);
                    return;
                  }
                }
                ppList.push(listElement);
              };
              _proto2._appendIn = function _appendIn(ppList, listElement) {
                ppList.push(listElement);
              };
              return Scheduler;
            }(System));
            Scheduler.ID = 'scheduler';
            legacyCC.Scheduler = Scheduler;

            var vmath = {};
            replaceProperty(vmath, 'vmath', [{
              name: 'vec2',
              newName: 'Vec2',
              target: math,
              targetName: 'math'
            }, {
              name: 'vec3',
              newName: 'Vec3',
              target: math,
              targetName: 'math'
            }, {
              name: 'vec4',
              newName: 'Vec4',
              target: math,
              targetName: 'math'
            }, {
              name: 'quat',
              newName: 'Quat',
              target: math,
              targetName: 'math'
            }, {
              name: 'mat3',
              newName: 'Mat3',
              target: math,
              targetName: 'math'
            }, {
              name: 'mat4',
              newName: 'Mat4',
              target: math,
              targetName: 'math'
            }, {
              name: 'color4',
              newName: 'Color',
              target: math,
              targetName: 'math'
            }, {
              name: 'rect',
              newName: 'Rect',
              target: math,
              targetName: 'math'
            }, {
              name: 'approx',
              newName: 'approx',
              target: math,
              targetName: 'math'
            }, {
              name: 'EPSILON',
              newName: 'EPSILON',
              target: math,
              targetName: 'math'
            }, {
              name: 'equals',
              newName: 'equals',
              target: math,
              targetName: 'math'
            }, {
              name: 'clamp',
              newName: 'clamp',
              target: math,
              targetName: 'math'
            }, {
              name: 'clamp01',
              newName: 'clamp01',
              target: math,
              targetName: 'math'
            }, {
              name: 'lerp',
              newName: 'lerp',
              target: math,
              targetName: 'math'
            }, {
              name: 'toRadian',
              newName: 'toRadian',
              target: math,
              targetName: 'math'
            }, {
              name: 'toDegree',
              newName: 'toDegree',
              target: math,
              targetName: 'math'
            }, {
              name: 'random',
              newName: 'random',
              target: math,
              targetName: 'math'
            }, {
              name: 'randomRange',
              newName: 'randomRange',
              target: math,
              targetName: 'math'
            }, {
              name: 'randomRangeInt',
              newName: 'randomRangeInt',
              target: math,
              targetName: 'math'
            }, {
              name: 'pseudoRandom',
              newName: 'pseudoRandom',
              target: math,
              targetName: 'math'
            }, {
              name: 'pseudoRandomRangeInt',
              newName: 'pseudoRandomRangeInt',
              target: math,
              targetName: 'math'
            }, {
              name: 'nextPow2',
              newName: 'nextPow2',
              target: math,
              targetName: 'math'
            }, {
              name: 'repeat',
              newName: 'repeat',
              target: math,
              targetName: 'math'
            }, {
              name: 'pingPong',
              newName: 'pingPong',
              target: math,
              targetName: 'math'
            }, {
              name: 'inverseLerp',
              newName: 'inverseLerp',
              target: math,
              targetName: 'math'
            }]);
            legacyCC.vmath = vmath;
            replaceProperty(Scheduler.prototype, 'Scheduler.prototype', [{
              name: 'enableForTarget',
              newName: 'enableForTarget',
              target: Scheduler,
              targetName: 'Scheduler'
            }]);
            replaceProperty(Scheduler, 'Scheduler', [{
              name: 'PRIORITY_SYSTEM',
              newName: 'System.Priority.SCHEDULER',
              customGetter: function customGetter() {
                return 2147483648;
              }
            }]);
            removeProperty(Scheduler, 'Scheduler', [{
              name: 'PRIORITY_NON_SYSTEM',
              suggest: 'Use enum` System.Priority` instead'
            }]);

            markAsWarning(js$1, 'js', [{
              name: 'js',
              suggest: "'js.js' is deprecated since v3.7.0, please access 'js' directly instead."
            }]);

            legacyCC.easing = easing;

            function shift(array, first, last) {
              assertsArrayIndex(array, first);
              assertsArrayIndex(array, last);
              if (first === last) {
                return array;
              }
              var element = array[first];
              if (first < last) {
                for (var iElement = first + 1; iElement <= last; ++iElement) {
                  array[iElement - 1] = array[iElement];
                }
              } else {
                for (var _iElement = first; _iElement !== last; --_iElement) {
                  array[_iElement] = array[_iElement - 1];
                }
              }
              array[last] = element;
              return array;
            }

            function deepFlatten(strList, array) {
              for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done;) {
                var item = _step.value;
                if (Array.isArray(item)) {
                  deepFlatten(strList, item);
                } else {
                  strList.push(item);
                }
              }
            }
            function flattenCodeArray(array) {
              var separator = '';
              var strList = [];
              deepFlatten(strList, array);
              return strList.join(separator);
            }

            function applyMixins(derivedCtor, baseCtors) {
              baseCtors.forEach(function (baseCtor) {
                Object.getOwnPropertyNames(baseCtor.prototype).forEach(function (name) {
                  if (name !== 'constructor') {
                    Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));
                  }
                });
              });
            }

            legacyCC.math = math;
            legacyCC.geometry = geometry;

            var polyfills = {
              GFXDevice: true,
              GFXBuffer: true,
              GFXTexture: true,
              GFXSampler: true,
              GFXShader: true,
              GFXInputAssembler: true,
              GFXRenderPass: true,
              GFXFramebuffer: true,
              GFXPipelineState: true,
              GFXCommandBuffer: true,
              GFXQueue: true,
              GFXObjectType: true,
              GFXObject: false,
              GFXAttributeName: true,
              GFXType: true,
              GFXFormat: true,
              GFXBufferUsageBit: true,
              GFXMemoryUsageBit: true,
              GFXBufferFlagBit: true,
              GFXBufferAccessBit: 'MemoryAccessBit',
              GFXPrimitiveMode: true,
              GFXPolygonMode: true,
              GFXShadeModel: true,
              GFXCullMode: true,
              GFXComparisonFunc: true,
              GFXStencilOp: true,
              GFXBlendOp: true,
              GFXBlendFactor: true,
              GFXColorMask: true,
              GFXFilter: true,
              GFXAddress: true,
              GFXTextureType: true,
              GFXTextureUsageBit: true,
              GFXSampleCount: true,
              GFXTextureFlagBit: true,
              GFXShaderStageFlagBit: true,
              GFXDescriptorType: true,
              GFXCommandBufferType: true,
              GFXLoadOp: true,
              GFXStoreOp: true,
              GFXPipelineBindPoint: true,
              GFXDynamicStateFlagBit: true,
              GFXStencilFace: true,
              GFXQueueType: true,
              GFXRect: true,
              GFXViewport: true,
              GFXColor: true,
              GFXClearFlag: true,
              GFXOffset: true,
              GFXExtent: true,
              GFXTextureSubres: 'TextureSubresLayers',
              GFXTextureCopy: true,
              GFXBufferTextureCopy: true,
              GFXFormatType: true,
              GFXFormatInfo: true,
              GFXMemoryStatus: true,
              GFXFormatInfos: true,
              GFXFormatSize: true,
              GFXFormatSurfaceSize: true,
              GFXGetTypeSize: true,
              getTypedArrayConstructor: false
            };
            for (var name in polyfills) {
              var newName = polyfills[name];
              if (newName === true) {
                newName = name.slice(3);
              } else if (newName === false) {
                newName = name;
              }
              replaceProperty(cclegacy, 'cc', [{
                name: name,
                newName: newName,
                target: cclegacy.gfx,
                targetName: 'cc.gfx'
              }]);
            }
            removeProperty(cclegacy, 'cc', [{
              name: 'GFX_MAX_VERTEX_ATTRIBUTES'
            }, {
              name: 'GFX_MAX_TEXTURE_UNITS'
            }, {
              name: 'GFX_MAX_ATTACHMENTS'
            }, {
              name: 'GFX_MAX_BUFFER_BINDINGS'
            }, {
              name: 'GFXTextureLayout'
            }]);

            removeProperty(Feature$1, 'Feature', [{
              name: 'COLOR_FLOAT',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R32F) & FormatFeatureBit.RENDER_TARGET;'
            }, {
              name: 'COLOR_HALF_FLOAT',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R16F) & FormatFeatureBit.RENDER_TARGET;'
            }, {
              name: 'TEXTURE_FLOAT',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = (device.getFormatFeatures(Format.R32F) & (FormatFeatureBit.RENDER_TARGET' + ' | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);'
            }, {
              name: 'TEXTURE_HALF_FLOAT',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = (device.getFormatFeatures(Format.R16F) & (FormatFeatureBit.RENDER_TARGET' + ' | FormatFeatureBit.SAMPLED_TEXTURE)) === (FormatFeatureBit.RENDER_TARGET | FormatFeatureBit.SAMPLED_TEXTURE);'
            }, {
              name: 'TEXTURE_FLOAT_LINEAR',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R32F) & FormatFeatureBit.LINEAR_FILTER;'
            }, {
              name: 'TEXTURE_HALF_FLOAT_LINEAR',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R16F) & FormatFeatureBit.LINEAR_FILTER;'
            }, {
              name: 'FORMAT_R11G11B10F',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.R11G11B10F) !== FormatFeatureBit.NONE;'
            }, {
              name: 'FORMAT_SRGB',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.SRGB8) !== FormatFeatureBit.NONE;'
            }, {
              name: 'FORMAT_ETC1',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.ETC_RGB8) !== FormatFeatureBit.NONE;'
            }, {
              name: 'FORMAT_ETC2',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.ETC2_RGB8) !== FormatFeatureBit.NONE;'
            }, {
              name: 'FORMAT_DXT',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.BC1) !== FormatFeatureBit.NONE;'
            }, {
              name: 'FORMAT_PVRTC',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.PVRTC_RGB2) !== FormatFeatureBit.NONE;'
            }, {
              name: 'FORMAT_ASTC',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.ASTC_RGBA_4x4) !== FormatFeatureBit.NONE;'
            }, {
              name: 'FORMAT_RGB8',
              suggest: 'Please use device.getFormatFeatures() instead, like: \n' + 'let isSupported = device.getFormatFeatures(Format.RGB8) !== FormatFeatureBit.NONE;'
            }]);
            removeProperty(ColorAttachment.prototype, 'ColorAttachment', [{
              name: 'beginAccesses',
              suggest: 'Please assign to ColorAttachment.barrier instead'
            }, {
              name: 'endAccesses',
              suggest: 'Please assign to ColorAttachment.barrier instead'
            }]);
            removeProperty(DepthStencilAttachment.prototype, 'DepthStencilAttachment', [{
              name: 'beginAccesses',
              suggest: 'Please assign to DepthStencilAttachment.barrier instead'
            }, {
              name: 'endAccesses',
              suggest: 'Please assign to DepthStencilAttachment.barrier instead'
            }]);
            replaceProperty(Device.prototype, 'Device', [{
              name: 'getGlobalBarrier',
              newName: 'getGeneralBarrier'
            }]);

            var LegacyRenderMode = {
              AUTO: 0,
              CANVAS: 1,
              WEBGL: 2,
              HEADLESS: 3,
              WEBGPU: 4
            };
            var RenderType = {
              UNKNOWN: -1,
              CANVAS: 0,
              WEBGL: 1,
              WEBGPU: 2,
              OPENGL: 3,
              HEADLESS: 4
            };
            var DeviceManager = function () {
              function DeviceManager() {
                this.initialized = false;
                this._gfxDevice = undefined;
                this._canvas = null;
                this._swapchain = undefined;
                this._renderType = -1;
                this._deviceInitialized = false;
              }
              var _proto = DeviceManager.prototype;
              _proto._tryInitializeWebGPUDevice = function _tryInitializeWebGPUDevice(DeviceConstructor, info) {
                var _this = this;
                if (this._deviceInitialized) {
                  return Promise.resolve(true);
                }
                if (DeviceConstructor) {
                  this._gfxDevice = new DeviceConstructor();
                  return new Promise(function (resolve, reject) {
                    _this._gfxDevice.initialize(info).then(function (val) {
                      _this._deviceInitialized = val;
                      resolve(val);
                    })["catch"](function (err) {
                      reject(err);
                    });
                  });
                }
                return Promise.resolve(false);
              };
              _proto._tryInitializeDeviceSync = function _tryInitializeDeviceSync(DeviceConstructor, info) {
                if (this._deviceInitialized) {
                  return true;
                }
                if (DeviceConstructor) {
                  this._gfxDevice = new DeviceConstructor();
                  this._deviceInitialized = this._gfxDevice.initialize(info);
                }
                return this._deviceInitialized;
              };
              _proto.init = function init(canvas, bindingMappingInfo) {
                var _this2 = this;
                if (this.initialized) {
                  return true;
                }
                var renderMode = settings.querySettings(Settings.Category.RENDERING, 'renderMode');
                this._canvas = canvas;
                if (this._canvas) {
                  this._canvas.oncontextmenu = function () {
                    return false;
                  };
                }
                this._renderType = this._determineRenderType(renderMode);
                this._deviceInitialized = false;
                var deviceInfo = new DeviceInfo(bindingMappingInfo);
                if (this._renderType === 1 || this._renderType === 2) {
                  {
                    var useWebGL2 = !!globalThis.WebGL2RenderingContext;
                    globalThis.navigator.userAgent.toLowerCase();
                    if (sys.browserType === BrowserType.UC) {
                      useWebGL2 = false;
                    }
                    Device.canvas = canvas;
                    if (this._renderType === 2 && cclegacy.WebGPUDevice) {
                      return new Promise(function (resolve, reject) {
                        _this2._tryInitializeWebGPUDevice(cclegacy.WebGPUDevice, deviceInfo).then(function (val) {
                          _this2._initSwapchain();
                          resolve(val);
                        })["catch"](function (err) {
                          reject(err);
                        });
                      });
                    }
                    if (useWebGL2 && cclegacy.WebGL2Device) {
                      this._tryInitializeDeviceSync(cclegacy.WebGL2Device, deviceInfo);
                    }
                    if (cclegacy.WebGLDevice) {
                      this._tryInitializeDeviceSync(cclegacy.WebGLDevice, deviceInfo);
                    }
                    if (cclegacy.EmptyDevice) {
                      this._tryInitializeDeviceSync(cclegacy.EmptyDevice, deviceInfo);
                    }
                    this._initSwapchain();
                  }
                } else if (this._renderType === 4 && cclegacy.EmptyDevice) {
                  this._tryInitializeDeviceSync(cclegacy.EmptyDevice, deviceInfo);
                  this._initSwapchain();
                }
                if (!this._gfxDevice) {
                  errorID(16337);
                  this._renderType = -1;
                  return false;
                }
                return true;
              };
              _proto._initSwapchain = function _initSwapchain() {
                var swapchainInfo = new SwapchainInfo(1, this._canvas);
                var windowSize = screen$1.windowSize;
                swapchainInfo.width = windowSize.width;
                swapchainInfo.height = windowSize.height;
                this._swapchain = this._gfxDevice.createSwapchain(swapchainInfo);
              };
              _proto._supportWebGPU = function _supportWebGPU() {
                return 'gpu' in globalThis.navigator;
              };
              _proto._determineRenderType = function _determineRenderType(renderMode) {
                if (typeof renderMode !== 'number' || renderMode > 4 || renderMode < 0) {
                  renderMode = 0;
                }
                var renderType = 0;
                var supportRender = false;
                if (renderMode === 1) {
                  renderType = 0;
                  supportRender = true;
                } else if (renderMode === 0 || renderMode === 4) {
                  renderType = this._supportWebGPU() && true ? 2 : 1;
                  supportRender = true;
                } else if (renderMode === 2) {
                  renderType = 1;
                  supportRender = true;
                } else if (renderMode === 3) {
                  renderType = 4;
                  supportRender = true;
                }
                if (!supportRender) {
                  throw new Error(getError(3820, renderMode));
                }
                return renderType;
              };
              _createClass(DeviceManager, [{
                key: "gfxDevice",
                get: function get() {
                  return this._gfxDevice;
                }
              }, {
                key: "swapchain",
                get: function get() {
                  return this._swapchain;
                }
              }]);
              return DeviceManager;
            }();
            var deviceManager = new DeviceManager();

            var index$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                API: API,
                AccessFlagBit: AccessFlagBit,
                Address: Address,
                Attribute: Attribute,
                AttributeName: AttributeName,
                BarrierType: BarrierType,
                BindingMappingInfo: BindingMappingInfo,
                BlendFactor: BlendFactor,
                BlendOp: BlendOp,
                BlendState: BlendState,
                BlendTarget: BlendTarget,
                Buffer: Buffer,
                BufferBarrierInfo: BufferBarrierInfo,
                BufferFlagBit: BufferFlagBit,
                BufferInfo: BufferInfo,
                BufferTextureCopy: BufferTextureCopy,
                BufferUsageBit: BufferUsageBit,
                BufferViewInfo: BufferViewInfo,
                ClearFlagBit: ClearFlagBit,
                Color: Color$1,
                ColorAttachment: ColorAttachment,
                ColorMask: ColorMask,
                CommandBuffer: CommandBuffer,
                CommandBufferInfo: CommandBufferInfo,
                CommandBufferType: CommandBufferType,
                ComparisonFunc: ComparisonFunc,
                CullMode: CullMode,
                DESCRIPTOR_BUFFER_TYPE: DESCRIPTOR_BUFFER_TYPE,
                DESCRIPTOR_DYNAMIC_TYPE: DESCRIPTOR_DYNAMIC_TYPE,
                DESCRIPTOR_SAMPLER_TYPE: DESCRIPTOR_SAMPLER_TYPE,
                DESCRIPTOR_STORAGE_BUFFER_TYPE: DESCRIPTOR_STORAGE_BUFFER_TYPE,
                DRAW_INFO_SIZE: DRAW_INFO_SIZE,
                DefaultResource: DefaultResource,
                DepthStencilAttachment: DepthStencilAttachment,
                DepthStencilState: DepthStencilState,
                DescriptorSet: DescriptorSet,
                DescriptorSetInfo: DescriptorSetInfo,
                DescriptorSetLayout: DescriptorSetLayout,
                DescriptorSetLayoutBinding: DescriptorSetLayoutBinding,
                DescriptorSetLayoutInfo: DescriptorSetLayoutInfo,
                DescriptorType: DescriptorType,
                Device: Device,
                DeviceCaps: DeviceCaps,
                DeviceInfo: DeviceInfo,
                DeviceManager: DeviceManager,
                DeviceOptions: DeviceOptions,
                DispatchInfo: DispatchInfo,
                DrawInfo: DrawInfo,
                DynamicStateFlagBit: DynamicStateFlagBit,
                DynamicStates: DynamicStates,
                DynamicStencilStates: DynamicStencilStates,
                Extent: Extent,
                Feature: Feature$1,
                Filter: Filter,
                Format: Format,
                FormatFeatureBit: FormatFeatureBit,
                FormatInfo: FormatInfo,
                FormatInfos: FormatInfos,
                FormatSize: FormatSize,
                FormatSurfaceSize: FormatSurfaceSize,
                FormatType: FormatType,
                Framebuffer: Framebuffer,
                FramebufferInfo: FramebufferInfo,
                GFXObject: GFXObject,
                GeneralBarrier: GeneralBarrier,
                GeneralBarrierInfo: GeneralBarrierInfo,
                GetTypeSize: GetTypeSize,
                IndirectBuffer: IndirectBuffer,
                InputAssembler: InputAssembler,
                InputAssemblerInfo: InputAssemblerInfo,
                InputState: InputState,
                IsPowerOf2: IsPowerOf2,
                LegacyRenderMode: LegacyRenderMode,
                LoadOp: LoadOp,
                MarkerInfo: MarkerInfo,
                MemoryAccessBit: MemoryAccessBit,
                MemoryStatus: MemoryStatus,
                MemoryUsageBit: MemoryUsageBit,
                ObjectType: ObjectType,
                Offset: Offset,
                PassType: PassType,
                PipelineBindPoint: PipelineBindPoint,
                PipelineLayout: PipelineLayout,
                PipelineLayoutInfo: PipelineLayoutInfo,
                PipelineState: PipelineState,
                PipelineStateInfo: PipelineStateInfo,
                PolygonMode: PolygonMode,
                PrimitiveMode: PrimitiveMode,
                QueryPoolInfo: QueryPoolInfo,
                QueryType: QueryType,
                Queue: Queue,
                QueueInfo: QueueInfo,
                QueueType: QueueType,
                RasterizerState: RasterizerState,
                Rect: Rect$1,
                RenderPass: RenderPass,
                RenderPassInfo: RenderPassInfo,
                RenderType: RenderType,
                ResolveMode: ResolveMode,
                ResourceRange: ResourceRange,
                SampleCount: SampleCount,
                SampleType: SampleType,
                Sampler: Sampler,
                SamplerInfo: SamplerInfo,
                ShadeModel: ShadeModel,
                Shader: Shader,
                ShaderInfo: ShaderInfo,
                ShaderStage: ShaderStage,
                ShaderStageFlagBit: ShaderStageFlagBit,
                Size: Size$1,
                Status: Status,
                StencilFace: StencilFace,
                StencilOp: StencilOp,
                StoreOp: StoreOp,
                SubpassDependency: SubpassDependency,
                SubpassInfo: SubpassInfo,
                SurfaceTransform: SurfaceTransform,
                Swapchain: Swapchain,
                SwapchainInfo: SwapchainInfo,
                Texture: Texture,
                TextureBarrier: TextureBarrier,
                TextureBarrierInfo: TextureBarrierInfo,
                TextureBlit: TextureBlit,
                TextureCopy: TextureCopy,
                TextureFlagBit: TextureFlagBit,
                TextureInfo: TextureInfo,
                TextureSubresLayers: TextureSubresLayers,
                TextureSubresRange: TextureSubresRange,
                TextureType: TextureType,
                TextureUsageBit: TextureUsageBit,
                TextureViewInfo: TextureViewInfo,
                Type: Type,
                Uniform: Uniform,
                UniformBlock: UniformBlock,
                UniformInputAttachment: UniformInputAttachment,
                UniformSampler: UniformSampler,
                UniformSamplerTexture: UniformSamplerTexture,
                UniformStorageBuffer: UniformStorageBuffer,
                UniformStorageImage: UniformStorageImage,
                UniformTexture: UniformTexture,
                ViewDimension: ViewDimension,
                Viewport: Viewport,
                VsyncMode: VsyncMode,
                alignTo: alignTo,
                deviceManager: deviceManager,
                formatAlignment: formatAlignment,
                getTypedArrayConstructor: getTypedArrayConstructor
            });
            exports("gfx", index$1);

            var _typeMap2;
            var _typeMap = (_typeMap2 = {}, _typeMap2[1] = 'Uint', _typeMap2[2] = 'Int', _typeMap2[3] = 'Uint', _typeMap2[4] = 'Int', _typeMap2[5] = 'Float', _typeMap2[6] = 'Float', _typeMap2["default"] = 'Uint', _typeMap2);
            function _getDataViewType(info) {
              var type = _typeMap[info.type] || _typeMap["default"];
              var bytes = info.size / info.count * 8;
              return "" + type + bytes;
            }
            function writeBuffer(target, data, format, offset, stride) {
              if (format === undefined) {
                format = 11;
              }
              if (offset === undefined) {
                offset = 0;
              }
              if (stride === undefined) {
                stride = 0;
              }
              var info = FormatInfos[format];
              if (!stride) {
                stride = info.size;
              }
              var writer = "set" + _getDataViewType(info);
              var componentBytesLength = info.size / info.count;
              var nSeg = Math.floor(data.length / info.count);
              var isLittleEndian = sys.isLittleEndian;
              for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
                var x = offset + stride * iSeg;
                for (var iComponent = 0; iComponent < info.count; ++iComponent) {
                  var y = x + componentBytesLength * iComponent;
                  target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian);
                }
              }
            }
            function readBuffer(target, format, offset, length, stride, out) {
              if (format === undefined) {
                format = 11;
              }
              if (offset === undefined) {
                offset = 0;
              }
              if (length === undefined) {
                length = target.byteLength - offset;
              }
              if (stride === undefined) {
                stride = 0;
              }
              if (out === undefined) {
                out = [];
              }
              var info = FormatInfos[format];
              if (!stride) {
                stride = info.size;
              }
              var reader = "get" + _getDataViewType(info);
              var componentBytesLength = info.size / info.count;
              var nSeg = Math.floor(length / stride);
              var isLittleEndian = sys.isLittleEndian;
              for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
                var x = offset + stride * iSeg;
                for (var iComponent = 0; iComponent < info.count; ++iComponent) {
                  var y = x + componentBytesLength * iComponent;
                  out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian);
                }
              }
              return out;
            }
            function mapBuffer(target, callback, format, offset, length, stride, out) {
              if (format === undefined) {
                format = 11;
              }
              if (offset === undefined) {
                offset = 0;
              }
              if (length === undefined) {
                length = target.byteLength - offset;
              }
              if (stride === undefined) {
                stride = 0;
              }
              if (!out) {
                out = new DataView(target.buffer.slice(target.byteOffset, target.byteOffset + target.byteLength));
              }
              var info = FormatInfos[format];
              if (!stride) {
                stride = info.size;
              }
              var writer = "set" + _getDataViewType(info);
              var reader = "get" + _getDataViewType(info);
              var componentBytesLength = info.size / info.count;
              var nSeg = Math.floor(length / stride);
              var isLittleEndian = sys.isLittleEndian;
              for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
                var x = offset + stride * iSeg;
                for (var iComponent = 0; iComponent < info.count; ++iComponent) {
                  var y = x + componentBytesLength * iComponent;
                  var _cur = target[reader](y, isLittleEndian);
                  out[writer](y, callback(_cur, iComponent, target), isLittleEndian);
                }
              }
              return out;
            }

            var _keyMap = {
              positions: "a_position",
              normals: "a_normal",
              uvs: "a_texCoord",
              colors: "a_color"
            };
            function readMesh(mesh, iPrimitive) {
              if (iPrimitive === undefined) {
                iPrimitive = 0;
              }
              var out = {
                positions: []
              };
              var dataView = new DataView(mesh.data.buffer, mesh.data.byteOffset, mesh.data.byteLength);
              var struct = mesh.struct;
              var primitive = struct.primitives[iPrimitive];
              primitive.vertexBundelIndices.forEach(function (idx) {
                var bundle = struct.vertexBundles[idx];
                var offset = bundle.view.offset;
                var _bundle$view = bundle.view,
                  length = _bundle$view.length,
                  stride = _bundle$view.stride;
                bundle.attributes.forEach(function (attr) {
                  var name = _keyMap[attr.name];
                  if (name) {
                    out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride));
                  }
                  offset += FormatInfos[attr.format].size;
                });
              });
              var view = primitive.indexView;
              out.indices = readBuffer(dataView, Format["R" + view.stride * 8 + "UI"], view.offset, view.length);
              return out;
            }

            var Cache = function () {
              function Cache(map) {
                this._map = null;
                this._count = 0;
                if (map) {
                  this._map = map;
                  this._count = Object.keys(map).length;
                } else {
                  this._map = createMap(true);
                  this._count = 0;
                }
              }
              var _proto = Cache.prototype;
              _proto.add = function add(key, val) {
                if (!(key in this._map)) {
                  this._count++;
                }
                return this._map[key] = val;
              };
              _proto.get = function get(key) {
                return this._map[key];
              };
              _proto.has = function has(key) {
                return key in this._map;
              };
              _proto.remove = function remove(key) {
                var out = this._map[key];
                if (key in this._map) {
                  delete this._map[key];
                  this._count--;
                }
                return out;
              };
              _proto.clear = function clear() {
                if (this._count !== 0) {
                  this._map = createMap(true);
                  this._count = 0;
                }
              };
              _proto.forEach = function forEach(func) {
                for (var _key in this._map) {
                  func(this._map[_key], _key);
                }
              };
              _proto.find = function find(predicate) {
                for (var _key2 in this._map) {
                  if (predicate(this._map[_key2], _key2)) {
                    return this._map[_key2];
                  }
                }
                return null;
              };
              _proto.destroy = function destroy() {
                this._map = null;
              };
              _createClass(Cache, [{
                key: "map",
                get: function get() {
                  return this._map;
                }
              }, {
                key: "count",
                get: function get() {
                  return this._count;
                }
              }]);
              return Cache;
            }();

            var Pipeline = function () {
              function Pipeline(name, funcs) {
                this.id = Pipeline._pipelineId++;
                this.name = '';
                this.pipes = [];
                this.name = name;
                for (var i = 0, l = funcs.length; i < l; i++) {
                  this.pipes.push(funcs[i]);
                }
              }
              var _proto = Pipeline.prototype;
              _proto.insert = function insert(func, index) {
                if (index > this.pipes.length) {
                  warnID(4921);
                  return this;
                }
                this.pipes.splice(index, 0, func);
                return this;
              };
              _proto.append = function append(func) {
                this.pipes.push(func);
                return this;
              };
              _proto.remove = function remove(index) {
                this.pipes.splice(index, 1);
                return this;
              };
              _proto.sync = function sync(task) {
                var pipes = this.pipes;
                if (pipes.length === 0) {
                  return null;
                }
                task.isFinished = false;
                for (var i = 0, l = pipes.length; i < l;) {
                  var pipe = pipes[i];
                  var result = pipe(task);
                  if (result) {
                    task.isFinished = true;
                    return result;
                  }
                  i++;
                  if (i !== l) {
                    task.input = task.output;
                    task.output = null;
                  }
                }
                task.isFinished = true;
                return task.output;
              };
              _proto.async = function async(task) {
                var pipes = this.pipes;
                if (pipes.length === 0) {
                  return;
                }
                task.isFinished = false;
                this._flow(0, task);
              };
              _proto._flow = function _flow(index, task) {
                var _this = this;
                var pipe = this.pipes[index];
                pipe(task, function (result) {
                  if (result) {
                    task.isFinished = true;
                    task.dispatch('complete', result);
                  } else {
                    index++;
                    if (index < _this.pipes.length) {
                      task.input = task.output;
                      task.output = null;
                      _this._flow(index, task);
                    } else {
                      task.isFinished = true;
                      task.dispatch('complete', result, task.output);
                    }
                  }
                });
              };
              return Pipeline;
            }();
            Pipeline._pipelineId = 0;

            var assets = new Cache();
            var files = new Cache();
            var parsed = new Cache();
            var bundles = new Cache();
            var pipeline = new Pipeline('normal load', []);
            var fetchPipeline = new Pipeline('fetch', []);
            var transformPipeline = new Pipeline('transform url', []);
            var references = null;
            var assetsOverrideMap = new Map();
            var presets = {
              "default": {
                priority: 0
              },
              preload: {
                maxConcurrency: 6,
                maxRequestsPerFrame: 2,
                priority: -1
              },
              scene: {
                maxConcurrency: 20,
                maxRequestsPerFrame: 20,
                priority: 1
              },
              bundle: {
                maxConcurrency: 20,
                maxRequestsPerFrame: 20,
                priority: 2
              },
              remote: {
                maxRetryCount: 4
              }
            };
            var BuiltinBundleName = {
              INTERNAL: "internal",
              RESOURCES: "resources",
              MAIN: "main",
              START_SCENE: "start-scene"
            };

            var Task = function () {
              Task.create = function create(options) {
                var out;
                if (Task._deadPool.length !== 0) {
                  out = Task._deadPool.pop();
                  out.set(options);
                } else {
                  out = new Task(options);
                }
                return out;
              };
              function Task(options) {
                this.id = Task._taskId++;
                this.onComplete = null;
                this.onProgress = null;
                this.onError = null;
                this.source = null;
                this.output = null;
                this.input = null;
                this.progress = null;
                this.options = null;
                this.isFinished = true;
                this.set(options);
              }
              var _proto = Task.prototype;
              _proto.set = function set(options) {
                if (options === undefined) {
                  options = Object.create(null);
                }
                this.onComplete = options.onComplete || null;
                this.onProgress = options.onProgress || null;
                this.onError = options.onError || null;
                this.source = this.input = options.input;
                this.output = null;
                this.progress = options.progress;
                this.options = options.options || Object.create(null);
              };
              _proto.dispatch = function dispatch(event, param1, param2, param3, param4) {
                switch (event) {
                  case 'complete':
                    if (this.onComplete) {
                      this.onComplete(param1, param2);
                    }
                    break;
                  case 'progress':
                    if (this.onProgress) {
                      this.onProgress(param1, param2, param3, param4);
                    }
                    break;
                  case 'error':
                    if (this.onError) {
                      this.onError(param1, param2, param3, param4);
                    }
                    break;
                  default:
                    {
                      var str = "on" + event[0].toUpperCase() + event.substring(1);
                      if (typeof this[str] === 'function') {
                        this[str](param1, param2, param3, param4);
                      }
                      break;
                    }
                }
              };
              _proto.recycle = function recycle() {
                if (Task._deadPool.length === Task.MAX_DEAD_NUM) {
                  return;
                }
                this.onComplete = null;
                this.onProgress = null;
                this.onError = null;
                this.source = this.output = this.input = null;
                this.progress = null;
                this.options = null;
                Task._deadPool.push(this);
              };
              _createClass(Task, [{
                key: "isFinish",
                get: function get() {
                  return this.isFinished;
                },
                set: function set(val) {
                  this.isFinished = val;
                }
              }]);
              return Task;
            }();
            Task.MAX_DEAD_NUM = 500;
            Task._taskId = 0;
            Task._deadPool = [];

            var separator = '@';
            var HexChars = '0123456789abcdef'.split('');
            var _t = ['', '', '', ''];
            var UuidTemplate = _t.concat(_t, '-', _t, '-', _t, '-', _t, '-', _t, _t, _t);
            var Indices = UuidTemplate.map(function (x, i) {
              return x === '-' ? NaN : i;
            }).filter(Number.isFinite);
            function decodeUuid(base64) {
              var strs = base64.split(separator);
              var uuid = strs[0];
              if (uuid.length !== 22) {
                return base64;
              }
              UuidTemplate[0] = base64[0];
              UuidTemplate[1] = base64[1];
              for (var i = 2, j = 2; i < 22; i += 2) {
                var lhs = BASE64_VALUES[base64.charCodeAt(i)];
                var rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
                UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
                UuidTemplate[Indices[j++]] = HexChars[(lhs & 3) << 2 | rhs >> 4];
                UuidTemplate[Indices[j++]] = HexChars[rhs & 0xF];
              }
              return base64.replace(uuid, UuidTemplate.join(''));
            }

            var _uuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;
            function getUuidFromURL(url) {
              var matches = _uuidRegex.exec(url);
              if (matches) {
                return matches[1];
              }
              return '';
            }
            function getUrlWithUuid(uuid, options) {
              options = options || Object.create(null);
              options.__isNative__ = options.isNative;
              if (options.nativeExt) {
                options.ext = options.nativeExt;
              }
              var bundle = bundles.find(function (b) {
                return !!b.getAssetInfo(uuid);
              });
              if (bundle) {
                options.bundle = bundle.name;
              }
              return transform(uuid, options);
            }
            function isScene(asset) {
              return !!asset && (asset instanceof cclegacy.SceneAsset || asset instanceof cclegacy.Scene);
            }
            function normalize(url) {
              if (url) {
                if (url.charCodeAt(0) === 46 && url.charCodeAt(1) === 47) {
                  url = url.slice(2);
                } else if (url.charCodeAt(0) === 47) {
                  url = url.slice(1);
                }
              }
              return url;
            }
            function transform(input, options) {
              var subTask = Task.create({
                input: input,
                options: options
              });
              var urls = [];
              try {
                var result = transformPipeline.sync(subTask);
                for (var _iterator = _createForOfIteratorHelperLoose(result), _step; !(_step = _iterator()).done;) {
                  var requestItem = _step.value;
                  var url = requestItem.url;
                  requestItem.recycle();
                  urls.push(url);
                }
              } catch (e) {
                for (var _iterator2 = _createForOfIteratorHelperLoose(subTask.output), _step2; !(_step2 = _iterator2()).done;) {
                  var item = _step2.value;
                  item.recycle();
                }
                error(e.message, e.stack);
              }
              subTask.recycle();
              return urls.length > 1 ? urls : urls[0];
            }

            var helper = /*#__PURE__*/Object.freeze({
                __proto__: null,
                decodeUuid: decodeUuid,
                getUrlWithUuid: getUrlWithUuid,
                getUuidFromURL: getUuidFromURL,
                isScene: isScene,
                normalize: normalize,
                transform: transform
            });

            var _dec$N, _class$O, _class2$I, _initializer$D;
            var ccclass$5 = ccclass$6,
              serializable$4 = serializable$5,
              property$2 = property$3;
            var Asset = exports("Asset", (_dec$N = ccclass$5('cc.Asset'), _dec$N(_class$O = (_class2$I = function (_Eventify) {
              _inheritsLoose(Asset, _Eventify);
              Asset.deserialize = function deserialize(data) {
                return cclegacy.deserialize(data);
              };
              function Asset(name) {
                var _this;
                _this = _Eventify.call(this, name) || this;
                _this.loaded = true;
                _this._native = _initializer$D && _initializer$D();
                _this._nativeUrl = '';
                _this._file = null;
                _this._ref = 0;
                Object.defineProperty(_assertThisInitialized(_this), '_uuid', {
                  value: '',
                  writable: true
                });
                return _this;
              }
              var _proto = Asset.prototype;
              _proto.toString = function toString() {
                return this.nativeUrl;
              };
              _proto.serialize = function serialize() {};
              _proto._setRawAsset = function _setRawAsset(filename, inLibrary) {
                if (inLibrary === undefined) {
                  inLibrary = true;
                }
                if (inLibrary !== false) {
                  this._native = filename || '';
                } else {
                  this._native = "/" + filename;
                }
              };
              _proto.addRef = function addRef() {
                this._ref++;
                return this;
              };
              _proto.decRef = function decRef(autoRelease) {
                if (autoRelease === undefined) {
                  autoRelease = true;
                }
                if (this._ref > 0) {
                  this._ref--;
                }
                if (autoRelease) {
                  cclegacy.assetManager.getReleaseManager().tryRelease(this);
                }
                return this;
              };
              _proto.onLoaded = function onLoaded() {};
              _proto.initDefault = function initDefault(uuid) {
                if (uuid) {
                  this._uuid = uuid;
                }
                this.isDefault = true;
              };
              _proto.validate = function validate() {
                return true;
              };
              _proto.destroy = function destroy() {
                debug(getError(12101, this._uuid));
                return _Eventify.prototype.destroy.call(this);
              };
              _createClass(Asset, [{
                key: "nativeUrl",
                get: function get() {
                  if (!this._nativeUrl) {
                    if (!this._native) return '';
                    var name = this._native;
                    if (name.charCodeAt(0) === 47) {
                      return name.slice(1);
                    }
                    if (name.charCodeAt(0) === 46) {
                      this._nativeUrl = getUrlWithUuid(this._uuid, {
                        nativeExt: name,
                        isNative: true
                      });
                    } else {
                      this._nativeUrl = getUrlWithUuid(this._uuid, {
                        __nativeName__: name,
                        nativeExt: extname(name),
                        isNative: true
                      });
                    }
                  }
                  return this._nativeUrl;
                }
              }, {
                key: "uuid",
                get: function get() {
                  return this._uuid;
                }
              }, {
                key: "_nativeAsset",
                get: function get() {
                  return this._file;
                },
                set: function set(obj) {
                  this._file = obj;
                }
              }, {
                key: "nativeAsset",
                get: function get() {
                  return this._file;
                }
              }, {
                key: "_nativeDep",
                get: function get() {
                  if (this._native) {
                    return {
                      __isNative__: true,
                      uuid: this._uuid,
                      ext: this._native
                    };
                  }
                  return undefined;
                }
              }, {
                key: "refCount",
                get: function get() {
                  return this._ref;
                }
              }]);
              return Asset;
            }(Eventify(CCObject)), (_initializer$D = applyDecoratedInitializer(_class2$I.prototype, "_native", [serializable$4], function () {
              return '';
            }), _applyDecoratedDescriptor(_class2$I.prototype, "_nativeAsset", [property$2], Object.getOwnPropertyDescriptor(_class2$I.prototype, "_nativeAsset"), _class2$I.prototype)), _class2$I)) || _class$O));
            Asset.prototype.createNode = null;
            cclegacy.Asset = Asset;

            var BufferBlob = function () {
              function BufferBlob() {
                this._arrayBufferOrPaddings = [];
                this._length = 0;
              }
              var _proto = BufferBlob.prototype;
              _proto.setNextAlignment = function setNextAlignment(align) {
                if (align !== 0) {
                  var remainder = this._length % align;
                  if (remainder !== 0) {
                    var padding = align - remainder;
                    this._arrayBufferOrPaddings.push(padding);
                    this._length += padding;
                  }
                }
              };
              _proto.addBuffer = function addBuffer(arrayBuffer) {
                var result = this._length;
                this._arrayBufferOrPaddings.push(arrayBuffer);
                this._length += arrayBuffer.byteLength;
                return result;
              };
              _proto.getLength = function getLength() {
                return this._length;
              };
              _proto.getCombined = function getCombined() {
                var result = new Uint8Array(this._length);
                var counter = 0;
                this._arrayBufferOrPaddings.forEach(function (arrayBufferOrPadding) {
                  if (typeof arrayBufferOrPadding === 'number') {
                    counter += arrayBufferOrPadding;
                  } else {
                    result.set(new Uint8Array(arrayBufferOrPadding), counter);
                    counter += arrayBufferOrPadding.byteLength;
                  }
                });
                return result.buffer;
              };
              return BufferBlob;
            }();

            var PixelFormat = {
              RGB565: 47,
              RGB5A1: 49,
              RGBA4444: 50,
              RGB888: 24,
              RGB32F: 32,
              RGBA8888: 35,
              BGRA8888: 36,
              RGBA32F: 44,
              A8: 1,
              I8: 2,
              AI8: 3,
              RGB_PVRTC_2BPPV1: 83,
              RGBA_PVRTC_2BPPV1: 84,
              RGB_A_PVRTC_2BPPV1: 1024,
              RGB_PVRTC_4BPPV1: 85,
              RGBA_PVRTC_4BPPV1: 86,
              RGB_A_PVRTC_4BPPV1: 1025,
              RGB_ETC1: 72,
              RGBA_ETC1: 1026,
              RGB_ETC2: 73,
              RGBA_ETC2: 77,
              RGBA_ASTC_4x4: 89,
              RGBA_ASTC_5x4: 90,
              RGBA_ASTC_5x5: 91,
              RGBA_ASTC_6x5: 92,
              RGBA_ASTC_6x6: 93,
              RGBA_ASTC_8x5: 94,
              RGBA_ASTC_8x6: 95,
              RGBA_ASTC_8x8: 96,
              RGBA_ASTC_10x5: 97,
              RGBA_ASTC_10x6: 98,
              RGBA_ASTC_10x8: 99,
              RGBA_ASTC_10x10: 100,
              RGBA_ASTC_12x10: 101,
              RGBA_ASTC_12x12: 102
            };
            var WrapMode = {
              REPEAT: 0,
              CLAMP_TO_EDGE: 2,
              MIRRORED_REPEAT: 1,
              CLAMP_TO_BORDER: 3
            };
            var TextureFilter = {
              NONE: 0,
              LINEAR: 2,
              NEAREST: 1
            };

            var _dec$M, _class$N, _class2$H, _initializer$C, _initializer2$u, _initializer3$o, _initializer4$j, _initializer5$g, _initializer6$b, _initializer7$a, _initializer8$a, _class3$f;
            ccenum(Format);
            var idGenerator$2 = new IDGenerator('Tex');
            var TextureBase = (_dec$M = ccclass$6('cc.TextureBase'), _dec$M(_class$N = (_class2$H = (_class3$f = function (_Asset) {
              _inheritsLoose(TextureBase, _Asset);
              function TextureBase(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this._format = _initializer$C && _initializer$C();
                _this._minFilter = _initializer2$u && _initializer2$u();
                _this._magFilter = _initializer3$o && _initializer3$o();
                _this._mipFilter = _initializer4$j && _initializer4$j();
                _this._wrapS = _initializer5$g && _initializer5$g();
                _this._wrapT = _initializer6$b && _initializer6$b();
                _this._wrapR = _initializer7$a && _initializer7$a();
                _this._anisotropy = _initializer8$a && _initializer8$a();
                _this._width = 1;
                _this._height = 1;
                _this._samplerInfo = new SamplerInfo();
                _this._gfxSampler = null;
                _this._gfxDevice = null;
                _this._textureHash = 0;
                _this._id = idGenerator$2.getNewId();
                _this._gfxDevice = _this._getGFXDevice();
                _this._textureHash = murmurhash2_32_gc(_this._id, 666);
                return _this;
              }
              var _proto = TextureBase.prototype;
              _proto.getId = function getId() {
                return this._id;
              };
              _proto.getPixelFormat = function getPixelFormat() {
                return this._format;
              };
              _proto.getAnisotropy = function getAnisotropy() {
                return this._anisotropy;
              };
              _proto.setWrapMode = function setWrapMode(wrapS, wrapT, wrapR) {
                if (wrapR === undefined) wrapR = wrapS;
                this._wrapS = wrapS;
                this._samplerInfo.addressU = wrapS;
                this._wrapT = wrapT;
                this._samplerInfo.addressV = wrapT;
                this._wrapR = wrapR;
                this._samplerInfo.addressW = wrapR;
                if (this._gfxDevice) {
                  this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                }
              };
              _proto.setFilters = function setFilters(minFilter, magFilter) {
                this._minFilter = minFilter;
                this._samplerInfo.minFilter = minFilter;
                this._magFilter = magFilter;
                this._samplerInfo.magFilter = magFilter;
                if (this._gfxDevice) {
                  this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                }
              };
              _proto.setMipFilter = function setMipFilter(mipFilter) {
                this._mipFilter = mipFilter;
                this._samplerInfo.mipFilter = mipFilter;
                if (this._gfxDevice) {
                  this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                }
              };
              _proto.setAnisotropy = function setAnisotropy(anisotropy) {
                anisotropy = Math.min(anisotropy, 16);
                this._anisotropy = anisotropy;
                this._samplerInfo.maxAnisotropy = anisotropy;
                if (this._gfxDevice) {
                  this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                }
              };
              _proto.destroy = function destroy() {
                var _cclegacy$director$ro;
                var destroyed = _Asset.prototype.destroy.call(this);
                if (destroyed && (_cclegacy$director$ro = cclegacy.director.root) != null && _cclegacy$director$ro.batcher2D) {
                  cclegacy.director.root.batcher2D._releaseDescriptorSetCache(this._textureHash);
                }
                return destroyed;
              };
              _proto.getHash = function getHash() {
                return this._textureHash;
              };
              _proto.getGFXTexture = function getGFXTexture() {
                return null;
              };
              _proto.getSamplerInfo = function getSamplerInfo() {
                return this._samplerInfo;
              };
              _proto.getGFXSampler = function getGFXSampler() {
                if (!this._gfxSampler) {
                  if (this._gfxDevice) {
                    this._gfxSampler = this._gfxDevice.getSampler(this._samplerInfo);
                  } else {
                    errorID(9302);
                  }
                }
                return this._gfxSampler;
              };
              _proto._serialize = function _serialize(ctxForExporting) {
                return '';
              };
              _proto._deserialize = function _deserialize(serializedData, handle) {
                var data = serializedData;
                var fields = data.split(',');
                fields.unshift('');
                if (fields.length >= 5) {
                  this.setFilters(parseInt(fields[1]), parseInt(fields[2]));
                  this.setWrapMode(parseInt(fields[3]), parseInt(fields[4]));
                }
                if (fields.length >= 7) {
                  this.setMipFilter(parseInt(fields[5]));
                  this.setAnisotropy(parseInt(fields[6]));
                }
              };
              _proto._getGFXDevice = function _getGFXDevice() {
                return deviceManager.gfxDevice;
              };
              _proto._getGFXFormat = function _getGFXFormat() {
                return this._getGFXPixelFormat(this._format);
              };
              _proto._setGFXFormat = function _setGFXFormat(format) {
                this._format = format === undefined ? 35 : format;
              };
              _proto._getGFXPixelFormat = function _getGFXPixelFormat(format) {
                if (format === 1026) {
                  format = 72;
                } else if (format === 1025) {
                  format = 85;
                } else if (format === 1024) {
                  format = 83;
                }
                return format;
              };
              _createClass(TextureBase, [{
                key: "isCompressed",
                get: function get() {
                  return this._format >= 72 && this._format <= 102 || this._format >= 1024 && this._format <= 1026;
                }
              }, {
                key: "isAlphaAtlas",
                get: function get() {
                  return this._format === 1026 || this._format === 1025 || this._format === 1024;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
              }]);
              return TextureBase;
            }(Asset), _class3$f.PixelFormat = PixelFormat, _class3$f.WrapMode = WrapMode, _class3$f.Filter = TextureFilter, _class3$f), (_initializer$C = applyDecoratedInitializer(_class2$H.prototype, "_format", [serializable$5], function () {
              return 35;
            }), _initializer2$u = applyDecoratedInitializer(_class2$H.prototype, "_minFilter", [serializable$5], function () {
              return 2;
            }), _initializer3$o = applyDecoratedInitializer(_class2$H.prototype, "_magFilter", [serializable$5], function () {
              return 2;
            }), _initializer4$j = applyDecoratedInitializer(_class2$H.prototype, "_mipFilter", [serializable$5], function () {
              return 0;
            }), _initializer5$g = applyDecoratedInitializer(_class2$H.prototype, "_wrapS", [serializable$5], function () {
              return 0;
            }), _initializer6$b = applyDecoratedInitializer(_class2$H.prototype, "_wrapT", [serializable$5], function () {
              return 0;
            }), _initializer7$a = applyDecoratedInitializer(_class2$H.prototype, "_wrapR", [serializable$5], function () {
              return 0;
            }), _initializer8$a = applyDecoratedInitializer(_class2$H.prototype, "_anisotropy", [serializable$5], function () {
              return 0;
            })), _class2$H)) || _class$N);
            cclegacy.TextureBase = TextureBase;

            var _dec$L, _class$M;
            var _colorAttachment = new ColorAttachment();
            _colorAttachment.format = 35;
            var _depthStencilAttachment = new DepthStencilAttachment();
            _depthStencilAttachment.format = 55;
            var passInfo = new RenderPassInfo([_colorAttachment], _depthStencilAttachment);
            var _windowInfo = {
              width: 1,
              height: 1,
              renderPassInfo: passInfo
            };
            var RenderTexture = exports("RenderTexture", (_dec$L = ccclass$6('cc.RenderTexture'), _dec$L(_class$M = function (_TextureBase) {
              _inheritsLoose(RenderTexture, _TextureBase);
              function RenderTexture(name) {
                var _this;
                _this = _TextureBase.call(this, name) || this;
                _this._window = null;
                return _this;
              }
              var _proto = RenderTexture.prototype;
              _proto.initialize = function initialize(info) {
                this._name = info.name || '';
                this._width = info.width;
                this._height = info.height;
                this._initWindow(info);
              };
              _proto.reset = function reset(info) {
                this.initialize(info);
              };
              _proto.destroy = function destroy() {
                if (this._window) {
                  var root = cclegacy.director.root;
                  root == null ? undefined : root.destroyWindow(this._window);
                  this._window = null;
                }
                return _TextureBase.prototype.destroy.call(this);
              };
              _proto.resize = function resize(width, height) {
                this._width = Math.floor(clamp(width, 1, 2048));
                this._height = Math.floor(clamp(height, 1, 2048));
                if (this._window) {
                  this._window.resize(this._width, this._height);
                }
                this.emit('resize', this._window);
              };
              _proto._serialize = function _serialize(ctxForExporting) {
                return {};
              };
              _proto._deserialize = function _deserialize(serializedData, handle) {
                var data = serializedData;
                this._width = data.w;
                this._height = data.h;
                this._name = data.n;
                _TextureBase.prototype._deserialize.call(this, data.base, handle);
              };
              _proto.getGFXTexture = function getGFXTexture() {
                return this._window && this._window.framebuffer.colorTextures[0];
              };
              _proto.onLoaded = function onLoaded() {
                this._initWindow();
              };
              _proto._initWindow = function _initWindow(info) {
                var root = cclegacy.director.root;
                _windowInfo.title = this._name;
                _windowInfo.width = this._width;
                _windowInfo.height = this._height;
                _windowInfo.renderPassInfo = info && info.passInfo ? info.passInfo : passInfo;
                _windowInfo.externalResLow = info && info.externalResLow ? info.externalResLow : 0;
                _windowInfo.externalResHigh = info && info.externalResHigh ? info.externalResHigh : 0;
                _windowInfo.externalFlag = info && info.externalFlag ? info.externalFlag : 0;
                _windowInfo.renderPassInfo.colorAttachments.forEach(function (colorAttachment) {
                  colorAttachment.format = root.device.swapchainFormat;
                });
                _colorAttachment.barrier = deviceManager.gfxDevice.getGeneralBarrier(new GeneralBarrierInfo(128, 128));
                if (this._window) {
                  this._window.destroy();
                  this._window.initialize(deviceManager.gfxDevice, _windowInfo);
                } else {
                  this._window = root.createWindow(_windowInfo);
                }
              };
              _proto.initDefault = function initDefault(uuid) {
                _TextureBase.prototype.initDefault.call(this, uuid);
                this._width = this._height = 1;
                this._initWindow();
              };
              _proto.validate = function validate() {
                return this.width >= 1 && this.width <= 2048 && this.height >= 1 && this.height <= 2048;
              };
              _proto.readPixels = function readPixels(x, y, width, height, buffer) {
                x = x || 0;
                y = y || 0;
                width = width || this.width;
                height = height || this.height;
                var gfxTexture = this.getGFXTexture();
                if (!gfxTexture) {
                  errorID(7606);
                  return null;
                }
                var needSize = 4 * width * height;
                if (buffer === undefined) {
                  buffer = new Uint8Array(needSize);
                } else if (buffer.length < needSize) {
                  errorID(7607, needSize);
                  return null;
                }
                var gfxDevice = this._getGFXDevice();
                var bufferViews = [];
                var regions = [];
                var region0 = new BufferTextureCopy();
                region0.texOffset.x = x;
                region0.texOffset.y = y;
                region0.texExtent.width = width;
                region0.texExtent.height = height;
                regions.push(region0);
                bufferViews.push(buffer);
                gfxDevice == null ? undefined : gfxDevice.copyTextureToBuffers(gfxTexture, bufferViews, regions);
                return buffer;
              };
              _createClass(RenderTexture, [{
                key: "window",
                get: function get() {
                  return this._window;
                }
              }]);
              return RenderTexture;
            }(TextureBase)) || _class$M));
            cclegacy.RenderTexture = RenderTexture;

            removeProperty(TextureBase.prototype, 'TextureBase.prototype', [{
              name: 'hasPremultipliedAlpha'
            }, {
              name: 'setPremultiplyAlpha'
            }, {
              name: 'setFlipY'
            }]);
            replaceProperty(RenderTexture.prototype, 'RenderTexture.prototype', [{
              name: 'getGFXWindow',
              customFunction: function customFunction() {
                return this.window;
              }
            }]);

            var _dec$K, _class$L, _class2$G;
            var BufferAsset = exports("BufferAsset", (_dec$K = ccclass$6('cc.BufferAsset'), _dec$K(_class$L = (_class2$G = function (_Asset) {
              _inheritsLoose(BufferAsset, _Asset);
              function BufferAsset(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this._buffer = null;
                return _this;
              }
              var _proto = BufferAsset.prototype;
              _proto.buffer = function buffer() {
                assertIsNonNullable(this._buffer);
                return this._buffer;
              };
              _proto.validate = function validate() {
                return !!this._buffer;
              };
              _createClass(BufferAsset, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._buffer;
                },
                set: function set(bin) {
                  if (bin instanceof ArrayBuffer) {
                    this._buffer = bin;
                  } else {
                    this._buffer = bin.buffer;
                  }
                }
              }]);
              return BufferAsset;
            }(Asset), (_applyDecoratedDescriptor(_class2$G.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$G.prototype, "_nativeAsset"), _class2$G.prototype)), _class2$G)) || _class$L));
            cclegacy.BufferAsset = BufferAsset;

            var _dec$J, _class$K, _dec2$s, _class2$F, _dec3$n, _class3$e;
            var Script = exports("Script", (_dec$J = ccclass$6('cc.Script'), _dec$J(_class$K = function (_Asset) {
              _inheritsLoose(Script, _Asset);
              function Script(name) {
                return _Asset.call(this, name) || this;
              }
              return Script;
            }(Asset)) || _class$K));
            cclegacy._Script = Script;
            var JavaScript = exports("JavaScript", (_dec2$s = ccclass$6('cc.JavaScript'), _dec2$s(_class2$F = function (_Script) {
              _inheritsLoose(JavaScript, _Script);
              function JavaScript(name) {
                return _Script.call(this, name) || this;
              }
              return JavaScript;
            }(Script)) || _class2$F));
            cclegacy._JavaScript = JavaScript;
            var TypeScript = exports("TypeScript", (_dec3$n = ccclass$6('cc.TypeScript'), _dec3$n(_class3$e = function (_Script2) {
              _inheritsLoose(TypeScript, _Script2);
              function TypeScript(name) {
                return _Script2.call(this, name) || this;
              }
              return TypeScript;
            }(Script)) || _class3$e));
            cclegacy._TypeScript = TypeScript;

            var EMPTY_GEOMETRIC_INFO = {
              positions: new Float32Array(),
              indices: new Uint8Array(),
              boundingBox: {
                min: Vec3.ZERO,
                max: Vec3.ZERO
              }
            };
            var RenderingSubMesh = exports("RenderingSubMesh", function () {
              function RenderingSubMesh(vertexBuffers, attributes, primitiveMode, indexBuffer, indirectBuffer, isOwnerOfIndexBuffer) {
                if (indexBuffer === undefined) {
                  indexBuffer = null;
                }
                if (indirectBuffer === undefined) {
                  indirectBuffer = null;
                }
                if (isOwnerOfIndexBuffer === undefined) {
                  isOwnerOfIndexBuffer = true;
                }
                this.mesh = undefined;
                this.subMeshIdx = undefined;
                this._flatBuffers = [];
                this._jointMappedBuffers = undefined;
                this._jointMappedBufferIndices = undefined;
                this._vertexIdChannel = undefined;
                this._geometricInfo = undefined;
                this._vertexBuffers = undefined;
                this._drawInfo = null;
                this._attributes = attributes;
                this._vertexBuffers = vertexBuffers;
                this._indexBuffer = indexBuffer;
                this._indirectBuffer = indirectBuffer;
                this._primitiveMode = primitiveMode;
                this._iaInfo = new InputAssemblerInfo(attributes, vertexBuffers, indexBuffer, indirectBuffer);
                this._isOwnerOfIndexBuffer = isOwnerOfIndexBuffer;
              }
              var _proto = RenderingSubMesh.prototype;
              _proto.invalidateGeometricInfo = function invalidateGeometricInfo() {
                this._geometricInfo = undefined;
              };
              _proto.genFlatBuffers = function genFlatBuffers() {
                if (this._flatBuffers.length || !this.mesh || this.subMeshIdx === undefined) {
                  return;
                }
                var mesh = this.mesh;
                var idxCount = 0;
                var prim = mesh.struct.primitives[this.subMeshIdx];
                if (prim.indexView) {
                  idxCount = prim.indexView.count;
                }
                for (var i = 0; i < prim.vertexBundelIndices.length; i++) {
                  var bundleIdx = prim.vertexBundelIndices[i];
                  var vertexBundle = mesh.struct.vertexBundles[bundleIdx];
                  var vbCount = prim.indexView ? prim.indexView.count : vertexBundle.view.count;
                  var vbStride = vertexBundle.view.stride;
                  var vbSize = vbStride * vbCount;
                  var view = new Uint8Array(mesh.data.buffer, vertexBundle.view.offset, vertexBundle.view.length);
                  var sharedView = new Uint8Array(prim.indexView ? vbSize : vertexBundle.view.length);
                  if (!prim.indexView) {
                    sharedView.set(mesh.data.subarray(vertexBundle.view.offset, vertexBundle.view.offset + vertexBundle.view.length));
                    this._flatBuffers.push({
                      stride: vbStride,
                      count: vbCount,
                      buffer: sharedView
                    });
                    continue;
                  }
                  var ibView = mesh.readIndices(this.subMeshIdx);
                  for (var n = 0; n < idxCount; ++n) {
                    var idx = ibView[n];
                    var offset = n * vbStride;
                    var srcOffset = idx * vbStride;
                    for (var m = 0; m < vbStride; ++m) {
                      sharedView[offset + m] = view[srcOffset + m];
                    }
                  }
                  this._flatBuffers.push({
                    stride: vbStride,
                    count: vbCount,
                    buffer: sharedView
                  });
                }
              };
              _proto.destroy = function destroy() {
                for (var i = 0; i < this.vertexBuffers.length; i++) {
                  this.vertexBuffers[i].destroy();
                }
                this.vertexBuffers.length = 0;
                if (this._indexBuffer) {
                  if (this._isOwnerOfIndexBuffer) {
                    this._indexBuffer.destroy();
                  }
                  this._indexBuffer = null;
                }
                if (this._jointMappedBuffers && this._jointMappedBufferIndices) {
                  for (var _i = 0; _i < this._jointMappedBufferIndices.length; _i++) {
                    this._jointMappedBuffers[this._jointMappedBufferIndices[_i]].destroy();
                  }
                  this._jointMappedBuffers = undefined;
                  this._jointMappedBufferIndices = undefined;
                }
                if (this._indirectBuffer) {
                  this._indirectBuffer.destroy();
                  this._indirectBuffer = null;
                }
              };
              _proto.enableVertexIdChannel = function enableVertexIdChannel(device) {
                if (this._vertexIdChannel) {
                  return;
                }
                var streamIndex = this.vertexBuffers.length;
                var attributeIndex = this.attributes.length;
                var vertexIdBuffer = this._allocVertexIdBuffer(device);
                this._vertexBuffers.push(vertexIdBuffer);
                this._attributes.push(new Attribute('a_vertexId', 11, false, streamIndex));
                this._iaInfo.attributes = this._attributes;
                this._iaInfo.vertexBuffers = this._vertexBuffers;
                this._vertexIdChannel = {
                  stream: streamIndex,
                  index: attributeIndex
                };
              };
              _proto._allocVertexIdBuffer = function _allocVertexIdBuffer(device) {
                var vertexCount = this.vertexBuffers.length === 0 || this.vertexBuffers[0].stride === 0 ? 0 : this.vertexBuffers[0].size / this.vertexBuffers[0].stride;
                var vertexIds = new Float32Array(vertexCount);
                for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
                  vertexIds[iVertex] = iVertex + 0.5;
                }
                var vertexIdBuffer = device.createBuffer(new BufferInfo(8 | 2, 1, vertexIds.byteLength, vertexIds.BYTES_PER_ELEMENT));
                vertexIdBuffer.update(vertexIds);
                return vertexIdBuffer;
              };
              _createClass(RenderingSubMesh, [{
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
              }, {
                key: "vertexBuffers",
                get: function get() {
                  return this._vertexBuffers;
                }
              }, {
                key: "indexBuffer",
                get: function get() {
                  return this._indexBuffer;
                }
              }, {
                key: "indirectBuffer",
                get: function get() {
                  return this._indirectBuffer;
                }
              }, {
                key: "primitiveMode",
                get: function get() {
                  return this._primitiveMode;
                }
              }, {
                key: "geometricInfo",
                get: function get() {
                  if (this._geometricInfo) {
                    return this._geometricInfo;
                  }
                  if (this.mesh === undefined) {
                    return EMPTY_GEOMETRIC_INFO;
                  }
                  if (this.subMeshIdx === undefined) {
                    return EMPTY_GEOMETRIC_INFO;
                  }
                  var mesh = this.mesh;
                  var index = this.subMeshIdx;
                  var pAttri = this.attributes.find(function (element) {
                    return element.name === "a_position";
                  });
                  if (!pAttri) {
                    return EMPTY_GEOMETRIC_INFO;
                  }
                  var positions;
                  switch (pAttri.format) {
                    case 21:
                    case 32:
                      {
                        positions = mesh.readAttribute(index, "a_position");
                        if (!positions) {
                          return EMPTY_GEOMETRIC_INFO;
                        }
                        break;
                      }
                    case 44:
                      {
                        var data = mesh.readAttribute(index, "a_position");
                        if (!data) {
                          return EMPTY_GEOMETRIC_INFO;
                        }
                        var count = data.length / 4;
                        positions = new Float32Array(count * 3);
                        for (var i = 0; i < count; ++i) {
                          var dstPtr = i * 3;
                          var srcPtr = i * 4;
                          positions[dstPtr] = data[srcPtr];
                          positions[dstPtr + 1] = data[srcPtr + 1];
                          positions[dstPtr + 2] = data[srcPtr + 2];
                        }
                        break;
                      }
                    case 18:
                    case 29:
                      {
                        var _data = mesh.readAttribute(index, "a_position");
                        if (!_data) {
                          return EMPTY_GEOMETRIC_INFO;
                        }
                        positions = new Float32Array(_data.length);
                        for (var _i2 = 0; _i2 < _data.length; ++_i2) {
                          positions[_i2] = halfToFloat(_data[_i2]);
                        }
                        break;
                      }
                    case 41:
                      {
                        var _data2 = mesh.readAttribute(index, "a_position");
                        if (!_data2) {
                          return EMPTY_GEOMETRIC_INFO;
                        }
                        var _count = _data2.length / 4;
                        positions = new Float32Array(_count * 3);
                        for (var _i3 = 0; _i3 < _count; ++_i3) {
                          var _dstPtr = _i3 * 3;
                          var _srcPtr = _i3 * 4;
                          positions[_dstPtr] = halfToFloat(_data2[_srcPtr]);
                          positions[_dstPtr + 1] = halfToFloat(_data2[_srcPtr + 1]);
                          positions[_dstPtr + 2] = halfToFloat(_data2[_srcPtr + 2]);
                        }
                        break;
                      }
                    default:
                      return EMPTY_GEOMETRIC_INFO;
                  }
                  var indices = mesh.readIndices(index) || undefined;
                  var max = new Vec3();
                  var min = new Vec3();
                  var conut = FormatInfos[pAttri.format].count;
                  if (conut === 2) {
                    max.set(positions[0], positions[1], 0);
                    min.set(positions[0], positions[1], 0);
                  } else {
                    max.set(positions[0], positions[1], positions[2]);
                    min.set(positions[0], positions[1], positions[2]);
                  }
                  for (var _i4 = 0; _i4 < positions.length; _i4 += conut) {
                    if (conut === 2) {
                      max.x = positions[_i4] > max.x ? positions[_i4] : max.x;
                      max.y = positions[_i4 + 1] > max.y ? positions[_i4 + 1] : max.y;
                      min.x = positions[_i4] < min.x ? positions[_i4] : min.x;
                      min.y = positions[_i4 + 1] < min.y ? positions[_i4 + 1] : min.y;
                    } else {
                      max.x = positions[_i4] > max.x ? positions[_i4] : max.x;
                      max.y = positions[_i4 + 1] > max.y ? positions[_i4 + 1] : max.y;
                      max.z = positions[_i4 + 2] > max.z ? positions[_i4 + 2] : max.z;
                      min.x = positions[_i4] < min.x ? positions[_i4] : min.x;
                      min.y = positions[_i4 + 1] < min.y ? positions[_i4 + 1] : min.y;
                      min.z = positions[_i4 + 2] < min.z ? positions[_i4 + 2] : min.z;
                    }
                  }
                  this._geometricInfo = {
                    positions: positions,
                    indices: indices,
                    boundingBox: {
                      max: max,
                      min: min
                    }
                  };
                  return this._geometricInfo;
                }
              }, {
                key: "drawInfo",
                get: function get() {
                  return this._drawInfo;
                },
                set: function set(info) {
                  this._drawInfo = info;
                }
              }, {
                key: "flatBuffers",
                get: function get() {
                  return this._flatBuffers;
                }
              }, {
                key: "jointMappedBuffers",
                get: function get() {
                  var _this = this;
                  if (this._jointMappedBuffers) {
                    return this._jointMappedBuffers;
                  }
                  var buffers = this._jointMappedBuffers = [];
                  var indices = this._jointMappedBufferIndices = [];
                  if (!this.mesh || this.subMeshIdx === undefined) {
                    return this._jointMappedBuffers = this.vertexBuffers;
                  }
                  var struct = this.mesh.struct;
                  var prim = struct.primitives[this.subMeshIdx];
                  if (!struct.jointMaps || prim.jointMapIndex === undefined || !struct.jointMaps[prim.jointMapIndex]) {
                    return this._jointMappedBuffers = this.vertexBuffers;
                  }
                  var jointFormat;
                  var jointOffset;
                  var _ref = cclegacy.director.root,
                    device = _ref.device;
                  var _loop = function _loop() {
                    var bundle = struct.vertexBundles[prim.vertexBundelIndices[i]];
                    jointOffset = 0;
                    jointFormat = 0;
                    for (var j = 0; j < bundle.attributes.length; j++) {
                      var attr = bundle.attributes[j];
                      if (attr.name === "a_joints") {
                        jointFormat = attr.format;
                        break;
                      }
                      jointOffset += FormatInfos[attr.format].size;
                    }
                    if (jointFormat) {
                      var data = new Uint8Array(_this.mesh.data.buffer, bundle.view.offset, bundle.view.length);
                      var dataView = new DataView(data.slice().buffer);
                      var idxMap = struct.jointMaps[prim.jointMapIndex];
                      mapBuffer(dataView, function (cur) {
                        return idxMap.indexOf(cur);
                      }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                      var buffer = device.createBuffer(new BufferInfo(8 | 2, 1, bundle.view.length, bundle.view.stride));
                      buffer.update(dataView.buffer);
                      buffers.push(buffer);
                      indices.push(i);
                    } else {
                      buffers.push(_this.vertexBuffers[prim.vertexBundelIndices[i]]);
                    }
                  };
                  for (var i = 0; i < prim.vertexBundelIndices.length; i++) {
                    _loop();
                  }
                  if (this._vertexIdChannel) {
                    buffers.push(this._allocVertexIdBuffer(device));
                  }
                  return buffers;
                }
              }, {
                key: "iaInfo",
                get: function get() {
                  return this._iaInfo;
                }
              }]);
              return RenderingSubMesh;
            }());

            var layerList = {
              NONE: 0,
              IGNORE_RAYCAST: 1 << 20,
              GIZMOS: 1 << 21,
              EDITOR: 1 << 22,
              UI_3D: 1 << 23,
              SCENE_GIZMO: 1 << 24,
              UI_2D: 1 << 25,
              PROFILER: 1 << 28,
              DEFAULT: 1 << 30,
              ALL: 0xffffffff
            };
            var Layers = exports("Layers", function () {
              function Layers() {}
              Layers.init = function init() {
                var userLayers = settings.querySettings("engine", 'customLayers');
                if (!userLayers) return;
                for (var i = 0; i < userLayers.length; i++) {
                  var layer = userLayers[i];
                  Layers.addLayer(layer.name, layer.bit);
                }
              };
              Layers.makeMaskInclude = function makeMaskInclude(includes) {
                return includes.reduce(function (mask, inc) {
                  return mask | inc;
                }, 0);
              };
              Layers.makeMaskExclude = function makeMaskExclude(excludes) {
                return ~Layers.makeMaskInclude(excludes);
              };
              Layers.addLayer = function addLayer(name, bitNum) {
                if (bitNum === undefined) {
                  warnID(16364);
                  return;
                }
                if (bitNum > 19 || bitNum < 0) {
                  warnID(16365);
                  return;
                }
                var val = 1 << bitNum;
                assertIsTrue(!Layers.Enum[name], getError(2104, name));
                Layers.Enum[name] = val;
                value(Layers.Enum, String(val), name);
                Layers.BitMask[name] = val;
                value(Layers.BitMask, String(val), name);
                BitMask.update(Layers.BitMask);
                Enum.update(Layers.Enum);
              };
              Layers.deleteLayer = function deleteLayer(bitNum) {
                if (bitNum > 19 || bitNum < 0) {
                  warnID(16366);
                  return;
                }
                var val = 1 << bitNum;
                delete Layers.Enum[Layers.Enum[val]];
                delete Layers.Enum[val];
                delete Layers.BitMask[Layers.BitMask[val]];
                delete Layers.BitMask[val];
                BitMask.update(Layers.BitMask);
                Enum.update(Layers.Enum);
              };
              Layers.nameToLayer = function nameToLayer(name) {
                if (name === undefined) {
                  warnID(16367);
                  return -1;
                }
                return log2(Layers.Enum[name]);
              };
              Layers.layerToName = function layerToName(bitNum) {
                if (bitNum > 31 || bitNum < 0) {
                  warnID(16368);
                  return '';
                }
                return Layers.Enum[1 << bitNum];
              };
              return Layers;
            }());
            Layers.Enum = Enum(layerList);
            Layers.BitMask = BitMask(_extends({}, layerList));
            legacyCC.Layers = Layers;

            var NodeUIProperties = function () {
              var _proto = NodeUIProperties.prototype;
              _proto.setOpacity = function setOpacity(v) {
                this._opacity = v;
              };
              function NodeUIProperties(node) {
                this._uiComp = null;
                this._opacity = 1;
                this._localOpacity = 1;
                this.colorDirty = true;
                this._uiTransformComp = null;
                this._uiSkewComp = null;
                this._node = node;
              }
              _proto.applyOpacity = function applyOpacity(effectOpacity) {
                this._opacity = this._localOpacity * effectOpacity;
              };
              NodeUIProperties.markOpacityTree = function markOpacityTree(node, isDirty) {
              };
              _createClass(NodeUIProperties, [{
                key: "uiTransformComp",
                get: function get() {
                  if (!this._uiTransformComp) {
                    this._uiTransformComp = this._node.getComponent('cc.UITransform');
                  }
                  return this._uiTransformComp;
                },
                set: function set(value) {
                  this._uiTransformComp = value;
                }
              }, {
                key: "uiComp",
                get: function get() {
                  return this._uiComp;
                },
                set: function set(comp) {
                  if (this._uiComp && comp) {
                    warnID(12002);
                    return;
                  }
                  this._uiComp = comp;
                }
              }, {
                key: "opacity",
                get: function get() {
                  return this._opacity;
                }
              }, {
                key: "localOpacity",
                get: function get() {
                  return this._localOpacity;
                },
                set: function set(val) {
                  this._localOpacity = val;
                  this.colorDirty = true;
                }
              }]);
              return NodeUIProperties;
            }();

            !!legacyCC.GAME_VIEW;

            var NodeSpace = exports("NodeSpace", {
              LOCAL: 0,
              WORLD: 1
            });
            var TransformBit = exports("TransformBit", {
              NONE: 0,
              POSITION: 1,
              ROTATION: 2,
              SCALE: 4,
              SKEW: 8,
              RS: 6,
              RSS: 14,
              TRS: 7,
              TRS_MASK: -8
            });
            legacyCC.internal.TransformBit = TransformBit;
            var MobilityMode = exports("MobilityMode", Enum({
              Static: 0,
              Stationary: 1,
              Movable: 2
            }));

            var _dec$I, _class$J, _class2$E, _initializer$B, _initializer2$t, _initializer3$n, _initializer4$i, _initializer5$f;
            var EventHandler = exports("EventHandler", (_dec$I = ccclass$6('cc.ClickEvent'), _dec$I(_class$J = (_class2$E = function () {
              function EventHandler() {
                this.target = _initializer$B && _initializer$B();
                this.component = _initializer2$t && _initializer2$t();
                this._componentId = _initializer3$n && _initializer3$n();
                this.handler = _initializer4$i && _initializer4$i();
                this.customEventData = _initializer5$f && _initializer5$f();
              }
              EventHandler.emitEvents = function emitEvents(events) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                for (var i = 0, l = events.length; i < l; i++) {
                  var event = events[i];
                  if (!(event instanceof EventHandler)) {
                    continue;
                  }
                  event.emit(args);
                }
              };
              var _proto = EventHandler.prototype;
              _proto.emit = function emit(params) {
                var target = this.target;
                if (!legacyCC.isValid(target)) {
                  return;
                }
                this._genCompIdIfNeeded();
                var compType = legacyCC.js.getClassById(this._componentId);
                var comp = target.getComponent(compType);
                if (!legacyCC.isValid(comp)) {
                  return;
                }
                var handler = comp[this.handler];
                if (typeof handler !== 'function') {
                  return;
                }
                if (this.customEventData != null && this.customEventData !== '') {
                  params = params.slice();
                  params.push(this.customEventData);
                }
                handler.apply(comp, params);
              };
              _proto._compName2Id = function _compName2Id(compName) {
                var comp = legacyCC.js.getClassByName(compName);
                return legacyCC.js.getClassId(comp);
              };
              _proto._compId2Name = function _compId2Name(compId) {
                var comp = legacyCC.js.getClassById(compId);
                return legacyCC.js.getClassName(comp);
              };
              _proto._genCompIdIfNeeded = function _genCompIdIfNeeded() {
                if (!this._componentId) {
                  this._componentName = this.component;
                  this.component = '';
                }
              };
              _createClass(EventHandler, [{
                key: "_componentName",
                get: function get() {
                  this._genCompIdIfNeeded();
                  return this._compId2Name(this._componentId);
                },
                set: function set(value) {
                  this._componentId = this._compName2Id(value);
                }
              }]);
              return EventHandler;
            }(), (_initializer$B = applyDecoratedInitializer(_class2$E.prototype, "target", [serializable$5], function () {
              return null;
            }), _initializer2$t = applyDecoratedInitializer(_class2$E.prototype, "component", [serializable$5], function () {
              return '';
            }), _initializer3$n = applyDecoratedInitializer(_class2$E.prototype, "_componentId", [serializable$5], function () {
              return '';
            }), _initializer4$i = applyDecoratedInitializer(_class2$E.prototype, "handler", [serializable$5], function () {
              return '';
            }), _initializer5$f = applyDecoratedInitializer(_class2$E.prototype, "customEventData", [serializable$5], function () {
              return '';
            })), _class2$E)) || _class$J));

            var _dec$H, _dec2$r, _class$I, _class2$D, _initializer$A, _initializer2$s, _initializer3$m, _class3$d;
            var idGenerator$1 = new IDGenerator('Comp');
            var IsOnLoadCalled$1 = 16384;
            var NullNode = null;
            var Component = exports("Component", (_dec$H = ccclass$6('cc.Component'), _dec2$r = type$5(Script), _dec$H(_class$I = (_class2$D = (_class3$d = function (_CCObject) {
              _inheritsLoose(Component, _CCObject);
              function Component() {
                var _this;
                _this = _CCObject.call(this) || this;
                _this.node = _initializer$A && _initializer$A();
                _this._enabled = _initializer2$s && _initializer2$s();
                _this.__prefab = _initializer3$m && _initializer3$m();
                _this._sceneGetter = null;
                _this._id = idGenerator$1.getNewId();
                return _this;
              }
              var _proto = Component.prototype;
              _proto._getRenderScene = function _getRenderScene() {
                if (this._sceneGetter) {
                  return this._sceneGetter();
                }
                return this.node.scene.renderScene;
              };
              _proto.addComponent = function addComponent(typeOrClassName) {
                return this.node.addComponent(typeOrClassName);
              };
              _proto.getComponent = function getComponent(typeOrClassName) {
                return this.node.getComponent(typeOrClassName);
              };
              _proto.getComponents = function getComponents(typeOrClassName) {
                return this.node.getComponents(typeOrClassName);
              };
              _proto.getComponentInChildren = function getComponentInChildren(typeOrClassName) {
                return this.node.getComponentInChildren(typeOrClassName);
              };
              _proto.getComponentsInChildren = function getComponentsInChildren(typeOrClassName) {
                return this.node.getComponentsInChildren(typeOrClassName);
              };
              _proto.destroy = function destroy() {
                if (_CCObject.prototype.destroy.call(this)) {
                  if (this._enabled && this.node.activeInHierarchy) {
                    legacyCC.director._compScheduler.disableComp(this);
                  }
                  return true;
                }
                return false;
              };
              _proto._onPreDestroy = function _onPreDestroy() {
                this.unscheduleAllCallbacks();
                legacyCC.director._nodeActivator.destroyComp(this);
                this.node._removeComponent(this);
              };
              _proto._instantiate = function _instantiate(cloned) {
                if (!cloned) {
                  cloned = legacyCC.instantiate._clone(this, this);
                }
                if (cloned) {
                  cloned.node = NullNode;
                }
                return cloned;
              };
              _proto.schedule = function schedule(callback, interval, repeat, delay) {
                if (interval === undefined) {
                  interval = 0;
                }
                if (repeat === undefined) {
                  repeat = legacyCC.macro.REPEAT_FOREVER;
                }
                if (delay === undefined) {
                  delay = 0;
                }
                assertID(Boolean(callback), 1619);
                interval = interval || 0;
                assertID(interval >= 0, 1620);
                repeat = Number.isNaN(repeat) ? legacyCC.macro.REPEAT_FOREVER : repeat;
                delay = delay || 0;
                var scheduler = legacyCC.director.getScheduler();
                var paused = scheduler.isTargetPaused(this);
                scheduler.schedule(callback, this, interval, repeat, delay, paused);
              };
              _proto.scheduleOnce = function scheduleOnce(callback, delay) {
                if (delay === undefined) {
                  delay = 0;
                }
                this.schedule(callback, 0, 0, delay);
              };
              _proto.unschedule = function unschedule(callback_fn) {
                if (!callback_fn) {
                  return;
                }
                legacyCC.director.getScheduler().unschedule(callback_fn, this);
              };
              _proto.unscheduleAllCallbacks = function unscheduleAllCallbacks() {
                legacyCC.director.getScheduler().unscheduleAllForTarget(this);
              };
              _createClass(Component, [{
                key: "name",
                get: function get() {
                  if (this._name) {
                    return this._name;
                  }
                  var className = getClassName(this);
                  var trimLeft = className.lastIndexOf('.');
                  if (trimLeft >= 0) {
                    className = className.slice(trimLeft + 1);
                  }
                  if (this.node) {
                    return this.node.name + "<" + className + ">";
                  } else {
                    return className;
                  }
                },
                set: function set(value) {
                  this._name = value;
                }
              }, {
                key: "uuid",
                get: function get() {
                  return this._id;
                }
              }, {
                key: "__scriptAsset",
                get: function get() {
                  return null;
                }
              }, {
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(value) {
                  if (this._enabled !== value) {
                    this._enabled = value;
                    if (this.node.activeInHierarchy) {
                      var compScheduler = legacyCC.director._compScheduler;
                      if (value) {
                        compScheduler.enableComp(this);
                      } else {
                        compScheduler.disableComp(this);
                      }
                    }
                  }
                }
              }, {
                key: "enabledInHierarchy",
                get: function get() {
                  return this._enabled && this.node && this.node.activeInHierarchy;
                }
              }, {
                key: "_isOnLoadCalled",
                get: function get() {
                  return this._objFlags & IsOnLoadCalled$1;
                }
              }, {
                key: "internalUpdate",
                get: function get() {
                  return this.update;
                }
              }, {
                key: "internalLateUpdate",
                get: function get() {
                  return this.lateUpdate;
                }
              }, {
                key: "internalPreload",
                get: function get() {
                  return this.__preload;
                }
              }, {
                key: "internalOnLoad",
                get: function get() {
                  return this.onLoad;
                }
              }, {
                key: "internalStart",
                get: function get() {
                  return this.start;
                }
              }, {
                key: "internalOnEnable",
                get: function get() {
                  return this.onEnable;
                }
              }, {
                key: "internalOnDisable",
                get: function get() {
                  return this.onDisable;
                }
              }, {
                key: "internalOnDestroy",
                get: function get() {
                  return this.onDestroy;
                }
              }]);
              return Component;
            }(CCObject), _class3$d.EventHandler = EventHandler, _class3$d._executionOrder = 0, _class3$d._requireComponent = null, _class3$d.system = null, _class3$d), (_applyDecoratedDescriptor(_class2$D.prototype, "__scriptAsset", [_dec2$r], Object.getOwnPropertyDescriptor(_class2$D.prototype, "__scriptAsset"), _class2$D.prototype), _initializer$A = applyDecoratedInitializer(_class2$D.prototype, "node", [serializable$5], function () {
              return NullNode;
            }), _initializer2$s = applyDecoratedInitializer(_class2$D.prototype, "_enabled", [serializable$5], function () {
              return true;
            }), _initializer3$m = applyDecoratedInitializer(_class2$D.prototype, "__prefab", [serializable$5], function () {
              return null;
            })), _class2$D)) || _class$I));
            value(Component, '_registerEditorProps', function (cls, props) {
              var reqComp = props.requireComponent;
              if (reqComp) {
                if (Array.isArray(reqComp)) {
                  reqComp = reqComp.filter(Boolean);
                }
                cls._requireComponent = reqComp;
              }
              var order = props.executionOrder;
              if (order && typeof order === 'number') {
                cls._executionOrder = order;
              }
            });
            legacyCC.Component = Component;

            var NodeEventType = exports("NodeEventType", {
              TOUCH_START: "touch-start",
              TOUCH_MOVE: "touch-move",
              TOUCH_END: "touch-end",
              TOUCH_CANCEL: "touch-cancel",
              MOUSE_DOWN: "mouse-down",
              MOUSE_MOVE: "mouse-move",
              MOUSE_UP: "mouse-up",
              MOUSE_WHEEL: "mouse-wheel",
              MOUSE_ENTER: "mouse-enter",
              MOUSE_LEAVE: "mouse-leave",
              KEY_DOWN: "keydown",
              KEY_UP: "keyup",
              DEVICEMOTION: "devicemotion",
              TRANSFORM_CHANGED: "transform-changed",
              MOBILITY_CHANGED: "mobility-changed",
              SCENE_CHANGED_FOR_PERSISTS: "scene-changed-for-persists",
              SIZE_CHANGED: "size-changed",
              ANCHOR_CHANGED: "anchor-changed",
              COLOR_CHANGED: "color-changed",
              CHILD_ADDED: "child-added",
              CHILD_REMOVED: "child-removed",
              PARENT_CHANGED: "parent-changed",
              NODE_DESTROYED: "node-destroyed",
              LAYER_CHANGED: "layer-changed",
              SIBLING_ORDER_CHANGED: "sibling-order-changed",
              CHILDREN_ORDER_CHANGED: "sibling-order-changed",
              ACTIVE_IN_HIERARCHY_CHANGED: "active-in-hierarchy-changed",
              COMPONENT_ADDED: "component-added",
              COMPONENT_REMOVED: "component-removed",
              LIGHT_PROBE_CHANGED: "light-probe-changed",
              LIGHT_PROBE_BAKING_CHANGED: "light-probe-baking-changed",
              ACTIVE_CHANGED: "active-changed"
            });

            var Event = exports("Event", function () {
              function Event(type, bubbles) {
                this.target = null;
                this.currentTarget = null;
                this.eventPhase = 0;
                this.propagationStopped = false;
                this.propagationImmediateStopped = false;
                this.type = type;
                this.bubbles = !!bubbles;
              }
              var _proto = Event.prototype;
              _proto.unuse = function unuse() {
                this.type = Event.NO_TYPE;
                this.target = null;
                this.currentTarget = null;
                this.eventPhase = Event.NONE;
                this.propagationStopped = false;
                this.propagationImmediateStopped = false;
              };
              _proto.reuse = function reuse(type, bubbles) {
                this.type = type;
                this.bubbles = bubbles || false;
              };
              _proto.isStopped = function isStopped() {
                return this.propagationStopped || this.propagationImmediateStopped;
              };
              _proto.getCurrentTarget = function getCurrentTarget() {
                return this.currentTarget;
              };
              _proto.getType = function getType() {
                return this.type;
              };
              return Event;
            }());
            Event.NO_TYPE = 'no_type';
            Event.TOUCH = 'touch';
            Event.MOUSE = 'mouse';
            Event.KEYBOARD = 'keyboard';
            Event.ACCELERATION = 'acceleration';
            Event.NONE = 0;
            Event.CAPTURING_PHASE = 1;
            Event.AT_TARGET = 2;
            Event.BUBBLING_PHASE = 3;
            cclegacy.Event = Event;

            var EventAcceleration = exports("EventAcceleration", function (_Event) {
              _inheritsLoose(EventAcceleration, _Event);
              function EventAcceleration(acc, bubbles) {
                var _this;
                _this = _Event.call(this, "devicemotion", bubbles) || this;
                _this.acc = acc;
                return _this;
              }
              return EventAcceleration;
            }(Event));
            Event.EventAcceleration = EventAcceleration;

            var EventKeyboard = exports("EventKeyboard", function (_Event) {
              _inheritsLoose(EventKeyboard, _Event);
              function EventKeyboard(keyCode, eventType, bubbles) {
                var _this;
                if (typeof eventType === 'boolean') {
                  var _isPressed = eventType;
                  eventType = _isPressed ? "keydown" : "keyup";
                }
                _this = _Event.call(this, eventType, bubbles) || this;
                _this.rawEvent = undefined;
                _this._isPressed = eventType !== "keyup";
                if (typeof keyCode === 'number') {
                  _this.keyCode = keyCode;
                } else {
                  _this.keyCode = keyCode.keyCode;
                  _this.rawEvent = keyCode;
                }
                _this.windowId = 0;
                return _this;
              }
              _createClass(EventKeyboard, [{
                key: "isPressed",
                get: function get() {
                  return this._isPressed;
                }
              }]);
              return EventKeyboard;
            }(Event));
            Event.EventKeyboard = EventKeyboard;

            var EventMouse = exports("EventMouse", function (_Event) {
              _inheritsLoose(EventMouse, _Event);
              function EventMouse(eventType, bubbles, prevLoc, windowId) {
                var _this;
                _this = _Event.call(this, eventType, bubbles) || this;
                _this.movementX = 0;
                _this.movementY = 0;
                _this.windowId = 0;
                _this.preventSwallow = false;
                _this._button = EventMouse.BUTTON_MISSING;
                _this._x = 0;
                _this._y = 0;
                _this._prevX = 0;
                _this._prevY = 0;
                _this._scrollX = 0;
                _this._scrollY = 0;
                _this._eventType = eventType;
                if (prevLoc) {
                  _this._prevX = prevLoc.x;
                  _this._prevY = prevLoc.y;
                }
                _this.windowId = windowId !== null && windowId !== undefined ? windowId : _this.windowId;
                return _this;
              }
              var _proto = EventMouse.prototype;
              _proto.setScrollData = function setScrollData(scrollX, scrollY) {
                this._scrollX = scrollX;
                this._scrollY = scrollY;
              };
              _proto.getScrollX = function getScrollX() {
                return this._scrollX;
              };
              _proto.getScrollY = function getScrollY() {
                return this._scrollY;
              };
              _proto.setLocation = function setLocation(x, y) {
                this._x = x;
                this._y = y;
              };
              _proto.getLocation = function getLocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                Vec2.set(out, this._x, this._y);
                return out;
              };
              _proto.getLocationInView = function getLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }
                Vec2.set(out, this._x, cclegacy.view._designResolutionSize.height - this._y);
                return out;
              };
              _proto.getUILocation = function getUILocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                Vec2.set(out, this._x, this._y);
                cclegacy.view._convertToUISpace(out);
                return out;
              };
              _proto.getPreviousLocation = function getPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                Vec2.set(out, this._prevX, this._prevY);
                return out;
              };
              _proto.getUIPreviousLocation = function getUIPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                Vec2.set(out, this._prevX, this._prevY);
                cclegacy.view._convertToUISpace(out);
                return out;
              };
              _proto.getDelta = function getDelta(out) {
                if (!out) {
                  out = new Vec2();
                }
                Vec2.set(out, this._x - this._prevX, this._y - this._prevY);
                return out;
              };
              _proto.getDeltaX = function getDeltaX() {
                return this._x - this._prevX;
              };
              _proto.getDeltaY = function getDeltaY() {
                return this._y - this._prevY;
              };
              _proto.getUIDelta = function getUIDelta(out) {
                if (!out) {
                  out = new Vec2();
                }
                var view = cclegacy.view;
                Vec2.set(out, (this._x - this._prevX) / view.getScaleX(), (this._y - this._prevY) / view.getScaleY());
                return out;
              };
              _proto.getUIDeltaX = function getUIDeltaX() {
                return (this._x - this._prevX) / cclegacy.view.getScaleX();
              };
              _proto.getUIDeltaY = function getUIDeltaY() {
                return (this._y - this._prevY) / cclegacy.view.getScaleY();
              };
              _proto.setButton = function setButton(button) {
                this._button = button;
              };
              _proto.getButton = function getButton() {
                return this._button;
              };
              _proto.getLocationX = function getLocationX() {
                return this._x;
              };
              _proto.getLocationY = function getLocationY() {
                return this._y;
              };
              _proto.getUILocationX = function getUILocationX() {
                var view = cclegacy.view;
                var viewport = view.getViewportRect();
                return (this._x - viewport.x) / view.getScaleX();
              };
              _proto.getUILocationY = function getUILocationY() {
                var view = cclegacy.view;
                var viewport = view.getViewportRect();
                return (this._y - viewport.y) / view.getScaleY();
              };
              _createClass(EventMouse, [{
                key: "eventType",
                get: function get() {
                  return this._eventType;
                }
              }]);
              return EventMouse;
            }(Event));
            EventMouse.BUTTON_MISSING = -1;
            EventMouse.BUTTON_LEFT = 0;
            EventMouse.BUTTON_RIGHT = 2;
            EventMouse.BUTTON_MIDDLE = 1;
            EventMouse.BUTTON_4 = 3;
            EventMouse.BUTTON_5 = 4;
            EventMouse.BUTTON_6 = 5;
            EventMouse.BUTTON_7 = 6;
            EventMouse.BUTTON_8 = 7;
            Event.EventMouse = EventMouse;

            var _vec2$1 = new Vec2();
            var EventTouch = exports("EventTouch", function (_Event) {
              _inheritsLoose(EventTouch, _Event);
              function EventTouch(changedTouches, bubbles, eventType, touches) {
                var _this;
                if (touches === undefined) {
                  touches = [];
                }
                _this = _Event.call(this, eventType, bubbles) || this;
                _this.touch = null;
                _this.simulate = false;
                _this.windowId = 0;
                _this.preventSwallow = false;
                _this._eventCode = eventType;
                _this._touches = changedTouches || [];
                _this._allTouches = touches;
                return _this;
              }
              var _proto = EventTouch.prototype;
              _proto.getEventCode = function getEventCode() {
                return this._eventCode;
              };
              _proto.getTouches = function getTouches() {
                return this._touches;
              };
              _proto.getAllTouches = function getAllTouches() {
                return this._allTouches;
              };
              _proto.setLocation = function setLocation(x, y) {
                if (this.touch) {
                  this.touch.setTouchInfo(this.touch.getID(), x, y);
                }
              };
              _proto.getLocation = function getLocation(out) {
                return this.touch ? this.touch.getLocation(out) : new Vec2();
              };
              _proto.getUILocation = function getUILocation(out) {
                return this.touch ? this.touch.getUILocation(out) : new Vec2();
              };
              _proto.getLocationInView = function getLocationInView(out) {
                return this.touch ? this.touch.getLocationInView(out) : new Vec2();
              };
              _proto.getPreviousLocation = function getPreviousLocation(out) {
                return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
              };
              _proto.getStartLocation = function getStartLocation(out) {
                return this.touch ? this.touch.getStartLocation(out) : new Vec2();
              };
              _proto.getUIStartLocation = function getUIStartLocation(out) {
                return this.touch ? this.touch.getUIStartLocation(out) : new Vec2();
              };
              _proto.getID = function getID() {
                return this.touch ? this.touch.getID() : null;
              };
              _proto.getDelta = function getDelta(out) {
                return this.touch ? this.touch.getDelta(out) : new Vec2();
              };
              _proto.getUIDelta = function getUIDelta(out) {
                return this.touch ? this.touch.getUIDelta(out) : new Vec2();
              };
              _proto.getDeltaX = function getDeltaX() {
                return this.touch ? this.touch.getDelta(_vec2$1).x : 0;
              };
              _proto.getDeltaY = function getDeltaY() {
                return this.touch ? this.touch.getDelta(_vec2$1).y : 0;
              };
              _proto.getLocationX = function getLocationX() {
                return this.touch ? this.touch.getLocationX() : 0;
              };
              _proto.getLocationY = function getLocationY() {
                return this.touch ? this.touch.getLocationY() : 0;
              };
              return EventTouch;
            }(Event));
            EventTouch.MAX_TOUCHES = 5;
            Event.EventTouch = EventTouch;

            var EventGamepad = exports("EventGamepad", function (_Event) {
              _inheritsLoose(EventGamepad, _Event);
              function EventGamepad(type, gamepad) {
                var _this;
                _this = _Event.call(this, type, false) || this;
                _this.gamepad = gamepad;
                return _this;
              }
              return EventGamepad;
            }(Event));

            var EventHandle = exports("EventHandle", function (_Event) {
              _inheritsLoose(EventHandle, _Event);
              function EventHandle(eventType, handleInputDevice) {
                var _this;
                _this = _Event.call(this, eventType, false) || this;
                _this.handleInputDevice = handleInputDevice;
                return _this;
              }
              return EventHandle;
            }(Event));

            var EventHMD = exports("EventHMD", function (_Event) {
              _inheritsLoose(EventHMD, _Event);
              function EventHMD(eventType, hmdInputDevice) {
                var _this;
                _this = _Event.call(this, eventType, false) || this;
                _this.hmdInputDevice = hmdInputDevice;
                return _this;
              }
              return EventHMD;
            }(Event));

            var EventHandheld = exports("EventHandheld", function (_Event) {
              _inheritsLoose(EventHandheld, _Event);
              function EventHandheld(eventType, handheldInputDevice) {
                var _this;
                _this = _Event.call(this, eventType, false) || this;
                _this.handheldInputDevice = handheldInputDevice;
                return _this;
              }
              return EventHandheld;
            }(Event));

            var Acceleration = exports("Acceleration", function Acceleration(x, y, z, timestamp) {
              if (x === undefined) {
                x = 0;
              }
              if (y === undefined) {
                y = 0;
              }
              if (z === undefined) {
                z = 0;
              }
              if (timestamp === undefined) {
                timestamp = 0;
              }
              this.x = x;
              this.y = y;
              this.z = z;
              this.timestamp = timestamp;
            });

            var SystemEventType = exports("SystemEventType", {
              TOUCH_START: "touch-start",
              TOUCH_MOVE: "touch-move",
              TOUCH_END: "touch-end",
              TOUCH_CANCEL: "touch-cancel",
              MOUSE_DOWN: "mouse-down",
              MOUSE_MOVE: "mouse-move",
              MOUSE_UP: "mouse-up",
              MOUSE_WHEEL: "mouse-wheel",
              MOUSE_ENTER: "mouse-enter",
              MOUSE_LEAVE: "mouse-leave",
              KEY_DOWN: "keydown",
              KEY_UP: "keyup",
              DEVICEMOTION: "devicemotion",
              TRANSFORM_CHANGED: "transform-changed",
              SCENE_CHANGED_FOR_PERSISTS: "scene-changed-for-persists",
              SIZE_CHANGED: "size-changed",
              ANCHOR_CHANGED: "anchor-changed",
              COLOR_CHANGED: "color-changed",
              CHILD_ADDED: "child-added",
              CHILD_REMOVED: "child-removed",
              PARENT_CHANGED: "parent-changed",
              NODE_DESTROYED: "node-destroyed",
              LAYER_CHANGED: "layer-changed",
              SIBLING_ORDER_CHANGED: "sibling-order-changed"
            });
            var InputEventType = {
              TOUCH_START: "touch-start",
              TOUCH_MOVE: "touch-move",
              TOUCH_END: "touch-end",
              TOUCH_CANCEL: "touch-cancel",
              MOUSE_DOWN: "mouse-down",
              MOUSE_MOVE: "mouse-move",
              MOUSE_UP: "mouse-up",
              MOUSE_LEAVE: "mouse-leave-window",
              MOUSE_ENTER: "mouse-enter-window",
              MOUSE_WHEEL: "mouse-wheel",
              KEY_DOWN: "keydown",
              KEY_PRESSING: "key-pressing",
              KEY_UP: "keyup",
              DEVICEMOTION: "devicemotion",
              GAMEPAD_INPUT: "gamepad-input",
              GAMEPAD_CHANGE: "gamepad-change",
              HANDLE_INPUT: "handle-input",
              HANDLE_POSE_INPUT: "handle-pose-input",
              HMD_POSE_INPUT: "hmd-pose-input",
              HANDHELD_POSE_INPUT: "handheld-pose-input"
            };
            cclegacy.SystemEventType = SystemEventType;

            var KeyCode = exports("KeyCode", {
              NONE: 0,
              MOBILE_BACK: 6,
              BACKSPACE: 8,
              TAB: 9,
              ENTER: 13,
              SHIFT_LEFT: 16,
              CTRL_LEFT: 17,
              ALT_LEFT: 18,
              PAUSE: 19,
              CAPS_LOCK: 20,
              ESCAPE: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              ARROW_LEFT: 37,
              ARROW_UP: 38,
              ARROW_RIGHT: 39,
              ARROW_DOWN: 40,
              INSERT: 45,
              DELETE: 46,
              DIGIT_0: 48,
              DIGIT_1: 49,
              DIGIT_2: 50,
              DIGIT_3: 51,
              DIGIT_4: 52,
              DIGIT_5: 53,
              DIGIT_6: 54,
              DIGIT_7: 55,
              DIGIT_8: 56,
              DIGIT_9: 57,
              KEY_A: 65,
              KEY_B: 66,
              KEY_C: 67,
              KEY_D: 68,
              KEY_E: 69,
              KEY_F: 70,
              KEY_G: 71,
              KEY_H: 72,
              KEY_I: 73,
              KEY_J: 74,
              KEY_K: 75,
              KEY_L: 76,
              KEY_M: 77,
              KEY_N: 78,
              KEY_O: 79,
              KEY_P: 80,
              KEY_Q: 81,
              KEY_R: 82,
              KEY_S: 83,
              KEY_T: 84,
              KEY_U: 85,
              KEY_V: 86,
              KEY_W: 87,
              KEY_X: 88,
              KEY_Y: 89,
              KEY_Z: 90,
              NUM_0: 96,
              NUM_1: 97,
              NUM_2: 98,
              NUM_3: 99,
              NUM_4: 100,
              NUM_5: 101,
              NUM_6: 102,
              NUM_7: 103,
              NUM_8: 104,
              NUM_9: 105,
              NUM_MULTIPLY: 106,
              NUM_PLUS: 107,
              NUM_SUBTRACT: 109,
              NUM_DECIMAL: 110,
              NUM_DIVIDE: 111,
              F1: 112,
              F2: 113,
              F3: 114,
              F4: 115,
              F5: 116,
              F6: 117,
              F7: 118,
              F8: 119,
              F9: 120,
              F10: 121,
              F11: 122,
              F12: 123,
              NUM_LOCK: 144,
              SCROLL_LOCK: 145,
              SEMICOLON: 186,
              EQUAL: 187,
              COMMA: 188,
              DASH: 189,
              PERIOD: 190,
              SLASH: 191,
              BACK_QUOTE: 192,
              BRACKET_LEFT: 219,
              BACKSLASH: 220,
              BRACKET_RIGHT: 221,
              QUOTE: 222,
              SHIFT_RIGHT: 2000,
              CTRL_RIGHT: 2001,
              ALT_RIGHT: 2002,
              NUM_ENTER: 2003
            });

            var _vec2 = new Vec2();
            var Touch = exports("Touch", function () {
              function Touch(x, y, id) {
                if (id === undefined) {
                  id = 0;
                }
                this._point = new Vec2();
                this._prevPoint = new Vec2();
                this._lastModified = 0;
                this._id = 0;
                this._startPoint = new Vec2();
                this._startPointCaptured = false;
                this.setTouchInfo(id, x, y);
              }
              var _proto = Touch.prototype;
              _proto.getLocation = function getLocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._point.x, this._point.y);
                return out;
              };
              _proto.getLocationX = function getLocationX() {
                return this._point.x;
              };
              _proto.getLocationY = function getLocationY() {
                return this._point.y;
              };
              _proto.getUILocation = function getUILocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._point.x, this._point.y);
                cclegacy.view._convertToUISpace(out);
                return out;
              };
              _proto.getUILocationX = function getUILocationX() {
                var view = cclegacy.view;
                var viewport = view.getViewportRect();
                return (this._point.x - viewport.x) / view.getScaleX();
              };
              _proto.getUILocationY = function getUILocationY() {
                var view = cclegacy.view;
                var viewport = view.getViewportRect();
                return (this._point.y - viewport.y) / view.getScaleY();
              };
              _proto.getPreviousLocation = function getPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._prevPoint.x, this._prevPoint.y);
                return out;
              };
              _proto.getUIPreviousLocation = function getUIPreviousLocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._prevPoint.x, this._prevPoint.y);
                cclegacy.view._convertToUISpace(out);
                return out;
              };
              _proto.getStartLocation = function getStartLocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._startPoint.x, this._startPoint.y);
                return out;
              };
              _proto.getUIStartLocation = function getUIStartLocation(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._startPoint.x, this._startPoint.y);
                cclegacy.view._convertToUISpace(out);
                return out;
              };
              _proto.getDelta = function getDelta(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._point);
                out.subtract(this._prevPoint);
                return out;
              };
              _proto.getUIDelta = function getUIDelta(out) {
                if (!out) {
                  out = new Vec2();
                }
                _vec2.set(this._point);
                _vec2.subtract(this._prevPoint);
                var view = cclegacy.view;
                out.set(view.getScaleX(), view.getScaleY());
                Vec2.divide(out, _vec2, out);
                return out;
              };
              _proto.getLocationInView = function getLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._point.x, cclegacy.view._designResolutionSize.height - this._point.y);
                return out;
              };
              _proto.getPreviousLocationInView = function getPreviousLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._prevPoint.x, cclegacy.view._designResolutionSize.height - this._prevPoint.y);
                return out;
              };
              _proto.getStartLocationInView = function getStartLocationInView(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._startPoint.x, cclegacy.view._designResolutionSize.height - this._startPoint.y);
                return out;
              };
              _proto.getID = function getID() {
                return this._id;
              };
              _proto.setTouchInfo = function setTouchInfo(id, x, y) {
                if (id === undefined) {
                  id = 0;
                }
                if (x === undefined) {
                  x = 0;
                }
                if (y === undefined) {
                  y = 0;
                }
                this._prevPoint = this._point;
                this._point = new Vec2(x || 0, y || 0);
                this._id = id;
                if (!this._startPointCaptured) {
                  this._startPoint = new Vec2(this._point);
                  this._startPointCaptured = true;
                }
              };
              _proto.setPoint = function setPoint(x, y) {
                if (typeof x === 'object') {
                  this._point.x = x.x;
                  this._point.y = x.y;
                } else {
                  this._point.x = x || 0;
                  this._point.y = y || 0;
                }
                this._lastModified = cclegacy.game.frameStartTime;
              };
              _proto.setPrevPoint = function setPrevPoint(x, y) {
                if (typeof x === 'object') {
                  this._prevPoint = new Vec2(x.x, x.y);
                } else {
                  this._prevPoint = new Vec2(x || 0, y || 0);
                }
                this._lastModified = cclegacy.game.frameStartTime;
              };
              _proto.clone = function clone() {
                var touchID = this.getID();
                this.getStartLocation(_vec2);
                var clonedTouch = new Touch(_vec2.x, _vec2.y, touchID);
                this.getLocation(_vec2);
                clonedTouch.setPoint(_vec2.x, _vec2.y);
                this.getPreviousLocation(_vec2);
                clonedTouch.setPrevPoint(_vec2);
                return clonedTouch;
              };
              _createClass(Touch, [{
                key: "lastModified",
                get: function get() {
                  return this._lastModified;
                }
              }]);
              return Touch;
            }());
            cclegacy.Touch = Touch;

            var _arrayPool = new Pool(function () {
              return new Array(16);
            }, 3);
            var _currentHovered = null;
            var pos = new Vec2();
            var _touchEvents = ["touch-start", "touch-move", "touch-end", "touch-cancel"];
            var _mouseEvents = ["mouse-down", "mouse-enter", "mouse-move", "mouse-leave", "mouse-up", "mouse-wheel"];
            var globalCallbacksInvoker = new CallbacksInvoker();
            var NodeEventProcessor = function () {
              function NodeEventProcessor(node) {
                this.claimedTouchIdList = [];
                this.maskList = null;
                this.cachedCameraPriority = 0;
                this.previousMouseIn = false;
                this.bubblingTarget = null;
                this.capturingTarget = null;
                this.shouldHandleEventMouse = false;
                this.shouldHandleEventTouch = false;
                this._dispatchingTouch = null;
                this._isEnabled = false;
                this._isMouseLeaveWindow = false;
                this._node = node;
              }
              var _proto = NodeEventProcessor.prototype;
              _proto.setEnabled = function setEnabled(value, recursive) {
                if (recursive === undefined) {
                  recursive = false;
                }
                if (this._isEnabled === value) {
                  return;
                }
                this._isEnabled = value;
                var node = this.node;
                var children = node.children;
                if (value) {
                  this._attachMask();
                }
                globalCallbacksInvoker.emit(2);
                if (recursive && children.length > 0) {
                  for (var i = 0; i < children.length; ++i) {
                    var child = children[i];
                    child.eventProcessor.setEnabled(value, true);
                  }
                }
              };
              _proto.reattach = function reattach() {
                this.node.walk(function (node) {
                  var eventProcessor = node.eventProcessor;
                  var currentMaskList = eventProcessor._searchComponentsInParent(NodeEventProcessor._maskComp);
                  eventProcessor.maskList = currentMaskList;
                });
              };
              _proto.destroy = function destroy() {
                if (_currentHovered === this._node) {
                  _currentHovered = null;
                }
                if (this.capturingTarget) this.capturingTarget.clear();
                if (this.bubblingTarget) this.bubblingTarget.clear();
                globalCallbacksInvoker.emit(1, this);
                if (this._dispatchingTouch) {
                  var cancelEvent = new EventTouch([this._dispatchingTouch], true, "touch-cancel");
                  cancelEvent.touch = this._dispatchingTouch;
                  this.dispatchEvent(cancelEvent);
                  this._dispatchingTouch = null;
                }
              };
              _proto.on = function on(type, callback, target, useCapture) {
                this._tryEmittingAddEvent(type);
                useCapture = !!useCapture;
                var invoker;
                if (useCapture) {
                  var _this$capturingTarget;
                  invoker = (_this$capturingTarget = this.capturingTarget) !== null && _this$capturingTarget !== undefined ? _this$capturingTarget : this.capturingTarget = this._newCallbacksInvoker();
                } else {
                  var _this$bubblingTarget;
                  invoker = (_this$bubblingTarget = this.bubblingTarget) !== null && _this$bubblingTarget !== undefined ? _this$bubblingTarget : this.bubblingTarget = this._newCallbacksInvoker();
                }
                invoker.on(type, callback, target);
                return callback;
              };
              _proto.once = function once(type, callback, target, useCapture) {
                this._tryEmittingAddEvent(type);
                useCapture = !!useCapture;
                var invoker;
                if (useCapture) {
                  var _this$capturingTarget2;
                  invoker = (_this$capturingTarget2 = this.capturingTarget) !== null && _this$capturingTarget2 !== undefined ? _this$capturingTarget2 : this.capturingTarget = this._newCallbacksInvoker();
                } else {
                  var _this$bubblingTarget2;
                  invoker = (_this$bubblingTarget2 = this.bubblingTarget) !== null && _this$bubblingTarget2 !== undefined ? _this$bubblingTarget2 : this.bubblingTarget = this._newCallbacksInvoker();
                }
                invoker.on(type, callback, target, true);
                return callback;
              };
              _proto.off = function off(type, callback, target, useCapture) {
                var _invoker;
                useCapture = !!useCapture;
                var invoker;
                if (useCapture) {
                  invoker = this.capturingTarget;
                } else {
                  invoker = this.bubblingTarget;
                }
                (_invoker = invoker) == null ? undefined : _invoker.off(type, callback, target);
              };
              _proto.targetOff = function targetOff(target) {
                var _this$capturingTarget3, _this$bubblingTarget3;
                (_this$capturingTarget3 = this.capturingTarget) == null ? undefined : _this$capturingTarget3.removeAll(target);
                (_this$bubblingTarget3 = this.bubblingTarget) == null ? undefined : _this$bubblingTarget3.removeAll(target);
                if (this.shouldHandleEventTouch && !this._hasTouchListeners()) {
                  this.shouldHandleEventTouch = false;
                }
                if (this.shouldHandleEventMouse && !this._hasMouseListeners()) {
                  this.shouldHandleEventMouse = false;
                }
                if (!this._hasPointerListeners()) {
                  globalCallbacksInvoker.emit(1, this);
                }
              };
              _proto.emit = function emit(type, arg0, arg1, arg2, arg3, arg4) {
                var _this$bubblingTarget4;
                (_this$bubblingTarget4 = this.bubblingTarget) == null ? undefined : _this$bubblingTarget4.emit(type, arg0, arg1, arg2, arg3, arg4);
              };
              _proto.dispatchEvent = function dispatchEvent(event) {
                var owner = this.node;
                var target;
                var i = 0;
                event.target = owner;
                var cachedArray = _arrayPool.alloc();
                cachedArray.length = 0;
                this.getCapturingTargets(event.type, cachedArray);
                event.eventPhase = 1;
                for (i = cachedArray.length - 1; i >= 0; --i) {
                  target = cachedArray[i];
                  if (target.eventProcessor.capturingTarget) {
                    event.currentTarget = target;
                    target.eventProcessor.capturingTarget.emit(event.type, event, cachedArray);
                    if (event.propagationStopped) {
                      _arrayPool.free(cachedArray);
                      return;
                    }
                  }
                }
                event.eventPhase = 2;
                event.currentTarget = owner;
                if (this.capturingTarget) {
                  this.capturingTarget.emit(event.type, event);
                }
                if (!event.propagationImmediateStopped && this.bubblingTarget) {
                  this.bubblingTarget.emit(event.type, event);
                }
                if (!event.propagationStopped && event.bubbles) {
                  cachedArray.length = 0;
                  this.getBubblingTargets(event.type, cachedArray);
                  event.eventPhase = 3;
                  for (i = 0; i < cachedArray.length; ++i) {
                    target = cachedArray[i];
                    if (target.eventProcessor.bubblingTarget) {
                      event.currentTarget = target;
                      target.eventProcessor.bubblingTarget.emit(event.type, event);
                      if (event.propagationStopped) {
                        _arrayPool.free(cachedArray);
                        return;
                      }
                    }
                  }
                }
                _arrayPool.free(cachedArray);
              };
              _proto.hasEventListener = function hasEventListener(type, callback, target) {
                var has = false;
                if (this.bubblingTarget) {
                  has = this.bubblingTarget.hasEventListener(type, callback, target);
                }
                if (!has && this.capturingTarget) {
                  has = this.capturingTarget.hasEventListener(type, callback, target);
                }
                return has;
              };
              _proto.getCapturingTargets = function getCapturingTargets(type, targets) {
                var parent = this._node.parent;
                while (parent) {
                  var _parent$eventProcesso;
                  if ((_parent$eventProcesso = parent.eventProcessor.capturingTarget) != null && _parent$eventProcesso.hasEventListener(type)) {
                    targets.push(parent);
                  }
                  parent = parent.parent;
                }
              };
              _proto.getBubblingTargets = function getBubblingTargets(type, targets) {
                var parent = this._node.parent;
                while (parent) {
                  var _parent$eventProcesso2;
                  if ((_parent$eventProcesso2 = parent.eventProcessor.bubblingTarget) != null && _parent$eventProcesso2.hasEventListener(type)) {
                    targets.push(parent);
                  }
                  parent = parent.parent;
                }
              };
              _proto.onUpdatingSiblingIndex = function onUpdatingSiblingIndex() {
                globalCallbacksInvoker.emit(2);
              };
              _proto._searchComponentsInParent = function _searchComponentsInParent(ctor) {
                var node = this.node;
                if (ctor) {
                  var index = 0;
                  var list = [];
                  for (var curr = node; curr && cclegacy.Node.isNode(curr); curr = curr.parent, ++index) {
                    var comp = curr.getComponent(ctor);
                    if (comp) {
                      var next = {
                        index: index,
                        comp: comp
                      };
                      if (list) {
                        list.push(next);
                      } else {
                        list = [next];
                      }
                    }
                  }
                  return list.length > 0 ? list : null;
                }
                return null;
              };
              _proto._attachMask = function _attachMask() {
                this.maskList = this._searchComponentsInParent(NodeEventProcessor._maskComp);
              };
              _proto._isTouchEvent = function _isTouchEvent(type) {
                var index = _touchEvents.indexOf(type);
                return index !== -1;
              };
              _proto._isMouseEvent = function _isMouseEvent(type) {
                var index = _mouseEvents.indexOf(type);
                return index !== -1;
              };
              _proto._hasTouchListeners = function _hasTouchListeners() {
                for (var i = 0; i < _touchEvents.length; ++i) {
                  var eventType = _touchEvents[i];
                  if (this.hasEventListener(eventType)) {
                    return true;
                  }
                }
                return false;
              };
              _proto._hasMouseListeners = function _hasMouseListeners() {
                for (var i = 0; i < _mouseEvents.length; ++i) {
                  var eventType = _mouseEvents[i];
                  if (this.hasEventListener(eventType)) {
                    return true;
                  }
                }
                return false;
              };
              _proto._hasPointerListeners = function _hasPointerListeners() {
                var has = this._hasTouchListeners();
                if (has) {
                  return true;
                }
                return this._hasMouseListeners();
              };
              _proto._tryEmittingAddEvent = function _tryEmittingAddEvent(typeToAdd) {
                var isTouchEvent = this._isTouchEvent(typeToAdd);
                var isMouseEvent = this._isMouseEvent(typeToAdd);
                if (isTouchEvent) {
                  this.shouldHandleEventTouch = true;
                } else if (isMouseEvent) {
                  this.shouldHandleEventMouse = true;
                }
                if ((isTouchEvent || isMouseEvent) && !this._hasPointerListeners()) {
                  globalCallbacksInvoker.emit(0, this);
                }
              };
              _proto._newCallbacksInvoker = function _newCallbacksInvoker() {
                var _this = this;
                var callbacksInvoker = new CallbacksInvoker();
                callbacksInvoker._registerOffCallback(function () {
                  if (_this.shouldHandleEventTouch && !_this._hasTouchListeners()) {
                    _this.shouldHandleEventTouch = false;
                  }
                  if (_this.shouldHandleEventMouse && !_this._hasMouseListeners()) {
                    _this.shouldHandleEventMouse = false;
                  }
                  if (!_this._hasPointerListeners()) {
                    globalCallbacksInvoker.emit(1, _this);
                  }
                });
                return callbacksInvoker;
              };
              _proto._handleEventMouse = function _handleEventMouse(eventMouse) {
                switch (eventMouse.type) {
                  case "mouse-down":
                    return this._handleMouseDown(eventMouse);
                  case "mouse-move":
                    return this._handleMouseMove(eventMouse);
                  case "mouse-up":
                    return this._handleMouseUp(eventMouse);
                  case "mouse-wheel":
                    return this._handleMouseWheel(eventMouse);
                  case "mouse-leave-window":
                    return this._handleMouseLeave(eventMouse);
                  case "mouse-enter-window":
                    return this._handleMouseEnter(eventMouse);
                  default:
                    return false;
                }
              };
              _proto._handleMouseDown = function _handleMouseDown(event) {
                var node = this._node;
                var uiTransformComp = node._getUITransformComp();
                if (!node || !uiTransformComp) {
                  return false;
                }
                event.getLocation(pos);
                if (uiTransformComp.hitTest(pos, event.windowId)) {
                  event.type = "mouse-down";
                  event.bubbles = true;
                  node.dispatchEvent(event);
                  event.propagationStopped = true;
                  return true;
                }
                return false;
              };
              _proto._handleMouseMove = function _handleMouseMove(event) {
                var node = this._node;
                var uiTransformComp = node._getUITransformComp();
                if (!node || !uiTransformComp || this._isMouseLeaveWindow) {
                  return false;
                }
                event.getLocation(pos);
                var hit = uiTransformComp.hitTest(pos, event.windowId);
                if (hit) {
                  if (!this.previousMouseIn) {
                    if (_currentHovered && _currentHovered !== node) {
                      event.type = "mouse-leave";
                      _currentHovered.dispatchEvent(event);
                      _currentHovered.eventProcessor.previousMouseIn = false;
                    }
                    _currentHovered = node;
                    event.type = "mouse-enter";
                    node.dispatchEvent(event);
                    this.previousMouseIn = true;
                  }
                  event.type = "mouse-move";
                  event.bubbles = true;
                  node.dispatchEvent(event);
                  event.propagationStopped = true;
                  return true;
                } else if (this.previousMouseIn) {
                  event.type = "mouse-leave";
                  node.dispatchEvent(event);
                  this.previousMouseIn = false;
                  _currentHovered = null;
                }
                return false;
              };
              _proto._handleMouseUp = function _handleMouseUp(event) {
                var node = this._node;
                var uiTransformComp = node._getUITransformComp();
                if (!node || !uiTransformComp) {
                  return false;
                }
                event.getLocation(pos);
                if (uiTransformComp.hitTest(pos, event.windowId)) {
                  event.type = "mouse-up";
                  event.bubbles = true;
                  node.dispatchEvent(event);
                  event.propagationStopped = true;
                  return true;
                }
                return false;
              };
              _proto._handleMouseWheel = function _handleMouseWheel(event) {
                var node = this._node;
                var uiTransformComp = node._getUITransformComp();
                if (!node || !uiTransformComp) {
                  return false;
                }
                event.getLocation(pos);
                if (uiTransformComp.hitTest(pos, event.windowId)) {
                  event.type = "mouse-wheel";
                  event.bubbles = true;
                  node.dispatchEvent(event);
                  event.propagationStopped = true;
                  return true;
                }
                return false;
              };
              _proto._handleMouseLeave = function _handleMouseLeave(event) {
                this._isMouseLeaveWindow = true;
                if (this.previousMouseIn) {
                  event.type = "mouse-leave";
                  this._node.dispatchEvent(event);
                  this.previousMouseIn = false;
                  _currentHovered = null;
                }
                return false;
              };
              _proto._handleMouseEnter = function _handleMouseEnter(event) {
                this._isMouseLeaveWindow = false;
                return false;
              };
              _proto._handleEventTouch = function _handleEventTouch(eventTouch) {
                try {
                  switch (eventTouch.type) {
                    case "touch-start":
                      return this._handleTouchStart(eventTouch);
                    case "touch-move":
                      return this._handleTouchMove(eventTouch);
                    case "touch-end":
                      return this._handleTouchEnd(eventTouch);
                    case "touch-cancel":
                      return this._handleTouchCancel(eventTouch);
                    default:
                      return false;
                  }
                } catch (err) {
                  this.claimedTouchIdList.length = 0;
                  throw err;
                }
              };
              _proto._handleTouchStart = function _handleTouchStart(event) {
                var node = this.node;
                var uiTransformComp = node._getUITransformComp();
                if (!node || !uiTransformComp) {
                  return false;
                }
                event.getLocation(pos);
                if (uiTransformComp.hitTest(pos, event.windowId)) {
                  event.type = "touch-start";
                  event.bubbles = true;
                  this._dispatchingTouch = event.touch;
                  node.dispatchEvent(event);
                  return true;
                }
                return false;
              };
              _proto._handleTouchMove = function _handleTouchMove(event) {
                var node = this.node;
                if (!node || !node._getUITransformComp()) {
                  return false;
                }
                event.type = "touch-move";
                event.bubbles = true;
                this._dispatchingTouch = event.touch;
                node.dispatchEvent(event);
                return true;
              };
              _proto._handleTouchEnd = function _handleTouchEnd(event) {
                var node = this.node;
                var uiTransformComp = node._getUITransformComp();
                if (!node || !uiTransformComp) {
                  return;
                }
                event.getLocation(pos);
                if (uiTransformComp.hitTest(pos, event.windowId)) {
                  event.type = "touch-end";
                } else {
                  event.type = "touch-cancel";
                }
                event.bubbles = true;
                node.dispatchEvent(event);
                this._dispatchingTouch = null;
              };
              _proto._handleTouchCancel = function _handleTouchCancel(event) {
                var node = this.node;
                if (!node || !node._getUITransformComp()) {
                  return;
                }
                event.type = "touch-cancel";
                event.bubbles = true;
                node.dispatchEvent(event);
                this._dispatchingTouch = null;
              };
              _createClass(NodeEventProcessor, [{
                key: "isEnabled",
                get: function get() {
                  return this._isEnabled;
                }
              }, {
                key: "node",
                get: function get() {
                  return this._node;
                }
              }]);
              return NodeEventProcessor;
            }();
            NodeEventProcessor._maskComp = null;
            NodeEventProcessor.callbacksInvoker = globalCallbacksInvoker;
            cclegacy.NodeEventProcessor = NodeEventProcessor;

            var _dec$G, _dec2$q, _dec3$m, _class$H, _class2$C, _initializer$z, _initializer2$r, _initializer3$l, _initializer4$h, _initializer5$e, _initializer6$a, _initializer7$9, _initializer8$9, _initializer9$8, _initializer10$7, _initializer11$6, _class3$c;
            var Destroying = 128;
            var DontDestroy = 64;
            var Deactivating$1 = 256;
            var TRANSFORM_CHANGED = "transform-changed";
            var ACTIVE_CHANGED = "active-changed";
            var TRANSFORM_ON = 1 << 0;
            var ACTIVE_ON = 1 << 1;
            var idGenerator = new IDGenerator('Node');
            function getConstructor(typeOrClassName) {
              if (!typeOrClassName) {
                errorID(3804);
                return null;
              }
              if (typeof typeOrClassName === 'string') {
                return getClassByName(typeOrClassName);
              }
              return typeOrClassName;
            }
            var v3_a = v3();
            var v3_b = v3();
            var q_a = quat();
            var q_b = quat();
            var qt_1 = quat();
            var m3_1 = new Mat3();
            var m4_1$4 = mat4();
            var m4_2$1 = mat4();
            var dirtyNodes = [];
            var reserveContentsForAllSyncablePrefabTag = Symbol('ReserveContentsForAllSyncablePrefab');
            var globalFlagChangeVersion = 0;
            var Node$1 = (_dec$G = ccclass$6('cc.Node'), _dec2$q = type$5(Vec3), _dec3$m = type$5(MobilityMode), _dec$G(_class$H = (_class2$C = (_class3$c = function (_CCObject) {
              _inheritsLoose(Node, _CCObject);
              var _proto = Node.prototype;
              _proto._setActiveInHierarchy = function _setActiveInHierarchy(v) {
                this._activeInHierarchy = v;
              };
              Node._setScene = function _setScene(node) {
                node._updateScene();
              };
              Node._incSkewCompCount = function _incSkewCompCount() {
              };
              Node._decSkewCompCount = function _decSkewCompCount() {
              };
              Node._findComponent = function _findComponent(node, constructor) {
                var cls = constructor;
                var comps = node._components;
                if (cls._sealed) {
                  for (var i = 0; i < comps.length; ++i) {
                    var comp = comps[i];
                    if (comp.constructor === constructor) {
                      return comp;
                    }
                  }
                } else {
                  for (var _i = 0; _i < comps.length; ++_i) {
                    var _comp = comps[_i];
                    if (_comp instanceof constructor) {
                      return _comp;
                    }
                  }
                }
                return null;
              };
              Node._findComponents = function _findComponents(node, constructor, components) {
                var cls = constructor;
                var comps = node._components;
                if (cls._sealed) {
                  for (var i = 0; i < comps.length; ++i) {
                    var comp = comps[i];
                    if (comp.constructor === constructor) {
                      components.push(comp);
                    }
                  }
                } else {
                  for (var _i2 = 0; _i2 < comps.length; ++_i2) {
                    var _comp2 = comps[_i2];
                    if (_comp2 instanceof constructor) {
                      components.push(_comp2);
                    }
                  }
                }
              };
              Node._findChildComponent = function _findChildComponent(children, constructor) {
                for (var i = 0; i < children.length; ++i) {
                  var node = children[i];
                  var comp = Node._findComponent(node, constructor);
                  if (comp) {
                    return comp;
                  }
                  if (node._children.length > 0) {
                    comp = Node._findChildComponent(node._children, constructor);
                    if (comp) {
                      return comp;
                    }
                  }
                }
                return null;
              };
              Node._findChildComponents = function _findChildComponents(children, constructor, components) {
                for (var i = 0; i < children.length; ++i) {
                  var node = children[i];
                  Node._findComponents(node, constructor, components);
                  if (node._children.length > 0) {
                    Node._findChildComponents(node._children, constructor, components);
                  }
                }
              };
              _proto.getWritableComponents = function getWritableComponents() {
                return this._components;
              };
              _proto._updateScene = function _updateScene() {
                if (this._parent == null) {
                  errorID(1640, this.name, this.uuid);
                } else {
                  this._scene = this._parent._scene;
                }
              };
              _proto.attr = function attr(attrs) {
                mixin(this, attrs);
              };
              _proto.getParent = function getParent() {
                return this._parent;
              };
              _proto.modifyParent = function modifyParent(parent) {
                this._parent = parent;
              };
              _proto.setParent = function setParent(value, keepWorldTransform) {
                if (keepWorldTransform === undefined) {
                  keepWorldTransform = false;
                }
                if (keepWorldTransform) {
                  this.updateWorldTransform();
                }
                if (this._parent === value) {
                  return;
                }
                var oldParent = this._parent;
                var newParent = value;
                if (oldParent && oldParent._objFlags & Deactivating$1) {
                  errorID(3821);
                }
                this._parent = newParent;
                this._siblingIndex = 0;
                this._onSetParent(oldParent, keepWorldTransform);
                if (this.emit) {
                  this.emit("parent-changed", oldParent);
                }
                if (oldParent) {
                  if (!(oldParent._objFlags & Destroying)) {
                    var removeAt = oldParent._children.indexOf(this);
                    oldParent._children.splice(removeAt, 1);
                    oldParent._updateSiblingIndex();
                    if (oldParent.emit) {
                      oldParent.emit("child-removed", this);
                    }
                  }
                }
                if (newParent) {
                  if (newParent._objFlags & Deactivating$1) {
                    errorID(3821);
                  }
                  newParent._children.push(this);
                  this._siblingIndex = newParent._children.length - 1;
                  if (newParent.emit) {
                    newParent.emit("child-added", this);
                  }
                }
                this._onHierarchyChanged(oldParent);
              };
              _proto.getChildByUuid = function getChildByUuid(uuid) {
                if (!uuid) {
                  log('Invalid uuid');
                  return null;
                }
                var locChildren = this._children;
                for (var i = 0, len = locChildren.length; i < len; i++) {
                  if (locChildren[i]._id === uuid) {
                    return locChildren[i];
                  }
                }
                return null;
              };
              _proto.getChildByName = function getChildByName(name) {
                if (!name) {
                  log('Invalid name');
                  return null;
                }
                var locChildren = this._children;
                for (var i = 0, len = locChildren.length; i < len; i++) {
                  if (locChildren[i]._name === name) {
                    return locChildren[i];
                  }
                }
                return null;
              };
              _proto.getChildByPath = function getChildByPath(path) {
                var segments = path.split('/');
                var lastNode = this;
                var _loop = function _loop() {
                    var segment = segments[i];
                    if (segment.length === 0) {
                      return 0;
                    }
                    var next = lastNode.children.find(function (childNode) {
                      return childNode.name === segment;
                    });
                    if (!next) {
                      return {
                        v: null
                      };
                    }
                    lastNode = next;
                  },
                  _ret;
                for (var i = 0; i < segments.length; ++i) {
                  _ret = _loop();
                  if (_ret === 0) continue;
                  if (_ret) return _ret.v;
                }
                return lastNode;
              };
              _proto.addChild = function addChild(child) {
                child.setParent(this);
              };
              _proto.insertChild = function insertChild(child, siblingIndex) {
                child.setParent(this);
                child.setSiblingIndex(siblingIndex);
              };
              _proto.getSiblingIndex = function getSiblingIndex() {
                return this._siblingIndex;
              };
              _proto.setSiblingIndex = function setSiblingIndex(index) {
                if (!this._parent) {
                  return;
                }
                if (this._parent._objFlags & Deactivating$1) {
                  errorID(3821);
                  return;
                }
                var siblings = this._parent._children;
                index = index >= 0 ? index : siblings.length + index;
                var oldIndex = siblings.indexOf(this);
                if (index !== oldIndex) {
                  siblings.splice(oldIndex, 1);
                  if (index < siblings.length) {
                    siblings.splice(index, 0, this);
                  } else {
                    siblings.push(this);
                  }
                  this._parent._updateSiblingIndex();
                  if (this._onSiblingIndexChanged) {
                    this._onSiblingIndexChanged(index);
                  }
                  this._eventProcessor.onUpdatingSiblingIndex();
                }
              };
              _proto.walk = function walk(preFunc, postFunc) {
                var index = 1;
                var children = null;
                var curr = null;
                var i = 0;
                var stack = Node._stacks[Node._stackId];
                if (!stack) {
                  stack = [];
                  Node._stacks.push(stack);
                }
                Node._stackId++;
                stack.length = 0;
                stack[0] = this;
                var parent = null;
                var afterChildren = false;
                while (index) {
                  index--;
                  curr = stack[index];
                  if (!curr) {
                    continue;
                  }
                  if (!afterChildren && preFunc) {
                    preFunc(curr);
                  } else if (afterChildren && postFunc) {
                    postFunc(curr);
                  }
                  stack[index] = null;
                  if (afterChildren) {
                    if (parent === this._parent) break;
                    afterChildren = false;
                  } else {
                    if (curr._children.length > 0) {
                      parent = curr;
                      children = curr._children;
                      i = 0;
                      stack[index] = children[i];
                      index++;
                    } else {
                      stack[index] = curr;
                      index++;
                      afterChildren = true;
                    }
                    continue;
                  }
                  if (children) {
                    i++;
                    if (children[i]) {
                      stack[index] = children[i];
                      index++;
                    } else if (parent) {
                      stack[index] = parent;
                      index++;
                      afterChildren = true;
                      if (parent._parent) {
                        children = parent._parent._children;
                        i = children.indexOf(parent);
                        parent = parent._parent;
                      } else {
                        parent = null;
                        children = null;
                      }
                      if (i < 0) {
                        break;
                      }
                    }
                  }
                }
                stack.length = 0;
                Node._stackId--;
              };
              _proto.removeFromParent = function removeFromParent() {
                if (this._parent) {
                  this._parent.removeChild(this);
                }
              };
              _proto.removeChild = function removeChild(child) {
                if (this._children.indexOf(child) > -1) {
                  child.parent = null;
                }
              };
              _proto.removeAllChildren = function removeAllChildren() {
                var children = this._children;
                for (var i = children.length - 1; i >= 0; i--) {
                  var node = children[i];
                  if (node) {
                    node.parent = null;
                  }
                }
                this._children.length = 0;
              };
              _proto.isChildOf = function isChildOf(parent) {
                var child = this;
                do {
                  if (child === parent) {
                    return true;
                  }
                  child = child._parent;
                } while (child);
                return false;
              };
              _proto.getComponent = function getComponent(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                if (constructor) {
                  return Node._findComponent(this, constructor);
                }
                return null;
              };
              _proto.getComponents = function getComponents(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                var components = [];
                if (constructor) {
                  Node._findComponents(this, constructor, components);
                }
                return components;
              };
              _proto.getComponentInChildren = function getComponentInChildren(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                if (constructor) {
                  return Node._findChildComponent(this._children, constructor);
                }
                return null;
              };
              _proto.getComponentsInChildren = function getComponentsInChildren(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                var components = [];
                if (constructor) {
                  Node._findComponents(this, constructor, components);
                  Node._findChildComponents(this._children, constructor, components);
                }
                return components;
              };
              _proto.addComponent = function addComponent(typeOrClassName) {
                var constructor;
                if (typeof typeOrClassName === 'string') {
                  constructor = getClassByName(typeOrClassName);
                  if (!constructor) {
                    if (cclegacy._RF.peek()) {
                      errorID(3808, typeOrClassName);
                    }
                    throw TypeError(getError(3807, typeOrClassName));
                  }
                } else {
                  if (!typeOrClassName) {
                    throw TypeError(getError(3804));
                  }
                  constructor = typeOrClassName;
                }
                if (typeof constructor !== 'function') {
                  throw TypeError(getError(3809));
                }
                if (!isChildClassOf(constructor, cclegacy.Component)) {
                  throw TypeError(getError(3810));
                }
                var reqComps = constructor._requireComponent;
                if (reqComps) {
                  if (Array.isArray(reqComps)) {
                    for (var i = 0; i < reqComps.length; i++) {
                      var reqComp = reqComps[i];
                      if (!this.getComponent(reqComp)) {
                        this.addComponent(reqComp);
                      }
                    }
                  } else {
                    var _reqComp = reqComps;
                    if (!this.getComponent(_reqComp)) {
                      this.addComponent(_reqComp);
                    }
                  }
                }
                var component = new constructor();
                component.node = this;
                this._components.push(component);
                this.emit("component-added", component);
                if (this._activeInHierarchy) {
                  cclegacy.director._nodeActivator.activateComp(component);
                }
                return component;
              };
              _proto.removeComponent = function removeComponent(component) {
                if (!component) {
                  errorID(3813);
                  return;
                }
                var componentInstance = null;
                if (component instanceof Component) {
                  componentInstance = component;
                } else {
                  componentInstance = this.getComponent(component);
                }
                if (componentInstance) {
                  componentInstance.destroy();
                }
              };
              _proto.on = function on(type, callback, target, useCapture) {
                if (useCapture === undefined) {
                  useCapture = false;
                }
                switch (type) {
                  case TRANSFORM_CHANGED:
                    this._eventMask |= TRANSFORM_ON;
                    break;
                  case ACTIVE_CHANGED:
                    this._eventMask |= ACTIVE_ON;
                    break;
                }
                this._eventProcessor.on(type, callback, target, useCapture);
              };
              _proto.off = function off(type, callback, target, useCapture) {
                if (useCapture === undefined) {
                  useCapture = false;
                }
                this._eventProcessor.off(type, callback, target, useCapture);
                var hasListeners = this._eventProcessor.hasEventListener(type);
                if (!hasListeners) {
                  switch (type) {
                    case TRANSFORM_CHANGED:
                      this._eventMask &= -2;
                      break;
                    case ACTIVE_CHANGED:
                      this._eventMask &= -3;
                      break;
                  }
                }
              };
              _proto.once = function once(type, callback, target, useCapture) {
                this._eventProcessor.once(type, callback, target, useCapture);
              };
              _proto.emit = function emit(type, arg0, arg1, arg2, arg3, arg4) {
                this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
              };
              _proto.dispatchEvent = function dispatchEvent(event) {
                this._eventProcessor.dispatchEvent(event);
              };
              _proto.hasEventListener = function hasEventListener(type, callback, target) {
                return this._eventProcessor.hasEventListener(type, callback, target);
              };
              _proto.targetOff = function targetOff(target) {
                this._eventProcessor.targetOff(target);
                if (this._eventMask & TRANSFORM_ON && !this._eventProcessor.hasEventListener(TRANSFORM_CHANGED)) {
                  this._eventMask &= -2;
                }
                if (this._eventMask & ACTIVE_ON && !this._eventProcessor.hasEventListener(ACTIVE_CHANGED)) {
                  this._eventMask &= -3;
                }
              };
              _proto.destroy = function destroy() {
                if (_CCObject.prototype.destroy.call(this)) {
                  this.active = false;
                  return true;
                }
                return false;
              };
              _proto.destroyAllChildren = function destroyAllChildren() {
                var children = this._children;
                for (var i = 0; i < children.length; ++i) {
                  children[i].destroy();
                }
              };
              _proto._removeComponent = function _removeComponent(component) {
                if (!component) {
                  errorID(3814);
                  return;
                }
                if (!(this._objFlags & Destroying)) {
                  var i = this._components.indexOf(component);
                  if (i !== -1) {
                    this._components.splice(i, 1);
                    this.emit("component-removed", component);
                  } else if (component.node !== this) {
                    errorID(3815);
                  }
                }
              };
              _proto._updateSiblingIndex = function _updateSiblingIndex() {
                for (var i = 0; i < this._children.length; ++i) {
                  this._children[i]._siblingIndex = i;
                }
                this.emit("sibling-order-changed");
              };
              _proto._instantiate = function _instantiate(cloned, isSyncedNode) {
                if (isSyncedNode === undefined) {
                  isSyncedNode = false;
                }
                if (!cloned) {
                  cloned = cclegacy.instantiate._clone(this, this);
                }
                cloned._prefab;
                cloned._parent = null;
                cloned._onBatchCreated(isSyncedNode);
                return cloned;
              };
              _proto._onHierarchyChangedBase = function _onHierarchyChangedBase(oldParent) {
                var newParent = this._parent;
                if (this._persistNode && !(newParent instanceof cclegacy.Scene)) {
                  cclegacy.game.removePersistRootNode(this);
                }
                var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);
                if (this._activeInHierarchy !== shouldActiveNow) {
                  cclegacy.director._nodeActivator.activateNode(this, shouldActiveNow);
                }
              };
              _proto._onPreDestroyBase = function _onPreDestroyBase() {
                this._objFlags |= Destroying;
                var parent = this._parent;
                var destroyByParent = !!parent && (parent._objFlags & Destroying) !== 0;
                if (this._persistNode) {
                  cclegacy.game.removePersistRootNode(this);
                }
                if (!destroyByParent) {
                  if (parent) {
                    this.emit("parent-changed", this);
                    var childIndex = parent._children.indexOf(this);
                    parent._children.splice(childIndex, 1);
                    this._siblingIndex = 0;
                    parent._updateSiblingIndex();
                    if (parent.emit) {
                      parent.emit("child-removed", this);
                    }
                  }
                }
                this.emit("node-destroyed", this);
                this._eventProcessor.destroy();
                var children = this._children;
                for (var i = 0; i < children.length; ++i) {
                  children[i]._destroyImmediate();
                }
                var comps = this._components;
                for (var _i3 = 0; _i3 < comps.length; ++_i3) {
                  comps[_i3]._destroyImmediate();
                }
                return destroyByParent;
              };
              function Node(name) {
                var _this;
                if (name === undefined) name = 'New Node';
                _this = _CCObject.call(this, name) || this;
                _this._parent = _initializer$z && _initializer$z();
                _this._children = _initializer2$r && _initializer2$r();
                _this._active = _initializer3$l && _initializer3$l();
                _this._components = _initializer4$h && _initializer4$h();
                _this._prefab = _initializer5$e && _initializer5$e();
                _this._scene = null;
                _this._activeInHierarchy = false;
                _this._id = idGenerator.getNewId();
                _this._eventProcessor = new NodeEventProcessor(_assertThisInitialized(_this));
                _this._eventMask = 0;
                _this._siblingIndex = 0;
                _this._originalSceneId = '';
                _this._uiProps = new NodeUIProperties(_assertThisInitialized(_this));
                _this._static = false;
                _this._lpos = _initializer6$a && _initializer6$a();
                _this._lrot = _initializer7$9 && _initializer7$9();
                _this._lscale = _initializer8$9 && _initializer8$9();
                _this._mobility = _initializer9$8 && _initializer9$8();
                _this._layer = _initializer10$7 && _initializer10$7();
                _this._euler = _initializer11$6 && _initializer11$6();
                _this._transformFlags = 7 | 8;
                _this._eulerDirty = false;
                _this._flagChangeVersion = 0;
                _this._hasChangedFlags = 0;
                _this._pos = new Vec3();
                _this._rot = new Quat();
                _this._scale = new Vec3(1, 1, 1);
                _this._mat = new Mat4();
                return _this;
              }
              Node.isNode = function isNode(obj) {
                return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cclegacy.Scene));
              };
              _proto._onPreDestroy = function _onPreDestroy() {
                return this._onPreDestroyBase();
              };
              _proto[serializeTag] = function (serializationOutput, context) {
                {
                  serializationOutput.writeThis();
                  return;
                }
              };
              _proto._onSetParent = function _onSetParent(oldParent, keepWorldTransform) {
                if (keepWorldTransform === undefined) {
                  keepWorldTransform = false;
                }
                var self = this;
                var parent = self._parent;
                if (parent) {
                  if ((oldParent == null || oldParent._scene !== parent._scene) && parent._scene != null) {
                    self.walk(Node._setScene);
                  }
                }
                if (keepWorldTransform) {
                  if (parent) {
                    parent.updateWorldTransform();
                    if (approx(Mat4.determinant(parent._mat), 0, EPSILON$1)) {
                      warnID(14300);
                      self._transformFlags |= 7;
                      self.updateWorldTransform();
                    } else {
                      var newParentMatWithoutSkew = parent._mat;
                      Mat4.multiply(m4_1$4, Mat4.invert(m4_1$4, newParentMatWithoutSkew), self._mat);
                      Mat4.toSRT(m4_1$4, self._lrot, self._lpos, self._lscale);
                    }
                  } else {
                    Vec3.copy(self._lpos, self._pos);
                    Quat.copy(self._lrot, self._rot);
                    Vec3.copy(self._lscale, self._scale);
                  }
                  self._eulerDirty = true;
                }
                self.invalidateChildren(7);
              };
              _proto._onHierarchyChanged = function _onHierarchyChanged(oldParent) {
                this.eventProcessor.reattach();
                this._onHierarchyChangedBase(oldParent);
              };
              _proto._onBatchCreated = function _onBatchCreated(dontSyncChildPrefab) {
                if (this._eventMask & ACTIVE_ON) {
                  if (!this._activeInHierarchy) {
                    this.emit(ACTIVE_CHANGED, this, false);
                  }
                }
                this.hasChangedFlags = 7;
                this._children.forEach(function (child, i) {
                  child._siblingIndex = i;
                  child._onBatchCreated(dontSyncChildPrefab);
                });
              };
              _proto._onBeforeSerialize = function _onBeforeSerialize() {
                this.eulerAngles;
              };
              _proto._onPostActivated = function _onPostActivated(active) {
                var self = this;
                if (self._eventMask & ACTIVE_ON) {
                  self.emit(ACTIVE_CHANGED, self, active);
                }
                var eventProcessor = this._eventProcessor;
                if (eventProcessor.isEnabled === active) {
                  NodeEventProcessor.callbacksInvoker.emit(2);
                }
                eventProcessor.setEnabled(active);
                if (active) {
                  self.invalidateChildren(7);
                  var uiComp = self._uiProps && self._uiProps.uiComp;
                  if (uiComp) {
                    uiComp.setNodeDirty();
                    uiComp.setTextureDirty();
                    uiComp._markForUpdateRenderData();
                  }
                }
              };
              _proto.translate = function translate(trans, ns) {
                var space = ns || 0;
                if (space === 0) {
                  Vec3.transformQuat(v3_a, trans, this._lrot);
                  this._lpos.x += v3_a.x;
                  this._lpos.y += v3_a.y;
                  this._lpos.z += v3_a.z;
                } else if (space === 1) {
                  if (this._parent) {
                    Quat.invert(q_a, this._parent.worldRotation);
                    Vec3.transformQuat(v3_a, trans, q_a);
                    var _scale = this.worldScale;
                    this._lpos.x += v3_a.x / _scale.x;
                    this._lpos.y += v3_a.y / _scale.y;
                    this._lpos.z += v3_a.z / _scale.z;
                  } else {
                    this._lpos.x += trans.x;
                    this._lpos.y += trans.y;
                    this._lpos.z += trans.z;
                  }
                }
                this.invalidateChildren(1);
                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(TRANSFORM_CHANGED, 1);
                }
              };
              _proto.rotate = function rotate(rot, ns) {
                var space = ns || 0;
                Quat.normalize(q_a, rot);
                if (space === 0) {
                  Quat.multiply(this._lrot, this._lrot, q_a);
                } else if (space === 1) {
                  var worldRot = this.worldRotation;
                  Quat.multiply(q_b, q_a, worldRot);
                  Quat.invert(q_a, worldRot);
                  Quat.multiply(q_b, q_a, q_b);
                  Quat.multiply(this._lrot, this._lrot, q_b);
                }
                this._eulerDirty = true;
                this.invalidateChildren(2);
                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(TRANSFORM_CHANGED, 2);
                }
              };
              _proto.lookAt = function lookAt(pos, up) {
                this.getWorldPosition(v3_a);
                Vec3.subtract(v3_a, v3_a, pos);
                Vec3.normalize(v3_a, v3_a);
                Quat.fromViewUp(q_a, v3_a, up);
                this.setWorldRotation(q_a);
              };
              _proto.invalidateChildren = function invalidateChildren(dirtyBit) {
                var i = 0;
                var j = 0;
                var l = 0;
                var cur;
                var children;
                var hasChangedFlags = 0;
                var childDirtyBit = dirtyBit | 1;
                dirtyNodes[0] = this;
                while (i >= 0) {
                  cur = dirtyNodes[i--];
                  hasChangedFlags = cur.hasChangedFlags;
                  if (cur.isValid && !cur.isSkipTransformUpdate && (cur._transformFlags & hasChangedFlags & dirtyBit) !== dirtyBit) {
                    cur._transformFlags |= dirtyBit;
                    cur.hasChangedFlags = hasChangedFlags | dirtyBit;
                    children = cur._children;
                    l = children.length;
                    for (j = 0; j < l; j++) {
                      dirtyNodes[++i] = children[j];
                    }
                  }
                  dirtyBit = childDirtyBit;
                }
              };
              _proto.updateWorldTransform = function updateWorldTransform() {
                if (!this._transformFlags) {
                  return;
                }
                var cur = this;
                var i = 0;
                while (cur && cur._transformFlags) {
                  dirtyNodes[i++] = cur;
                  cur = cur._parent;
                }
                var child;
                var childMat;
                var childPos;
                var dirtyBits = 0;
                var positionDirty = 0;
                var rotationScaleSkewDirty = 0;
                while (i) {
                  child = dirtyNodes[--i];
                  childMat = child._mat;
                  childPos = child._pos;
                  dirtyBits |= child._transformFlags;
                  positionDirty = dirtyBits & 1;
                  rotationScaleSkewDirty = dirtyBits & 14;
                  if (cur) {
                    if (positionDirty && !rotationScaleSkewDirty) {
                      Vec3.transformMat4(childPos, child._lpos, cur._mat);
                      childMat.m12 = childPos.x;
                      childMat.m13 = childPos.y;
                      childMat.m14 = childPos.z;
                    }
                    if (rotationScaleSkewDirty) {
                      var originalWorldMatrix = childMat;
                      Mat4.fromSRT(m4_1$4, child._lrot, child._lpos, child._lscale);
                      Mat4.multiply(childMat, cur._mat, m4_1$4);
                      var rotTmp = dirtyBits & 2 ? child._rot : null;
                      Mat4.toSRT(originalWorldMatrix, rotTmp, childPos, child._scale);
                    }
                  } else {
                    if (positionDirty) {
                      Vec3.copy(childPos, child._lpos);
                      childMat.m12 = childPos.x;
                      childMat.m13 = childPos.y;
                      childMat.m14 = childPos.z;
                    }
                    if (rotationScaleSkewDirty) {
                      if (dirtyBits & 2) {
                        Quat.copy(child._rot, child._lrot);
                      }
                      if (dirtyBits & 4) {
                        Vec3.copy(child._scale, child._lscale);
                      }
                      Mat4.fromSRT(childMat, child._rot, child._pos, child._scale);
                    }
                  }
                  child._transformFlags = 0;
                  cur = child;
                }
              };
              _proto.setPosition = function setPosition(val, y, z) {
                var localPosition = this._lpos;
                if (y === undefined) {
                  Vec3.copy(localPosition, val);
                } else {
                  if (z === undefined) {
                    z = localPosition.z;
                  }
                  Vec3.set(localPosition, val, y, z);
                }
                this.invalidateChildren(1);
                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(TRANSFORM_CHANGED, 1);
                }
              };
              _proto.getPosition = function getPosition(out) {
                if (out) {
                  return Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z);
                }
                return Vec3.copy(new Vec3(), this._lpos);
              };
              _proto.setRotation = function setRotation(val, y, z, w) {
                if (y === undefined) {
                  Quat.copy(this._lrot, val);
                } else {
                  Quat.set(this._lrot, val, y, z, w);
                }
                this._eulerDirty = true;
                this.invalidateChildren(2);
                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(TRANSFORM_CHANGED, 2);
                }
              };
              _proto.setRotationFromEuler = function setRotationFromEuler(val, y, zOpt) {
                if (y === undefined) {
                  Vec3.copy(this._euler, val);
                  Quat.fromEuler(this._lrot, val.x, val.y, val.z);
                } else {
                  var _z = zOpt === undefined ? this._euler.z : zOpt;
                  Vec3.set(this._euler, val, y, _z);
                  Quat.fromEuler(this._lrot, val, y, _z);
                }
                this._eulerDirty = false;
                this.invalidateChildren(2);
                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(TRANSFORM_CHANGED, 2);
                }
              };
              _proto.getRotation = function getRotation(out) {
                if (out) {
                  return Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w);
                }
                return Quat.copy(new Quat(), this._lrot);
              };
              _proto.setScale = function setScale(val, y, z) {
                var localScale = this._lscale;
                if (y === undefined) {
                  Vec3.copy(localScale, val);
                } else {
                  if (z === undefined) {
                    z = localScale.z;
                  }
                  Vec3.set(localScale, val, y, z);
                }
                this.invalidateChildren(4);
                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(TRANSFORM_CHANGED, 4);
                }
              };
              _proto.getScale = function getScale(out) {
                if (out) {
                  return Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z);
                }
                return Vec3.copy(new Vec3(), this._lscale);
              };
              _proto.inverseTransformPoint = function inverseTransformPoint(out, p) {
                Vec3.copy(out, p);
                var cur = this;
                var i = 0;
                while (cur._parent) {
                  dirtyNodes[i++] = cur;
                  cur = cur._parent;
                }
                while (i >= 0) {
                  Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale);
                  cur = dirtyNodes[--i];
                }
                return out;
              };
              _proto.setWorldPosition = function setWorldPosition(val, y, z) {
                var worldPosition = this._pos;
                if (y === undefined) {
                  Vec3.copy(worldPosition, val);
                } else {
                  Vec3.set(worldPosition, val, y, z);
                }
                var parent = this._parent;
                var local = this._lpos;
                if (parent) {
                  parent.updateWorldTransform();
                  Vec3.transformMat4(local, worldPosition, Mat4.invert(m4_1$4, parent._mat));
                } else {
                  Vec3.copy(local, worldPosition);
                }
                this.invalidateChildren(1);
                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(TRANSFORM_CHANGED, 1);
                }
              };
              _proto.getWorldPosition = function getWorldPosition(out) {
                this.updateWorldTransform();
                if (out) {
                  return Vec3.copy(out, this._pos);
                }
                return Vec3.copy(new Vec3(), this._pos);
              };
              _proto.setWorldRotation = function setWorldRotation(val, y, z, w) {
                var worldRotation = this._rot;
                if (y === undefined) {
                  Quat.copy(worldRotation, val);
                } else {
                  Quat.set(worldRotation, val, y, z, w);
                }
                if (this._parent) {
                  this._parent.updateWorldTransform();
                  Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), worldRotation);
                } else {
                  Quat.copy(this._lrot, worldRotation);
                }
                this._eulerDirty = true;
                this.invalidateChildren(2);
                if (this._eventMask & TRANSFORM_ON) {
                  this.emit(TRANSFORM_CHANGED, 2);
                }
              };
              _proto.setWorldRotationFromEuler = function setWorldRotationFromEuler(x, y, z) {
                Quat.fromEuler(q_a, x, y, z);
                this.setWorldRotation(q_a);
              };
              _proto.getWorldRotation = function getWorldRotation(out) {
                this.updateWorldTransform();
                if (out) {
                  return Quat.copy(out, this._rot);
                }
                return Quat.copy(new Quat(), this._rot);
              };
              _proto.setWorldScale = function setWorldScale(val, y, z) {
                var self = this;
                var parent = self._parent;
                if (parent) {
                  self.updateWorldTransform();
                }
                var worldScale = self._scale;
                if (y === undefined) {
                  Vec3.copy(worldScale, val);
                } else {
                  Vec3.set(worldScale, val, y, z);
                }
                var rotationFlag = 0;
                if (parent) {
                  var worldMatrix = self._mat;
                  var uiSkewComp = self._uiProps._uiSkewComp;
                  if (uiSkewComp) {
                    Mat4.fromSRT(m4_1$4, self._lrot, self._lpos, self._lscale);
                    Mat4.multiply(worldMatrix, parent._mat, m4_1$4);
                  }
                  var xScale = Vec3.set(v3_b, worldMatrix.m00, worldMatrix.m01, worldMatrix.m02).length();
                  var yScale = Vec3.set(v3_b, worldMatrix.m04, worldMatrix.m05, worldMatrix.m06).length();
                  var zScale = Vec3.set(v3_b, worldMatrix.m08, worldMatrix.m09, worldMatrix.m10).length();
                  if (xScale === 0) {
                    v3_a.x = worldScale.x;
                    worldMatrix.m00 = 1;
                    rotationFlag = 2;
                  } else {
                    v3_a.x = worldScale.x / xScale;
                  }
                  if (yScale === 0) {
                    v3_a.y = worldScale.y;
                    worldMatrix.m05 = 1;
                    rotationFlag = 2;
                  } else {
                    v3_a.y = worldScale.y / yScale;
                  }
                  if (zScale === 0) {
                    v3_a.z = worldScale.z;
                    worldMatrix.m10 = 1;
                    rotationFlag = 2;
                  } else {
                    v3_a.z = worldScale.z / zScale;
                  }
                  Mat4.scale(m4_1$4, worldMatrix, v3_a);
                  Mat4.multiply(m4_2$1, Mat4.invert(m4_2$1, parent._mat), m4_1$4);
                  Mat3.fromQuat(m3_1, Quat.conjugate(qt_1, self._lrot));
                  Mat3.multiplyMat4(m3_1, m3_1, m4_2$1);
                  var localScale = self._lscale;
                  localScale.x = Vec3.set(v3_a, m3_1.m00, m3_1.m01, m3_1.m02).length();
                  localScale.y = Vec3.set(v3_a, m3_1.m03, m3_1.m04, m3_1.m05).length();
                  localScale.z = Vec3.set(v3_a, m3_1.m06, m3_1.m07, m3_1.m08).length();
                  if (localScale.x === 0 || localScale.y === 0 || localScale.z === 0) {
                    rotationFlag = 2;
                  }
                } else {
                  Vec3.copy(self._lscale, worldScale);
                }
                self.invalidateChildren(4 | rotationFlag);
                if (self._eventMask & TRANSFORM_ON) {
                  self.emit(TRANSFORM_CHANGED, 4 | rotationFlag);
                }
              };
              _proto.getWorldScale = function getWorldScale(out) {
                this.updateWorldTransform();
                if (out) {
                  return Vec3.copy(out, this._scale);
                }
                return Vec3.copy(new Vec3(), this._scale);
              };
              _proto.getWorldMatrix = function getWorldMatrix(out) {
                this.updateWorldTransform();
                var target = out || new Mat4();
                return Mat4.copy(target, this._mat);
              };
              _proto.getWorldRS = function getWorldRS(out) {
                this.updateWorldTransform();
                var target = out || new Mat4();
                Mat4.copy(target, this._mat);
                target.m12 = 0;
                target.m13 = 0;
                target.m14 = 0;
                return target;
              };
              _proto.getWorldRT = function getWorldRT(out) {
                this.updateWorldTransform();
                var target = out || new Mat4();
                return Mat4.fromRT(target, this._rot, this._pos);
              };
              _proto.setRTS = function setRTS(rot, pos, scale) {
                var dirtyBit = 0;
                if (rot) {
                  dirtyBit |= 2;
                  if (rot.w !== undefined) {
                    Quat.copy(this._lrot, rot);
                    this._eulerDirty = true;
                  } else {
                    Vec3.copy(this._euler, rot);
                    Quat.fromEuler(this._lrot, rot.x, rot.y, rot.z);
                    this._eulerDirty = false;
                  }
                }
                if (pos) {
                  Vec3.copy(this._lpos, pos);
                  dirtyBit |= 1;
                }
                if (scale) {
                  Vec3.copy(this._lscale, scale);
                  dirtyBit |= 4;
                }
                if (dirtyBit) {
                  this.invalidateChildren(dirtyBit);
                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(TRANSFORM_CHANGED, dirtyBit);
                  }
                }
              };
              _proto.isTransformDirty = function isTransformDirty() {
                return this._transformFlags !== 0;
              };
              _proto.pauseSystemEvents = function pauseSystemEvents(recursive) {
                this._eventProcessor.setEnabled(false, recursive);
              };
              _proto.resumeSystemEvents = function resumeSystemEvents(recursive) {
                this._eventProcessor.setEnabled(true, recursive);
              };
              Node.resetHasChangedFlags = function resetHasChangedFlags() {
                globalFlagChangeVersion += 1;
              };
              Node.clearNodeArray = function clearNodeArray() {
                if (Node.ClearFrame < Node.ClearRound && true) {
                  Node.ClearFrame++;
                } else {
                  Node.ClearFrame = 0;
                  dirtyNodes.length = 0;
                }
              };
              _proto.getPathInHierarchy = function getPathInHierarchy() {
                var result = this.name;
                var curNode = this.parent;
                while (curNode && !(curNode instanceof cclegacy.Scene)) {
                  result = curNode.name + "/" + result;
                  curNode = curNode.parent;
                }
                return result;
              };
              _proto._getUITransformComp = function _getUITransformComp() {
                return this._uiProps.uiTransformComp;
              };
              _createClass(Node, [{
                key: "components",
                get: function get() {
                  return this._components;
                }
              }, {
                key: "_persistNode",
                get: function get() {
                  return (this._objFlags & DontDestroy) > 0;
                },
                set: function set(value) {
                  if (value) {
                    this._objFlags |= DontDestroy;
                  } else {
                    this._objFlags &= -65;
                  }
                }
              }, {
                key: "name",
                get: function get() {
                  return this._name;
                },
                set: function set(value) {
                  this._name = value;
                }
              }, {
                key: "uuid",
                get: function get() {
                  return this._id;
                }
              }, {
                key: "children",
                get: function get() {
                  return this._children;
                }
              }, {
                key: "active",
                get: function get() {
                  return this._active;
                },
                set: function set(isActive) {
                  isActive = !!isActive;
                  if (this._active !== isActive) {
                    this._active = isActive;
                    var parent = this._parent;
                    if (parent) {
                      var couldActiveInScene = parent._activeInHierarchy;
                      if (couldActiveInScene) {
                        cclegacy.director._nodeActivator.activateNode(this, isActive);
                      }
                    }
                  }
                }
              }, {
                key: "activeInHierarchy",
                get: function get() {
                  return this._activeInHierarchy;
                }
              }, {
                key: "parent",
                get: function get() {
                  return this._parent;
                },
                set: function set(value) {
                  this.setParent(value);
                }
              }, {
                key: "scene",
                get: function get() {
                  return this._scene;
                }
              }, {
                key: "eventProcessor",
                get: function get() {
                  return this._eventProcessor;
                }
              }, {
                key: "prefab",
                get: function get() {
                  return this._prefab;
                }
              }, {
                key: "id",
                set: function set(v) {
                  this._id = v;
                }
              }, {
                key: "siblingIndex",
                get: function get() {
                  return this._siblingIndex;
                },
                set: function set(val) {
                  this._siblingIndex = val;
                }
              }, {
                key: "position",
                get: function get() {
                  return this._lpos;
                },
                set: function set(val) {
                  this.setPosition(val);
                }
              }, {
                key: "x",
                get: function get() {
                  return this._lpos.x;
                },
                set: function set(val) {
                  this.setPosition(val, this._lpos.y, this._lpos.z);
                }
              }, {
                key: "y",
                get: function get() {
                  return this._lpos.y;
                },
                set: function set(val) {
                  this.setPosition(this._lpos.x, val, this._lpos.z);
                }
              }, {
                key: "z",
                get: function get() {
                  return this._lpos.z;
                },
                set: function set(val) {
                  this.setPosition(this._lpos.x, this._lpos.y, val);
                }
              }, {
                key: "worldPosition",
                get: function get() {
                  this.updateWorldTransform();
                  return this._pos;
                },
                set: function set(val) {
                  this.setWorldPosition(val);
                }
              }, {
                key: "worldPositionX",
                get: function get() {
                  this.updateWorldTransform();
                  return this._pos.x;
                },
                set: function set(val) {
                  this.setWorldPosition(val, this._pos.y, this._pos.z);
                }
              }, {
                key: "worldPositionY",
                get: function get() {
                  this.updateWorldTransform();
                  return this._pos.y;
                },
                set: function set(val) {
                  this.setWorldPosition(this._pos.x, val, this._pos.z);
                }
              }, {
                key: "worldPositionZ",
                get: function get() {
                  this.updateWorldTransform();
                  return this._pos.z;
                },
                set: function set(val) {
                  this.setWorldPosition(this._pos.x, this._pos.y, val);
                }
              }, {
                key: "rotation",
                get: function get() {
                  return this._lrot;
                },
                set: function set(val) {
                  this.setRotation(val);
                }
              }, {
                key: "eulerAngles",
                get: function get() {
                  if (this._eulerDirty) {
                    Quat.toEuler(this._euler, this._lrot);
                    this._eulerDirty = false;
                  }
                  return this._euler;
                },
                set: function set(val) {
                  this.setRotationFromEuler(val.x, val.y, val.z);
                }
              }, {
                key: "angle",
                get: function get() {
                  return this.eulerAngles.z;
                },
                set: function set(val) {
                  Vec3.set(this._euler, 0, 0, val);
                  Quat.fromAngleZ(this._lrot, val);
                  this._eulerDirty = false;
                  this.invalidateChildren(2);
                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(TRANSFORM_CHANGED, 2);
                  }
                }
              }, {
                key: "worldRotation",
                get: function get() {
                  this.updateWorldTransform();
                  return this._rot;
                },
                set: function set(val) {
                  this.setWorldRotation(val);
                }
              }, {
                key: "scale",
                get: function get() {
                  return this._lscale;
                },
                set: function set(val) {
                  this.setScale(val);
                }
              }, {
                key: "worldScale",
                get: function get() {
                  this.updateWorldTransform();
                  return this._scale;
                },
                set: function set(val) {
                  this.setWorldScale(val);
                }
              }, {
                key: "matrix",
                set: function set(val) {
                  Mat4.toSRT(val, this._lrot, this._lpos, this._lscale);
                  this.invalidateChildren(7);
                  this._eulerDirty = true;
                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(TRANSFORM_CHANGED, 7);
                  }
                }
              }, {
                key: "worldMatrix",
                get: function get() {
                  this.updateWorldTransform();
                  return this._mat;
                }
              }, {
                key: "forward",
                get: function get() {
                  return Vec3.transformQuat(new Vec3(), Vec3.FORWARD, this.worldRotation);
                },
                set: function set(dir) {
                  var len = dir.length();
                  Vec3.multiplyScalar(v3_a, dir, -1 / len);
                  Quat.fromViewUp(q_a, v3_a);
                  this.setWorldRotation(q_a);
                }
              }, {
                key: "up",
                get: function get() {
                  return Vec3.transformQuat(new Vec3(), Vec3.UP, this.worldRotation);
                }
              }, {
                key: "right",
                get: function get() {
                  return Vec3.transformQuat(new Vec3(), Vec3.RIGHT, this.worldRotation);
                }
              }, {
                key: "mobility",
                get: function get() {
                  return this._mobility;
                },
                set: function set(m) {
                  if (this._mobility === m) {
                    return;
                  }
                  this._mobility = m;
                  this.emit("mobility-changed");
                }
              }, {
                key: "layer",
                get: function get() {
                  return this._layer;
                },
                set: function set(l) {
                  var self = this;
                  if (self._layer === l) {
                    return;
                  }
                  self._layer = l;
                  var uiComp = self._uiProps && self._uiProps.uiComp;
                  if (uiComp) {
                    uiComp.setNodeDirty();
                    uiComp._markForUpdateRenderData();
                  }
                  self.emit("layer-changed", self._layer);
                }
              }, {
                key: "flagChangedVersion",
                get: function get() {
                  return this._flagChangeVersion;
                }
              }, {
                key: "hasChangedFlags",
                get: function get() {
                  return this._flagChangeVersion === globalFlagChangeVersion ? this._hasChangedFlags : 0;
                },
                set: function set(val) {
                  this._flagChangeVersion = globalFlagChangeVersion;
                  this._hasChangedFlags = val;
                }
              }, {
                key: "isSkipTransformUpdate",
                get: function get() {
                  return (this._objFlags & 16777216) !== 0;
                },
                set: function set(skip) {
                  if (skip) {
                    this._objFlags |= 16777216;
                  } else {
                    this._objFlags &= -16777217;
                  }
                }
              }]);
              return Node;
            }(CCObject), _class3$c.idGenerator = idGenerator, _class3$c._stacks = [[]], _class3$c._stackId = 0, _class3$c.EventType = NodeEventType, _class3$c.NodeSpace = NodeSpace, _class3$c.TransformDirtyBit = TransformBit, _class3$c.TransformBit = TransformBit, _class3$c.reserveContentsForAllSyncablePrefabTag = reserveContentsForAllSyncablePrefabTag, _class3$c.ClearFrame = 0, _class3$c.ClearRound = 1000, _class3$c), (_applyDecoratedDescriptor(_class2$C.prototype, "_persistNode", [property$3], Object.getOwnPropertyDescriptor(_class2$C.prototype, "_persistNode"), _class2$C.prototype), _initializer$z = applyDecoratedInitializer(_class2$C.prototype, "_parent", [serializable$5], function () {
              return null;
            }), _initializer2$r = applyDecoratedInitializer(_class2$C.prototype, "_children", [serializable$5], function () {
              return [];
            }), _initializer3$l = applyDecoratedInitializer(_class2$C.prototype, "_active", [serializable$5], function () {
              return true;
            }), _initializer4$h = applyDecoratedInitializer(_class2$C.prototype, "_components", [serializable$5], function () {
              return [];
            }), _initializer5$e = applyDecoratedInitializer(_class2$C.prototype, "_prefab", [serializable$5], function () {
              return null;
            }), _initializer6$a = applyDecoratedInitializer(_class2$C.prototype, "_lpos", [serializable$5], function () {
              return new Vec3();
            }), _initializer7$9 = applyDecoratedInitializer(_class2$C.prototype, "_lrot", [serializable$5], function () {
              return new Quat();
            }), _initializer8$9 = applyDecoratedInitializer(_class2$C.prototype, "_lscale", [serializable$5], function () {
              return new Vec3(1, 1, 1);
            }), _initializer9$8 = applyDecoratedInitializer(_class2$C.prototype, "_mobility", [serializable$5], function () {
              return MobilityMode.Static;
            }), _initializer10$7 = applyDecoratedInitializer(_class2$C.prototype, "_layer", [serializable$5], function () {
              return Layers.Enum.DEFAULT;
            }), _initializer11$6 = applyDecoratedInitializer(_class2$C.prototype, "_euler", [serializable$5], function () {
              return new Vec3();
            }), _applyDecoratedDescriptor(_class2$C.prototype, "eulerAngles", [_dec2$q], Object.getOwnPropertyDescriptor(_class2$C.prototype, "eulerAngles"), _class2$C.prototype), _applyDecoratedDescriptor(_class2$C.prototype, "mobility", [_dec3$m], Object.getOwnPropertyDescriptor(_class2$C.prototype, "mobility"), _class2$C.prototype)), _class2$C)) || _class$H); exports({ Node: Node$1, BaseNode: Node$1 });
            cclegacy.Node = Node$1;

            var _dec$F, _class$G, _class2$B, _class3$b;
            var COMPRESSED_HEADER_LENGTH = 4;
            var COMPRESSED_MIPMAP_DATA_SIZE_LENGTH = 4;
            var COMPRESSED_MIPMAP_LEVEL_COUNT_LENGTH = 4;
            var COMPRESSED_MIPMAP_MAGIC = 0x50494d43;
            var compressType = Enum({
              PVR: 0,
              PKM: 1,
              ASTC: 2
            });
            var PVR_HEADER_LENGTH = 13;
            var PVR_MAGIC = 0x03525650;
            var PVR_HEADER_MAGIC = 0;
            var PVR_HEADER_HEIGHT = 6;
            var PVR_HEADER_WIDTH = 7;
            var PVR_HEADER_METADATA = 12;
            var ETC_PKM_HEADER_LENGTH = 16;
            var ETC_PKM_FORMAT_OFFSET = 6;
            var ETC_PKM_WIDTH_OFFSET = 12;
            var ETC_PKM_HEIGHT_OFFSET = 14;
            var ETC1_RGB_NO_MIPMAPS = 0;
            var ETC2_RGB_NO_MIPMAPS = 1;
            var ETC2_RGBA_NO_MIPMAPS = 3;
            var ASTC_MAGIC = 0x5CA1AB13;
            var ASTC_HEADER_LENGTH = 16;
            var ASTC_HEADER_MAGIC = 4;
            var ASTC_HEADER_SIZE_X_BEGIN = 7;
            var ASTC_HEADER_SIZE_Y_BEGIN = 10;
            function getASTCFormat(xdim, ydim) {
              if (xdim === 4) {
                return 89;
              }
              if (xdim === 5) {
                if (ydim === 4) {
                  return 90;
                }
                return 91;
              }
              if (xdim === 6) {
                if (ydim === 5) {
                  return 92;
                }
                return 93;
              }
              if (xdim === 8) {
                if (ydim === 5) {
                  return 94;
                }
                if (ydim === 6) {
                  return 95;
                }
                return 96;
              }
              if (xdim === 10) {
                if (ydim === 5) {
                  return 97;
                }
                if (ydim === 6) {
                  return 98;
                }
                if (ydim === 8) {
                  return 99;
                }
                return 100;
              }
              if (ydim === 10) {
                return 101;
              }
              return 102;
            }
            function readBEUint16(header, offset) {
              return header[offset] << 8 | header[offset + 1];
            }
            function isImageBitmap(imageSource) {
              return !!(sys.hasFeature(sys.Feature.IMAGE_BITMAP) && imageSource instanceof ImageBitmap);
            }
            function isNativeImage(imageSource) {
              return imageSource instanceof HTMLImageElement || imageSource instanceof HTMLCanvasElement || isImageBitmap(imageSource);
            }
            var ImageAsset = exports("ImageAsset", (_dec$F = ccclass$6('cc.ImageAsset'), _dec$F(_class$G = (_class2$B = (_class3$b = function (_Asset) {
              _inheritsLoose(ImageAsset, _Asset);
              ImageAsset.mergeCompressedTextureMips = function mergeCompressedTextureMips(files) {
                var out = new Uint8Array(0);
                var err = null;
                try {
                  var fileHeaderLength = COMPRESSED_HEADER_LENGTH + COMPRESSED_MIPMAP_LEVEL_COUNT_LENGTH + files.length * COMPRESSED_MIPMAP_DATA_SIZE_LENGTH;
                  var fileLength = 0;
                  for (var _iterator = _createForOfIteratorHelperLoose(files), _step; !(_step = _iterator()).done;) {
                    var _file = _step.value;
                    fileLength += _file.byteLength;
                  }
                  fileLength += fileHeaderLength;
                  out = new Uint8Array(fileLength);
                  var outView = new DataView(out.buffer, out.byteOffset, out.byteLength);
                  outView.setUint32(0, COMPRESSED_MIPMAP_MAGIC, true);
                  outView.setUint32(COMPRESSED_HEADER_LENGTH, files.length, true);
                  var dataOffset = fileHeaderLength;
                  for (var i = 0; i < files.length; i++) {
                    var file = files[i];
                    outView.setUint32(COMPRESSED_HEADER_LENGTH + COMPRESSED_MIPMAP_LEVEL_COUNT_LENGTH + i * COMPRESSED_MIPMAP_DATA_SIZE_LENGTH, file.byteLength, true);
                    if (file instanceof ArrayBuffer) {
                      var srcArray = new Uint8Array(file);
                      out.set(srcArray, dataOffset);
                    } else {
                      var _srcArray = new Uint8Array(file.buffer, file.byteOffset, file.byteLength);
                      out.set(_srcArray, dataOffset);
                    }
                    dataOffset += file.byteLength;
                  }
                } catch (e) {
                  err = e;
                  warn(err);
                }
                return out;
              };
              ImageAsset.parseCompressedTextures = function parseCompressedTextures(file, type) {
                var out = {
                  _data: new Uint8Array(0),
                  _compressed: true,
                  width: 0,
                  height: 0,
                  format: 0,
                  mipmapLevelDataSize: []
                };
                var buffer = file instanceof ArrayBuffer ? file : file.buffer;
                var bufferView = new DataView(buffer);
                var magicNumber = bufferView.getUint32(0, true);
                if (magicNumber === COMPRESSED_MIPMAP_MAGIC) {
                  var mipmapLevelNumber = bufferView.getUint32(COMPRESSED_HEADER_LENGTH, true);
                  var mipmapLevelDataSize = bufferView.getUint32(COMPRESSED_HEADER_LENGTH + COMPRESSED_MIPMAP_LEVEL_COUNT_LENGTH, true);
                  var fileHeaderByteLength = COMPRESSED_HEADER_LENGTH + COMPRESSED_MIPMAP_LEVEL_COUNT_LENGTH + mipmapLevelNumber * COMPRESSED_MIPMAP_DATA_SIZE_LENGTH;
                  ImageAsset.parseCompressedTexture(file, 0, fileHeaderByteLength, mipmapLevelDataSize, type, out);
                  var beginOffset = fileHeaderByteLength + mipmapLevelDataSize;
                  for (var i = 1; i < mipmapLevelNumber; i++) {
                    var endOffset = bufferView.getUint32(COMPRESSED_HEADER_LENGTH + COMPRESSED_MIPMAP_LEVEL_COUNT_LENGTH + i * COMPRESSED_MIPMAP_DATA_SIZE_LENGTH, true);
                    ImageAsset.parseCompressedTexture(file, i, beginOffset, endOffset, type, out);
                    beginOffset += endOffset;
                  }
                } else {
                  ImageAsset.parseCompressedTexture(file, 0, 0, 0, type, out);
                }
                return out;
              };
              ImageAsset.parseCompressedTexture = function parseCompressedTexture(file, levelIndex, beginOffset, endOffset, type, out) {
                switch (type) {
                  case compressType.PVR:
                    ImageAsset.parsePVRTexture(file, levelIndex, beginOffset, endOffset, out);
                    break;
                  case compressType.PKM:
                    ImageAsset.parsePKMTexture(file, levelIndex, beginOffset, endOffset, out);
                    break;
                  case compressType.ASTC:
                    ImageAsset.parseASTCTexture(file, levelIndex, beginOffset, endOffset, out);
                    break;
                }
              };
              ImageAsset.parsePVRTexture = function parsePVRTexture(file, levelIndex, beginOffset, endOffset, out) {
                var buffer = file instanceof ArrayBuffer ? file : file.buffer;
                var header = new Int32Array(buffer, beginOffset, PVR_HEADER_LENGTH);
                if (header[PVR_HEADER_MAGIC] === PVR_MAGIC) {
                  var byteOffset = beginOffset + header[PVR_HEADER_METADATA] + 52;
                  var length = endOffset - header.byteLength;
                  if (endOffset > 0) {
                    var srcView = new Uint8Array(buffer, byteOffset, length);
                    var dstView = new Uint8Array(out._data.byteLength + srcView.byteLength);
                    dstView.set(out._data);
                    dstView.set(srcView, out._data.byteLength);
                    out._data = dstView;
                    out.mipmapLevelDataSize[levelIndex] = length;
                  } else {
                    out._data = new Uint8Array(buffer, byteOffset);
                  }
                  out.width = levelIndex > 0 ? out.width : header[PVR_HEADER_WIDTH];
                  out.height = levelIndex > 0 ? out.height : header[PVR_HEADER_HEIGHT];
                } else if (header[11] === 0x21525650) {
                  var _byteOffset = beginOffset + header[0];
                  var _length = endOffset - header.byteLength;
                  if (endOffset > 0) {
                    var _srcView = new Uint8Array(buffer, _byteOffset, _length);
                    var _dstView = new Uint8Array(out._data.byteLength + _srcView.byteLength);
                    _dstView.set(out._data);
                    _dstView.set(_srcView, out._data.byteLength);
                    out._data = _dstView;
                    out.mipmapLevelDataSize[levelIndex] = _length;
                  } else {
                    out._data = new Uint8Array(buffer, _byteOffset);
                  }
                  out.width = levelIndex > 0 ? out.width : header[1];
                  out.height = levelIndex > 0 ? out.height : header[2];
                } else {
                  throw new Error('Invalid magic number in PVR header');
                }
              };
              ImageAsset.parsePKMTexture = function parsePKMTexture(file, levelIndex, beginOffset, endOffset, out) {
                var buffer = file instanceof ArrayBuffer ? file : file.buffer;
                var header = new Uint8Array(buffer, beginOffset, ETC_PKM_HEADER_LENGTH);
                var format = readBEUint16(header, ETC_PKM_FORMAT_OFFSET);
                if (format !== ETC1_RGB_NO_MIPMAPS && format !== ETC2_RGB_NO_MIPMAPS && format !== ETC2_RGBA_NO_MIPMAPS) {
                  throw new Error('Invalid magic number in ETC header');
                }
                var byteOffset = beginOffset + ETC_PKM_HEADER_LENGTH;
                var length = endOffset - ETC_PKM_HEADER_LENGTH;
                if (endOffset > 0) {
                  var srcView = new Uint8Array(buffer, byteOffset, length);
                  var dstView = new Uint8Array(out._data.byteLength + srcView.byteLength);
                  dstView.set(out._data);
                  dstView.set(srcView, out._data.byteLength);
                  out._data = dstView;
                  out.mipmapLevelDataSize[levelIndex] = length;
                } else {
                  out._data = new Uint8Array(buffer, byteOffset);
                }
                out.width = levelIndex > 0 ? out.width : readBEUint16(header, ETC_PKM_WIDTH_OFFSET);
                out.height = levelIndex > 0 ? out.height : readBEUint16(header, ETC_PKM_HEIGHT_OFFSET);
              };
              ImageAsset.parseASTCTexture = function parseASTCTexture(file, levelIndex, beginOffset, endOffset, out) {
                var buffer = file instanceof ArrayBuffer ? file : file.buffer;
                var header = new Uint8Array(buffer, beginOffset, ASTC_HEADER_LENGTH);
                var magicval = header[0] + (header[1] << 8) + (header[2] << 16) + (header[3] << 24);
                if (magicval !== ASTC_MAGIC) {
                  throw new Error('Invalid magic number in ASTC header');
                }
                var xdim = header[ASTC_HEADER_MAGIC];
                var ydim = header[ASTC_HEADER_MAGIC + 1];
                var zdim = header[ASTC_HEADER_MAGIC + 2];
                if ((xdim < 3 || xdim > 6 || ydim < 3 || ydim > 6 || zdim < 3 || zdim > 6) && (xdim < 4 || xdim === 7 || xdim === 9 || xdim === 11 || xdim > 12 || ydim < 4 || ydim === 7 || ydim === 9 || ydim === 11 || ydim > 12 || zdim !== 1)) {
                  throw new Error('Invalid block number in ASTC header');
                }
                var format = getASTCFormat(xdim, ydim);
                var byteOffset = beginOffset + ASTC_HEADER_LENGTH;
                var length = endOffset - ASTC_HEADER_LENGTH;
                if (endOffset > 0) {
                  var srcView = new Uint8Array(buffer, byteOffset, length);
                  var dstView = new Uint8Array(out._data.byteLength + srcView.byteLength);
                  dstView.set(out._data);
                  dstView.set(srcView, out._data.byteLength);
                  out._data = dstView;
                  out.mipmapLevelDataSize[levelIndex] = length;
                } else {
                  out._data = new Uint8Array(buffer, byteOffset);
                }
                out.width = levelIndex > 0 ? out.width : header[ASTC_HEADER_SIZE_X_BEGIN] + (header[ASTC_HEADER_SIZE_X_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_X_BEGIN + 2] << 16);
                out.height = levelIndex > 0 ? out.height : header[ASTC_HEADER_SIZE_Y_BEGIN] + (header[ASTC_HEADER_SIZE_Y_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_Y_BEGIN + 2] << 16);
                out.format = format;
              };
              var _proto = ImageAsset.prototype;
              _proto.extractMipmap0 = function extractMipmap0() {
                if (this.mipmapLevelDataSize && this.mipmapLevelDataSize.length > 0) {
                  var mipmapSize = this.mipmapLevelDataSize[0];
                  var data = this.data;
                  var dataView = new Uint8Array(data.buffer, 0, mipmapSize);
                  var mipmap = new ImageAsset({
                    _data: dataView,
                    _compressed: true,
                    width: this.width,
                    height: this.height,
                    format: this.format,
                    mipmapLevelDataSize: []
                  });
                  mipmap._uuid = "" + this._uuid;
                  return mipmap;
                } else {
                  return this;
                }
              };
              _proto.extractMipmaps = function extractMipmaps() {
                var images = [];
                if (this.mipmapLevelDataSize && this.mipmapLevelDataSize.length > 0) {
                  var mipmapLevelDataSize = this.mipmapLevelDataSize;
                  var data = this.data;
                  var byteOffset = 0;
                  var height = this.height;
                  var width = this.width;
                  for (var _iterator2 = _createForOfIteratorHelperLoose(mipmapLevelDataSize), _step2; !(_step2 = _iterator2()).done;) {
                    var mipmapSize = _step2.value;
                    var dataView = new Uint8Array(data.buffer, byteOffset, mipmapSize);
                    var mipmap = new ImageAsset({
                      _data: dataView,
                      _compressed: true,
                      width: width,
                      height: height,
                      format: this.format,
                      mipmapLevelDataSize: []
                    });
                    byteOffset += mipmapSize;
                    mipmap._uuid = "" + this._uuid;
                    width = Math.max(width >> 1, 1);
                    height = Math.max(height >> 1, 1);
                    images.push(mipmap);
                  }
                } else {
                  images.push(this);
                }
                return images;
              };
              function ImageAsset(nativeAsset) {
                var _this;
                _this = _Asset.call(this) || this;
                _this._nativeData = undefined;
                _this._exportedExts = undefined;
                _this._format = 35;
                _this._width = 0;
                _this._height = 0;
                _this._nativeData = {
                  _data: null,
                  width: 0,
                  height: 0,
                  format: 0,
                  _compressed: false,
                  mipmapLevelDataSize: []
                };
                if (nativeAsset !== undefined) {
                  _this.reset(nativeAsset);
                }
                return _this;
              }
              _proto.reset = function reset(data) {
                if (isImageBitmap(data)) {
                  this._nativeData = data;
                } else if (!(data instanceof HTMLElement)) {
                  this._nativeData = data;
                  this._format = data.format;
                } else {
                  this._nativeData = data;
                }
              };
              _proto.destroy = function destroy() {
                if (this.data && this.data instanceof HTMLImageElement) {
                  this.data.src = '';
                  this._setRawAsset('');
                } else if (isImageBitmap(this.data)) {
                  var _this$data;
                  (_this$data = this.data) == null ? undefined : _this$data.close();
                }
                return _Asset.prototype.destroy.call(this);
              };
              _proto._serialize = function _serialize() {
              };
              _proto._deserialize = function _deserialize(data) {
                var fmtStr = '';
                if (typeof data === 'string') {
                  fmtStr = data;
                } else {
                  this._width = data.w;
                  this._height = data.h;
                  fmtStr = data.fmt;
                }
                var device = _getGlobalDevice();
                var extensionIDs = fmtStr.split('_');
                var preferedExtensionIndex = Number.MAX_VALUE;
                var format = this._format;
                var ext = '';
                var SupportTextureFormats = macro.SUPPORT_TEXTURE_FORMATS;
                for (var _iterator4 = _createForOfIteratorHelperLoose(extensionIDs), _step4; !(_step4 = _iterator4()).done;) {
                  var extensionID = _step4.value;
                  var extFormat = extensionID.split('@');
                  var i = parseInt(extFormat[0], undefined);
                  var tmpExt = ImageAsset.extnames[i] || extFormat[0];
                  var index = SupportTextureFormats.indexOf(tmpExt);
                  if (index !== -1 && index < preferedExtensionIndex) {
                    var fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format;
                    if (tmpExt === '.astc' && (!device || !(device.getFormatFeatures(89) & 2))) {
                      continue;
                    } else if (tmpExt === '.pvr' && (!device || !(device.getFormatFeatures(86) & 2))) {
                      continue;
                    } else if ((fmt === 72 || fmt === 1026) && (!device || !(device.getFormatFeatures(72) & 2))) {
                      continue;
                    } else if ((fmt === 73 || fmt === 77) && (!device || !(device.getFormatFeatures(73) & 2))) {
                      continue;
                    } else if (tmpExt === '.webp' && !sys.hasFeature(sys.Feature.WEBP)) {
                      continue;
                    }
                    preferedExtensionIndex = index;
                    ext = tmpExt;
                    format = fmt;
                  }
                }
                if (ext) {
                  this._setRawAsset(ext);
                  this._format = format;
                } else {
                  warnID(3121);
                }
              };
              _proto.initDefault = function initDefault(uuid) {
                _Asset.prototype.initDefault.call(this, uuid);
                if (!ImageAsset._sharedPlaceHolderCanvas) {
                  var canvas = ccwindow.document.createElement('canvas');
                  var context = canvas.getContext('2d');
                  var l = canvas.width = canvas.height = 2;
                  context.fillStyle = '#ff00ff';
                  context.fillRect(0, 0, l, l);
                  this.reset(canvas);
                  ImageAsset._sharedPlaceHolderCanvas = canvas;
                } else {
                  this.reset(ImageAsset._sharedPlaceHolderCanvas);
                }
              };
              _proto.validate = function validate() {
                return !!this.data;
              };
              _createClass(ImageAsset, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._nativeData;
                },
                set: function set(value) {
                  if (!(value instanceof HTMLElement) && !isImageBitmap(value)) {
                    value.format = value.format || this._format;
                  }
                  this.reset(value);
                }
              }, {
                key: "data",
                get: function get() {
                  if (isNativeImage(this._nativeData)) {
                    return this._nativeData;
                  }
                  return this._nativeData && this._nativeData._data;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._nativeData.width || this._width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._nativeData.height || this._height;
                }
              }, {
                key: "format",
                get: function get() {
                  return this._format;
                }
              }, {
                key: "isCompressed",
                get: function get() {
                  return this._format >= 72 && this._format <= 102 || this._format >= 1024 && this._format <= 1026;
                }
              }, {
                key: "mipmapLevelDataSize",
                get: function get() {
                  return this._nativeData.mipmapLevelDataSize;
                }
              }, {
                key: "url",
                get: function get() {
                  return this.nativeUrl;
                }
              }]);
              return ImageAsset;
            }(Asset), _class3$b.extnames = ['.png', '.jpg', '.jpeg', '.bmp', '.webp', '.pvr', '.pkm', '.astc'], _class3$b._sharedPlaceHolderCanvas = null, _class3$b), (_applyDecoratedDescriptor(_class2$B.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$B.prototype, "_nativeAsset"), _class2$B.prototype)), _class2$B)) || _class$G));
            function _getGlobalDevice() {
              return deviceManager.gfxDevice;
            }
            cclegacy.ImageAsset = ImageAsset;

            var _dec$E, _class$F, _class2$A, _initializer$y;
            var MissingScript = exports("MissingScript", (_dec$E = ccclass$6('cc.MissingScript'), _dec$E(_class$F = (_class2$A = function (_Component) {
              _inheritsLoose(MissingScript, _Component);
              MissingScript.safeFindClass = function safeFindClass(id) {
                var cls = getClassById(id);
                if (cls) {
                  return cls;
                }
                cclegacy.deserialize.reportMissingClass(id);
                return undefined;
              };
              function MissingScript() {
                var _this;
                _this = _Component.call(this) || this;
                _this._$erialized = _initializer$y && _initializer$y();
                return _this;
              }
              var _proto = MissingScript.prototype;
              _proto.onLoad = function onLoad() {
                warnID(4600, this.node.name);
              };
              return MissingScript;
            }(Component), (_initializer$y = applyDecoratedInitializer(_class2$A.prototype, "_$erialized", [serializable$5, editorOnly], function () {
              return null;
            })), _class2$A)) || _class$F));
            cclegacy._MissingScript = MissingScript;
            try {
              var props = MissingScript.__values__;
              if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
                errorID(16338);
                errorID(16339, props.join(', '));
              }
            } catch (e) {
              errorID(16340, "" + e);
            }

            var Decoder = function () {
              function Decoder(buffer) {
                this._offset = 0;
                this._buffer = undefined;
                this._view = undefined;
                if (buffer instanceof ArrayBuffer) {
                  this._buffer = buffer;
                  this._view = new DataView(this._buffer);
                } else if (ArrayBuffer.isView(buffer)) {
                  this._buffer = buffer.buffer;
                  this._view = new DataView(this._buffer, buffer.byteOffset, buffer.byteLength);
                } else {
                  throw new Error('Invalid argument');
                }
              }
              var _proto = Decoder.prototype;
              _proto._array = function _array(length) {
                var value = new Array(length);
                for (var i = 0; i < length; i++) {
                  value[i] = this.parse();
                }
                return value;
              };
              _proto._map = function _map(length) {
                var key = '';
                var value = {};
                for (var i = 0; i < length; i++) {
                  key = this.parse();
                  value[key] = this.parse();
                }
                return value;
              };
              _proto._str = function _str(length) {
                var value = utf8Read(this._view, this._offset, length);
                this._offset += length;
                return value;
              };
              _proto._bin = function _bin(length) {
                var value = this._buffer.slice(this._offset, this._offset + length);
                this._offset += length;
                return value;
              };
              _proto.parse = function parse() {
                var prefix = this._view.getUint8(this._offset++);
                var value;
                var length = 0;
                var type = 0;
                var hi = 0;
                var lo = 0;
                if (prefix < 0xc0) {
                  if (prefix < 0x80) {
                    return prefix;
                  }
                  if (prefix < 0x90) {
                    return this._map(prefix & 0x0f);
                  }
                  if (prefix < 0xa0) {
                    return this._array(prefix & 0x0f);
                  }
                  return this._str(prefix & 0x1f);
                }
                if (prefix > 0xdf) {
                  return (0xff - prefix + 1) * -1;
                }
                switch (prefix) {
                  case 0xc0:
                    return null;
                  case 0xc2:
                    return false;
                  case 0xc3:
                    return true;
                  case 0xc4:
                    length = this._view.getUint8(this._offset);
                    this._offset += 1;
                    return this._bin(length);
                  case 0xc5:
                    length = this._view.getUint16(this._offset);
                    this._offset += 2;
                    return this._bin(length);
                  case 0xc6:
                    length = this._view.getUint32(this._offset);
                    this._offset += 4;
                    return this._bin(length);
                  case 0xc7:
                    length = this._view.getUint8(this._offset);
                    type = this._view.getInt8(this._offset + 1);
                    this._offset += 2;
                    if (type === -1) {
                      var ns = this._view.getUint32(this._offset);
                      hi = this._view.getInt32(this._offset + 4);
                      lo = this._view.getUint32(this._offset + 8);
                      this._offset += 12;
                      return new Date((hi * 0x100000000 + lo) * 1e3 + ns / 1e6);
                    }
                    return [type, this._bin(length)];
                  case 0xc8:
                    length = this._view.getUint16(this._offset);
                    type = this._view.getInt8(this._offset + 2);
                    this._offset += 3;
                    return [type, this._bin(length)];
                  case 0xc9:
                    length = this._view.getUint32(this._offset);
                    type = this._view.getInt8(this._offset + 4);
                    this._offset += 5;
                    return [type, this._bin(length)];
                  case 0xca:
                    value = this._view.getFloat32(this._offset);
                    this._offset += 4;
                    return value;
                  case 0xcb:
                    value = this._view.getFloat64(this._offset);
                    this._offset += 8;
                    return value;
                  case 0xcc:
                    value = this._view.getUint8(this._offset);
                    this._offset += 1;
                    return value;
                  case 0xcd:
                    value = this._view.getUint16(this._offset);
                    this._offset += 2;
                    return value;
                  case 0xce:
                    value = this._view.getUint32(this._offset);
                    this._offset += 4;
                    return value;
                  case 0xcf:
                    hi = this._view.getUint32(this._offset) * Math.pow(2, 32);
                    lo = this._view.getUint32(this._offset + 4);
                    this._offset += 8;
                    return hi + lo;
                  case 0xd0:
                    value = this._view.getInt8(this._offset);
                    this._offset += 1;
                    return value;
                  case 0xd1:
                    value = this._view.getInt16(this._offset);
                    this._offset += 2;
                    return value;
                  case 0xd2:
                    value = this._view.getInt32(this._offset);
                    this._offset += 4;
                    return value;
                  case 0xd3:
                    hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
                    lo = this._view.getUint32(this._offset + 4);
                    this._offset += 8;
                    return hi + lo;
                  case 0xd4:
                    type = this._view.getInt8(this._offset);
                    this._offset += 1;
                    if (type === 0x00) {
                      this._offset += 1;
                      return undefined;
                    }
                    return [type, this._bin(1)];
                  case 0xd5:
                    type = this._view.getInt8(this._offset);
                    this._offset += 1;
                    return [type, this._bin(2)];
                  case 0xd6:
                    type = this._view.getInt8(this._offset);
                    this._offset += 1;
                    if (type === -1) {
                      value = this._view.getUint32(this._offset);
                      this._offset += 4;
                      return new Date(value * 1e3);
                    }
                    return [type, this._bin(4)];
                  case 0xd7:
                    type = this._view.getInt8(this._offset);
                    this._offset += 1;
                    if (type === 0x00) {
                      hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
                      lo = this._view.getUint32(this._offset + 4);
                      this._offset += 8;
                      return new Date(hi + lo);
                    }
                    if (type === -1) {
                      hi = this._view.getUint32(this._offset);
                      lo = this._view.getUint32(this._offset + 4);
                      this._offset += 8;
                      var s = (hi & 0x3) * 0x100000000 + lo;
                      return new Date(s * 1e3 + (hi >>> 2) / 1e6);
                    }
                    return [type, this._bin(8)];
                  case 0xd8:
                    type = this._view.getInt8(this._offset);
                    this._offset += 1;
                    return [type, this._bin(16)];
                  case 0xd9:
                    length = this._view.getUint8(this._offset);
                    this._offset += 1;
                    return this._str(length);
                  case 0xda:
                    length = this._view.getUint16(this._offset);
                    this._offset += 2;
                    return this._str(length);
                  case 0xdb:
                    length = this._view.getUint32(this._offset);
                    this._offset += 4;
                    return this._str(length);
                  case 0xdc:
                    length = this._view.getUint16(this._offset);
                    this._offset += 2;
                    return this._array(length);
                  case 0xdd:
                    length = this._view.getUint32(this._offset);
                    this._offset += 4;
                    return this._array(length);
                  case 0xde:
                    length = this._view.getUint16(this._offset);
                    this._offset += 2;
                    return this._map(length);
                  case 0xdf:
                    length = this._view.getUint32(this._offset);
                    this._offset += 4;
                    return this._map(length);
                }
                throw new Error('Could not parse');
              };
              _createClass(Decoder, [{
                key: "offset",
                get: function get() {
                  return this._offset;
                }
              }]);
              return Decoder;
            }();
            function utf8Read(view, offset, length) {
              var string = '';
              var chr = 0;
              for (var i = offset, end = offset + length; i < end; i++) {
                var _byte = view.getUint8(i);
                if ((_byte & 0x80) === 0x00) {
                  string += String.fromCharCode(_byte);
                  continue;
                }
                if ((_byte & 0xe0) === 0xc0) {
                  string += String.fromCharCode((_byte & 0x1f) << 6 | view.getUint8(++i) & 0x3f);
                  continue;
                }
                if ((_byte & 0xf0) === 0xe0) {
                  string += String.fromCharCode((_byte & 0x0f) << 12 | (view.getUint8(++i) & 0x3f) << 6 | (view.getUint8(++i) & 0x3f) << 0);
                  continue;
                }
                if ((_byte & 0xf8) === 0xf0) {
                  chr = (_byte & 0x07) << 18 | (view.getUint8(++i) & 0x3f) << 12 | (view.getUint8(++i) & 0x3f) << 6 | (view.getUint8(++i) & 0x3f) << 0;
                  if (chr >= 0x010000) {
                    chr -= 0x010000;
                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
                  } else {
                    string += String.fromCharCode(chr);
                  }
                  continue;
                }
                throw new Error("Invalid byte " + _byte.toString(16));
              }
              return string;
            }
            function notepackDecode(buffer) {
              var decoder = new Decoder(buffer);
              var value = decoder.parse();
              if (decoder.offset !== buffer.byteLength) {
                throw new Error(buffer.byteLength - decoder.offset + " trailing bytes");
              }
              return value;
            }

            var MAGIC = 0x4E4F4343;
            var CHUNK_ALIGN_AS = 8;
            var CCON = function () {
              function CCON(document, chunks) {
                this._document = document;
                this._chunks = chunks;
              }
              _createClass(CCON, [{
                key: "document",
                get: function get() {
                  return this._document;
                }
              }, {
                key: "chunks",
                get: function get() {
                  return this._chunks;
                }
              }]);
              return CCON;
            }();
            function decodeCCONBinary(bytes) {
              if (bytes.length < 16) {
                throw new InvalidCCONError(getError(13102));
              }
              var dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
              var magic = dataView.getUint32(0, true);
              if (magic !== MAGIC) {
                throw new InvalidCCONError(getError(13100));
              }
              var version = dataView.getUint32(4, true);
              var dataByteLength = dataView.getUint32(8, true);
              if (dataByteLength !== dataView.byteLength) {
                throw new InvalidCCONError(getError(13102));
              }
              var chunksStart = 12;
              var jsonDataLength = dataView.getUint32(chunksStart, true);
              chunksStart += 4;
              var jsonData = new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, jsonDataLength);
              chunksStart += jsonDataLength;
              var json;
              try {
                if (version === 1) {
                  var jsonString = decodeJson(jsonData);
                  json = JSON.parse(jsonString);
                } else if (version === 2) {
                  json = notepackDecode(jsonData);
                }
              } catch (err) {
                throw new InvalidCCONError(err);
              }
              var chunks = [];
              while (chunksStart < dataView.byteLength) {
                if (chunksStart % CHUNK_ALIGN_AS !== 0) {
                  var padding = CHUNK_ALIGN_AS - chunksStart % CHUNK_ALIGN_AS;
                  chunksStart += padding;
                }
                var chunkDataLength = dataView.getUint32(chunksStart, true);
                chunksStart += 4;
                chunks.push(new Uint8Array(dataView.buffer, chunksStart + dataView.byteOffset, chunkDataLength));
                chunksStart += chunkDataLength;
              }
              if (chunksStart !== dataView.byteLength) {
                throw new InvalidCCONError(getError(13102));
              }
              return new CCON(json, chunks);
            }
            function decodeJson(data) {
              if (typeof TextDecoder !== 'undefined') {
                return new TextDecoder().decode(data);
              } else if ('Buffer' in globalThis) {
                var _ref = globalThis,
                  _Buffer = _ref.Buffer;
                return _Buffer.from(data.buffer, data.byteOffset, data.byteLength).toString();
              } else {
                throw new Error(getError(13104));
              }
            }
            var InvalidCCONError = function (_Error) {
              _inheritsLoose(InvalidCCONError, _Error);
              function InvalidCCONError() {
                return _Error.apply(this, arguments) || this;
              }
              return InvalidCCONError;
            }(_wrapNativeSuper(Error));
            (function () {
              function BufferBuilder() {
                this._viewOrPaddings = [];
                this._length = 0;
              }
              var _proto = BufferBuilder.prototype;
              _proto.alignAs = function alignAs(align) {
                if (align !== 0) {
                  var remainder = this._length % align;
                  if (remainder !== 0) {
                    var padding = align - remainder;
                    this._viewOrPaddings.push(padding);
                    this._length += padding;
                    return padding;
                  }
                }
                return 0;
              };
              _proto.append = function append(view) {
                var result = this._length;
                this._viewOrPaddings.push(view);
                this._length += view.byteLength;
                return result;
              };
              _proto.get = function get() {
                var result = new Uint8Array(this._length);
                var counter = 0;
                this._viewOrPaddings.forEach(function (viewOrPadding) {
                  if (typeof viewOrPadding === 'number') {
                    counter += viewOrPadding;
                  } else {
                    result.set(new Uint8Array(viewOrPadding.buffer, viewOrPadding.byteOffset, viewOrPadding.byteLength), counter);
                    counter += viewOrPadding.byteLength;
                  }
                });
                return result;
              };
              _createClass(BufferBuilder, [{
                key: "byteLength",
                get: function get() {
                  return this._length;
                }
              }]);
              return BufferBuilder;
            })();
            cclegacy.internal.decodeCCONBinary = decodeCCONBinary;
            cclegacy.internal.CCON = CCON;

            function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue) {
              if (defaultValue instanceof cclegacy.ValueType) {
                if (!assumeHavePropIfIsValue) {
                  sources.push('if(prop){');
                }
                var ctorCode = getClassName(defaultValue);
                sources.push("s._deserializeFastDefinedObject(o" + accessorToSet + ",prop," + ctorCode + ");");
                if (!assumeHavePropIfIsValue) {
                  sources.push("}else o" + accessorToSet + "=null;");
                }
              } else {
                sources.push("\nif (prop) {\n    s._deserializeAndAssignField(o, prop, " + propNameLiteralToSet + ");\n} else {\n    o" + accessorToSet + "=null;\n}\n");
              }
            }
            var compileDeserialize = compileDeserializeJIT ;
            var DELIMITER = CCClass.Attr.DELIMETER;
            var POSTFIX_TYPE = DELIMITER + "type";
            var POSTFIX_DEFAULT = DELIMITER + "default";
            var POSTFIX_FORMERLY_SERIALIZED_AS = DELIMITER + "formerlySerializedAs";
            function compileDeserializeJIT(self, klass) {
              var attrs = CCClass.Attr.getClassAttrs(klass);
              var props = klass.__values__;
              var sources = ['var prop;'];
              var fastMode = canBeDeserializedInFastMode(klass);
              for (var p = 0; p < props.length; p++) {
                var propName = props[p];
                var accessorToSet = undefined;
                var propNameLiteralToSet = undefined;
                if (CCClass.IDENTIFIER_RE.test(propName)) {
                  propNameLiteralToSet = "\"" + propName + "\"";
                  accessorToSet = "." + propName;
                } else {
                  propNameLiteralToSet = CCClass.escapeForJS(propName);
                  accessorToSet = "[" + propNameLiteralToSet + "]";
                }
                var accessorToGet = accessorToSet;
                if (attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS]) {
                  var propNameToRead = attrs[propName + POSTFIX_FORMERLY_SERIALIZED_AS];
                  if (CCClass.IDENTIFIER_RE.test(propNameToRead)) {
                    accessorToGet = "." + propNameToRead;
                  } else {
                    accessorToGet = "[" + CCClass.escapeForJS(propNameToRead) + "]";
                  }
                }
                sources.push("prop=d" + accessorToGet + ";");
                sources.push("if(typeof " + ('prop') + "!==\"undefined\"){");
                var defaultValue = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
                var userType = attrs[propName + POSTFIX_TYPE];
                if (fastMode && (defaultValue !== undefined || userType)) {
                  var isPrimitiveTypeInFastMode = isPrimitivePropertyByDefaultOrType(defaultValue, userType);
                  if (isPrimitiveTypeInFastMode) {
                    sources.push("o" + accessorToSet + "=prop;");
                  } else {
                    compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true);
                  }
                } else {
                  sources.push("" + ("if(typeof " + ('prop') + "!==\"object\"){" + 'o') + accessorToSet + "=prop;" + "}else{");
                  compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false);
                  sources.push('}');
                }
                sources.push('}');
              }
              if (isChildClassOf(klass, cclegacy.Node) || isChildClassOf(klass, cclegacy.Component)) {
                {
                  sources.push('d._id&&(o._id=d._id);');
                }
              }
              if (props[props.length - 1] === '_$erialized') {
                sources.push('o._$erialized=JSON.parse(JSON.stringify(d));');
                sources.push('s._fillPlainObject(o._$erialized,d);');
              }
              return Function('s', 'o', 'd', 'k', sources.join(''));
            }
            function canBeDeserializedInFastMode(klass) {
              return BUILTIN_CLASSID_RE.test(getClassId(klass));
            }
            function isPrimitivePropertyByDefaultOrType(defaultValue, userType) {
              if (defaultValue === undefined) {
                return userType instanceof CCClass.Attr.PrimitiveType || userType === ENUM_TAG || userType === BITMASK_TAG;
              } else {
                var defaultType = typeof defaultValue;
                return defaultType === 'string' || defaultType === 'number' || defaultType === 'boolean';
              }
            }
            var DeserializerPool = function (_js$Pool) {
              _inheritsLoose(DeserializerPool, _js$Pool);
              function DeserializerPool() {
                return _js$Pool.call(this, function (deserializer) {
                  deserializer.clear();
                }, 1) || this;
              }
              return DeserializerPool;
            }(Pool$1);
            DeserializerPool.prototype.get = function (details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
              var cache = this._get();
              if (cache) {
                cache.reset(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
                return cache;
              } else {
                return new _Deserializer(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
              }
            };
            var _Deserializer = function () {
              function _Deserializer(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
                this.deserializedList = [];
                this.deserializedData = null;
                this.result = result;
                this.customEnv = customEnv;
                this._classFinder = classFinder;
                this._reportMissingClass = reportMissingClass;
                this._onDereferenced = classFinder == null ? undefined : classFinder.onDereferenced;
              }
              var _proto = _Deserializer.prototype;
              _proto.reset = function reset(result, classFinder, reportMissingClass, customEnv, ignoreEditorOnly) {
                this.result = result;
                this.customEnv = customEnv;
                this._classFinder = classFinder;
                this._reportMissingClass = reportMissingClass;
                this._onDereferenced = classFinder == null ? undefined : classFinder.onDereferenced;
              };
              _proto.clear = function clear() {
                this.result = null;
                this.customEnv = null;
                this.deserializedList.length = 0;
                this.deserializedData = null;
                this._classFinder = null;
                this._reportMissingClass = null;
                this._onDereferenced = null;
              };
              _proto.deserialize = function deserialize(serializedData) {
                var fromCCON = false;
                var jsonObj;
                if (serializedData instanceof CCON) {
                  fromCCON = true;
                  jsonObj = serializedData.document;
                  if (serializedData.chunks.length > 0) {
                    assertIsTrue(serializedData.chunks.length === 1);
                    this._mainBinChunk = serializedData.chunks[0];
                  }
                } else {
                  jsonObj = serializedData;
                }
                this._serializedData = jsonObj;
                this._context = {
                  fromCCON: fromCCON
                };
                var serializedRootObject = Array.isArray(jsonObj) ? jsonObj[0] : jsonObj;
                {
                  this.deserializedData = this._deserializeObject(serializedRootObject, 0);
                }
                this._serializedData = undefined;
                this._mainBinChunk = undefined;
                this._context = undefined;
                return this.deserializedData;
              };
              _proto._deserializeObject = function _deserializeObject(serialized, globalIndex, owner, propName) {
                switch (serialized.__type__) {
                  case 'TypedArray':
                    return this._deserializeTypedArrayView(serialized);
                  case 'TypedArrayRef':
                    return this._deserializeTypedArrayViewRef(serialized);
                  default:
                    if (serialized.__type__) {
                      return this._deserializeTypeTaggedObject(serialized, globalIndex, owner, propName);
                    } else if (!Array.isArray(serialized)) {
                      return this._deserializePlainObject(serialized);
                    } else {
                      return this._deserializeArray(serialized);
                    }
                }
              };
              _proto._deserializeTypedArrayView = function _deserializeTypedArrayView(value) {
                return globalThis[value.ctor].from(value.array);
              };
              _proto._deserializeTypedArrayViewRef = function _deserializeTypedArrayViewRef(value) {
                var offset = value.offset,
                  length = value.length,
                  constructorName = value.ctor;
                var obj = new globalThis[constructorName](this._mainBinChunk.buffer, this._mainBinChunk.byteOffset + offset, length);
                return obj;
              };
              _proto._deserializeArray = function _deserializeArray(value) {
                var obj = new Array(value.length);
                var prop;
                for (var i = 0; i < value.length; i++) {
                  prop = value[i];
                  if (typeof prop === 'object' && prop) {
                    var isAssetType = this._deserializeAndAssignField(obj, prop, "" + i);
                    if (isAssetType) {
                      obj[i] = null;
                    }
                  } else {
                    obj[i] = prop;
                  }
                }
                return obj;
              };
              _proto._deserializePlainObject = function _deserializePlainObject(value) {
                var obj = {};
                this._fillPlainObject(obj, value);
                return obj;
              };
              _proto._deserializeTypeTaggedObject = function _deserializeTypeTaggedObject(value, globalIndex, owner, propName) {
                var _this = this;
                var type = value.__type__;
                var klass = this._classFinder(type, value, owner, propName);
                if (!klass) {
                  var notReported = this._classFinder === getClassById;
                  if (notReported) {
                    this._reportMissingClass(type);
                  }
                  return null;
                }
                var createObject = function createObject(constructor) {
                  var obj = new constructor();
                  if (globalIndex >= 0) {
                    _this.deserializedList[globalIndex] = obj;
                  }
                  return obj;
                };
                {
                  var obj = createObject(klass);
                  this._deserializeInto(value, obj, klass);
                  return obj;
                }
              };
              _proto._deserializeInto = function _deserializeInto(value, object, constructor, skipCustomized) {
                if (skipCustomized === undefined) {
                  skipCustomized = false;
                }
                if (!skipCustomized && object[deserializeTag]) {
                  this._runCustomizedDeserialize(value, object, constructor);
                  return;
                }
                if (object._deserialize) {
                  object._deserialize(value.content, this);
                  return;
                }
                if (cclegacy.Class._isCCClass(constructor)) {
                  this._deserializeFireClass(object, value, constructor);
                } else {
                  this._deserializeFastDefinedObject(object, value, constructor);
                }
              };
              _proto._runCustomizedDeserialize = function _runCustomizedDeserialize(value, object, constructor) {
                var _this2 = this;
                var serializationInput = {
                  readProperty: function readProperty(name) {
                    var serializedField = value[name];
                    if (typeof serializedField !== 'object' || !serializedField) {
                      return serializedField;
                    } else {
                      return _this2._deserializeObjectField(serializedField);
                    }
                  },
                  readThis: function readThis() {
                    _this2._deserializeInto(value, object, constructor, true);
                  },
                  readSuper: function readSuper() {
                    var superConstructor = getSuper(constructor);
                    if (superConstructor) {
                      _this2._deserializeInto(value, object, superConstructor);
                    }
                  }
                };
                object[deserializeTag](serializationInput, this._context);
              };
              _proto._deserializeFireClass = function _deserializeFireClass(obj, serialized, klass) {
                var deserialize;
                if (klass.hasOwnProperty('__deserialize__')) {
                  deserialize = klass.__deserialize__;
                } else {
                  deserialize = compileDeserialize(this, klass);
                  try {
                    if (klass === MissingScript) {
                      var props = klass.__values__;
                      if (props.length === 0 || props[props.length - 1] !== '_$erialized') {
                        errorID(16341);
                        errorID(16342, props.join(', '));
                      }
                      var rawDeserialize = deserialize;
                      deserialize = function deserialize(deserializer, object, deserialized, constructor) {
                        rawDeserialize(deserializer, object, deserialized, constructor);
                        if (!object._$erialized) {
                          errorID(16343, JSON.stringify(deserialized));
                        }
                      };
                    }
                  } catch (e) {
                    errorID(16344, "" + e);
                  }
                  value(klass, '__deserialize__', deserialize, true);
                }
                deserialize(this, obj, serialized, klass);
              };
              _proto._deserializeAndAssignField = function _deserializeAndAssignField(obj, serializedField, propName) {
                var id = serializedField.__id__;
                if (typeof id === 'number') {
                  var field = this.deserializedList[id];
                  if (field) {
                    obj[propName] = field;
                  } else {
                    var _this$_onDereferenced;
                    var source = this._serializedData[id];
                    {
                      obj[propName] = this._deserializeObject(source, id, undefined, propName);
                    }
                    (_this$_onDereferenced = this._onDereferenced) == null ? undefined : _this$_onDereferenced.call(this, this.deserializedList, id, obj, propName);
                  }
                } else {
                  var uuid = serializedField.__uuid__;
                  if (uuid) {
                    var expectedType = serializedField.__expectedType__;
                    this.result.push(obj, propName, uuid, expectedType);
                  } else {
                    obj[propName] = this._deserializeObject(serializedField, -1);
                  }
                }
                return false;
              };
              _proto._deserializeObjectField = function _deserializeObjectField(serializedField) {
                var id = serializedField.__id__;
                if (typeof id === 'number') {
                  var field = this.deserializedList[id];
                  if (field) {
                    return field;
                  } else {
                    var source = this._serializedData[id];
                    var _field = this._deserializeObject(source, id, undefined, undefined);
                    return _field;
                  }
                } else {
                  var uuid = serializedField.__uuid__;
                  if (uuid) {
                    serializedField.__expectedType__;
                    throw new Error("Asset reference field serialization is currently not supported in custom serialization.");
                  } else {
                    return this._deserializeObject(serializedField, -1);
                  }
                }
              };
              _proto._fillPlainObject = function _fillPlainObject(instance, serialized) {
                for (var propName in serialized) {
                  if (!serialized.hasOwnProperty(propName)) {
                    continue;
                  }
                  var prop = serialized[propName];
                  if (typeof prop !== 'object') {
                    if (propName !== '__type__') {
                      instance[propName] = prop;
                    }
                  } else if (prop) {
                    var isAssetType = this._deserializeAndAssignField(instance, prop, propName);
                    if (isAssetType) {
                      instance[propName] = null;
                    }
                  } else {
                    instance[propName] = null;
                  }
                }
              };
              _proto._deserializeFastDefinedObject = function _deserializeFastDefinedObject(instance, serialized, klass) {
                if (klass === cclegacy.Vec2) {
                  instance.x = serialized.x || 0;
                  instance.y = serialized.y || 0;
                  return;
                } else if (klass === cclegacy.Vec3) {
                  instance.x = serialized.x || 0;
                  instance.y = serialized.y || 0;
                  instance.z = serialized.z || 0;
                  return;
                } else if (klass === cclegacy.Color) {
                  instance.r = serialized.r || 0;
                  instance.g = serialized.g || 0;
                  instance.b = serialized.b || 0;
                  var a = serialized.a;
                  instance.a = a === undefined ? 255 : a;
                  return;
                } else if (klass === cclegacy.Size) {
                  instance.width = serialized.width || 0;
                  instance.height = serialized.height || 0;
                  return;
                }
                var attrs = CCClass.Attr.getClassAttrs(klass);
                var props = klass.__values__;
                if (!props) {
                  error("Unable to deserialize " + getClassName(klass) + ". " + 'For non-CCClass types, they can only be marked as serializable by `CCClass.fastDefine`.');
                }
                for (var i = 0; i < props.length; i++) {
                  var propName = props[i];
                  var value = serialized[propName];
                  var exists = value !== undefined || serialized.hasOwnProperty(propName);
                  if (!exists) {
                    value = CCClass.getDefault(attrs[propName + POSTFIX_DEFAULT]);
                  }
                  if (typeof value !== 'object') {
                    instance[propName] = value;
                  } else if (value) {
                    this._deserializeAndAssignField(instance, value, propName);
                  } else {
                    instance[propName] = null;
                  }
                }
              };
              _createClass(_Deserializer, [{
                key: "ignoreEditorOnly",
                get: function get() {
                  return this._ignoreEditorOnly;
                }
              }]);
              return _Deserializer;
            }();
            _Deserializer.pool = new DeserializerPool();
            function deserializeDynamic(data, details, options) {
              var _options$reportMissin;
              options = options || {};
              var classFinder = options.classFinder || getClassById;
              var createAssetRefs = options.createAssetRefs || sys.platform === Platform.EDITOR_CORE;
              var customEnv = options.customEnv;
              var ignoreEditorOnly = options.ignoreEditorOnly;
              var reportMissingClass = (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== undefined ? _options$reportMissin : cclegacy.deserialize.reportMissingClass;
              details.init();
              var deserializer = _Deserializer.pool.get(details, classFinder, reportMissingClass, customEnv, ignoreEditorOnly);
              cclegacy.game._isCloning = true;
              var res = deserializer.deserialize(data);
              cclegacy.game._isCloning = false;
              _Deserializer.pool.put(deserializer);
              if (createAssetRefs) {
                details.assignAssetsBy(function (uuid, options) {
                  return EditorExtends.serialize.asAsset(uuid, options.type);
                });
              }
              return res;
            }

            function reportMissingClass(id) {
              {
                errorID(5302, id);
              }
            }

            var constructorMap = [Vec2, Vec3, Vec4, Quat, Color, Size, Rect, Mat4];
            function vec4LikeSetter(obj, data) {
              obj.x = data[1];
              obj.y = data[2];
              obj.z = data[3];
              obj.w = data[4];
            }
            var setterMap = [function (obj, data) {
              obj.x = data[1];
              obj.y = data[2];
            }, function (obj, data) {
              obj.x = data[1];
              obj.y = data[2];
              obj.z = data[3];
            }, vec4LikeSetter, vec4LikeSetter, function (obj, data) {
              Color.fromUint32(obj, data[1]);
            }, function (obj, data) {
              obj.width = data[1];
              obj.height = data[2];
            }, function (obj, data) {
              obj.x = data[1];
              obj.y = data[2];
              obj.width = data[3];
              obj.height = data[4];
            }, function (obj, data) {
              Mat4.fromArray(obj, data, 1);
            }];
            function deserializeBuiltinValueType(data, owner, key, value) {
              var typeIndex = value[0];
              assertIsTrue(typeIndex >= 0 && typeIndex < constructorMap.length);
              var object = new constructorMap[typeIndex]();
              var setter = setterMap[typeIndex];
              setter(object, value);
              owner[key] = object;
            }
            function deserializeBuiltinValueTypeInto(data, owner, key, value) {
              var typeIndex = value[0];
              assertIsTrue(typeIndex >= 0 && typeIndex < constructorMap.length);
              {
                var object = owner[key];
                var _setter = setterMap[typeIndex];
                _setter(object, value);
              }
            }

            var SUPPORT_MIN_FORMAT_VERSION = 1;
            var EMPTY_PLACEHOLDER = 0;
            var CLASS_TYPE = 0;
            var CLASS_KEYS = 1;
            var CLASS_PROP_TYPE_OFFSET = 2;
            var MASK_CLASS = 0;
            var OBJ_DATA_MASK = 0;
            var CUSTOM_OBJ_DATA_CLASS = 0;
            var CUSTOM_OBJ_DATA_CONTENT = 1;
            var DICT_JSON_LAYOUT = 0;
            var ARRAY_ITEM_VALUES = 0;
            var PACKED_SECTIONS = 5;
            var Details = exports("Details", function () {
              function Details() {
                this.uuidObjList = null;
                this.uuidPropList = null;
                this.uuidList = null;
                this.uuidTypeList = [];
              }
              var _proto = Details.prototype;
              _proto.init = function init(data) {
                if (data) {
                  this.uuidObjList = data[8];
                  this.uuidPropList = data[9];
                  this.uuidList = data[10];
                } else {
                  var used = this.uuidList;
                  if (!used) {
                    this.uuidList = [];
                    this.uuidObjList = [];
                    this.uuidPropList = [];
                    this.uuidTypeList = [];
                  }
                }
              };
              _proto.reset = function reset() {
                {
                  var used = this.uuidList;
                  if (used) {
                    this.uuidList.length = 0;
                    this.uuidObjList.length = 0;
                    this.uuidPropList.length = 0;
                    this.uuidTypeList.length = 0;
                  }
                }
              };
              _proto.push = function push(obj, propName, uuid, type) {
                this.uuidObjList.push(obj);
                this.uuidPropList.push(propName);
                this.uuidList.push(uuid);
                this.uuidTypeList.push(type || '');
              };
              return Details;
            }());
            Details.pool = new Pool$1(function (obj) {
              obj.reset();
            }, 5);
            Details.pool.get = function () {
              return this._get() || new Details();
            };
            function dereference(refs, instances, strings) {
              var dataLength = refs.length - 1;
              var i = 0;
              var instanceOffset = refs[dataLength] * 3;
              for (; i < instanceOffset; i += 3) {
                var _owner = refs[i];
                var target = instances[refs[i + 2]];
                var keyIndex = refs[i + 1];
                if (keyIndex >= 0) {
                  _owner[strings[keyIndex]] = target;
                } else {
                  _owner[~keyIndex] = target;
                }
              }
              for (; i < dataLength; i += 3) {
                var _owner2 = instances[refs[i]];
                var _target = instances[refs[i + 2]];
                var _keyIndex = refs[i + 1];
                if (_keyIndex >= 0) {
                  _owner2[strings[_keyIndex]] = _target;
                } else {
                  _owner2[~_keyIndex] = _target;
                }
              }
            }
            function deserializeCCObject(data, objectData) {
              var mask = data[4][objectData[OBJ_DATA_MASK]];
              var clazz = mask[MASK_CLASS];
              var ctor = clazz[CLASS_TYPE];
              var obj = new ctor();
              var keys = clazz[CLASS_KEYS];
              var classTypeOffset = clazz[CLASS_PROP_TYPE_OFFSET];
              var maskTypeOffset = mask[mask.length - 1];
              var i = MASK_CLASS + 1;
              for (; i < maskTypeOffset; ++i) {
                var _key = keys[mask[i]];
                obj[_key] = objectData[i];
              }
              for (; i < objectData.length; ++i) {
                var _key2 = keys[mask[i]];
                var type = clazz[mask[i] + classTypeOffset];
                var op = ASSIGNMENTS[type];
                op(data, obj, _key2, objectData[i]);
              }
              return obj;
            }
            function deserializeCustomCCObject(data, ctor, value) {
              var obj = new ctor();
              if (obj._deserialize) {
                obj._deserialize(value, data[0]);
              } else {
                errorID(5303, getClassName(ctor));
              }
              return obj;
            }
            function assignSimple(data, owner, key, value) {
              owner[key] = value;
            }
            function assignInstanceRef(data, owner, key, value) {
              if (value >= 0) {
                owner[key] = data[5][value];
              } else {
                data[7][~value * 3] = owner;
              }
            }
            function genArrayParser(parser) {
              return function (data, owner, key, value) {
                for (var i = 0; i < value.length; ++i) {
                  parser(data, value, i, value[i]);
                }
                owner[key] = value;
              };
            }
            function parseAssetRefByInnerObj(data, owner, key, value) {
              owner[key] = null;
              data[8][value] = owner;
            }
            function parseClass(data, owner, key, value) {
              owner[key] = deserializeCCObject(data, value);
            }
            function parseCustomClass(data, owner, key, value) {
              var ctor = data[3][value[CUSTOM_OBJ_DATA_CLASS]];
              owner[key] = deserializeCustomCCObject(data, ctor, value[CUSTOM_OBJ_DATA_CONTENT]);
            }
            function parseTRS(data, owner, key, value) {
              var typedArray = owner[key];
              typedArray.set(value);
            }
            function parseDict(data, owner, key, value) {
              var dict = value[DICT_JSON_LAYOUT];
              owner[key] = dict;
              for (var i = DICT_JSON_LAYOUT + 1; i < value.length; i += 3) {
                var subKey = value[i];
                var subType = value[i + 1];
                var subValue = value[i + 2];
                var op = ASSIGNMENTS[subType];
                op(data, dict, subKey, subValue);
              }
            }
            function parseArray(data, owner, key, value) {
              var array = value[ARRAY_ITEM_VALUES];
              for (var i = 0; i < array.length; ++i) {
                var subValue = array[i];
                var type = value[i + 1];
                if (type !== 0) {
                  var op = ASSIGNMENTS[type];
                  op(data, array, i, subValue);
                }
              }
              owner[key] = array;
            }
            var ASSIGNMENTS = new Array(13);
            ASSIGNMENTS[0] = assignSimple;
            ASSIGNMENTS[1] = assignInstanceRef;
            ASSIGNMENTS[2] = genArrayParser(assignInstanceRef);
            ASSIGNMENTS[3] = genArrayParser(parseAssetRefByInnerObj);
            ASSIGNMENTS[4] = parseClass;
            ASSIGNMENTS[5] = deserializeBuiltinValueTypeInto;
            ASSIGNMENTS[6] = parseAssetRefByInnerObj;
            ASSIGNMENTS[7] = parseTRS;
            ASSIGNMENTS[8] = deserializeBuiltinValueType;
            ASSIGNMENTS[9] = genArrayParser(parseClass);
            ASSIGNMENTS[10] = parseCustomClass;
            ASSIGNMENTS[11] = parseDict;
            ASSIGNMENTS[12] = parseArray;
            function parseInstances(data) {
              var instances = data[5];
              var instanceTypes = data[6];
              var instanceTypesLen = instanceTypes === EMPTY_PLACEHOLDER ? 0 : instanceTypes.length;
              var rootIndex = instances[instances.length - 1];
              var normalObjectCount = instances.length - instanceTypesLen;
              if (typeof rootIndex !== 'number') {
                rootIndex = 0;
              } else {
                if (rootIndex < 0) {
                  rootIndex = ~rootIndex;
                }
                --normalObjectCount;
              }
              var insIndex = 0;
              for (; insIndex < normalObjectCount; ++insIndex) {
                instances[insIndex] = deserializeCCObject(data, instances[insIndex]);
              }
              var classes = data[3];
              for (var typeIndex = 0; typeIndex < instanceTypesLen; ++typeIndex, ++insIndex) {
                var type = instanceTypes[typeIndex];
                var eachData = instances[insIndex];
                if (type >= 0) {
                  var ctor = classes[type];
                  instances[insIndex] = deserializeCustomCCObject(data, ctor, eachData);
                } else {
                  type = ~type;
                  var op = ASSIGNMENTS[type];
                  op(data, instances, insIndex, eachData);
                }
              }
              return rootIndex;
            }
            function getMissingClass(hasCustomFinder, type, reportMissingClass) {
              if (!hasCustomFinder) {
                reportMissingClass(type);
              }
              return Object;
            }
            function doLookupClass(classFinder, type, container, index, silent, hasCustomFinder, reportMissingClass) {
              var klass = classFinder(type);
              if (!klass) {
                if (silent) {
                  container[index] = function (c, i, t) {
                    return function proxy() {
                      var actualClass = classFinder(t) || getMissingClass(hasCustomFinder, t, reportMissingClass);
                      c[i] = actualClass;
                      return new actualClass();
                    };
                  }(container, index, type);
                  return;
                } else {
                  klass = getMissingClass(hasCustomFinder, type, reportMissingClass);
                }
              }
              container[index] = klass;
            }
            function lookupClasses(data, silent, customFinder, reportMissingClass) {
              var classFinder = customFinder || getClassById;
              var classes = data[3];
              for (var i = 0; i < classes.length; ++i) {
                var klassLayout = classes[i];
                if (typeof klassLayout !== 'string') {
                  {
                    if (typeof klassLayout[CLASS_TYPE] === 'function') {
                      throw new Error('Can not deserialize the same JSON data again.');
                    }
                  }
                  var type = klassLayout[CLASS_TYPE];
                  doLookupClass(classFinder, type, klassLayout, CLASS_TYPE, silent, customFinder, reportMissingClass);
                } else {
                  doLookupClass(classFinder, klassLayout, classes, i, silent, customFinder, reportMissingClass);
                }
              }
            }
            function cacheMasks(data) {
              var masks = data[4];
              if (masks) {
                var classes = data[3];
                for (var i = 0; i < masks.length; ++i) {
                  var mask = masks[i];
                  mask[MASK_CLASS] = classes[mask[MASK_CLASS]];
                }
              }
            }
            function parseResult(data) {
              var instances = data[5];
              var sharedStrings = data[2];
              var dependSharedUuids = data[1];
              var dependObjs = data[8];
              var dependKeys = data[9];
              var dependUuids = data[10];
              for (var i = 0; i < dependObjs.length; ++i) {
                var obj = dependObjs[i];
                if (typeof obj === 'number') {
                  dependObjs[i] = instances[obj];
                }
                var _key3 = dependKeys[i];
                if (typeof _key3 === 'number') {
                  if (_key3 >= 0) {
                    _key3 = sharedStrings[_key3];
                  } else {
                    _key3 = ~_key3;
                  }
                  dependKeys[i] = _key3;
                }
                var _uuid2 = dependUuids[i];
                if (typeof _uuid2 === 'number') {
                  dependUuids[i] = dependSharedUuids[_uuid2];
                }
              }
            }
            function isCompiledJson(json) {
              if (Array.isArray(json)) {
                var _version = json[0];
                return typeof _version === 'number' || _version instanceof FileInfo;
              } else {
                return false;
              }
            }
            function initializeDeserializationContext(data, details, options) {
              var _options;
              details.init(data);
              (_options = options) !== null && _options !== undefined ? _options : options = {};
              var version = data[0];
              var preprocessed = false;
              if (typeof version === 'object') {
                preprocessed = version.preprocessed;
                version = version.version;
              }
              if (version < SUPPORT_MIN_FORMAT_VERSION) {
                throw new Error(getError(5304, version));
              }
              var context = options;
              context._version = version;
              context.result = details;
              data[0] = context;
              if (!preprocessed) {
                var _options$reportMissin;
                lookupClasses(data, false, options.classFinder, (_options$reportMissin = options.reportMissingClass) !== null && _options$reportMissin !== undefined ? _options$reportMissin : deserialize.reportMissingClass);
                cacheMasks(data);
              }
            }
            function deserialize(data, details, options) {
              if (typeof data === 'string') {
                data = JSON.parse(data);
              }
              var isBorrowedDetails = false;
              if (!details) {
                var borrowedDetails = Details.pool.get();
                assertIsTrue(borrowedDetails, "Can not allocate deserialization details");
                details = borrowedDetails;
                isBorrowedDetails = true;
              }
              var res;
              if (!isCompiledJson(data)) {
                res = deserializeDynamic(data, details, options);
              } else {
                initializeDeserializationContext(data, details, options);
                var runtimeData = data;
                cclegacy.game._isCloning = true;
                var instances = runtimeData[5];
                var rootIndex = parseInstances(runtimeData);
                cclegacy.game._isCloning = false;
                if (runtimeData[7]) {
                  dereference(runtimeData[7], instances, runtimeData[2]);
                }
                parseResult(runtimeData);
                res = instances[rootIndex];
              }
              if (isBorrowedDetails) {
                Details.pool.put(details);
              }
              return res;
            }
            deserialize.Details = Details;
            deserialize.reportMissingClass = reportMissingClass;
            var FileInfo = function FileInfo(version) {
              this.preprocessed = true;
              this.version = version;
            };
            function unpackJSONs(data, classFinder, reportMissingClass) {
              if (data[0] < SUPPORT_MIN_FORMAT_VERSION) {
                throw new Error(getError(5304, data[0]));
              }
              lookupClasses(data, true, classFinder, deserialize.reportMissingClass);
              cacheMasks(data);
              var version = new FileInfo(data[0]);
              var sharedUuids = data[1];
              var sharedStrings = data[2];
              var sharedClasses = data[3];
              var sharedMasks = data[4];
              var sections = data[PACKED_SECTIONS];
              for (var i = 0; i < sections.length; ++i) {
                var section = sections[i];
                section.unshift(version, sharedUuids, sharedStrings, sharedClasses, sharedMasks);
              }
              return sections;
            }
            function packCustomObjData(type, data, hasNativeDep) {
              return [SUPPORT_MIN_FORMAT_VERSION, EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER, [type], EMPTY_PLACEHOLDER, hasNativeDep ? [data, -1] : [data], [0], EMPTY_PLACEHOLDER, [], [], []];
            }
            function hasNativeDep(data) {
              var instances = data[5];
              var rootInfo = instances[instances.length - 1];
              if (typeof rootInfo !== 'number') {
                return false;
              } else {
                return rootInfo < 0;
              }
            }
            function getDependUuidList(json) {
              var sharedUuids = json[1];
              return json[10].map(function (index) {
                return sharedUuids[index];
              });
            }
            function parseUuidDependencies(serialized) {
              {
                return getDependUuidList(serialized);
              }
            }
            cclegacy.deserialize = deserialize;

            var dependMap = new WeakMap();
            var nativeDependMap = new WeakSet();
            var onLoadedInvokedMap = new WeakSet();

            function deserializeAsset(json, options) {
              var classFinder;
              {
                classFinder = MissingScript.safeFindClass;
              }
              var tdInfo = Details.pool.get();
              var asset;
              try {
                asset = deserialize(json, tdInfo, {
                  classFinder: classFinder,
                  customEnv: options
                });
              } catch (e) {
                error(e);
                Details.pool.put(tdInfo);
                throw e;
              }
              asset._uuid = options.__uuid__ || '';
              var uuidList = tdInfo.uuidList;
              var objList = tdInfo.uuidObjList;
              var propList = tdInfo.uuidPropList;
              var typeList = tdInfo.uuidTypeList || [];
              var depends = [];
              for (var i = 0; i < uuidList.length; i++) {
                var dependUuid = uuidList[i];
                depends[i] = {
                  uuid: decodeUuid(dependUuid),
                  owner: objList[i],
                  prop: propList[i],
                  type: getClassById(typeList[i])
                };
              }
              dependMap.set(asset, depends);
              if (asset._native) {
                nativeDependMap.add(asset);
              }
              Details.pool.put(tdInfo);
              return asset;
            }

            var DependUtil = function () {
              function DependUtil() {
                this._depends = new Cache();
              }
              var _proto = DependUtil.prototype;
              _proto.init = function init() {
                this._depends.clear();
              };
              _proto.getNativeDep = function getNativeDep(uuid) {
                var depend = this._depends.get(uuid);
                if (depend && depend.nativeDep) {
                  return _extends({}, depend.nativeDep);
                }
                return null;
              };
              _proto.getDeps = function getDeps(uuid) {
                if (this._depends.has(uuid)) {
                  return this._depends.get(uuid).deps;
                }
                return [];
              };
              _proto.getDepsRecursively = function getDepsRecursively(uuid) {
                var exclude = Object.create(null);
                var depends = [];
                this._descend(uuid, exclude, depends);
                return depends;
              };
              _proto.remove = function remove(uuid) {
                this._depends.remove(uuid);
              };
              _proto.parse = function parse(uuid, json) {
                var out = null;
                if (Array.isArray(json) || json.__type__ || json instanceof CCON) {
                  if (this._depends.has(uuid)) {
                    return this._depends.get(uuid);
                  }
                  if (Array.isArray(json) && (!hasNativeDep(json))) {
                    out = {
                      deps: this._parseDepsFromJson(json)
                    };
                  } else {
                    try {
                      var asset = deserializeAsset(json, {
                        __uuid__: uuid
                      });
                      out = this._parseDepsFromAsset(asset);
                      if (out.nativeDep) {
                        out.nativeDep.uuid = uuid;
                      }
                      parsed.add(uuid + "@import", asset);
                    } catch (e) {
                      files.remove(uuid + "@import");
                      out = {
                        deps: []
                      };
                    }
                  }
                } else {
                  if (this._depends.has(uuid)) {
                    out = this._depends.get(uuid);
                    if (out.parsedFromExistAsset) {
                      return out;
                    }
                  }
                  out = this._parseDepsFromAsset(json);
                }
                this._depends.add(uuid, out);
                return out;
              };
              _proto._parseDepsFromAsset = function _parseDepsFromAsset(asset) {
                var out = {
                  deps: [],
                  parsedFromExistAsset: true
                };
                var deps = dependMap.get(asset);
                assertIsNonNullable(deps);
                for (var i = 0, l = deps.length; i < l; i++) {
                  out.deps.push(deps[i].uuid);
                }
                if (nativeDependMap.has(asset)) {
                  out.nativeDep = asset._nativeDep;
                }
                return out;
              };
              _proto._parseDepsFromJson = function _parseDepsFromJson(json) {
                var depends = parseUuidDependencies(json);
                depends.forEach(function (uuid, index) {
                  return depends[index] = decodeUuid(uuid);
                });
                return depends;
              };
              _proto._descend = function _descend(uuid, exclude, depends) {
                var deps = this.getDeps(uuid);
                for (var i = 0; i < deps.length; i++) {
                  var depend = deps[i];
                  if (!exclude[depend]) {
                    exclude[depend] = true;
                    depends.push(depend);
                    this._descend(depend, exclude, depends);
                  }
                }
              };
              _createClass(DependUtil, null, [{
                key: "instance",
                get: function get() {
                  if (!this._instance) {
                    this._instance = new DependUtil();
                  }
                  return this._instance;
                }
              }]);
              return DependUtil;
            }();
            DependUtil._instance = undefined;
            var dependUtil = DependUtil.instance;

            var _dec$D, _class$E;
            var _regions = [new BufferTextureCopy()];
            function getMipLevel(width, height) {
              var size = Math.max(width, height);
              var level = 0;
              while (size) {
                size >>= 1;
                level++;
              }
              return level;
            }
            function isPOT(n) {
              return n && (n & n - 1) === 0;
            }
            function canGenerateMipmap(device, w, h) {
              var needCheckPOT = device.gfxAPI === 6;
              if (needCheckPOT) {
                return isPOT(w) && isPOT(h);
              }
              return true;
            }
            var SimpleTexture = (_dec$D = ccclass$6('cc.SimpleTexture'), _dec$D(_class$E = function (_TextureBase) {
              _inheritsLoose(SimpleTexture, _TextureBase);
              function SimpleTexture(name) {
                var _this;
                _this = _TextureBase.call(this, name) || this;
                _this._gfxTexture = null;
                _this._gfxTextureView = null;
                _this._mipmapLevel = 1;
                _this._textureWidth = 0;
                _this._textureHeight = 0;
                _this._baseLevel = 0;
                _this._maxLevel = 1000;
                return _this;
              }
              var _proto = SimpleTexture.prototype;
              _proto.getGFXTexture = function getGFXTexture() {
                return this._gfxTextureView;
              };
              _proto.destroy = function destroy() {
                this._tryDestroyTextureView();
                this._tryDestroyTexture();
                return _TextureBase.prototype.destroy.call(this);
              };
              _proto.updateImage = function updateImage() {
                this.updateMipmaps(0);
              };
              _proto.updateMipmaps = function updateMipmaps(firstLevel, count) {
              };
              _proto.uploadData = function uploadData(source, level, arrayIndex) {
                if (level === undefined) {
                  level = 0;
                }
                if (arrayIndex === undefined) {
                  arrayIndex = 0;
                }
                if (!this._gfxTexture || this._mipmapLevel <= level) {
                  return;
                }
                var gfxDevice = this._getGFXDevice();
                if (!gfxDevice) {
                  return;
                }
                var region = _regions[0];
                region.texExtent.width = this._textureWidth >> level;
                region.texExtent.height = this._textureHeight >> level;
                region.texSubres.mipLevel = level;
                region.texSubres.baseArrayLayer = arrayIndex;
                if (ArrayBuffer.isView(source)) {
                  gfxDevice.copyBuffersToTexture([source], this._gfxTexture, _regions);
                } else {
                  gfxDevice.copyTexImagesToTexture([source], this._gfxTexture, _regions);
                }
              };
              _proto._assignImage = function _assignImage(image, level, arrayIndex) {
                var data = image.data;
                if (!data) {
                  return;
                }
                this.uploadData(data, level, arrayIndex);
                this._checkTextureLoaded();
                if (macro.CLEANUP_IMAGE_CACHE) {
                  var deps = dependUtil.getDeps(this._uuid);
                  var index = deps.indexOf(image._uuid);
                  if (index !== -1) {
                    fastRemoveAt$2(deps, index);
                    image.decRef();
                  }
                }
              };
              _proto._checkTextureLoaded = function _checkTextureLoaded() {
                this._textureReady();
              };
              _proto._textureReady = function _textureReady() {
                this.loaded = true;
                this.emit('load');
              };
              _proto._setMipmapLevel = function _setMipmapLevel(value) {
                this._mipmapLevel = value < 1 ? 1 : value;
              };
              _proto._setMipRange = function _setMipRange(baseLevel, maxLevel) {
                this._baseLevel = baseLevel < 1 ? 0 : baseLevel;
                this._maxLevel = maxLevel < 1 ? 0 : maxLevel;
              };
              _proto.setMipRange = function setMipRange(baseLevel, maxLevel) {
                assertID(baseLevel <= maxLevel, 3124);
                this._setMipRange(baseLevel, maxLevel);
                var device = this._getGFXDevice();
                if (!device) {
                  return;
                }
                var textureView = this._createTextureView(device);
                this._tryDestroyTextureView();
                this._gfxTextureView = textureView;
              };
              _proto._getGfxTextureCreateInfo = function _getGfxTextureCreateInfo(presumed) {
                return null;
              };
              _proto._getGfxTextureViewCreateInfo = function _getGfxTextureViewCreateInfo(presumed) {
                return null;
              };
              _proto._tryReset = function _tryReset() {
                this._tryDestroyTextureView();
                this._tryDestroyTexture();
                if (this._mipmapLevel === 0) {
                  return;
                }
                var device = this._getGFXDevice();
                if (!device) {
                  return;
                }
                this._createTexture(device);
                this._gfxTextureView = this._createTextureView(device);
              };
              _proto.isUsingOfflineMipmaps = function isUsingOfflineMipmaps() {
                return false;
              };
              _proto._createTexture = function _createTexture(device) {
                if (this._width === 0 || this._height === 0) {
                  return;
                }
                var flags = 0;
                if (this._mipFilter !== 0 && canGenerateMipmap(device, this._width, this._height)) {
                  this._mipmapLevel = getMipLevel(this._width, this._height);
                  if (!this.isUsingOfflineMipmaps() && !this.isCompressed) {
                    flags = 1;
                  }
                }
                var textureCreateInfo = this._getGfxTextureCreateInfo({
                  usage: 4 | 2 | 16,
                  format: this._getGFXFormat(),
                  levelCount: this._mipmapLevel,
                  flags: flags
                });
                if (!textureCreateInfo) {
                  return;
                }
                var texture = device.createTexture(textureCreateInfo);
                this._textureWidth = textureCreateInfo.width;
                this._textureHeight = textureCreateInfo.height;
                this._gfxTexture = texture;
              };
              _proto._createTextureView = function _createTextureView(device) {
                if (!this._gfxTexture) {
                  return null;
                }
                var maxLevel = this._maxLevel < this._mipmapLevel ? this._maxLevel : this._mipmapLevel - 1;
                var textureViewCreateInfo = this._getGfxTextureViewCreateInfo({
                  texture: this._gfxTexture,
                  format: this._getGFXFormat(),
                  baseLevel: this._baseLevel,
                  levelCount: maxLevel - this._baseLevel + 1
                });
                if (!textureViewCreateInfo) {
                  return null;
                }
                return device.createTexture(textureViewCreateInfo);
              };
              _proto._tryDestroyTexture = function _tryDestroyTexture() {
                if (this._gfxTexture) {
                  this._gfxTexture.destroy();
                  this._gfxTexture = null;
                }
              };
              _proto._tryDestroyTextureView = function _tryDestroyTextureView() {
                if (this._gfxTextureView) {
                  this._gfxTextureView.destroy();
                  this._gfxTextureView = null;
                }
              };
              _createClass(SimpleTexture, [{
                key: "mipmapLevel",
                get: function get() {
                  return this._mipmapLevel;
                }
              }]);
              return SimpleTexture;
            }(TextureBase)) || _class$E);
            cclegacy.SimpleTexture = SimpleTexture;

            var _dec$C, _dec2$p, _class$D, _class2$z, _initializer$x;
            var Texture2D = exports("Texture2D", (_dec$C = ccclass$6('cc.Texture2D'), _dec2$p = type$5([ImageAsset]), _dec$C(_class$D = (_class2$z = function (_SimpleTexture) {
              _inheritsLoose(Texture2D, _SimpleTexture);
              function Texture2D(name) {
                var _this;
                _this = _SimpleTexture.call(this, name) || this;
                _this._mipmaps = _initializer$x && _initializer$x();
                _this._generatedMipmaps = [];
                return _this;
              }
              var _proto = Texture2D.prototype;
              _proto._setMipmapParams = function _setMipmapParams(value) {
                var _this2 = this;
                this._generatedMipmaps = value;
                this._setMipmapLevel(this._generatedMipmaps.length);
                if (this._generatedMipmaps.length > 0) {
                  var imageAsset = this._generatedMipmaps[0];
                  this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._generatedMipmaps.length,
                    baseLevel: this._baseLevel,
                    maxLevel: this._maxLevel
                  });
                  this._generatedMipmaps.forEach(function (mipmap, level) {
                    _this2._assignImage(mipmap, level);
                  });
                } else {
                  this.reset({
                    width: 0,
                    height: 0,
                    mipmapLevel: this._generatedMipmaps.length,
                    baseLevel: this._baseLevel,
                    maxLevel: this._maxLevel
                  });
                }
              };
              _proto.initialize = function initialize() {
                this.mipmaps = this._mipmaps;
              };
              _proto.onLoaded = function onLoaded() {
                this.initialize();
              };
              _proto.reset = function reset(info) {
                this._width = info.width;
                this._height = info.height;
                this._setGFXFormat(info.format);
                var mipLevels = info.mipmapLevel === undefined ? 1 : info.mipmapLevel;
                this._setMipmapLevel(mipLevels);
                var minLod = info.baseLevel === undefined ? 0 : info.baseLevel;
                var maxLod = info.maxLevel === undefined ? 1000 : info.maxLevel;
                this._setMipRange(minLod, maxLod);
                this._tryReset();
              };
              _proto.create = function create(width, height, format, mipmapLevel, baseLevel, maxLevel) {
                if (format === undefined) {
                  format = 35;
                }
                if (mipmapLevel === undefined) {
                  mipmapLevel = 1;
                }
                if (baseLevel === undefined) {
                  baseLevel = 0;
                }
                if (maxLevel === undefined) {
                  maxLevel = 1000;
                }
                this.reset({
                  width: width,
                  height: height,
                  format: format,
                  mipmapLevel: mipmapLevel,
                  baseLevel: baseLevel,
                  maxLevel: maxLevel
                });
              };
              _proto.toString = function toString() {
                return this._mipmaps.length !== 0 ? this._mipmaps[0].url : '';
              };
              _proto.updateMipmaps = function updateMipmaps(firstLevel, count) {
                if (firstLevel === undefined) {
                  firstLevel = 0;
                }
                if (count === undefined) {
                  count = undefined;
                }
                if (firstLevel >= this._generatedMipmaps.length) {
                  return;
                }
                var nUpdate = Math.min(count === undefined ? this._generatedMipmaps.length : count, this._generatedMipmaps.length - firstLevel);
                for (var i = 0; i < nUpdate; ++i) {
                  var level = firstLevel + i;
                  this._assignImage(this._generatedMipmaps[level], level);
                }
              };
              _proto.getHtmlElementObj = function getHtmlElementObj() {
                return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
              };
              _proto.destroy = function destroy() {
                this._mipmaps = [];
                this._generatedMipmaps = [];
                return _SimpleTexture.prototype.destroy.call(this);
              };
              _proto.description = function description() {
                var url = this._mipmaps[0] ? this._mipmaps[0].url : '';
                return "<cc.Texture2D | Name = " + url + " | Dimension = " + this.width + " x " + this.height + ">";
              };
              _proto.releaseTexture = function releaseTexture() {
                this.destroy();
              };
              _proto._serialize = function _serialize(ctxForExporting) {
                return null;
              };
              _proto._deserialize = function _deserialize(serializedData, handle) {
                var data = serializedData;
                _SimpleTexture.prototype._deserialize.call(this, data.base, handle);
                this._mipmaps = new Array(data.mipmaps.length);
                for (var i = 0; i < data.mipmaps.length; ++i) {
                  this._mipmaps[i] = new ImageAsset();
                  if (!data.mipmaps[i]) {
                    continue;
                  }
                  var mipmapUUID = data.mipmaps[i];
                  handle.result.push(this._mipmaps, "" + i, mipmapUUID, getClassId(ImageAsset));
                }
              };
              _proto._getGfxTextureCreateInfo = function _getGfxTextureCreateInfo(presumed) {
                var texInfo = new TextureInfo(1);
                texInfo.width = this._width;
                texInfo.height = this._height;
                Object.assign(texInfo, presumed);
                return texInfo;
              };
              _proto._getGfxTextureViewCreateInfo = function _getGfxTextureViewCreateInfo(presumed) {
                var texViewInfo = new TextureViewInfo();
                texViewInfo.type = 1;
                Object.assign(texViewInfo, presumed);
                return texViewInfo;
              };
              _proto.initDefault = function initDefault(uuid) {
                _SimpleTexture.prototype.initDefault.call(this, uuid);
                var imageAsset = new ImageAsset();
                imageAsset.initDefault();
                this.image = imageAsset;
              };
              _proto.validate = function validate() {
                return this.mipmaps && this.mipmaps.length !== 0;
              };
              _createClass(Texture2D, [{
                key: "mipmaps",
                get: function get() {
                  return this._mipmaps;
                },
                set: function set(value) {
                  this._mipmaps = value;
                  var mipmaps = [];
                  if (value.length === 1) {
                    var image = value[0];
                    mipmaps.push.apply(mipmaps, image.extractMipmaps());
                  } else if (value.length > 1) {
                    for (var i = 0; i < value.length; ++i) {
                      var _image = value[i];
                      mipmaps.push(_image.extractMipmap0());
                    }
                  }
                  this._setMipmapParams(mipmaps);
                }
              }, {
                key: "image",
                get: function get() {
                  return this._mipmaps.length === 0 ? null : this._mipmaps[0];
                },
                set: function set(value) {
                  this.mipmaps = value ? [value] : [];
                }
              }]);
              return Texture2D;
            }(SimpleTexture), (_initializer$x = applyDecoratedInitializer(_class2$z.prototype, "_mipmaps", [_dec2$p], function () {
              return [];
            })), _class2$z)) || _class$D));
            cclegacy.Texture2D = Texture2D;

            var _dec$B, _class$C, _class2$y, _initializer$w, _initializer2$q, _initializer3$k, _initializer4$g, _class3$a;
            var FaceIndex = {
              right: 0,
              left: 1,
              top: 2,
              bottom: 3,
              front: 4,
              back: 5
            };
            var TextureCube = exports("TextureCube", (_dec$B = ccclass$6('cc.TextureCube'), _dec$B(_class$C = (_class2$y = (_class3$a = function (_SimpleTexture) {
              _inheritsLoose(TextureCube, _SimpleTexture);
              function TextureCube(name) {
                var _this;
                _this = _SimpleTexture.call(this, name) || this;
                _this.isRGBE = _initializer$w && _initializer$w();
                _this._mipmapAtlas = _initializer2$q && _initializer2$q();
                _this._mipmapMode = _initializer3$k && _initializer3$k();
                _this._mipmaps = _initializer4$g && _initializer4$g();
                _this._generatedMipmaps = [];
                return _this;
              }
              var _proto = TextureCube.prototype;
              _proto._setMipmapParams = function _setMipmapParams(value) {
                var _this2 = this;
                this._generatedMipmaps = value;
                this._setMipmapLevel(this._generatedMipmaps.length);
                if (this._generatedMipmaps.length > 0) {
                  var imageAsset = this._generatedMipmaps[0].front;
                  this.reset({
                    width: imageAsset.width,
                    height: imageAsset.height,
                    format: imageAsset.format,
                    mipmapLevel: this._generatedMipmaps.length,
                    baseLevel: this._baseLevel,
                    maxLevel: this._maxLevel
                  });
                  this._generatedMipmaps.forEach(function (mipmap, level) {
                    _forEachFace(mipmap, function (face, faceIndex) {
                      _this2._assignImage(face, level, faceIndex);
                    });
                  });
                } else {
                  this.reset({
                    width: 0,
                    height: 0,
                    mipmapLevel: this._generatedMipmaps.length,
                    baseLevel: this._baseLevel,
                    maxLevel: this._maxLevel
                  });
                }
              };
              _proto.isUsingOfflineMipmaps = function isUsingOfflineMipmaps() {
                return this._mipmapMode === 2;
              };
              TextureCube.fromTexture2DArray = function fromTexture2DArray(textures, out) {
                var mipmaps = [];
                var nMipmaps = textures.length / 6;
                for (var i = 0; i < nMipmaps; i++) {
                  var x = i * 6;
                  mipmaps.push({
                    front: textures[x + 4].image,
                    back: textures[x + 5].image,
                    left: textures[x + 1].image,
                    right: textures[x + 0].image,
                    top: textures[x + 2].image,
                    bottom: textures[x + 3].image
                  });
                }
                out = out || new TextureCube();
                out.mipmaps = mipmaps;
                return out;
              };
              _proto.onLoaded = function onLoaded() {
                if (this._mipmapMode === 2) {
                  this.mipmapAtlas = this._mipmapAtlas;
                } else {
                  this.mipmaps = this._mipmaps;
                }
              };
              _proto.reset = function reset(info) {
                this._width = info.width;
                this._height = info.height;
                this._setGFXFormat(info.format);
                var mipLevels = info.mipmapLevel === undefined ? 1 : info.mipmapLevel;
                this._setMipmapLevel(mipLevels);
                var minLod = info.baseLevel === undefined ? 0 : info.baseLevel;
                var maxLod = info.maxLevel === undefined ? 1000 : info.maxLevel;
                this._setMipRange(minLod, maxLod);
                this._tryReset();
              };
              _proto.updateMipmaps = function updateMipmaps(firstLevel, count) {
                var _this3 = this;
                if (firstLevel === undefined) {
                  firstLevel = 0;
                }
                if (count === undefined) {
                  count = undefined;
                }
                if (firstLevel >= this._generatedMipmaps.length) {
                  return;
                }
                var nUpdate = Math.min(count === undefined ? this._generatedMipmaps.length : count, this._generatedMipmaps.length - firstLevel);
                var _loop = function _loop() {
                  var level = firstLevel + i;
                  _forEachFace(_this3._generatedMipmaps[level], function (face, faceIndex) {
                    _this3._assignImage(face, level, faceIndex);
                  });
                };
                for (var i = 0; i < nUpdate; ++i) {
                  _loop();
                }
              };
              _proto.destroy = function destroy() {
                this._mipmaps = [];
                this._generatedMipmaps = [];
                this._mipmapAtlas = null;
                return _SimpleTexture.prototype.destroy.call(this);
              };
              _proto.releaseTexture = function releaseTexture() {
                this.destroy();
              };
              _proto._serialize = function _serialize(ctxForExporting) {
                return null;
              };
              _proto._deserialize = function _deserialize(serializedData, handle) {
                var data = serializedData;
                _SimpleTexture.prototype._deserialize.call(this, data.base, handle);
                this.isRGBE = data.rgbe;
                this._mipmapMode = data.mipmapMode;
                if (this._mipmapMode === 2) {
                  var mipmapAtlas = data.mipmapAtlas;
                  var mipmapLayout = data.mipmapLayout;
                  this._mipmapAtlas = {
                    atlas: {},
                    layout: mipmapLayout
                  };
                  this._mipmapAtlas.atlas = {
                    front: new ImageAsset(),
                    back: new ImageAsset(),
                    left: new ImageAsset(),
                    right: new ImageAsset(),
                    top: new ImageAsset(),
                    bottom: new ImageAsset()
                  };
                  var imageAssetClassId = getClassId(ImageAsset);
                  handle.result.push(this._mipmapAtlas.atlas, "front", mipmapAtlas.front, imageAssetClassId);
                  handle.result.push(this._mipmapAtlas.atlas, "back", mipmapAtlas.back, imageAssetClassId);
                  handle.result.push(this._mipmapAtlas.atlas, "left", mipmapAtlas.left, imageAssetClassId);
                  handle.result.push(this._mipmapAtlas.atlas, "right", mipmapAtlas.right, imageAssetClassId);
                  handle.result.push(this._mipmapAtlas.atlas, "top", mipmapAtlas.top, imageAssetClassId);
                  handle.result.push(this._mipmapAtlas.atlas, "bottom", mipmapAtlas.bottom, imageAssetClassId);
                } else {
                  this._mipmaps = new Array(data.mipmaps.length);
                  for (var i = 0; i < data.mipmaps.length; ++i) {
                    this._mipmaps[i] = {
                      front: new ImageAsset(),
                      back: new ImageAsset(),
                      left: new ImageAsset(),
                      right: new ImageAsset(),
                      top: new ImageAsset(),
                      bottom: new ImageAsset()
                    };
                    var mipmap = data.mipmaps[i];
                    var _imageAssetClassId = getClassId(ImageAsset);
                    handle.result.push(this._mipmaps[i], "front", mipmap.front, _imageAssetClassId);
                    handle.result.push(this._mipmaps[i], "back", mipmap.back, _imageAssetClassId);
                    handle.result.push(this._mipmaps[i], "left", mipmap.left, _imageAssetClassId);
                    handle.result.push(this._mipmaps[i], "right", mipmap.right, _imageAssetClassId);
                    handle.result.push(this._mipmaps[i], "top", mipmap.top, _imageAssetClassId);
                    handle.result.push(this._mipmaps[i], "bottom", mipmap.bottom, _imageAssetClassId);
                  }
                }
              };
              _proto._getGfxTextureCreateInfo = function _getGfxTextureCreateInfo(presumed) {
                var texInfo = new TextureInfo(3);
                texInfo.width = this._width;
                texInfo.height = this._height;
                texInfo.layerCount = 6;
                Object.assign(texInfo, presumed);
                return texInfo;
              };
              _proto._getGfxTextureViewCreateInfo = function _getGfxTextureViewCreateInfo(presumed) {
                var texViewInfo = new TextureViewInfo();
                texViewInfo.type = 3;
                texViewInfo.baseLayer = 0;
                texViewInfo.layerCount = 6;
                Object.assign(texViewInfo, presumed);
                return texViewInfo;
              };
              _proto._uploadAtlas = function _uploadAtlas() {
                var _this4 = this;
                var layout = this._mipmapAtlas.layout;
                var mip0Layout = layout[0];
                this.reset({
                  width: mip0Layout.width,
                  height: mip0Layout.height,
                  format: this._mipmapAtlas.atlas.front.format,
                  mipmapLevel: layout.length
                });
                _forEachFace(this._mipmapAtlas.atlas, function (face, faceIndex) {
                  var tex = new Texture2D();
                  tex.image = face;
                  tex.reset({
                    width: face.width,
                    height: face.height,
                    format: face.format
                  });
                  tex.uploadData(face.data);
                  for (var i = 0; i < layout.length; i++) {
                    var layoutInfo = layout[i];
                    var size = tex.getGFXTexture().size;
                    var buffer = new Uint8Array(size);
                    var region = new BufferTextureCopy();
                    region.texOffset.x = layoutInfo.left;
                    region.texOffset.y = layoutInfo.top;
                    region.texExtent.width = layoutInfo.width;
                    region.texExtent.height = layoutInfo.height;
                    _this4._getGFXDevice().copyTextureToBuffers(tex.getGFXTexture(), [buffer], [region]);
                    var bufferAsset = new ImageAsset({
                      _data: buffer,
                      _compressed: face.isCompressed,
                      width: layoutInfo.width,
                      height: layoutInfo.height,
                      format: face.format
                    });
                    _this4._assignImage(bufferAsset, layoutInfo.level, faceIndex);
                  }
                });
              };
              _proto.initDefault = function initDefault(uuid) {
                _SimpleTexture.prototype.initDefault.call(this, uuid);
                var imageAsset = new ImageAsset();
                imageAsset.initDefault();
                this.mipmaps = [{
                  front: imageAsset,
                  back: imageAsset,
                  top: imageAsset,
                  bottom: imageAsset,
                  left: imageAsset,
                  right: imageAsset
                }];
              };
              _proto.validate = function validate() {
                if (this._mipmapMode === 2) {
                  if (this.mipmapAtlas === null || this.mipmapAtlas.layout.length === 0) {
                    return false;
                  }
                  var atlas = this.mipmapAtlas.atlas;
                  return !!(atlas.top && atlas.bottom && atlas.front && atlas.back && atlas.left && atlas.right);
                } else {
                  return this._mipmaps.length !== 0 && !this._mipmaps.find(function (x) {
                    return !(x.top && x.bottom && x.front && x.back && x.left && x.right);
                  });
                }
              };
              _createClass(TextureCube, [{
                key: "mipmaps",
                get: function get() {
                  return this._mipmaps;
                },
                set: function set(value) {
                  this._mipmaps = value;
                  var cubeMaps = [];
                  if (value.length === 1) {
                    var cubeMipmap = value[0];
                    var front = cubeMipmap.front.extractMipmaps();
                    var back = cubeMipmap.back.extractMipmaps();
                    var left = cubeMipmap.left.extractMipmaps();
                    var right = cubeMipmap.right.extractMipmaps();
                    var top = cubeMipmap.top.extractMipmaps();
                    var bottom = cubeMipmap.bottom.extractMipmaps();
                    if (front.length !== back.length || front.length !== left.length || front.length !== right.length || front.length !== top.length || front.length !== bottom.length) {
                      errorID(16347);
                      this._setMipmapParams([]);
                      return;
                    }
                    var level = front.length;
                    for (var i = 0; i < level; ++i) {
                      var cubeMap = {
                        front: front[i],
                        back: back[i],
                        left: left[i],
                        right: right[i],
                        top: top[i],
                        bottom: bottom[i]
                      };
                      cubeMaps.push(cubeMap);
                    }
                  } else if (value.length > 1) {
                    value.forEach(function (mipmap) {
                      var cubeMap = {
                        front: mipmap.front.extractMipmap0(),
                        back: mipmap.back.extractMipmap0(),
                        left: mipmap.left.extractMipmap0(),
                        right: mipmap.right.extractMipmap0(),
                        top: mipmap.top.extractMipmap0(),
                        bottom: mipmap.bottom.extractMipmap0()
                      };
                      cubeMaps.push(cubeMap);
                    });
                  }
                  this._setMipmapParams(cubeMaps);
                }
              }, {
                key: "mipmapAtlas",
                get: function get() {
                  return this._mipmapAtlas;
                },
                set: function set(value) {
                  var _this5 = this;
                  this._mipmapAtlas = value;
                  if (!this._mipmapAtlas) {
                    this.reset({
                      width: 0,
                      height: 0,
                      mipmapLevel: 0
                    });
                    return;
                  }
                  var imageAtlasAsset = this._mipmapAtlas.atlas.front;
                  if (!imageAtlasAsset.data) {
                    return;
                  }
                  var faceAtlas = this._mipmapAtlas.atlas;
                  var layout = this._mipmapAtlas.layout;
                  var mip0Layout = layout[0];
                  var ctx = Object.assign(ccwindow.document.createElement('canvas'), {
                    width: imageAtlasAsset.width,
                    height: imageAtlasAsset.height
                  }).getContext('2d');
                  this.reset({
                    width: mip0Layout.width,
                    height: mip0Layout.height,
                    format: imageAtlasAsset.format,
                    mipmapLevel: layout.length
                  });
                  var _loop2 = function _loop2() {
                    var layoutInfo = layout[j];
                    _forEachFace(faceAtlas, function (face, faceIndex) {
                      ctx.clearRect(0, 0, imageAtlasAsset.width, imageAtlasAsset.height);
                      var drawImg = face.data;
                      ctx.drawImage(drawImg, 0, 0);
                      var rawData = ctx.getImageData(layoutInfo.left, layoutInfo.top, layoutInfo.width, layoutInfo.height);
                      var bufferAsset = new ImageAsset({
                        _data: rawData.data,
                        _compressed: face.isCompressed,
                        width: rawData.width,
                        height: rawData.height,
                        format: face.format
                      });
                      _this5._assignImage(bufferAsset, layoutInfo.level, faceIndex);
                    });
                  };
                  for (var j = 0; j < layout.length; j++) {
                    _loop2();
                  }
                }
              }, {
                key: "image",
                get: function get() {
                  return this._mipmaps.length === 0 ? null : this._mipmaps[0];
                },
                set: function set(value) {
                  this.mipmaps = value ? [value] : [];
                }
              }]);
              return TextureCube;
            }(SimpleTexture), _class3$a.FaceIndex = FaceIndex, _class3$a), (_initializer$w = applyDecoratedInitializer(_class2$y.prototype, "isRGBE", [serializable$5], function () {
              return false;
            }), _initializer2$q = applyDecoratedInitializer(_class2$y.prototype, "_mipmapAtlas", [serializable$5], function () {
              return null;
            }), _initializer3$k = applyDecoratedInitializer(_class2$y.prototype, "_mipmapMode", [serializable$5], function () {
              return 0;
            }), _initializer4$g = applyDecoratedInitializer(_class2$y.prototype, "_mipmaps", [serializable$5], function () {
              return [];
            })), _class2$y)) || _class$C));
            legacyCC.TextureCube = TextureCube;
            function _forEachFace(mipmap, callback) {
              callback(mipmap.front, 4);
              callback(mipmap.back, 5);
              callback(mipmap.left, 1);
              callback(mipmap.right, 0);
              callback(mipmap.top, 2);
              callback(mipmap.bottom, 3);
            }

            function getPipelineSceneData() {
              return cclegacy.director.root.pipeline.pipelineSceneData;
            }

            var Ambient = function () {
              function Ambient() {
                this._groundAlbedoHDR = new Vec4(0.2, 0.2, 0.2, 1.0);
                this._skyColorHDR = new Vec4(0.2, 0.5, 0.8, 1.0);
                this._skyIllumHDR = 0;
                this._groundAlbedoLDR = new Vec4(0.2, 0.2, 0.2, 1.0);
                this._skyColorLDR = new Vec4(0.2, 0.5, 0.8, 1.0);
                this._skyIllumLDR = 0;
                this._mipmapCount = 1;
                this._enabled = false;
              }
              var _proto = Ambient.prototype;
              _proto.initialize = function initialize(ambientInfo) {
                this._skyColorHDR = ambientInfo.skyColorHDR;
                this._groundAlbedoHDR.set(ambientInfo.groundAlbedoHDR);
                this._skyIllumHDR = ambientInfo.skyIllumHDR;
                this._skyColorLDR = ambientInfo.skyColorLDR;
                this._groundAlbedoLDR.set(ambientInfo.groundAlbedoLDR);
                this._skyIllumLDR = ambientInfo.skyIllumLDR;
              };
              _createClass(Ambient, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                }
              }, {
                key: "skyColor",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._skyColorHDR;
                  } else {
                    return this._skyColorLDR;
                  }
                },
                set: function set(color) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._skyColorHDR.set(color);
                  } else {
                    this._skyColorLDR.set(color);
                  }
                }
              }, {
                key: "skyIllum",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._skyIllumHDR;
                  } else {
                    return this._skyIllumLDR;
                  }
                },
                set: function set(illum) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._skyIllumHDR = illum;
                  } else {
                    this._skyIllumLDR = illum;
                  }
                }
              }, {
                key: "groundAlbedo",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._groundAlbedoHDR;
                  } else {
                    return this._groundAlbedoLDR;
                  }
                },
                set: function set(color) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._groundAlbedoHDR.set(color);
                  } else {
                    this._groundAlbedoLDR.set(color);
                  }
                }
              }]);
              return Ambient;
            }();
            Ambient.SUN_ILLUM = 65000.0;
            Ambient.SKY_ILLUM = 20000.0;
            cclegacy.Ambient = Ambient;

            var _class$B, _class2$x, _class3$9, _class4$6, _class5$6, _class6$2, _class7$2, _class8$2, _class10$2, _class11$2, _class12, _class13$2, _class14$2, _class15;
            var PIPELINE_FLOW_MAIN = 'MainFlow';
            var PIPELINE_FLOW_FORWARD = 'ForwardFlow';
            var PIPELINE_FLOW_SHADOW = 'ShadowFlow';
            var PIPELINE_FLOW_SMAA = 'SMAAFlow';
            var PIPELINE_FLOW_TONEMAP = 'ToneMapFlow';
            var RenderPassStage = {
              DEFAULT: 100,
              UI: 200
            };
            cclegacy.RenderPassStage = RenderPassStage;
            var RenderPriority = {
              MIN: 0,
              MAX: 255,
              DEFAULT: 128
            };
            var globalDescriptorSetLayout = {
              bindings: [],
              layouts: {}
            };
            var localDescriptorSetLayout = {
              bindings: [],
              layouts: {}
            };
            var PipelineGlobalBindings = {
              UBO_GLOBAL: 0,
              UBO_CAMERA: 1,
              UBO_SHADOW: 2,
              UBO_CSM: 3,
              SAMPLER_SHADOWMAP: 4,
              SAMPLER_ENVIRONMENT: 5,
              SAMPLER_SPOT_SHADOW_MAP: 6,
              SAMPLER_DIFFUSEMAP: 7,
              COUNT: 8
            };
            var GLOBAL_UBO_COUNT = 4;
            var GLOBAL_SAMPLER_COUNT = 8 - GLOBAL_UBO_COUNT;
            var ModelLocalBindings = {
              UBO_LOCAL: 0,
              UBO_FORWARD_LIGHTS: 1,
              UBO_SKINNING_ANIMATION: 2,
              UBO_SKINNING_TEXTURE: 3,
              UBO_MORPH: 4,
              UBO_UI_LOCAL: 5,
              UBO_SH: 6,
              SAMPLER_JOINTS: 7,
              SAMPLER_MORPH_POSITION: 8,
              SAMPLER_MORPH_NORMAL: 9,
              SAMPLER_MORPH_TANGENT: 10,
              SAMPLER_LIGHTMAP: 11,
              SAMPLER_SPRITE: 12,
              SAMPLER_REFLECTION_PROBE_CUBE: 13,
              SAMPLER_REFLECTION_PROBE_PLANAR: 14,
              SAMPLER_REFLECTION_PROBE_DATA_MAP: 15,
              COUNT: 16
            };
            var LOCAL_UBO_COUNT = 7;
            var LOCAL_SAMPLER_COUNT = 16 - LOCAL_UBO_COUNT;
            var LOCAL_STORAGE_IMAGE_COUNT = 16 - LOCAL_UBO_COUNT - LOCAL_SAMPLER_COUNT;
            var SetIndex = {
              GLOBAL: 0,
              MATERIAL: 1,
              LOCAL: 2,
              COUNT: 3
            };
            var bindingMappingInfo = new BindingMappingInfo([GLOBAL_UBO_COUNT, 0, LOCAL_UBO_COUNT, 0], [GLOBAL_SAMPLER_COUNT, 0, LOCAL_SAMPLER_COUNT, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, LOCAL_STORAGE_IMAGE_COUNT, 0], [0, 0, 0, 0], [0, 2, 1, 3]);
            var UBOGlobalEnum = {
              TIME_OFFSET: 0,
              SCREEN_SIZE_OFFSET: 4,
              NATIVE_SIZE_OFFSET: 8,
              PROBE_INFO_OFFSET: 12,
              DEBUG_VIEW_MODE_OFFSET: 16,
              COUNT: 20,
              SIZE: 80
            };
            var UBOGlobal = function UBOGlobal() {};
            _class$B = UBOGlobal;
            UBOGlobal.TIME_OFFSET = 0;
            UBOGlobal.SCREEN_SIZE_OFFSET = 4;
            UBOGlobal.NATIVE_SIZE_OFFSET = 8;
            UBOGlobal.PROBE_INFO_OFFSET = 12;
            UBOGlobal.DEBUG_VIEW_MODE_OFFSET = 16;
            UBOGlobal.COUNT = 20;
            UBOGlobal.SIZE = 80;
            UBOGlobal.NAME = 'CCGlobal';
            UBOGlobal.BINDING = 0;
            UBOGlobal.DESCRIPTOR = new DescriptorSetLayoutBinding(_class$B.BINDING, 1, 1, 63);
            UBOGlobal.LAYOUT = new UniformBlock(0, _class$B.BINDING, _class$B.NAME, [new Uniform('cc_time', 16, 1), new Uniform('cc_screenSize', 16, 1), new Uniform('cc_nativeSize', 16, 1), new Uniform('cc_probeInfo', 16, 1), new Uniform('cc_debug_view_mode', 16, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOGlobal.NAME] = UBOGlobal.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOGlobal.BINDING] = UBOGlobal.DESCRIPTOR;
            var UBOCameraEnum = {
              MAT_VIEW_OFFSET: 0,
              MAT_VIEW_INV_OFFSET: 16,
              MAT_PROJ_OFFSET: 32,
              MAT_PROJ_INV_OFFSET: 48,
              MAT_VIEW_PROJ_OFFSET: 64,
              MAT_VIEW_PROJ_INV_OFFSET: 80,
              CAMERA_POS_OFFSET: 96,
              SURFACE_TRANSFORM_OFFSET: 100,
              SCREEN_SCALE_OFFSET: 104,
              EXPOSURE_OFFSET: 108,
              MAIN_LIT_DIR_OFFSET: 112,
              MAIN_LIT_COLOR_OFFSET: 116,
              AMBIENT_SKY_OFFSET: 120,
              AMBIENT_GROUND_OFFSET: 124,
              GLOBAL_FOG_COLOR_OFFSET: 128,
              GLOBAL_FOG_BASE_OFFSET: 132,
              GLOBAL_FOG_ADD_OFFSET: 136,
              NEAR_FAR_OFFSET: 140,
              VIEW_PORT_OFFSET: 144,
              COUNT: 148,
              SIZE: 592
            };
            var UBOCamera = function UBOCamera() {};
            _class2$x = UBOCamera;
            UBOCamera.MAT_VIEW_OFFSET = 0;
            UBOCamera.MAT_VIEW_INV_OFFSET = 16;
            UBOCamera.MAT_PROJ_OFFSET = 32;
            UBOCamera.MAT_PROJ_INV_OFFSET = 48;
            UBOCamera.MAT_VIEW_PROJ_OFFSET = 64;
            UBOCamera.MAT_VIEW_PROJ_INV_OFFSET = 80;
            UBOCamera.CAMERA_POS_OFFSET = 96;
            UBOCamera.SURFACE_TRANSFORM_OFFSET = 100;
            UBOCamera.SCREEN_SCALE_OFFSET = 104;
            UBOCamera.EXPOSURE_OFFSET = 108;
            UBOCamera.MAIN_LIT_DIR_OFFSET = 112;
            UBOCamera.MAIN_LIT_COLOR_OFFSET = 116;
            UBOCamera.AMBIENT_SKY_OFFSET = 120;
            UBOCamera.AMBIENT_GROUND_OFFSET = 124;
            UBOCamera.GLOBAL_FOG_COLOR_OFFSET = 128;
            UBOCamera.GLOBAL_FOG_BASE_OFFSET = 132;
            UBOCamera.GLOBAL_FOG_ADD_OFFSET = 136;
            UBOCamera.NEAR_FAR_OFFSET = 140;
            UBOCamera.VIEW_PORT_OFFSET = 144;
            UBOCamera.COUNT = 148;
            UBOCamera.SIZE = 592;
            UBOCamera.NAME = 'CCCamera';
            UBOCamera.BINDING = 1;
            UBOCamera.DESCRIPTOR = new DescriptorSetLayoutBinding(_class2$x.BINDING, 1, 1, 63);
            UBOCamera.LAYOUT = new UniformBlock(0, _class2$x.BINDING, _class2$x.NAME, [new Uniform('cc_matView', 25, 1), new Uniform('cc_matViewInv', 25, 1), new Uniform('cc_matProj', 25, 1), new Uniform('cc_matProjInv', 25, 1), new Uniform('cc_matViewProj', 25, 1), new Uniform('cc_matViewProjInv', 25, 1), new Uniform('cc_cameraPos', 16, 1), new Uniform('cc_surfaceTransform', 16, 1), new Uniform('cc_screenScale', 16, 1), new Uniform('cc_exposure', 16, 1), new Uniform('cc_mainLitDir', 16, 1), new Uniform('cc_mainLitColor', 16, 1), new Uniform('cc_ambientSky', 16, 1), new Uniform('cc_ambientGround', 16, 1), new Uniform('cc_fogColor', 16, 1), new Uniform('cc_fogBase', 16, 1), new Uniform('cc_fogAdd', 16, 1), new Uniform('cc_nearFar', 16, 1), new Uniform('cc_viewPort', 16, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOCamera.NAME] = UBOCamera.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOCamera.BINDING] = UBOCamera.DESCRIPTOR;
            var UBOShadowEnum = {
              MAT_LIGHT_VIEW_OFFSET: 0,
              MAT_LIGHT_VIEW_PROJ_OFFSET: 16,
              SHADOW_INV_PROJ_DEPTH_INFO_OFFSET: 32,
              SHADOW_PROJ_DEPTH_INFO_OFFSET: 36,
              SHADOW_PROJ_INFO_OFFSET: 40,
              SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET: 44,
              SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET: 48,
              SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET: 52,
              SHADOW_COLOR_OFFSET: 56,
              PLANAR_NORMAL_DISTANCE_INFO_OFFSET: 60,
              COUNT: 64,
              SIZE: 256
            };
            var UBOShadow = function UBOShadow() {};
            _class3$9 = UBOShadow;
            UBOShadow.MAT_LIGHT_VIEW_OFFSET = 0;
            UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET = 16;
            UBOShadow.SHADOW_INV_PROJ_DEPTH_INFO_OFFSET = 32;
            UBOShadow.SHADOW_PROJ_DEPTH_INFO_OFFSET = 36;
            UBOShadow.SHADOW_PROJ_INFO_OFFSET = 40;
            UBOShadow.SHADOW_NEAR_FAR_LINEAR_SATURATION_INFO_OFFSET = 44;
            UBOShadow.SHADOW_WIDTH_HEIGHT_PCF_BIAS_INFO_OFFSET = 48;
            UBOShadow.SHADOW_LIGHT_PACKING_NBIAS_NULL_INFO_OFFSET = 52;
            UBOShadow.SHADOW_COLOR_OFFSET = 56;
            UBOShadow.PLANAR_NORMAL_DISTANCE_INFO_OFFSET = 60;
            UBOShadow.COUNT = 64;
            UBOShadow.SIZE = 256;
            UBOShadow.NAME = 'CCShadow';
            UBOShadow.BINDING = 2;
            UBOShadow.DESCRIPTOR = new DescriptorSetLayoutBinding(_class3$9.BINDING, 1, 1, 63);
            UBOShadow.LAYOUT = new UniformBlock(0, _class3$9.BINDING, _class3$9.NAME, [new Uniform('cc_matLightView', 25, 1), new Uniform('cc_matLightViewProj', 25, 1), new Uniform('cc_shadowInvProjDepthInfo', 16, 1), new Uniform('cc_shadowProjDepthInfo', 16, 1), new Uniform('cc_shadowProjInfo', 16, 1), new Uniform('cc_shadowNFLSInfo', 16, 1), new Uniform('cc_shadowWHPBInfo', 16, 1), new Uniform('cc_shadowLPNNInfo', 16, 1), new Uniform('cc_shadowColor', 16, 1), new Uniform('cc_planarNDInfo', 16, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOShadow.NAME] = UBOShadow.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOShadow.BINDING] = UBOShadow.DESCRIPTOR;
            var UBOCSMEnum = {
              CSM_LEVEL_COUNT: 4,
              CSM_VIEW_DIR_0_OFFSET: 0,
              CSM_VIEW_DIR_1_OFFSET: 16,
              CSM_VIEW_DIR_2_OFFSET: 32,
              CSM_ATLAS_OFFSET: 48,
              MAT_CSM_VIEW_PROJ_OFFSET: 64,
              CSM_PROJ_DEPTH_INFO_OFFSET: 128,
              CSM_PROJ_INFO_OFFSET: 144,
              CSM_SPLITS_INFO_OFFSET: 160,
              COUNT: 164,
              SIZE: 656
            };
            var UBOCSM = function UBOCSM() {};
            _class4$6 = UBOCSM;
            UBOCSM.CSM_LEVEL_COUNT = 4;
            UBOCSM.CSM_VIEW_DIR_0_OFFSET = 0;
            UBOCSM.CSM_VIEW_DIR_1_OFFSET = 16;
            UBOCSM.CSM_VIEW_DIR_2_OFFSET = 32;
            UBOCSM.CSM_ATLAS_OFFSET = 48;
            UBOCSM.MAT_CSM_VIEW_PROJ_OFFSET = 64;
            UBOCSM.CSM_PROJ_DEPTH_INFO_OFFSET = 128;
            UBOCSM.CSM_PROJ_INFO_OFFSET = 144;
            UBOCSM.CSM_SPLITS_INFO_OFFSET = 160;
            UBOCSM.COUNT = 164;
            UBOCSM.SIZE = 656;
            UBOCSM.NAME = 'CCCSM';
            UBOCSM.BINDING = 3;
            UBOCSM.DESCRIPTOR = new DescriptorSetLayoutBinding(_class4$6.BINDING, 1, 1, 16);
            UBOCSM.LAYOUT = new UniformBlock(0, _class4$6.BINDING, _class4$6.NAME, [new Uniform('cc_csmViewDir0', 16, _class4$6.CSM_LEVEL_COUNT), new Uniform('cc_csmViewDir1', 16, _class4$6.CSM_LEVEL_COUNT), new Uniform('cc_csmViewDir2', 16, _class4$6.CSM_LEVEL_COUNT), new Uniform('cc_csmAtlas', 16, _class4$6.CSM_LEVEL_COUNT), new Uniform('cc_matCSMViewProj', 25, _class4$6.CSM_LEVEL_COUNT), new Uniform('cc_csmProjDepthInfo', 16, _class4$6.CSM_LEVEL_COUNT), new Uniform('cc_csmProjInfo', 16, _class4$6.CSM_LEVEL_COUNT), new Uniform('cc_csmSplitsInfo', 16, 1)], 1);
            globalDescriptorSetLayout.layouts[UBOCSM.NAME] = UBOCSM.LAYOUT;
            globalDescriptorSetLayout.bindings[UBOCSM.BINDING] = UBOCSM.DESCRIPTOR;
            var UNIFORM_SHADOWMAP_NAME = 'cc_shadowMap';
            var UNIFORM_SHADOWMAP_BINDING = 4;
            var UNIFORM_SHADOWMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SHADOWMAP_BINDING, 16, 1, 16);
            var UNIFORM_SHADOWMAP_LAYOUT = new UniformSamplerTexture(0, UNIFORM_SHADOWMAP_BINDING, UNIFORM_SHADOWMAP_NAME, 28, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_SHADOWMAP_NAME] = UNIFORM_SHADOWMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_SHADOWMAP_BINDING] = UNIFORM_SHADOWMAP_DESCRIPTOR;
            var UNIFORM_ENVIRONMENT_NAME = 'cc_environment';
            var UNIFORM_ENVIRONMENT_BINDING = 5;
            var UNIFORM_ENVIRONMENT_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_ENVIRONMENT_BINDING, 16, 1, 16);
            var UNIFORM_ENVIRONMENT_LAYOUT = new UniformSamplerTexture(0, UNIFORM_ENVIRONMENT_BINDING, UNIFORM_ENVIRONMENT_NAME, 31, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_ENVIRONMENT_NAME] = UNIFORM_ENVIRONMENT_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_ENVIRONMENT_BINDING] = UNIFORM_ENVIRONMENT_DESCRIPTOR;
            var UNIFORM_DIFFUSEMAP_NAME = 'cc_diffuseMap';
            var UNIFORM_DIFFUSEMAP_BINDING = 7;
            var UNIFORM_DIFFUSEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_DIFFUSEMAP_BINDING, 16, 1, 16);
            var UNIFORM_DIFFUSEMAP_LAYOUT = new UniformSamplerTexture(0, UNIFORM_DIFFUSEMAP_BINDING, UNIFORM_DIFFUSEMAP_NAME, 31, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_DIFFUSEMAP_NAME] = UNIFORM_DIFFUSEMAP_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_DIFFUSEMAP_BINDING] = UNIFORM_DIFFUSEMAP_DESCRIPTOR;
            var UNIFORM_SPOT_SHADOW_MAP_TEXTURE_NAME = 'cc_spotShadowMap';
            var UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING = 6;
            var UNIFORM_SPOT_SHADOW_MAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING, 16, 1, 16);
            var UNIFORM_SPOT_SHADOW_MAP_TEXTURE_LAYOUT = new UniformSamplerTexture(0, UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING, UNIFORM_SPOT_SHADOW_MAP_TEXTURE_NAME, 28, 1);
            globalDescriptorSetLayout.layouts[UNIFORM_SPOT_SHADOW_MAP_TEXTURE_NAME] = UNIFORM_SPOT_SHADOW_MAP_TEXTURE_LAYOUT;
            globalDescriptorSetLayout.bindings[UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING] = UNIFORM_SPOT_SHADOW_MAP_TEXTURE_DESCRIPTOR;
            var UBOLocalEnum = {
              MAT_WORLD_OFFSET: 0,
              MAT_WORLD_IT_OFFSET: 16,
              LIGHTINGMAP_UVPARAM: 32,
              LOCAL_SHADOW_BIAS: 36,
              REFLECTION_PROBE_DATA1: 40,
              REFLECTION_PROBE_DATA2: 44,
              REFLECTION_PROBE_BLEND_DATA1: 48,
              REFLECTION_PROBE_BLEND_DATA2: 52,
              COUNT: 56,
              SIZE: 224,
              BINDING: 0
            };
            var UBOLocal = function UBOLocal() {};
            _class5$6 = UBOLocal;
            UBOLocal.MAT_WORLD_OFFSET = 0;
            UBOLocal.MAT_WORLD_IT_OFFSET = 16;
            UBOLocal.LIGHTINGMAP_UVPARAM = 32;
            UBOLocal.LOCAL_SHADOW_BIAS = 36;
            UBOLocal.REFLECTION_PROBE_DATA1 = 40;
            UBOLocal.REFLECTION_PROBE_DATA2 = 44;
            UBOLocal.REFLECTION_PROBE_BLEND_DATA1 = 48;
            UBOLocal.REFLECTION_PROBE_BLEND_DATA2 = 52;
            UBOLocal.COUNT = 56;
            UBOLocal.SIZE = 224;
            UBOLocal.NAME = 'CCLocal';
            UBOLocal.BINDING = 0;
            UBOLocal.DESCRIPTOR = new DescriptorSetLayoutBinding(0, 1, 1, 1 | 16 | 32, 1, 1);
            UBOLocal.LAYOUT = new UniformBlock(2, 0, _class5$6.NAME, [new Uniform('cc_matWorld', 25, 1), new Uniform('cc_matWorldIT', 25, 1), new Uniform('cc_lightingMapUVParam', 16, 1), new Uniform('cc_localShadowBias', 16, 1), new Uniform('cc_reflectionProbeData1', 16, 1), new Uniform('cc_reflectionProbeData2', 16, 1), new Uniform('cc_reflectionProbeBlendData1', 16, 1), new Uniform('cc_reflectionProbeBlendData2', 16, 1)], 1);
            localDescriptorSetLayout.layouts[UBOLocal.NAME] = UBOLocal.LAYOUT;
            localDescriptorSetLayout.bindings[0] = UBOLocal.DESCRIPTOR;
            var UBOWorldBound = function UBOWorldBound() {};
            _class6$2 = UBOWorldBound;
            UBOWorldBound.WORLD_BOUND_CENTER = 0;
            UBOWorldBound.WORLD_BOUND_HALF_EXTENTS = _class6$2.WORLD_BOUND_CENTER + 4;
            UBOWorldBound.COUNT = _class6$2.WORLD_BOUND_HALF_EXTENTS + 4;
            UBOWorldBound.SIZE = _class6$2.COUNT * 4;
            UBOWorldBound.NAME = 'CCWorldBound';
            UBOWorldBound.BINDING = 0;
            UBOWorldBound.DESCRIPTOR = new DescriptorSetLayoutBinding(_class6$2.BINDING, 1, 1, 1 | 32, 1, 1);
            UBOWorldBound.LAYOUT = new UniformBlock(2, _class6$2.BINDING, _class6$2.NAME, [new Uniform('cc_worldBoundCenter', 16, 1), new Uniform('cc_worldBoundHalfExtents', 16, 1)], 1);
            localDescriptorSetLayout.layouts[UBOWorldBound.NAME] = UBOWorldBound.LAYOUT;
            localDescriptorSetLayout.bindings[UBOWorldBound.BINDING] = UBOWorldBound.DESCRIPTOR;
            var INST_MAT_WORLD = 'a_matWorld0';
            var INST_SH = 'a_sh_linear_const_r';
            var UBOLocalBatched = function UBOLocalBatched() {};
            _class7$2 = UBOLocalBatched;
            UBOLocalBatched.BATCHING_COUNT = 10;
            UBOLocalBatched.MAT_WORLDS_OFFSET = 0;
            UBOLocalBatched.COUNT = 16 * _class7$2.BATCHING_COUNT;
            UBOLocalBatched.SIZE = _class7$2.COUNT * 4;
            UBOLocalBatched.NAME = 'CCLocalBatched';
            UBOLocalBatched.BINDING = 0;
            UBOLocalBatched.DESCRIPTOR = new DescriptorSetLayoutBinding(_class7$2.BINDING, 1, 1, 1 | 32, 1, 1);
            UBOLocalBatched.LAYOUT = new UniformBlock(2, _class7$2.BINDING, _class7$2.NAME, [new Uniform('cc_matWorlds', 25, _class7$2.BATCHING_COUNT)], 1);
            localDescriptorSetLayout.layouts[UBOLocalBatched.NAME] = UBOLocalBatched.LAYOUT;
            localDescriptorSetLayout.bindings[UBOLocalBatched.BINDING] = UBOLocalBatched.DESCRIPTOR;
            var UBOForwardLightEnum = {
              LIGHTS_PER_PASS: 1,
              LIGHT_POS_OFFSET: 0,
              LIGHT_COLOR_OFFSET: 4,
              LIGHT_SIZE_RANGE_ANGLE_OFFSET: 8,
              LIGHT_DIR_OFFSET: 12,
              LIGHT_BOUNDING_SIZE_VS_OFFSET: 16,
              COUNT: 20,
              SIZE: 80
            };
            var UBOForwardLight = function UBOForwardLight() {};
            _class8$2 = UBOForwardLight;
            UBOForwardLight.LIGHTS_PER_PASS = 1;
            UBOForwardLight.LIGHT_POS_OFFSET = 0;
            UBOForwardLight.LIGHT_COLOR_OFFSET = 4;
            UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET = 8;
            UBOForwardLight.LIGHT_DIR_OFFSET = 12;
            UBOForwardLight.LIGHT_BOUNDING_SIZE_VS_OFFSET = 16;
            UBOForwardLight.COUNT = 20;
            UBOForwardLight.SIZE = 80;
            UBOForwardLight.NAME = 'CCForwardLight';
            UBOForwardLight.BINDING = 1;
            UBOForwardLight.DESCRIPTOR = new DescriptorSetLayoutBinding(_class8$2.BINDING, 2, 1, 16, 1, 1);
            UBOForwardLight.LAYOUT = new UniformBlock(2, _class8$2.BINDING, _class8$2.NAME, [new Uniform('cc_lightPos', 16, 1), new Uniform('cc_lightColor', 16, 1), new Uniform('cc_lightSizeRangeAngle', 16, 1), new Uniform('cc_lightDir', 16, 1), new Uniform('cc_lightBoundingSizeVS', 16, 1)], 1);
            localDescriptorSetLayout.layouts[UBOForwardLight.NAME] = UBOForwardLight.LAYOUT;
            localDescriptorSetLayout.bindings[UBOForwardLight.BINDING] = UBOForwardLight.DESCRIPTOR;
            var UBODeferredLight = function UBODeferredLight() {};
            UBODeferredLight.LIGHTS_PER_PASS = 10;
            var JOINT_UNIFORM_CAPACITY = 30;
            var UBOSkinningTexture = function UBOSkinningTexture() {};
            _class10$2 = UBOSkinningTexture;
            UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0;
            UBOSkinningTexture.COUNT = _class10$2.JOINTS_TEXTURE_INFO_OFFSET + 4;
            UBOSkinningTexture.SIZE = _class10$2.COUNT * 4;
            UBOSkinningTexture.NAME = 'CCSkinningTexture';
            UBOSkinningTexture.BINDING = 3;
            UBOSkinningTexture.DESCRIPTOR = new DescriptorSetLayoutBinding(_class10$2.BINDING, 1, 1, 1, 1, 1);
            UBOSkinningTexture.LAYOUT = new UniformBlock(2, _class10$2.BINDING, _class10$2.NAME, [new Uniform('cc_jointTextureInfo', 16, 1)], 1);
            localDescriptorSetLayout.layouts[UBOSkinningTexture.NAME] = UBOSkinningTexture.LAYOUT;
            localDescriptorSetLayout.bindings[UBOSkinningTexture.BINDING] = UBOSkinningTexture.DESCRIPTOR;
            var UBOSkinningAnimation = function UBOSkinningAnimation() {};
            _class11$2 = UBOSkinningAnimation;
            UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0;
            UBOSkinningAnimation.COUNT = _class11$2.JOINTS_ANIM_INFO_OFFSET + 4;
            UBOSkinningAnimation.SIZE = _class11$2.COUNT * 4;
            UBOSkinningAnimation.NAME = 'CCSkinningAnimation';
            UBOSkinningAnimation.BINDING = 2;
            UBOSkinningAnimation.DESCRIPTOR = new DescriptorSetLayoutBinding(_class11$2.BINDING, 1, 1, 1, 1, 1);
            UBOSkinningAnimation.LAYOUT = new UniformBlock(2, _class11$2.BINDING, _class11$2.NAME, [new Uniform('cc_jointAnimInfo', 16, 1)], 1);
            localDescriptorSetLayout.layouts[UBOSkinningAnimation.NAME] = UBOSkinningAnimation.LAYOUT;
            localDescriptorSetLayout.bindings[UBOSkinningAnimation.BINDING] = UBOSkinningAnimation.DESCRIPTOR;
            var INST_JOINT_ANIM_INFO = 'a_jointAnimInfo';
            var UBOSkinning = function () {
              function UBOSkinning() {}
              UBOSkinning.initLayout = function initLayout(capacity) {
                UBOSkinning._jointUniformCapacity = capacity;
                UBOSkinning._count = capacity * 12;
                UBOSkinning._size = UBOSkinning._count * 4;
                UBOSkinning.LAYOUT.members[0].count = capacity * 3;
              };
              _createClass(UBOSkinning, null, [{
                key: "JOINT_UNIFORM_CAPACITY",
                get: function get() {
                  return UBOSkinning._jointUniformCapacity;
                }
              }, {
                key: "COUNT",
                get: function get() {
                  return UBOSkinning._count;
                }
              }, {
                key: "SIZE",
                get: function get() {
                  return UBOSkinning._size;
                }
              }]);
              return UBOSkinning;
            }();
            _class12 = UBOSkinning;
            UBOSkinning._jointUniformCapacity = 0;
            UBOSkinning._count = 0;
            UBOSkinning._size = 0;
            UBOSkinning.NAME = 'CCSkinning';
            UBOSkinning.BINDING = 3;
            UBOSkinning.DESCRIPTOR = new DescriptorSetLayoutBinding(_class12.BINDING, 1, 1, 1, 1, 1);
            UBOSkinning.LAYOUT = new UniformBlock(2, _class12.BINDING, _class12.NAME, [new Uniform('cc_joints', 16, 1)], 1);
            function localDescriptorSetLayout_ResizeMaxJoints(maxCount) {
              UBOSkinning.initLayout(maxCount);
              localDescriptorSetLayout.layouts[UBOSkinning.NAME] = UBOSkinning.LAYOUT;
              localDescriptorSetLayout.bindings[UBOSkinning.BINDING] = UBOSkinning.DESCRIPTOR;
            }
            var UBOMorphEnum = {
              MAX_MORPH_TARGET_COUNT: 60,
              OFFSET_OF_WEIGHTS: 0,
              OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH: 240,
              OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT: 244,
              OFFSET_OF_VERTICES_COUNT: 248,
              COUNT_BASE_4_BYTES: 64,
              SIZE: 256
            };
            var UBOMorph = function UBOMorph() {};
            _class13$2 = UBOMorph;
            UBOMorph.MAX_MORPH_TARGET_COUNT = 60;
            UBOMorph.OFFSET_OF_WEIGHTS = 0;
            UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 240;
            UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = 244;
            UBOMorph.OFFSET_OF_VERTICES_COUNT = 248;
            UBOMorph.COUNT_BASE_4_BYTES = 64;
            UBOMorph.SIZE = 256;
            UBOMorph.NAME = 'CCMorph';
            UBOMorph.BINDING = 4;
            UBOMorph.DESCRIPTOR = new DescriptorSetLayoutBinding(_class13$2.BINDING, 1, 1, 1, 1, 1);
            UBOMorph.LAYOUT = new UniformBlock(2, _class13$2.BINDING, _class13$2.NAME, [new Uniform('cc_displacementWeights', 16, 60 / 4), new Uniform('cc_displacementTextureInfo', 16, 1)], 1);
            localDescriptorSetLayout.layouts[UBOMorph.NAME] = UBOMorph.LAYOUT;
            localDescriptorSetLayout.bindings[UBOMorph.BINDING] = UBOMorph.DESCRIPTOR;
            var UBOUILocal = function UBOUILocal() {};
            _class14$2 = UBOUILocal;
            UBOUILocal.NAME = 'CCUILocal';
            UBOUILocal.BINDING = 5;
            UBOUILocal.DESCRIPTOR = new DescriptorSetLayoutBinding(_class14$2.BINDING, 2, 1, 1, 1, 1);
            UBOUILocal.LAYOUT = new UniformBlock(2, _class14$2.BINDING, _class14$2.NAME, [new Uniform('cc_local_data', 16, 1)], 1);
            localDescriptorSetLayout.layouts[UBOUILocal.NAME] = UBOUILocal.LAYOUT;
            localDescriptorSetLayout.bindings[UBOUILocal.BINDING] = UBOUILocal.DESCRIPTOR;
            var UBOSHEnum = {
              SH_LINEAR_CONST_R_OFFSET: 0,
              SH_LINEAR_CONST_G_OFFSET: 4,
              SH_LINEAR_CONST_B_OFFSET: 8,
              SH_QUADRATIC_R_OFFSET: 12,
              SH_QUADRATIC_G_OFFSET: 16,
              SH_QUADRATIC_B_OFFSET: 20,
              SH_QUADRATIC_A_OFFSET: 24,
              COUNT: 28,
              SIZE: 112,
              BINDING: 6
            };
            var UBOSH = function UBOSH() {};
            _class15 = UBOSH;
            UBOSH.SH_LINEAR_CONST_R_OFFSET = 0;
            UBOSH.SH_LINEAR_CONST_G_OFFSET = 4;
            UBOSH.SH_LINEAR_CONST_B_OFFSET = 8;
            UBOSH.SH_QUADRATIC_R_OFFSET = 12;
            UBOSH.SH_QUADRATIC_G_OFFSET = 16;
            UBOSH.SH_QUADRATIC_B_OFFSET = 20;
            UBOSH.SH_QUADRATIC_A_OFFSET = 24;
            UBOSH.COUNT = 28;
            UBOSH.SIZE = 112;
            UBOSH.NAME = 'CCSH';
            UBOSH.BINDING = 6;
            UBOSH.DESCRIPTOR = new DescriptorSetLayoutBinding(6, 1, 1, 16, 1, 1);
            UBOSH.LAYOUT = new UniformBlock(2, 6, _class15.NAME, [new Uniform('cc_sh_linear_const_r', 16, 1), new Uniform('cc_sh_linear_const_g', 16, 1), new Uniform('cc_sh_linear_const_b', 16, 1), new Uniform('cc_sh_quadratic_r', 16, 1), new Uniform('cc_sh_quadratic_g', 16, 1), new Uniform('cc_sh_quadratic_b', 16, 1), new Uniform('cc_sh_quadratic_a', 16, 1)], 1);
            localDescriptorSetLayout.layouts[UBOSH.NAME] = UBOSH.LAYOUT;
            localDescriptorSetLayout.bindings[6] = UBOSH.DESCRIPTOR;
            var UNIFORM_JOINT_TEXTURE_NAME = 'cc_jointTexture';
            var UNIFORM_JOINT_TEXTURE_BINDING = 7;
            var UNIFORM_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_JOINT_TEXTURE_BINDING, 16, 1, 1, 1, 4);
            var UNIFORM_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(2, UNIFORM_JOINT_TEXTURE_BINDING, UNIFORM_JOINT_TEXTURE_NAME, 28, 1);
            localDescriptorSetLayout.layouts[UNIFORM_JOINT_TEXTURE_NAME] = UNIFORM_JOINT_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_JOINT_TEXTURE_BINDING] = UNIFORM_JOINT_TEXTURE_DESCRIPTOR;
            var UNIFORM_REALTIME_JOINT_TEXTURE_NAME = 'cc_realtimeJoint';
            var UNIFORM_REALTIME_JOINT_TEXTURE_BINDING = 7;
            var UNIFORM_REALTIME_JOINT_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, 16, 1, 1, 1, 4);
            var UNIFORM_REALTIME_JOINT_TEXTURE_LAYOUT = new UniformSamplerTexture(2, UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, UNIFORM_REALTIME_JOINT_TEXTURE_NAME, 28, 1);
            localDescriptorSetLayout.layouts[UNIFORM_REALTIME_JOINT_TEXTURE_NAME] = UNIFORM_REALTIME_JOINT_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_REALTIME_JOINT_TEXTURE_BINDING] = UNIFORM_REALTIME_JOINT_TEXTURE_DESCRIPTOR;
            var UNIFORM_POSITION_MORPH_TEXTURE_NAME = 'cc_PositionDisplacements';
            var UNIFORM_POSITION_MORPH_TEXTURE_BINDING = 8;
            var UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_POSITION_MORPH_TEXTURE_BINDING, 16, 1, 1, 1, 4);
            var UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(2, UNIFORM_POSITION_MORPH_TEXTURE_BINDING, UNIFORM_POSITION_MORPH_TEXTURE_NAME, 28, 1);
            localDescriptorSetLayout.layouts[UNIFORM_POSITION_MORPH_TEXTURE_NAME] = UNIFORM_POSITION_MORPH_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_POSITION_MORPH_TEXTURE_BINDING] = UNIFORM_POSITION_MORPH_TEXTURE_DESCRIPTOR;
            var UNIFORM_NORMAL_MORPH_TEXTURE_NAME = 'cc_NormalDisplacements';
            var UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = 9;
            var UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, 16, 1, 1, 1, 4);
            var UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(2, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, UNIFORM_NORMAL_MORPH_TEXTURE_NAME, 28, 1);
            localDescriptorSetLayout.layouts[UNIFORM_NORMAL_MORPH_TEXTURE_NAME] = UNIFORM_NORMAL_MORPH_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_NORMAL_MORPH_TEXTURE_BINDING] = UNIFORM_NORMAL_MORPH_TEXTURE_DESCRIPTOR;
            var UNIFORM_TANGENT_MORPH_TEXTURE_NAME = 'cc_TangentDisplacements';
            var UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = 10;
            var UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, 16, 1, 1, 1, 4);
            var UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT = new UniformSamplerTexture(2, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, UNIFORM_TANGENT_MORPH_TEXTURE_NAME, 28, 1);
            localDescriptorSetLayout.layouts[UNIFORM_TANGENT_MORPH_TEXTURE_NAME] = UNIFORM_TANGENT_MORPH_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_TANGENT_MORPH_TEXTURE_BINDING] = UNIFORM_TANGENT_MORPH_TEXTURE_DESCRIPTOR;
            var UNIFORM_LIGHTMAP_TEXTURE_NAME = 'cc_lightingMap';
            var UNIFORM_LIGHTMAP_TEXTURE_BINDING = 11;
            var UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_LIGHTMAP_TEXTURE_BINDING, 16, 1, 16, 1, 4);
            var UNIFORM_LIGHTMAP_TEXTURE_LAYOUT = new UniformSamplerTexture(2, UNIFORM_LIGHTMAP_TEXTURE_BINDING, UNIFORM_LIGHTMAP_TEXTURE_NAME, 28, 1);
            localDescriptorSetLayout.layouts[UNIFORM_LIGHTMAP_TEXTURE_NAME] = UNIFORM_LIGHTMAP_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_LIGHTMAP_TEXTURE_BINDING] = UNIFORM_LIGHTMAP_TEXTURE_DESCRIPTOR;
            var UNIFORM_SPRITE_TEXTURE_NAME = 'cc_spriteTexture';
            var UNIFORM_SPRITE_TEXTURE_BINDING = 12;
            var UNIFORM_SPRITE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_SPRITE_TEXTURE_BINDING, 16, 1, 16, 1, 4);
            var UNIFORM_SPRITE_TEXTURE_LAYOUT = new UniformSamplerTexture(2, UNIFORM_SPRITE_TEXTURE_BINDING, UNIFORM_SPRITE_TEXTURE_NAME, 28, 1);
            localDescriptorSetLayout.layouts[UNIFORM_SPRITE_TEXTURE_NAME] = UNIFORM_SPRITE_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_SPRITE_TEXTURE_BINDING] = UNIFORM_SPRITE_TEXTURE_DESCRIPTOR;
            var UNIFORM_REFLECTION_PROBE_CUBEMAP_NAME = 'cc_reflectionProbeCubemap';
            var UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING = 13;
            var UNIFORM_REFLECTION_PROBE_CUBEMAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING, 16, 1, 16, 1, 9);
            var UNIFORM_REFLECTION_PROBE_CUBEMAP_LAYOUT = new UniformSamplerTexture(2, UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING, UNIFORM_REFLECTION_PROBE_CUBEMAP_NAME, 31, 1);
            localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_CUBEMAP_NAME] = UNIFORM_REFLECTION_PROBE_CUBEMAP_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING] = UNIFORM_REFLECTION_PROBE_CUBEMAP_DESCRIPTOR;
            var UNIFORM_REFLECTION_PROBE_TEXTURE_NAME = 'cc_reflectionProbePlanarMap';
            var UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING = 14;
            var UNIFORM_REFLECTION_PROBE_TEXTURE_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING, 16, 1, 16, 1, 4);
            var UNIFORM_REFLECTION_PROBE_TEXTURE_LAYOUT = new UniformSamplerTexture(2, UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING, UNIFORM_REFLECTION_PROBE_TEXTURE_NAME, 28, 1);
            localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_TEXTURE_NAME] = UNIFORM_REFLECTION_PROBE_TEXTURE_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING] = UNIFORM_REFLECTION_PROBE_TEXTURE_DESCRIPTOR;
            var UNIFORM_REFLECTION_PROBE_DATA_MAP_NAME = 'cc_reflectionProbeDataMap';
            var UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING = 15;
            var UNIFORM_REFLECTION_PROBE_DATA_MAP_DESCRIPTOR = new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING, 16, 1, 16, 1, 4);
            var UNIFORM_REFLECTION_PROBE_DATA_MAP_LAYOUT = new UniformSamplerTexture(2, UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING, UNIFORM_REFLECTION_PROBE_DATA_MAP_NAME, 28, 1);
            localDescriptorSetLayout.layouts[UNIFORM_REFLECTION_PROBE_DATA_MAP_NAME] = UNIFORM_REFLECTION_PROBE_DATA_MAP_LAYOUT;
            localDescriptorSetLayout.bindings[UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING] = UNIFORM_REFLECTION_PROBE_DATA_MAP_DESCRIPTOR;
            var UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_NAME = 'cc_reflectionProbeBlendCubemap';
            var UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING = 15 + 1;
            new DescriptorSetLayoutBinding(UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING, 16, 1, 16, 1, 9);
            new UniformSamplerTexture(2, UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING, UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_NAME, 31, 1);
            var ENABLE_PROBE_BLEND = false;
            var CAMERA_DEFAULT_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER]);
            var CAMERA_EDITOR_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.PROFILER]);
            var MODEL_ALWAYS_MASK = Layers.Enum.ALL;
            function supportsR16HalfFloatTexture(device) {
              return (device.getFormatFeatures(8) & (1 | 2)) === (1 | 2);
            }
            var dftShadowTexture;
            function getDefaultShadowTexture(device) {
              if (dftShadowTexture) return dftShadowTexture;
              var texInfo = new TextureInfo(1, 0, supportsR32FloatTexture(device) ? 11 : 35, 16, 16, 0, 1, 1, 1, 1);
              dftShadowTexture = device.createTexture(texInfo);
              return dftShadowTexture;
            }
            function supportsR32FloatTexture(device) {
              return (device.getFormatFeatures(11) & (1 | 2)) === (1 | 2) && !(device.gfxAPI === 6);
            }
            function supportsRGBA16HalfFloatTexture(device) {
              return (device.getFormatFeatures(41) & (1 | 2)) === (1 | 2);
            }
            function supportsRGBA32FloatTexture(device) {
              return (device.getFormatFeatures(44) & (1 | 2)) === (1 | 2);
            }
            function isEnableEffect() {
              return !!(cclegacy.rendering && cclegacy.rendering.enableEffectImport);
            }
            function getPassPool() {
              return new RecyclePool(function () {
                return {
                  priority: 0,
                  hash: 0,
                  depth: 0,
                  shaderId: 0,
                  subModel: null,
                  passIdx: 0
                };
              }, 64);
            }

            var define = /*#__PURE__*/Object.freeze({
                __proto__: null,
                CAMERA_DEFAULT_MASK: CAMERA_DEFAULT_MASK,
                CAMERA_EDITOR_MASK: CAMERA_EDITOR_MASK,
                ENABLE_PROBE_BLEND: ENABLE_PROBE_BLEND,
                INST_JOINT_ANIM_INFO: INST_JOINT_ANIM_INFO,
                INST_MAT_WORLD: INST_MAT_WORLD,
                INST_SH: INST_SH,
                JOINT_UNIFORM_CAPACITY: JOINT_UNIFORM_CAPACITY,
                MODEL_ALWAYS_MASK: MODEL_ALWAYS_MASK,
                ModelLocalBindings: ModelLocalBindings,
                PIPELINE_FLOW_FORWARD: PIPELINE_FLOW_FORWARD,
                PIPELINE_FLOW_MAIN: PIPELINE_FLOW_MAIN,
                PIPELINE_FLOW_SHADOW: PIPELINE_FLOW_SHADOW,
                PIPELINE_FLOW_SMAA: PIPELINE_FLOW_SMAA,
                PIPELINE_FLOW_TONEMAP: PIPELINE_FLOW_TONEMAP,
                PipelineGlobalBindings: PipelineGlobalBindings,
                RenderPassStage: RenderPassStage,
                RenderPriority: RenderPriority,
                SetIndex: SetIndex,
                UBOCSM: UBOCSM,
                UBOCSMEnum: UBOCSMEnum,
                UBOCamera: UBOCamera,
                UBOCameraEnum: UBOCameraEnum,
                UBODeferredLight: UBODeferredLight,
                UBOForwardLight: UBOForwardLight,
                UBOForwardLightEnum: UBOForwardLightEnum,
                UBOGlobal: UBOGlobal,
                UBOGlobalEnum: UBOGlobalEnum,
                UBOLocal: UBOLocal,
                UBOLocalBatched: UBOLocalBatched,
                UBOLocalEnum: UBOLocalEnum,
                UBOMorph: UBOMorph,
                UBOMorphEnum: UBOMorphEnum,
                UBOSH: UBOSH,
                UBOSHEnum: UBOSHEnum,
                UBOShadow: UBOShadow,
                UBOShadowEnum: UBOShadowEnum,
                UBOSkinning: UBOSkinning,
                UBOSkinningAnimation: UBOSkinningAnimation,
                UBOSkinningTexture: UBOSkinningTexture,
                UBOUILocal: UBOUILocal,
                UBOWorldBound: UBOWorldBound,
                UNIFORM_DIFFUSEMAP_BINDING: UNIFORM_DIFFUSEMAP_BINDING,
                UNIFORM_ENVIRONMENT_BINDING: UNIFORM_ENVIRONMENT_BINDING,
                UNIFORM_JOINT_TEXTURE_BINDING: UNIFORM_JOINT_TEXTURE_BINDING,
                UNIFORM_LIGHTMAP_TEXTURE_BINDING: UNIFORM_LIGHTMAP_TEXTURE_BINDING,
                UNIFORM_NORMAL_MORPH_TEXTURE_BINDING: UNIFORM_NORMAL_MORPH_TEXTURE_BINDING,
                UNIFORM_POSITION_MORPH_TEXTURE_BINDING: UNIFORM_POSITION_MORPH_TEXTURE_BINDING,
                UNIFORM_REALTIME_JOINT_TEXTURE_BINDING: UNIFORM_REALTIME_JOINT_TEXTURE_BINDING,
                UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING: UNIFORM_REFLECTION_PROBE_BLEND_CUBEMAP_BINDING,
                UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING: UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING,
                UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING: UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING,
                UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING: UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING,
                UNIFORM_SHADOWMAP_BINDING: UNIFORM_SHADOWMAP_BINDING,
                UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING: UNIFORM_SPOT_SHADOW_MAP_TEXTURE_BINDING,
                UNIFORM_SPRITE_TEXTURE_BINDING: UNIFORM_SPRITE_TEXTURE_BINDING,
                UNIFORM_TANGENT_MORPH_TEXTURE_BINDING: UNIFORM_TANGENT_MORPH_TEXTURE_BINDING,
                bindingMappingInfo: bindingMappingInfo,
                getDefaultShadowTexture: getDefaultShadowTexture,
                getPassPool: getPassPool,
                globalDescriptorSetLayout: globalDescriptorSetLayout,
                isEnableEffect: isEnableEffect,
                localDescriptorSetLayout: localDescriptorSetLayout,
                localDescriptorSetLayout_ResizeMaxJoints: localDescriptorSetLayout_ResizeMaxJoints,
                supportsR16HalfFloatTexture: supportsR16HalfFloatTexture,
                supportsR32FloatTexture: supportsR32FloatTexture,
                supportsRGBA16HalfFloatTexture: supportsRGBA16HalfFloatTexture,
                supportsRGBA32FloatTexture: supportsRGBA32FloatTexture
            });
            exports("pipeline", define);

            var _type2reader, _type2writer, _type2validator;
            var typeMask = 0xfc000000;
            var bindingMask = 0x03f00000;
            var countMask = 0x000ff000;
            var offsetMask = 0x00000fff;
            var genHandle = function genHandle(binding, type, count, offset) {
              if (offset === undefined) {
                offset = 0;
              }
              return type << 26 & typeMask | binding << 20 & bindingMask | count << 12 & countMask | offset & offsetMask;
            };
            var getTypeFromHandle = function getTypeFromHandle(handle) {
              return (handle & typeMask) >>> 26;
            };
            var getBindingFromHandle = function getBindingFromHandle(handle) {
              return (handle & bindingMask) >>> 20;
            };
            var getCountFromHandle = function getCountFromHandle(handle) {
              return (handle & countMask) >>> 12;
            };
            var getOffsetFromHandle = function getOffsetFromHandle(handle) {
              return handle & offsetMask;
            };
            var customizeType = function customizeType(handle, type) {
              return handle & 67108863 | type << 26 & typeMask;
            };
            var type2reader = (_type2reader = {}, _type2reader[0] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return warnID(12010, idx);
            }, _type2reader[5] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return a[idx];
            }, _type2reader[6] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec2.fromArray(v, a, idx);
            }, _type2reader[7] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec3.fromArray(v, a, idx);
            }, _type2reader[8] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec4.fromArray(v, a, idx);
            }, _type2reader[13] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return a[idx];
            }, _type2reader[14] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec2.fromArray(v, a, idx);
            }, _type2reader[15] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec3.fromArray(v, a, idx);
            }, _type2reader[16] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec4.fromArray(v, a, idx);
            }, _type2reader[21] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Mat3.fromArray(v, a, idx);
            }, _type2reader[25] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Mat4.fromArray(v, a, idx);
            }, _type2reader);
            var type2writer = (_type2writer = {}, _type2writer[0] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return warnID(12010, idx);
            }, _type2writer[5] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return a[idx] = v;
            }, _type2writer[6] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec2.toArray(a, v, idx);
            }, _type2writer[7] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec3.toArray(a, v, idx);
            }, _type2writer[8] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec4.toArray(a, v, idx);
            }, _type2writer[13] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return a[idx] = v;
            }, _type2writer[14] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec2.toArray(a, v, idx);
            }, _type2writer[15] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec3.toArray(a, v, idx);
            }, _type2writer[16] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Vec4.toArray(a, v, idx);
            }, _type2writer[21] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Mat3.toArray(a, v, idx);
            }, _type2writer[25] = function _(a, v, idx) {
              if (idx === undefined) {
                idx = 0;
              }
              return Mat4.toArray(a, v, idx);
            }, _type2writer);
            var type2validator = (_type2validator = {}, _type2validator[5] = function _(v) {
              return typeof v === 'number';
            }, _type2validator[13] = function _(v) {
              return typeof v === 'number';
            }, _type2validator[6] = function _(v) {
              return !!(v instanceof Vec2);
            }, _type2validator[14] = function _(v) {
              return !!(v instanceof Vec2);
            }, _type2validator[7] = function _(v) {
              return !!(v instanceof Vec3);
            }, _type2validator[15] = function _(v) {
              return !!(v instanceof Vec3);
            }, _type2validator[8] = function _(v) {
              return !!(v instanceof Vec4);
            }, _type2validator[16] = function _(v) {
              return !!(v instanceof Vec4 || v instanceof Color || v instanceof Quat);
            }, _type2validator[21] = function _(v) {
              return !!(v instanceof Mat3);
            }, _type2validator[25] = function _(v) {
              return !!(v instanceof Mat4);
            }, _type2validator);
            var defaultValues = [Object.freeze([0]), Object.freeze([0, 0]), Object.freeze([0, 0, 0, 0]), Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])];
            function getDefaultFromType(type) {
              switch (type) {
                case 1:
                case 5:
                case 9:
                case 13:
                  return defaultValues[0];
                case 2:
                case 6:
                case 10:
                case 14:
                  return defaultValues[1];
                case 4:
                case 8:
                case 12:
                case 16:
                  return defaultValues[2];
                case 25:
                  return defaultValues[3];
                case 28:
                  return 'default-texture';
                case 31:
                  return 'default-cube-texture';
                case 29:
                  return 'default-array-texture';
                case 30:
                  return 'default-3d-texture';
              }
              return defaultValues[0];
            }
            function getStringFromType(type) {
              switch (type) {
                case 28:
                  return '-texture';
                case 31:
                  return '-cube-texture';
                case 29:
                  return '-array-texture';
                case 30:
                  return '-3d-texture';
                default:
                  return '-unknown';
              }
            }
            function overrideMacros(target, source) {
              var entries = Object.entries(source);
              var isDifferent = false;
              for (var i = 0; i < entries.length; i++) {
                if (target[entries[i][0]] !== entries[i][1]) {
                  target[entries[i][0]] = entries[i][1];
                  isDifferent = true;
                }
              }
              return isDifferent;
            }

            function mapDefine(info, def) {
              switch (info.type) {
                case 'boolean':
                  return typeof def === 'number' ? def.toString() : def ? '1' : '0';
                case 'string':
                  return def !== undefined ? def : info.options[0];
                case 'number':
                  return def !== undefined ? def.toString() : info.range[0].toString();
                default:
                  warnID(16369);
                  return '-1';
              }
            }
            function prepareDefines(defs, tDefs) {
              var macros = [];
              for (var i = 0; i < tDefs.length; i++) {
                var tmpl = tDefs[i];
                var name = tmpl.name;
                var v = defs[name];
                var value = mapDefine(tmpl, v);
                var isDefault = !v || v === '0';
                macros.push({
                  name: name,
                  value: value,
                  isDefault: isDefault
                });
              }
              return macros;
            }
            function getShaderInstanceName(name, macros) {
              return name + macros.reduce(function (acc, cur) {
                return cur.isDefault ? acc : acc + "|" + cur.name + cur.value;
              }, '');
            }
            function dependencyCheck(dependencies, defines) {
              for (var i = 0; i < dependencies.length; i++) {
                var d = dependencies[i];
                if (d[0] === '!') {
                  if (defines[d.slice(1)]) {
                    return false;
                  }
                } else if (!defines[d]) {
                  return false;
                }
              }
              return true;
            }
            function getActiveAttributes(tmpl, gfxAttributes, defines) {
              var out = [];
              var attributes = tmpl.attributes;
              for (var i = 0; i < attributes.length; i++) {
                if (!dependencyCheck(attributes[i].defines, defines)) {
                  continue;
                }
                out.push(gfxAttributes[i]);
              }
              return out;
            }
            function getVariantKey(programInfo, defines) {
              var tmplDefs = programInfo.defines;
              if (programInfo.uber) {
                var _key = '';
                for (var i = 0; i < tmplDefs.length; i++) {
                  var tmplDef = tmplDefs[i];
                  var value = defines[tmplDef.name];
                  if (!value || !tmplDef._map) {
                    continue;
                  }
                  var mapped = tmplDef._map(value);
                  var offset = tmplDef._offset;
                  _key += "" + offset + mapped + "|";
                }
                return "" + _key + programInfo.hash;
              }
              var key = 0;
              for (var _i = 0; _i < tmplDefs.length; _i++) {
                var _tmplDef = tmplDefs[_i];
                var _value = defines[_tmplDef.name];
                if (!_value || !_tmplDef._map) {
                  continue;
                }
                var _mapped = _tmplDef._map(_value);
                var _offset = _tmplDef._offset;
                key |= _mapped << _offset;
              }
              return key.toString(16) + "|" + programInfo.hash;
            }
            var defaultUniformCounts = new Map();
            defaultUniformCounts.set('cc_joints', UBOSkinning.LAYOUT.members[0].count);
            defaultUniformCounts.set('cc_lightPos', 1);
            defaultUniformCounts.set('cc_lightColor', 1);
            defaultUniformCounts.set('cc_lightSizeRangeAngle', 1);
            defaultUniformCounts.set('cc_lightDir', 1);
            defaultUniformCounts.set('cc_lightBoundingSizeVS', 1);
            function getUniformSize(prevSize, m) {
              if (m.count) {
                return prevSize + GetTypeSize(m.type) * m.count;
              } else {
                var count = defaultUniformCounts.get(m.name);
                if (count !== undefined) {
                  return prevSize + GetTypeSize(m.type) * count;
                }
                errorID(16345, m.name);
              }
              return prevSize;
            }
            function getSize(blockMembers) {
              return blockMembers.reduce(getUniformSize, 0);
            }
            function genHandles(tmpl) {
              var handleMap = {};
              for (var i = 0; i < tmpl.blocks.length; i++) {
                var block = tmpl.blocks[i];
                var members = block.members;
                var offset = 0;
                for (var j = 0; j < members.length; j++) {
                  var uniform = members[j];
                  handleMap[uniform.name] = genHandle(block.binding, uniform.type, uniform.count, offset);
                  offset += (GetTypeSize(uniform.type) >> 2) * uniform.count;
                }
              }
              for (var _i2 = 0; _i2 < tmpl.samplerTextures.length; _i2++) {
                var samplerTexture = tmpl.samplerTextures[_i2];
                handleMap[samplerTexture.name] = genHandle(samplerTexture.binding, samplerTexture.type, samplerTexture.count);
              }
              return handleMap;
            }
            function getBitCount(cnt) {
              return Math.ceil(Math.log2(Math.max(cnt, 2)));
            }
            function populateMacros(tmpl) {
              var offset = 0;
              var _loop = function _loop() {
                var def = tmpl.defines[i];
                var cnt = 1;
                if (def.type === 'number') {
                  var range = def.range;
                  cnt = getBitCount(range[1] - range[0] + 1);
                  def._map = function (value) {
                    return value - range[0];
                  };
                } else if (def.type === 'string') {
                  cnt = getBitCount(def.options.length);
                  def._map = function (value) {
                    return Math.max(0, def.options.findIndex(function (s) {
                      return s === value;
                    }));
                  };
                } else if (def.type === 'boolean') {
                  def._map = function (value) {
                    return value ? 1 : 0;
                  };
                }
                def._offset = offset;
                offset += cnt;
              };
              for (var i = 0; i < tmpl.defines.length; i++) {
                _loop();
              }
              if (offset > 31) {
                tmpl.uber = true;
              }
              tmpl.constantMacros = '';
              for (var key in tmpl.builtins.statistics) {
                tmpl.constantMacros += "#define " + key + " " + tmpl.builtins.statistics[key] + "\n";
              }
            }
            function getCombinationDefines(combination) {
              var defines = Object.keys(combination).reduce(function (out, name) {
                return out.reduce(function (acc, cur) {
                  var choices = combination[name];
                  for (var i = 0; i < choices.length; ++i) {
                    var _defines = _extends({}, cur);
                    _defines[name] = choices[i];
                    acc.push(_defines);
                  }
                  return acc;
                }, []);
              }, [{}]);
              return defines;
            }
            function addEffectDefaultProperties(effect) {
              for (var i = 0; i < effect.techniques.length; i++) {
                var tech = effect.techniques[i];
                for (var j = 0; j < tech.passes.length; j++) {
                  var pass = tech.passes[j];
                  if (pass.propertyIndex !== undefined && pass.properties === undefined) {
                    pass.properties = tech.passes[pass.propertyIndex].properties;
                  }
                }
              }
            }

            var _dsLayoutInfo = new DescriptorSetLayoutInfo();
            function insertBuiltinBindings(tmpl, tmplInfo, source, type, outBindings) {
              var target = tmpl.builtins[type];
              var tempBlocks = [];
              var _loop = function _loop() {
                var b = target.blocks[i];
                var info = source.layouts[b.name];
                var binding = info && source.bindings.find(function (bd) {
                  return bd.binding === info.binding;
                });
                if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_BUFFER_TYPE)) {
                  warnID(16348, b.name);
                  return 1;
                }
                tempBlocks.push(info);
              };
              for (var i = 0; i < target.blocks.length; i++) {
                if (_loop()) continue;
              }
              Array.prototype.unshift.apply(tmplInfo.shaderInfo.blocks, tempBlocks);
              var tempSamplerTextures = [];
              var _loop2 = function _loop2() {
                var s = target.samplerTextures[_i];
                var info = source.layouts[s.name];
                var binding = info && source.bindings.find(function (bd) {
                  return bd.binding === info.binding;
                });
                if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_SAMPLER_TYPE)) {
                  warnID(16349, s.name);
                  return 1;
                }
                tempSamplerTextures.push(info);
              };
              for (var _i = 0; _i < target.samplerTextures.length; _i++) {
                if (_loop2()) continue;
              }
              Array.prototype.unshift.apply(tmplInfo.shaderInfo.samplerTextures, tempSamplerTextures);
            }
            var ProgramLib = function () {
              function ProgramLib() {
                this._templates = {};
                this._cache = {};
                this._templateInfos = {};
              }
              var _proto = ProgramLib.prototype;
              _proto.register = function register(effect) {
                for (var i = 0; i < effect.shaders.length; i++) {
                  var tmpl = this.define(effect.shaders[i]);
                  tmpl.effectName = effect.name;
                }
                for (var _i2 = 0; _i2 < effect.techniques.length; _i2++) {
                  var tech = effect.techniques[_i2];
                  for (var j = 0; j < tech.passes.length; j++) {
                    var pass = tech.passes[j];
                    if (pass.propertyIndex !== undefined && pass.properties === undefined) {
                      pass.properties = tech.passes[pass.propertyIndex].properties;
                    }
                  }
                }
              };
              _proto.define = function define(shader) {
                var curTmpl = this._templates[shader.name];
                if (curTmpl && curTmpl.hash === shader.hash) {
                  return curTmpl;
                }
                var tmpl = _extends({}, shader);
                populateMacros(tmpl);
                this._templates[shader.name] = tmpl;
                if (!this._templateInfos[tmpl.hash]) {
                  var tmplInfo = {};
                  tmplInfo.samplerStartBinding = tmpl.blocks.length;
                  tmplInfo.shaderInfo = new ShaderInfo();
                  tmplInfo.blockSizes = [];
                  tmplInfo.bindings = [];
                  for (var i = 0; i < tmpl.blocks.length; i++) {
                    var block = tmpl.blocks[i];
                    tmplInfo.blockSizes.push(getSize(block.members));
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(block.binding, 1, 1, block.stageFlags));
                    tmplInfo.shaderInfo.blocks.push(new UniformBlock(1, block.binding, block.name, block.members.map(function (m) {
                      return new Uniform(m.name, m.type, m.count);
                    }), 1));
                  }
                  for (var _i3 = 0; _i3 < tmpl.samplerTextures.length; _i3++) {
                    var samplerTexture = tmpl.samplerTextures[_i3];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(samplerTexture.binding, 16, samplerTexture.count, samplerTexture.stageFlags));
                    tmplInfo.shaderInfo.samplerTextures.push(new UniformSamplerTexture(1, samplerTexture.binding, samplerTexture.name, samplerTexture.type, samplerTexture.count));
                  }
                  for (var _i4 = 0; _i4 < tmpl.samplers.length; _i4++) {
                    var sampler = tmpl.samplers[_i4];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(sampler.binding, 32, sampler.count, sampler.stageFlags));
                    tmplInfo.shaderInfo.samplers.push(new UniformSampler(1, sampler.binding, sampler.name, sampler.count));
                  }
                  for (var _i5 = 0; _i5 < tmpl.textures.length; _i5++) {
                    var texture = tmpl.textures[_i5];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(texture.binding, 64, texture.count, texture.stageFlags));
                    tmplInfo.shaderInfo.textures.push(new UniformTexture(1, texture.binding, texture.name, texture.type, texture.count));
                  }
                  for (var _i6 = 0; _i6 < tmpl.buffers.length; _i6++) {
                    var buffer = tmpl.buffers[_i6];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(buffer.binding, 4, 1, buffer.stageFlags));
                    tmplInfo.shaderInfo.buffers.push(new UniformStorageBuffer(1, buffer.binding, buffer.name, 1, buffer.memoryAccess));
                  }
                  for (var _i7 = 0; _i7 < tmpl.images.length; _i7++) {
                    var image = tmpl.images[_i7];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(image.binding, 128, image.count, image.stageFlags));
                    tmplInfo.shaderInfo.images.push(new UniformStorageImage(1, image.binding, image.name, image.type, image.count, image.memoryAccess));
                  }
                  for (var _i8 = 0; _i8 < tmpl.subpassInputs.length; _i8++) {
                    var subpassInput = tmpl.subpassInputs[_i8];
                    tmplInfo.bindings.push(new DescriptorSetLayoutBinding(subpassInput.binding, 256, subpassInput.count, subpassInput.stageFlags));
                    tmplInfo.shaderInfo.subpassInputs.push(new UniformInputAttachment(1, subpassInput.binding, subpassInput.name, subpassInput.count));
                  }
                  tmplInfo.gfxAttributes = [];
                  for (var _i9 = 0; _i9 < tmpl.attributes.length; _i9++) {
                    var attr = tmpl.attributes[_i9];
                    tmplInfo.gfxAttributes.push(new Attribute(attr.name, attr.format, attr.isNormalized, 0, attr.isInstanced, attr.location));
                  }
                  insertBuiltinBindings(tmpl, tmplInfo, localDescriptorSetLayout, 'locals');
                  tmplInfo.shaderInfo.stages.push(new ShaderStage(1, ''));
                  tmplInfo.shaderInfo.stages.push(new ShaderStage(16, ''));
                  tmplInfo.handleMap = genHandles(tmpl);
                  tmplInfo.setLayouts = [];
                  this._templateInfos[tmpl.hash] = tmplInfo;
                }
                return tmpl;
              };
              _proto.getTemplate = function getTemplate(name) {
                return this._templates[name];
              };
              _proto.getTemplateInfo = function getTemplateInfo(name) {
                var hash = this._templates[name].hash;
                return this._templateInfos[hash];
              };
              _proto.getDescriptorSetLayout = function getDescriptorSetLayout(device, name, isLocal) {
                if (isLocal === undefined) {
                  isLocal = false;
                }
                var tmpl = this._templates[name];
                var tmplInfo = this._templateInfos[tmpl.hash];
                if (!tmplInfo.setLayouts.length) {
                  _dsLayoutInfo.bindings = tmplInfo.bindings;
                  tmplInfo.setLayouts[1] = device.createDescriptorSetLayout(_dsLayoutInfo);
                  _dsLayoutInfo.bindings = localDescriptorSetLayout.bindings;
                  tmplInfo.setLayouts[2] = device.createDescriptorSetLayout(_dsLayoutInfo);
                }
                return tmplInfo.setLayouts[isLocal ? 2 : 1];
              };
              _proto.hasProgram = function hasProgram(name) {
                return this._templates[name] !== undefined;
              };
              _proto.getKey = function getKey(name, defines) {
                var tmpl = this._templates[name];
                return getVariantKey(tmpl, defines);
              };
              _proto.destroyShaderByDefines = function destroyShaderByDefines(defines) {
                var _this = this;
                var names = Object.keys(defines);
                if (!names.length) {
                  return;
                }
                var regexes = names.map(function (cur) {
                  var val = defines[cur];
                  if (typeof val === 'boolean') {
                    val = val ? '1' : '0';
                  }
                  return new RegExp("" + cur + val);
                });
                var keys = Object.keys(this._cache).filter(function (k) {
                  return regexes.every(function (re) {
                    return re.test(_this._cache[k].name);
                  });
                });
                for (var i = 0; i < keys.length; i++) {
                  var k = keys[i];
                  var prog = this._cache[k];
                  debug("destroyed shader " + prog.name);
                  prog.destroy();
                  delete this._cache[k];
                }
              };
              _proto.getGFXShader = function getGFXShader(device, name, defines, pipeline, key) {
                Object.assign(defines, pipeline.macros);
                if (!key) key = this.getKey(name, defines);
                var res = this._cache[key];
                if (res) {
                  return res;
                }
                var tmpl = this._templates[name];
                var tmplInfo = this._templateInfos[tmpl.hash];
                if (!tmplInfo.pipelineLayout) {
                  this.getDescriptorSetLayout(device, name);
                  insertBuiltinBindings(tmpl, tmplInfo, globalDescriptorSetLayout, 'globals');
                  tmplInfo.setLayouts[0] = pipeline.descriptorSetLayout;
                  tmplInfo.pipelineLayout = device.createPipelineLayout(new PipelineLayoutInfo(tmplInfo.setLayouts));
                }
                var macroArray = prepareDefines(defines, tmpl.defines);
                var prefix = pipeline.constantMacros + tmpl.constantMacros + macroArray.reduce(function (acc, cur) {
                  return acc + "#define " + cur.name + " " + cur.value + "\n";
                }, '');
                var src = tmpl.glsl3;
                var deviceShaderVersion = getDeviceShaderVersion(device);
                if (deviceShaderVersion) {
                  src = tmpl[deviceShaderVersion];
                } else {
                  errorID(16346);
                }
                tmplInfo.shaderInfo.stages[0].source = prefix + src.vert;
                tmplInfo.shaderInfo.stages[1].source = prefix + src.frag;
                tmplInfo.shaderInfo.attributes = getActiveAttributes(tmpl, tmplInfo.gfxAttributes, defines);
                tmplInfo.shaderInfo.name = getShaderInstanceName(name, macroArray);
                var shaderInfo = tmplInfo.shaderInfo;
                return this._cache[key] = device.createShader(shaderInfo);
              };
              return ProgramLib;
            }();
            function getDeviceShaderVersion(device) {
              switch (device.gfxAPI) {
                case 1:
                case 6:
                  return 'glsl1';
                case 2:
                case 7:
                  return 'glsl3';
                default:
                  return 'glsl4';
              }
            }
            var programLib$1 = new ProgramLib();
            cclegacy.programLib = programLib$1;

            var _dec$A, _class$A, _class2$w, _initializer$v, _initializer2$p, _initializer3$j, _initializer4$f, _class3$8;
            var legacyBuiltinEffectNames = ['planar-shadow', 'skybox', 'deferred-lighting', 'bloom', 'hbao', 'copy-pass', 'post-process', 'profiler', 'splash-screen', 'unlit', 'sprite', 'particle', 'particle-gpu', 'particle-trail', 'billboard', 'terrain', 'graphics', 'clear-stencil', 'spine', 'occlusion-query', 'geometry-renderer', 'debug-renderer', 'ssss-blur', 'float-output-process'];
            var EffectAsset = exports("EffectAsset", (_dec$A = ccclass$6('cc.EffectAsset'), _dec$A(_class$A = (_class2$w = (_class3$8 = function (_Asset) {
              _inheritsLoose(EffectAsset, _Asset);
              EffectAsset.register = function register(asset) {
                EffectAsset._effects[asset.name] = asset;
                EffectAsset._layoutValid = false;
              };
              EffectAsset.remove = function remove(asset) {
                if (typeof asset !== 'string') {
                  if (EffectAsset._effects[asset.name] && EffectAsset._effects[asset.name] === asset) {
                    delete EffectAsset._effects[asset.name];
                  }
                } else {
                  if (EffectAsset._effects[asset]) {
                    delete EffectAsset._effects[asset];
                    return;
                  }
                  for (var n in EffectAsset._effects) {
                    if (EffectAsset._effects[n]._uuid === asset) {
                      delete EffectAsset._effects[n];
                      return;
                    }
                  }
                }
              };
              EffectAsset.get = function get(name) {
                if (EffectAsset._effects[name]) {
                  return EffectAsset._effects[name];
                }
                for (var n in EffectAsset._effects) {
                  if (EffectAsset._effects[n]._uuid === name) {
                    return EffectAsset._effects[n];
                  }
                }
                if (legacyBuiltinEffectNames.includes(name)) {
                  warnID(16101, name);
                }
                return null;
              };
              EffectAsset.getAll = function getAll() {
                return EffectAsset._effects;
              };
              EffectAsset.isLayoutValid = function isLayoutValid() {
                return EffectAsset._layoutValid;
              };
              EffectAsset.setLayoutValid = function setLayoutValid() {
                EffectAsset._layoutValid = true;
              };
              function EffectAsset(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this.techniques = _initializer$v && _initializer$v();
                _this.shaders = _initializer2$p && _initializer2$p();
                _this.combinations = _initializer3$j && _initializer3$j();
                _this.hideInEditor = _initializer4$f && _initializer4$f();
                return _this;
              }
              var _proto = EffectAsset.prototype;
              _proto.onLoaded = function onLoaded() {
                if (cclegacy.rendering && cclegacy.rendering.enableEffectImport) {
                  addEffectDefaultProperties(this);
                  var _programLib = cclegacy.rendering.programLib;
                  _programLib.addEffect(this);
                  _programLib.init(deviceManager.gfxDevice);
                } else {
                  programLib$1.register(this);
                }
                EffectAsset.register(this);
                {
                  cclegacy.game.once(cclegacy.Game.EVENT_RENDERER_INITED, this._precompile, this);
                }
              };
              _proto._precompile = function _precompile() {
                var _this2 = this;
                if (cclegacy.rendering && cclegacy.rendering.enableEffectImport) {
                  cclegacy.rendering.programLib.precompileEffect(deviceManager.gfxDevice, this);
                  return;
                }
                var root = cclegacy.director.root;
                var _loop = function _loop() {
                  var shader = _this2.shaders[i];
                  var combination = _this2.combinations[i];
                  if (!combination) {
                    return 1;
                  }
                  var defines = getCombinationDefines(combination);
                  defines.forEach(function (defines) {
                    return programLib$1.getGFXShader(deviceManager.gfxDevice, shader.name, defines, root.pipeline);
                  });
                };
                for (var i = 0; i < this.shaders.length; i++) {
                  if (_loop()) continue;
                }
              };
              _proto.destroy = function destroy() {
                EffectAsset.remove(this);
                return _Asset.prototype.destroy.call(this);
              };
              _proto.initDefault = function initDefault(uuid) {
                _Asset.prototype.initDefault.call(this, uuid);
                var effect = EffectAsset.get('builtin-unlit');
                this.name = 'builtin-unlit';
                this.shaders = effect.shaders;
                this.combinations = effect.combinations;
                this.techniques = effect.techniques;
              };
              _proto.validate = function validate() {
                return this.techniques.length > 0 && this.shaders.length > 0;
              };
              return EffectAsset;
            }(Asset), _class3$8._effects = {}, _class3$8._layoutValid = true, _class3$8), (_initializer$v = applyDecoratedInitializer(_class2$w.prototype, "techniques", [serializable$5], function () {
              return [];
            }), _initializer2$p = applyDecoratedInitializer(_class2$w.prototype, "shaders", [serializable$5], function () {
              return [];
            }), _initializer3$j = applyDecoratedInitializer(_class2$w.prototype, "combinations", [serializable$5], function () {
              return [];
            }), _initializer4$f = applyDecoratedInitializer(_class2$w.prototype, "hideInEditor", [serializable$5, editorOnly], function () {
              return false;
            })), _class2$w)) || _class$A));
            cclegacy.EffectAsset = EffectAsset;

            var isMatchByWord = function isMatchByWord(path, test) {
              if (path.length > test.length) {
                var nextAscii = path.charCodeAt(test.length);
                return nextAscii === 47;
              }
              return true;
            };
            var processOptions = function processOptions(options) {
              var uuids = options.uuids;
              var paths = options.paths;
              var types = options.types;
              var bundles = options.deps;
              var realEntries = options.paths = Object.create(null);
              if (options.debug === false) {
                for (var i = 0, l = uuids.length; i < l; i++) {
                  uuids[i] = decodeUuid(uuids[i]);
                }
                for (var id in paths) {
                  var entry = paths[id];
                  var type = entry[1];
                  entry[1] = types[type];
                }
              } else {
                var out = Object.create(null);
                for (var _i = 0, _l = uuids.length; _i < _l; _i++) {
                  var uuid = uuids[_i];
                  uuids[_i] = out[uuid] = decodeUuid(uuid);
                }
                uuids = out;
              }
              for (var _id in paths) {
                var _entry = paths[_id];
                realEntries[uuids[_id]] = _entry;
              }
              var scenes = options.scenes;
              for (var name in scenes) {
                var _uuid = scenes[name];
                scenes[name] = uuids[_uuid];
              }
              var packs = options.packs;
              for (var packId in packs) {
                var packedIds = packs[packId];
                for (var j = 0; j < packedIds.length; ++j) {
                  packedIds[j] = uuids[packedIds[j]];
                }
              }
              var versions = options.versions;
              if (versions) {
                for (var folder in versions) {
                  var entries = versions[folder];
                  for (var _i2 = 0; _i2 < entries.length; _i2 += 2) {
                    var _uuid2 = entries[_i2];
                    entries[_i2] = uuids[_uuid2] || _uuid2;
                  }
                }
              }
              var redirect = options.redirect;
              if (redirect) {
                for (var _i3 = 0; _i3 < redirect.length; _i3 += 2) {
                  redirect[_i3] = uuids[redirect[_i3]];
                  redirect[_i3 + 1] = bundles[redirect[_i3 + 1]];
                }
              }
              var extensionMap = options.extensionMap;
              if (extensionMap) {
                var _loop = function _loop(ext) {
                  if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
                    return 1;
                  }
                  options.extensionMap[ext].forEach(function (uuid, index) {
                    options.extensionMap[ext][index] = uuids[uuid] || uuid;
                  });
                };
                for (var ext in options.extensionMap) {
                  if (_loop(ext)) continue;
                }
              }
            };
            var Config = function () {
              function Config() {
                this.name = '';
                this.base = '';
                this.importBase = '';
                this.nativeBase = '';
                this.deps = null;
                this.assetInfos = new Cache();
                this.scenes = new Cache();
                this.paths = new Cache();
              }
              var _proto = Config.prototype;
              _proto.init = function init(options) {
                var _this = this;
                processOptions(options);
                this.importBase = options.importBase || '';
                this.nativeBase = options.nativeBase || '';
                this.base = options.base || '';
                this.name = options.name || '';
                this.deps = options.deps || [];
                this._initUuid(options.uuids);
                this._initPath(options.paths);
                this._initScene(options.scenes);
                this._initPackage(options.packs, options.extensionMap['.cconb']);
                this._initVersion(options.versions);
                this._initRedirect(options.redirect);
                var _loop2 = function _loop2(ext) {
                  if (!Object.prototype.hasOwnProperty.call(options.extensionMap, ext)) {
                    return 1;
                  }
                  options.extensionMap[ext].forEach(function (uuid) {
                    var assetInfo = _this.assetInfos.get(uuid);
                    if (assetInfo) {
                      assetInfo.extension = ext;
                    }
                  });
                };
                for (var ext in options.extensionMap) {
                  if (_loop2(ext)) continue;
                }
              };
              _proto.getInfoWithPath = function getInfoWithPath(path, type) {
                if (!path) {
                  return null;
                }
                path = normalize(path);
                var items = this.paths.get(path);
                if (items) {
                  if (type) {
                    for (var i = 0, l = items.length; i < l; i++) {
                      var assetInfo = items[i];
                      if (isChildClassOf(assetInfo.ctor, type)) {
                        return assetInfo;
                      }
                    }
                  } else {
                    return items[0];
                  }
                }
                return null;
              };
              _proto.getDirWithPath = function getDirWithPath(path, type, out) {
                path = normalize(path);
                if (path[path.length - 1] === '/') {
                  path = path.slice(0, -1);
                }
                var infos = out || [];
                this.paths.forEach(function (items, p) {
                  if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                    for (var i = 0, l = items.length; i < l; i++) {
                      var entry = items[i];
                      if (!type || isChildClassOf(entry.ctor, type)) {
                        infos.push(entry);
                      }
                    }
                  }
                });
                return infos;
              };
              _proto.getAssetInfo = function getAssetInfo(uuid) {
                return this.assetInfos.get(uuid) || null;
              };
              _proto.getSceneInfo = function getSceneInfo(name) {
                if (!name.endsWith('.scene')) {
                  name += '.scene';
                }
                if (name[0] !== '/' && !name.startsWith('db://')) {
                  name = "/" + name;
                }
                var info = this.scenes.find(function (val, key) {
                  return key.endsWith(name);
                });
                return info;
              };
              _proto.destroy = function destroy() {
                this.paths.destroy();
                this.scenes.destroy();
                this.assetInfos.destroy();
              };
              _proto._initUuid = function _initUuid(uuidList) {
                if (!uuidList) {
                  return;
                }
                this.assetInfos.clear();
                for (var i = 0, l = uuidList.length; i < l; i++) {
                  var uuid = uuidList[i];
                  this.assetInfos.add(uuid, {
                    uuid: uuid
                  });
                }
              };
              _proto._initPath = function _initPath(pathList) {
                if (!pathList) {
                  return;
                }
                var paths = this.paths;
                paths.clear();
                for (var uuid in pathList) {
                  var info = pathList[uuid];
                  var path = info[0];
                  var type = info[1];
                  var isSubAsset = info.length === 3;
                  var assetInfo = this.assetInfos.get(uuid);
                  assetInfo.path = path;
                  assetInfo.ctor = getClassById(type);
                  if (paths.has(path)) {
                    if (isSubAsset) {
                      paths.get(path).push(assetInfo);
                    } else {
                      paths.get(path).unshift(assetInfo);
                    }
                  } else {
                    paths.add(path, [assetInfo]);
                  }
                }
              };
              _proto._initScene = function _initScene(sceneList) {
                if (!sceneList) {
                  return;
                }
                var scenes = this.scenes;
                scenes.clear();
                var assetInfos = this.assetInfos;
                for (var sceneName in sceneList) {
                  var uuid = sceneList[sceneName];
                  var assetInfo = assetInfos.get(uuid);
                  assetInfo.url = sceneName;
                  scenes.add(sceneName, assetInfo);
                }
              };
              _proto._initPackage = function _initPackage(packageList, cconbUuids) {
                if (!packageList) {
                  return;
                }
                var assetInfos = this.assetInfos;
                for (var packUuid in packageList) {
                  var uuids = packageList[packUuid];
                  var isCconb = (uuids == null ? undefined : uuids.length) > 0 && (cconbUuids == null ? undefined : cconbUuids.includes(uuids[0]));
                  var ext = isCconb ? '.bin' : '.json';
                  var pack = {
                    uuid: packUuid,
                    packedUuids: uuids,
                    ext: ext
                  };
                  assetInfos.add(packUuid, pack);
                  for (var i = 0, l = uuids.length; i < l; i++) {
                    var uuid = uuids[i];
                    var assetInfo = assetInfos.get(uuid);
                    var assetPacks = assetInfo.packs;
                    if (assetPacks) {
                      if (l === 1) {
                        assetPacks.unshift(pack);
                      } else {
                        assetPacks.push(pack);
                      }
                    } else {
                      assetInfo.packs = [pack];
                    }
                  }
                }
              };
              _proto._initVersion = function _initVersion(versions) {
                if (!versions) {
                  return;
                }
                var assetInfos = this.assetInfos;
                var entries = versions["import"];
                if (entries) {
                  for (var i = 0, l = entries.length; i < l; i += 2) {
                    var uuid = entries[i];
                    var assetInfo = assetInfos.get(uuid);
                    assetInfo.ver = entries[i + 1];
                  }
                }
                entries = versions["native"];
                if (entries) {
                  for (var _i4 = 0, _l2 = entries.length; _i4 < _l2; _i4 += 2) {
                    var _uuid3 = entries[_i4];
                    var _assetInfo = assetInfos.get(_uuid3);
                    _assetInfo.nativeVer = entries[_i4 + 1];
                  }
                }
              };
              _proto._initRedirect = function _initRedirect(redirect) {
                if (!redirect) {
                  return;
                }
                var assetInfos = this.assetInfos;
                for (var i = 0, l = redirect.length; i < l; i += 2) {
                  var uuid = redirect[i];
                  var assetInfo = assetInfos.get(uuid);
                  assetInfo.redirect = redirect[i + 1];
                }
              };
              return Config;
            }();

            function visitAsset(asset, deps) {
              if (!asset._uuid) {
                return;
              }
              deps.push(asset._uuid);
            }
            function visitComponent(comp, deps) {
              var props = Object.getOwnPropertyNames(comp);
              for (var i = 0; i < props.length; i++) {
                var propName = props[i];
                if (propName === 'node' || propName === '__eventTargets') {
                  continue;
                }
                var value = comp[propName];
                if (typeof value === 'object' && value) {
                  if (Array.isArray(value)) {
                    for (var j = 0; j < value.length; j++) {
                      var val = value[j];
                      if (val instanceof Asset) {
                        visitAsset(val, deps);
                      }
                    }
                  } else if (!value.constructor || value.constructor === Object) {
                    var keys = Object.getOwnPropertyNames(value);
                    for (var _j = 0; _j < keys.length; _j++) {
                      var _val = value[keys[_j]];
                      if (_val instanceof Asset) {
                        visitAsset(_val, deps);
                      }
                    }
                  } else if (value instanceof Asset) {
                    visitAsset(value, deps);
                  }
                }
              }
            }
            function visitNode(node, deps) {
              for (var i = 0; i < node._components.length; i++) {
                visitComponent(node._components[i], deps);
              }
              for (var _i = 0; _i < node._children.length; _i++) {
                visitNode(node._children[_i], deps);
              }
            }
            function descendOpRef(asset, refs, exclude, op) {
              exclude.push(asset._uuid);
              var depends = dependUtil.getDeps(asset._uuid);
              for (var i = 0, l = depends.length; i < l; i++) {
                var dependAsset = assets.get(depends[i]);
                if (!dependAsset) {
                  continue;
                }
                var uuid = dependAsset._uuid;
                if (!(uuid in refs)) {
                  refs[uuid] = dependAsset.refCount + op;
                } else {
                  refs[uuid] += op;
                }
                if (exclude.includes(uuid)) {
                  continue;
                }
                descendOpRef(dependAsset, refs, exclude, op);
              }
            }
            var _temp = [];
            function checkCircularReference(asset) {
              var refs = Object.create(null);
              refs[asset._uuid] = asset.refCount;
              descendOpRef(asset, refs, _temp, -1);
              _temp.length = 0;
              if (refs[asset._uuid] !== 0) {
                return refs[asset._uuid];
              }
              for (var uuid in refs) {
                if (refs[uuid] !== 0) {
                  descendOpRef(assets.get(uuid), refs, _temp, 1);
                }
              }
              _temp.length = 0;
              return refs[asset._uuid];
            }
            var ReleaseManager = function () {
              function ReleaseManager() {
                this._persistNodeDeps = new Cache();
                this._toDelete = new Cache();
                this._eventListener = false;
                this._dontDestroyAssets = [];
              }
              var _proto = ReleaseManager.prototype;
              _proto.addIgnoredAsset = function addIgnoredAsset(asset) {
                this._dontDestroyAssets.push(asset._uuid);
              };
              _proto.init = function init() {
                this._persistNodeDeps.clear();
                this._toDelete.clear();
              };
              _proto._addPersistNodeRef = function _addPersistNodeRef(node) {
                var deps = [];
                visitNode(node, deps);
                for (var i = 0, l = deps.length; i < l; i++) {
                  var dependAsset = assets.get(deps[i]);
                  if (dependAsset) {
                    dependAsset.addRef();
                  }
                }
                this._persistNodeDeps.add(node.uuid, deps);
              };
              _proto._removePersistNodeRef = function _removePersistNodeRef(node) {
                if (!this._persistNodeDeps.has(node.uuid)) {
                  return;
                }
                var deps = this._persistNodeDeps.get(node.uuid);
                for (var i = 0, l = deps.length; i < l; i++) {
                  var dependAsset = assets.get(deps[i]);
                  if (dependAsset) {
                    dependAsset.decRef();
                  }
                }
                this._persistNodeDeps.remove(node.uuid);
              };
              _proto._autoRelease = function _autoRelease(oldScene, newScene, persistNodes) {
                if (oldScene) {
                  var childs = dependUtil.getDeps(oldScene.uuid);
                  for (var i = 0, l = childs.length; i < l; i++) {
                    var asset = assets.get(childs[i]);
                    if (asset) {
                      asset.decRef(oldScene.autoReleaseAssets);
                    }
                  }
                  var dependencies = dependUtil._depends.get(oldScene.uuid);
                  if (dependencies && dependencies.persistDeps) {
                    var persistDeps = dependencies.persistDeps;
                    for (var _i2 = 0, _l = persistDeps.length; _i2 < _l; _i2++) {
                      var _asset = assets.get(persistDeps[_i2]);
                      if (_asset) {
                        _asset.decRef(oldScene.autoReleaseAssets);
                      }
                    }
                  }
                  if (oldScene.uuid !== newScene.uuid) {
                    dependUtil.remove(oldScene.uuid);
                  }
                }
                var sceneDeps = dependUtil._depends.get(newScene.uuid);
                if (sceneDeps) {
                  sceneDeps.persistDeps = [];
                }
                for (var key in persistNodes) {
                  var _ref;
                  var node = persistNodes[key];
                  var deps = this._persistNodeDeps.get(node.uuid);
                  for (var _iterator = _createForOfIteratorHelperLoose(deps), _step; !(_step = _iterator()).done;) {
                    var dep = _step.value;
                    var dependAsset = assets.get(dep);
                    if (dependAsset) {
                      dependAsset.addRef();
                    }
                  }
                  if (!sceneDeps) {
                    continue;
                  }
                  (_ref = sceneDeps.persistDeps).push.apply(_ref, deps);
                }
              };
              _proto.tryRelease = function tryRelease(asset, force) {
                if (force === undefined) {
                  force = false;
                }
                if (!(asset instanceof Asset)) {
                  return;
                }
                if (force) {
                  this._free(asset, force);
                  return;
                }
                this._toDelete.add(asset._uuid, asset);
                if (!this._eventListener) {
                  this._eventListener = true;
                  callInNextTick(this._freeAssets.bind(this));
                }
              };
              _proto._freeAssets = function _freeAssets() {
                var _this = this;
                this._eventListener = false;
                this._toDelete.forEach(function (asset) {
                  _this._free(asset);
                });
                this._toDelete.clear();
              };
              _proto._free = function _free(asset, force) {
                if (force === undefined) {
                  force = false;
                }
                var uuid = asset._uuid;
                this._toDelete.remove(uuid);
                if (!isValid(asset, true) || this._dontDestroyAssets.indexOf(uuid) !== -1) {
                  return;
                }
                if (!force) {
                  if (asset.refCount > 0) {
                    if (checkCircularReference(asset) > 0) {
                      return;
                    }
                  }
                }
                assets.remove(uuid);
                var depends = dependUtil.getDeps(uuid);
                for (var i = 0, l = depends.length; i < l; i++) {
                  var dependAsset = assets.get(depends[i]);
                  if (dependAsset) {
                    dependAsset.decRef(false);
                    {
                      this._free(dependAsset, false);
                    }
                  }
                }
                {
                  asset.destroy();
                }
                dependUtil.remove(uuid);
              };
              return ReleaseManager;
            }();
            var releaseManager = new ReleaseManager();

            var defaultProgressCallback = null;
            function setDefaultProgressCallback(onProgress) {
              defaultProgressCallback = onProgress;
            }
            function clear(task, clearRef) {
              for (var i = 0, l = task.input.length; i < l; i++) {
                var _item = task.input[i];
                {
                  if (!_item.isNative && _item.content instanceof Asset) {
                    _item.content.decRef(false);
                  }
                }
                _item.recycle();
              }
              task.input = null;
            }
            function urlAppendTimestamp(url, append) {
              if (append) {
                if (/\?/.test(url)) {
                  return url + "&_t=" + Date.now();
                }
                return url + "?_t=" + Date.now();
              }
              return url;
            }
            function retry(process, times, wait, onComplete, index) {
              if (index === undefined) {
                index = 0;
              }
              process(index, function (err, result) {
                index++;
                if (!err || index > times) {
                  if (onComplete) {
                    onComplete(err, result);
                  }
                } else {
                  setTimeout(function () {
                    retry(process, times, wait, onComplete, index);
                  }, wait);
                }
              });
            }
            function getDepends(uuid, data, exclude, depends, config) {
              try {
                var info = dependUtil.parse(uuid, data);
                for (var i = 0, l = info.deps.length; i < l; i++) {
                  var dep = info.deps[i];
                  if (!(dep in exclude)) {
                    exclude[dep] = true;
                    depends.push({
                      uuid: dep,
                      bundle: config && config.name
                    });
                  }
                }
                if (info.nativeDep) {
                  if (config) {
                    info.nativeDep.bundle = config.name;
                  }
                  depends.push(_extends({}, info.nativeDep));
                }
              } catch (e) {
                error(e.message, e.stack);
              }
            }
            function cache(id, asset, cacheAsset) {
              if (!asset) {
                return;
              }
              cacheAsset = cacheAsset !== undefined ? cacheAsset : cclegacy.assetManager.cacheAsset;
              if (!isScene(asset) && cacheAsset && !asset.isDefault) {
                assets.add(id, asset);
              }
            }
            function setProperties(uuid, asset, assetsMap) {
              var missingAsset = false;
              var depends = dependMap.get(asset);
              if (depends) {
                var missingAssetReporter = null;
                for (var i = 0, l = depends.length; i < l; i++) {
                  var depend = depends[i];
                  var dependAsset = assetsMap[depend.uuid + "@import"];
                  if (!dependAsset) {
                    {
                      errorID(16350, depend.uuid);
                    }
                    cclegacy.assetManager.dispatchAssetMissing(asset, depend.owner, depend.prop, depend.uuid);
                    if (depend.type && depend.type !== Asset) {
                      var placeHolder = new depend.type();
                      placeHolder.initDefault(depend.uuid);
                      depend.owner[depend.prop] = placeHolder;
                    }
                    missingAsset = true;
                  } else {
                    depend.owner[depend.prop] = dependAsset.addRef();
                  }
                }
                if (missingAssetReporter) {
                  missingAssetReporter.reportByOwner();
                }
                dependMap["delete"](asset);
              }
              if (nativeDependMap.has(asset)) {
                if (assetsMap[uuid + "@native"]) {
                  asset._nativeAsset = assetsMap[uuid + "@native"];
                } else {
                  missingAsset = true;
                  errorID(16351, uuid);
                }
                nativeDependMap["delete"](asset);
              }
              return missingAsset;
            }
            function gatherAsset(task) {
              var source = task.source;
              if (!task.options.__outputAsArray__ && source.length === 1) {
                task.output = source[0].content;
              } else {
                var output = task.output = [];
                for (var i = 0, l = source.length; i < l; i++) {
                  output.push(source[i].content);
                }
              }
            }
            function forEach(array, process, onComplete) {
              var count = 0;
              var errs = [];
              var length = array.length;
              if (length === 0 && onComplete) {
                onComplete(errs);
              }
              var cb = function cb(err) {
                if (err) {
                  errs.push(err);
                }
                count++;
                if (count === length) {
                  if (onComplete) {
                    onComplete(errs);
                  }
                }
              };
              for (var i = 0; i < length; i++) {
                process(array[i], cb);
              }
            }
            function parseParameters(options, onProgress, onComplete) {
              var optionsOut = options;
              var onProgressOut = onProgress;
              var onCompleteOut = onComplete;
              if (onComplete === undefined) {
                var isCallback = typeof options === 'function';
                if (onProgress) {
                  onCompleteOut = onProgress;
                  if (!isCallback) {
                    onProgressOut = null;
                  }
                } else if (onProgress === undefined && isCallback) {
                  onCompleteOut = options;
                  optionsOut = null;
                  onProgressOut = null;
                }
                if (onProgress !== undefined && isCallback) {
                  onProgressOut = options;
                  optionsOut = null;
                }
              }
              return {
                options: optionsOut || Object.create(null),
                onProgress: onProgressOut,
                onComplete: onCompleteOut
              };
            }
            function parseLoadResArgs(type, onProgress, onComplete) {
              var typeOut = type;
              var onProgressOut = onProgress;
              var onCompleteOut = onComplete;
              if (onComplete === undefined) {
                var isValidType = isChildClassOf(type, Asset);
                if (onProgress) {
                  onCompleteOut = onProgress;
                  if (isValidType) {
                    onProgressOut = null;
                  }
                } else if (onProgress === undefined && !isValidType) {
                  onCompleteOut = type;
                  onProgressOut = null;
                  typeOut = null;
                }
                if (onProgress !== undefined && !isValidType) {
                  onProgressOut = type;
                  typeOut = null;
                }
              }
              return {
                type: typeOut,
                onProgress: onProgressOut || defaultProgressCallback,
                onComplete: onCompleteOut
              };
            }
            function checkCircleReference(owner, uuid, map, checked) {
              if (checked === undefined) {
                checked = {};
              }
              var item = map[uuid];
              if (!item || checked[uuid]) {
                return false;
              }
              checked[uuid] = true;
              var result = false;
              var deps = dependUtil.getDeps(uuid);
              if (deps) {
                for (var i = 0, l = deps.length; i < l; i++) {
                  var dep = deps[i];
                  if (dep === owner || checkCircleReference(owner, dep, map, checked)) {
                    result = true;
                    break;
                  }
                }
              }
              return result;
            }
            function asyncify(cb) {
              return function (p1, p2) {
                if (!cb) {
                  return;
                }
                var refs = [];
                if (Array.isArray(p2)) {
                  p2.forEach(function (x) {
                    return x instanceof Asset && refs.push(x.addRef());
                  });
                } else if (p2 instanceof Asset) {
                  refs.push(p2.addRef());
                }
                callInNextTick(function () {
                  refs.forEach(function (x) {
                    return x.decRef(false);
                  });
                  cb(p1, p2);
                });
              };
            }

            var Bundle = function () {
              function Bundle() {
                this._config = new Config();
              }
              var _proto = Bundle.prototype;
              _proto.getInfoWithPath = function getInfoWithPath(path, type) {
                return this._config.getInfoWithPath(path, type);
              };
              _proto.getDirWithPath = function getDirWithPath(path, type, out) {
                return this._config.getDirWithPath(path, type, out);
              };
              _proto.getAssetInfo = function getAssetInfo(uuid) {
                return this._config.getAssetInfo(uuid);
              };
              _proto.getSceneInfo = function getSceneInfo(name) {
                return this._config.getSceneInfo(name);
              };
              _proto.init = function init(options) {
                this._config.init(options);
                bundles.add(options.name, this);
              };
              _proto.load = function load(paths, type, onProgress, onComplete) {
                var _parseLoadResArgs = parseLoadResArgs(type, onProgress, onComplete),
                  _type = _parseLoadResArgs.type,
                  onProg = _parseLoadResArgs.onProgress,
                  onComp = _parseLoadResArgs.onComplete;
                var options = {
                  __requestType__: "path",
                  type: _type,
                  bundle: this.name,
                  __outputAsArray__: Array.isArray(paths)
                };
                cclegacy.assetManager.loadAny(paths, options, onProg, onComp);
              };
              _proto.preload = function preload(paths, type, onProgress, onComplete) {
                var _parseLoadResArgs2 = parseLoadResArgs(type, onProgress, onComplete),
                  _type = _parseLoadResArgs2.type,
                  onProg = _parseLoadResArgs2.onProgress,
                  onComp = _parseLoadResArgs2.onComplete;
                cclegacy.assetManager.preloadAny(paths, {
                  __requestType__: "path",
                  type: _type,
                  bundle: this.name
                }, onProg, onComp);
              };
              _proto.loadDir = function loadDir(dir, type, onProgress, onComplete) {
                var _parseLoadResArgs3 = parseLoadResArgs(type, onProgress, onComplete),
                  _type = _parseLoadResArgs3.type,
                  onProg = _parseLoadResArgs3.onProgress,
                  onComp = _parseLoadResArgs3.onComplete;
                cclegacy.assetManager.loadAny(dir, {
                  __requestType__: "dir",
                  type: _type,
                  bundle: this.name,
                  __outputAsArray__: true
                }, onProg, onComp);
              };
              _proto.preloadDir = function preloadDir(dir, type, onProgress, onComplete) {
                var _parseLoadResArgs4 = parseLoadResArgs(type, onProgress, onComplete),
                  _type = _parseLoadResArgs4.type,
                  onProg = _parseLoadResArgs4.onProgress,
                  onComp = _parseLoadResArgs4.onComplete;
                cclegacy.assetManager.preloadAny(dir, {
                  __requestType__: "dir",
                  type: _type,
                  bundle: this.name
                }, onProg, onComp);
              };
              _proto.loadScene = function loadScene(sceneName, options, onProgress, onComplete) {
                var _parseParameters = parseParameters(options, onProgress, onComplete),
                  opts = _parseParameters.options,
                  onProg = _parseParameters.onProgress,
                  onComp = _parseParameters.onComplete;
                opts.preset = opts.preset || 'scene';
                opts.bundle = this.name;
                cclegacy.assetManager.loadAny({
                  scene: sceneName
                }, opts, onProg, function (err, sceneAsset) {
                  if (err) {
                    error(err.message, err.stack);
                  } else if (sceneAsset.scene) {
                    var scene = sceneAsset.scene;
                    scene.id = sceneAsset._uuid;
                    scene.name = sceneAsset.name;
                  } else {
                    err = new Error("The asset " + sceneAsset._uuid + " is not a scene");
                  }
                  if (onComp) {
                    onComp(err, sceneAsset);
                  }
                });
              };
              _proto.preloadScene = function preloadScene(sceneName, options, onProgress, onComplete) {
                var _parseParameters2 = parseParameters(options, onProgress, onComplete),
                  opts = _parseParameters2.options,
                  onProg = _parseParameters2.onProgress,
                  onComp = _parseParameters2.onComplete;
                opts.bundle = this.name;
                cclegacy.assetManager.preloadAny({
                  scene: sceneName
                }, opts, onProg, function (err) {
                  if (err) {
                    errorID(1210, sceneName, err.message);
                  }
                  if (onComp) {
                    onComp(err);
                  }
                });
              };
              _proto.get = function get(path, type) {
                var info = this.getInfoWithPath(path, type);
                if (info) {
                  return assets.get(info.uuid) || null;
                }
                return null;
              };
              _proto.release = function release(path, type) {
                var asset = this.get(path, type);
                if (asset) {
                  releaseManager.tryRelease(asset, true);
                }
              };
              _proto.releaseUnusedAssets = function releaseUnusedAssets() {
                var _this = this;
                assets.forEach(function (asset) {
                  var info = _this.getAssetInfo(asset._uuid);
                  if (info && !info.redirect) {
                    releaseManager.tryRelease(asset);
                  }
                });
              };
              _proto.releaseAll = function releaseAll() {
                var _this2 = this;
                assets.forEach(function (asset) {
                  var info = _this2.getAssetInfo(asset._uuid);
                  if (info && !info.redirect) {
                    releaseManager.tryRelease(asset, true);
                  }
                });
              };
              _proto._destroy = function _destroy() {
                this._config.destroy();
              };
              _createClass(Bundle, [{
                key: "config",
                get: function get() {
                  return this._config;
                }
              }, {
                key: "name",
                get: function get() {
                  return this._config.name;
                }
              }, {
                key: "deps",
                get: function get() {
                  return this._config.deps;
                }
              }, {
                key: "base",
                get: function get() {
                  return this._config.base;
                }
              }]);
              return Bundle;
            }();
            var resources = exports("resources", new Bundle());
            cclegacy.resources = resources;

            var CacheManager = function CacheManager() {
              this.cacheDir = undefined;
              this.cacheEnabled = undefined;
              this.autoClear = undefined;
              this.cacheInterval = undefined;
              this.deleteInterval = undefined;
              this.cachedFiles = undefined;
            };

            function downloadDomImage(url, options, onComplete) {
              var img = new ccwindow.Image();
              if (ccwindow.location.protocol !== 'file:' || XIAOMI) {
                img.crossOrigin = 'anonymous';
              }
              function loadCallback() {
                img.removeEventListener('load', loadCallback);
                img.removeEventListener('error', errorCallback);
                if (onComplete) {
                  onComplete(null, img);
                }
              }
              function errorCallback() {
                img.removeEventListener('load', loadCallback);
                img.removeEventListener('error', errorCallback);
                if (onComplete) {
                  onComplete(new Error(getError(4930, url)));
                }
              }
              img.addEventListener('load', loadCallback);
              img.addEventListener('error', errorCallback);
              img.src = url;
              return img;
            }

            function downloadFile(url, options, onProgress, onComplete) {
              var xhr = new XMLHttpRequest();
              var errInfo = "download failed: " + url + ", status: ";
              xhr.open('GET', url, true);
              if (options.xhrResponseType !== undefined) {
                xhr.responseType = options.xhrResponseType;
              }
              if (options.xhrWithCredentials !== undefined) {
                xhr.withCredentials = options.xhrWithCredentials;
              }
              if (options.xhrMimeType !== undefined && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.xhrMimeType);
              }
              if (options.xhrTimeout !== undefined) {
                xhr.timeout = options.xhrTimeout;
              }
              if (options.xhrHeader) {
                for (var header in options.xhrHeader) {
                  xhr.setRequestHeader(header, options.xhrHeader[header]);
                }
              }
              xhr.onload = function () {
                if (xhr.status === 200 || xhr.status === 0) {
                  if (onComplete) {
                    onComplete(null, xhr.response);
                  }
                } else if (onComplete) {
                  onComplete(new Error("" + errInfo + xhr.status + "(no response)"));
                }
              };
              if (onProgress) {
                xhr.onprogress = function (e) {
                  if (e.lengthComputable) {
                    onProgress(e.loaded, e.total);
                  }
                };
              }
              xhr.onerror = function () {
                if (onComplete) {
                  onComplete(new Error("" + errInfo + xhr.status + "(error)"));
                }
              };
              xhr.ontimeout = function () {
                if (onComplete) {
                  onComplete(new Error("" + errInfo + xhr.status + "(time out)"));
                }
              };
              xhr.onabort = function () {
                if (onComplete) {
                  onComplete(new Error("" + errInfo + xhr.status + "(abort)"));
                }
              };
              xhr.send(null);
              return xhr;
            }

            var ccdocument$1 = ccwindow.document;
            var downloaded = {};
            function downloadScript(url, options, onComplete) {
              if (downloaded[url]) {
                if (onComplete) {
                  onComplete(null);
                }
                return null;
              }
              var script = ccdocument$1.createElement('script');
              if (ccwindow.location.protocol !== 'file:') {
                script.crossOrigin = 'anonymous';
              }
              script.async = options.scriptAsyncLoading || false;
              script.src = url;
              function loadHandler() {
                script.parentNode.removeChild(script);
                script.removeEventListener('load', loadHandler, false);
                script.removeEventListener('error', errorHandler, false);
                downloaded[url] = true;
                if (onComplete) {
                  onComplete(null);
                }
              }
              function errorHandler() {
                script.parentNode.removeChild(script);
                script.removeEventListener('load', loadHandler, false);
                script.removeEventListener('error', errorHandler, false);
                if (onComplete) {
                  onComplete(new Error(getError(4928, url)));
                }
              }
              script.addEventListener('load', loadHandler, false);
              script.addEventListener('error', errorHandler, false);
              ccdocument$1.body.appendChild(script);
              return script;
            }

            var REGEX = /^(?:\w+:\/\/|\.+\/).+/;
            var downloadImage = function downloadImage(url, options, onComplete) {
              var func = sys.hasFeature(sys.Feature.IMAGE_BITMAP) && cclegacy.assetManager.allowImageBitmap ? downloadBlob : downloadDomImage;
              func(url, options, onComplete);
            };
            var downloadBlob = function downloadBlob(url, options, onComplete) {
              options.xhrResponseType = 'blob';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };
            var downloadJson = function downloadJson(url, options, onComplete) {
              options.xhrResponseType = 'json';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };
            var downloadArrayBuffer = function downloadArrayBuffer(url, options, onComplete) {
              options.xhrResponseType = 'arraybuffer';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };
            var downloadCCONB = function downloadCCONB(url, options, onComplete) {
              var handleArrayBuffer = function handleArrayBuffer(arrayBuffer, onComplete) {
                try {
                  var ccon = decodeCCONBinary(new Uint8Array(arrayBuffer));
                  onComplete(null, ccon);
                } catch (err) {
                  onComplete(err);
                }
              };
              downloader._downloadArrayBuffer(url.replace('.cconb', '.bin'), options, function (err, arrayBuffer) {
                if (err) {
                  downloader._downloadArrayBuffer(url, options, function (err, arrayBuffer) {
                    if (err) {
                      onComplete(err);
                      return;
                    }
                    handleArrayBuffer(arrayBuffer, onComplete);
                  });
                  return;
                }
                handleArrayBuffer(arrayBuffer, onComplete);
              });
            };
            var downloadText = function downloadText(url, options, onComplete) {
              options.xhrResponseType = 'text';
              downloadFile(url, options, options.onFileProgress, onComplete);
            };
            var downloadBundle = function downloadBundle(nameOrUrl, options, onComplete) {
              var bundleName = basename(nameOrUrl);
              var url = nameOrUrl;
              if (!REGEX.test(url)) {
                if (downloader.remoteBundles.indexOf(bundleName) !== -1) {
                  url = downloader.remoteServerAddress + "remote/" + bundleName;
                } else {
                  url = "assets/" + bundleName;
                }
              }
              var version = options.version || downloader.bundleVers[bundleName];
              var count = 0;
              var config = url + "/config." + (version ? version + "." : '') + "json";
              var out = null;
              var error = null;
              downloadJson(config, options, function (err, response) {
                error = err || error;
                out = response;
                if (out) {
                  out.base = url + "/";
                }
                if (++count === 2) {
                  onComplete(error, out);
                }
              });
              var jspath = url + "/index." + (version ? version + "." : '') + "js";
              downloadScript(jspath, options, function (err) {
                error = err || error;
                if (++count === 2) {
                  onComplete(error, out);
                }
              });
            };
            var Downloader = function () {
              var _proto = Downloader.prototype;
              _proto.init = function init(remoteServerAddress, bundleVers, remoteBundles) {
                if (remoteServerAddress === undefined) {
                  remoteServerAddress = '';
                }
                if (bundleVers === undefined) {
                  bundleVers = {};
                }
                if (remoteBundles === undefined) {
                  remoteBundles = [];
                }
                this._downloading.clear();
                this._queue.length = 0;
                this._remoteServerAddress = remoteServerAddress;
                this.bundleVers = bundleVers;
                this.remoteBundles = remoteBundles;
              };
              _proto.register = function register(type, handler) {
                if (typeof type === 'object') {
                  mixin(this._downloaders, type);
                } else {
                  this._downloaders[type] = handler;
                }
              };
              _proto.download = function download(id, url, type, options, onComplete) {
                var _this = this;
                var file = files.get(id);
                if (file) {
                  onComplete(null, file);
                  return;
                }
                var downloadCallbacks = this._downloading.get(id);
                if (downloadCallbacks) {
                  downloadCallbacks.push(onComplete);
                  var request = this._queue.find(function (x) {
                    return x.id === id;
                  });
                  if (!request) {
                    return;
                  }
                  var priority = options.priority || 0;
                  if (request.priority < priority) {
                    request.priority = priority;
                    this._queueDirty = true;
                  }
                  return;
                }
                var maxRetryCount = typeof options.maxRetryCount !== 'undefined' ? options.maxRetryCount : this.maxRetryCount;
                var maxConcurrency = typeof options.maxConcurrency !== 'undefined' ? options.maxConcurrency : this.maxConcurrency;
                var maxRequestsPerFrame = typeof options.maxRequestsPerFrame !== 'undefined' ? options.maxRequestsPerFrame : this.maxRequestsPerFrame;
                var handler = this._downloaders[type] || this._downloaders["default"];
                var process = function process(index, callback) {
                  if (index === 0) {
                    _this._downloading.add(id, [onComplete]);
                  }
                  if (!_this.limited) {
                    handler(urlAppendTimestamp(url, _this.appendTimeStamp), options, callback);
                    return;
                  }
                  _this._updateTime();
                  var done = function done(err, data) {
                    _this._totalNum--;
                    _this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
                    callback(err, data);
                  };
                  if (_this._totalNum < maxConcurrency && _this._totalNumThisPeriod < maxRequestsPerFrame) {
                    handler(urlAppendTimestamp(url, _this.appendTimeStamp), options, done);
                    _this._totalNum++;
                    _this._totalNumThisPeriod++;
                  } else {
                    _this._queue.push({
                      id: id,
                      priority: options.priority || 0,
                      url: url,
                      options: options,
                      done: done,
                      handler: handler
                    });
                    _this._queueDirty = true;
                    if (_this._totalNum < maxConcurrency) {
                      _this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
                    }
                  }
                };
                var finale = function finale(err, result) {
                  if (!err) {
                    files.add(id, result);
                  }
                  var callbacks = _this._downloading.remove(id);
                  for (var i = 0, l = callbacks.length; i < l; i++) {
                    callbacks[i](err, result);
                  }
                };
                retry(process, maxRetryCount, this.retryInterval, finale);
              };
              _proto.loadSubpackage = function loadSubpackage(name, completeCallback) {
                cclegacy.assetManager.loadBundle(name, null, completeCallback);
              };
              function Downloader() {
                this.maxConcurrency = 15;
                this.maxRequestsPerFrame = 15;
                this.maxRetryCount = 3 ;
                this.appendTimeStamp = false;
                this.limited = true;
                this.retryInterval = 2000;
                this.bundleVers = {};
                this.remoteBundles = [];
                this.downloadDomImage = downloadDomImage;
                this.downloadDomAudio = null;
                this.downloadFile = downloadFile;
                this.downloadScript = downloadScript;
                this._downloadArrayBuffer = downloadArrayBuffer;
                this._downloadJson = downloadJson;
                this._downloaders = {
                  '.png': downloadImage,
                  '.jpg': downloadImage,
                  '.bmp': downloadImage,
                  '.jpeg': downloadImage,
                  '.gif': downloadImage,
                  '.ico': downloadImage,
                  '.tiff': downloadImage,
                  '.webp': downloadImage,
                  '.image': downloadImage,
                  '.pvr': downloadArrayBuffer,
                  '.pkm': downloadArrayBuffer,
                  '.astc': downloadArrayBuffer,
                  '.txt': downloadText,
                  '.xml': downloadText,
                  '.vsh': downloadText,
                  '.fsh': downloadText,
                  '.atlas': downloadText,
                  '.tmx': downloadText,
                  '.tsx': downloadText,
                  '.json': downloadJson,
                  '.ExportJson': downloadJson,
                  '.plist': downloadText,
                  '.cconb': downloadCCONB,
                  '.fnt': downloadText,
                  '.binary': downloadArrayBuffer,
                  '.bin': downloadArrayBuffer,
                  '.dbbin': downloadArrayBuffer,
                  '.skel': downloadArrayBuffer,
                  '.js': downloadScript,
                  bundle: downloadBundle,
                  "default": downloadText
                };
                this._downloading = new Cache();
                this._queue = [];
                this._queueDirty = false;
                this._totalNum = 0;
                this._totalNumThisPeriod = 0;
                this._lastDate = -1;
                this._checkNextPeriod = false;
                this._remoteServerAddress = '';
                this._maxInterval = 1 / 30;
              }
              _proto._updateTime = function _updateTime() {
                var now = performance.now();
                var deltaTime = cclegacy.game.deltaTime;
                var interval = deltaTime > this._maxInterval ? this._maxInterval : deltaTime;
                if (now - this._lastDate > interval * 1000) {
                  this._totalNumThisPeriod = 0;
                  this._lastDate = now;
                }
              };
              _proto._handleQueue = function _handleQueue(maxConcurrency, maxRequestsPerFrame) {
                this._checkNextPeriod = false;
                this._updateTime();
                while (this._queue.length > 0 && this._totalNum < maxConcurrency && this._totalNumThisPeriod < maxRequestsPerFrame) {
                  if (this._queueDirty) {
                    this._queue.sort(function (a, b) {
                      return a.priority - b.priority;
                    });
                    this._queueDirty = false;
                  }
                  var request = this._queue.pop();
                  if (!request) {
                    break;
                  }
                  this._totalNum++;
                  this._totalNumThisPeriod++;
                  request.handler(urlAppendTimestamp(request.url, this.appendTimeStamp), request.options, request.done);
                }
                this._handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame);
              };
              _proto._handleQueueInNextFrame = function _handleQueueInNextFrame(maxConcurrency, maxRequestsPerFrame) {
                if (!this._checkNextPeriod && this._queue.length > 0) {
                  callInNextTick(this._handleQueue.bind(this), maxConcurrency, maxRequestsPerFrame);
                  this._checkNextPeriod = true;
                }
              };
              _createClass(Downloader, [{
                key: "remoteServerAddress",
                get: function get() {
                  return this._remoteServerAddress;
                }
              }, {
                key: "handlers",
                get: function get() {
                  return this._downloaders;
                }
              }], [{
                key: "instance",
                get: function get() {
                  if (!Downloader._instance) {
                    Downloader._instance = new Downloader();
                  }
                  return Downloader._instance;
                }
              }]);
              return Downloader;
            }();
            Downloader._instance = undefined;
            var downloader = Downloader.instance;
            var downloader$1 = Downloader.instance;

            var _dec$z, _class$z, _class2$v, _initializer$u;
            var JsonAsset = exports("JsonAsset", (_dec$z = ccclass$6('cc.JsonAsset'), _dec$z(_class$z = (_class2$v = function (_Asset) {
              _inheritsLoose(JsonAsset, _Asset);
              function JsonAsset(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this.json = _initializer$u && _initializer$u();
                return _this;
              }
              return JsonAsset;
            }(Asset), (_initializer$u = applyDecoratedInitializer(_class2$v.prototype, "json", [serializable$5], function () {
              return null;
            })), _class2$v)) || _class$z));
            cclegacy.JsonAsset = JsonAsset;

            var _dec$y, _class$y, _class2$u, _initializer$t;
            var TextAsset = exports("TextAsset", (_dec$y = ccclass$6('cc.TextAsset'), _dec$y(_class$y = (_class2$u = function (_Asset) {
              _inheritsLoose(TextAsset, _Asset);
              var _proto = TextAsset.prototype;
              _proto.toString = function toString() {
                return this.text;
              };
              function TextAsset(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this.text = _initializer$t && _initializer$t();
                return _this;
              }
              return TextAsset;
            }(Asset), (_initializer$t = applyDecoratedInitializer(_class2$u.prototype, "text", [serializable$5], function () {
              return '';
            })), _class2$u)) || _class$y));
            cclegacy.TextAsset = TextAsset;

            function createImageAsset(id, data, options, onComplete) {
              var out = null;
              var err = null;
              try {
                out = new ImageAsset();
                out._nativeUrl = id;
                out._nativeAsset = data;
              } catch (e) {
                err = e;
              }
              onComplete(err, out);
            }
            function createJsonAsset(id, data, options, onComplete) {
              var out = new JsonAsset();
              out.json = data;
              onComplete(null, out);
            }
            function createTextAsset(id, data, options, onComplete) {
              var out = new TextAsset();
              out.text = data;
              onComplete(null, out);
            }
            function createBufferAsset(id, data, options, onComplete) {
              var out = new BufferAsset();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }
            function createAsset(id, data, options, onComplete) {
              var out = new Asset();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }
            function createBundle(id, data, options, onComplete) {
              var bundle = bundles.get(data.name);
              if (!bundle) {
                bundle = data.name === "resources" ? resources : new Bundle();
                data.base = data.base || id + "/";
                bundle.init(data);
              }
              {
                module.import("virtual:///prerequisite-imports/" + bundle.name).then(function () {
                  onComplete(null, bundle);
                })["catch"](onComplete);
              }
            }
            var Factory = function () {
              function Factory() {
                this._creating = new Cache();
                this._producers = {
                  '.png': createImageAsset,
                  '.jpg': createImageAsset,
                  '.bmp': createImageAsset,
                  '.jpeg': createImageAsset,
                  '.gif': createImageAsset,
                  '.ico': createImageAsset,
                  '.tiff': createImageAsset,
                  '.webp': createImageAsset,
                  '.image': createImageAsset,
                  '.pvr': createImageAsset,
                  '.pkm': createImageAsset,
                  '.astc': createImageAsset,
                  '.txt': createTextAsset,
                  '.xml': createTextAsset,
                  '.vsh': createTextAsset,
                  '.fsh': createTextAsset,
                  '.atlas': createTextAsset,
                  '.tmx': createTextAsset,
                  '.tsx': createTextAsset,
                  '.fnt': createTextAsset,
                  '.json': createJsonAsset,
                  '.ExportJson': createJsonAsset,
                  '.binary': createBufferAsset,
                  '.bin': createBufferAsset,
                  '.dbbin': createBufferAsset,
                  '.skel': createBufferAsset,
                  bundle: createBundle,
                  "default": createAsset
                };
              }
              var _proto = Factory.prototype;
              _proto.register = function register(type, handler) {
                if (typeof type === 'object') {
                  mixin(this._producers, type);
                } else {
                  this._producers[type] = handler;
                }
              };
              _proto.create = function create(id, data, type, options, onComplete) {
                var _this = this;
                var handler = this._producers[type] || this._producers["default"];
                var asset = assets.get(id);
                if (!options.reloadAsset && asset) {
                  onComplete(null, asset);
                  return;
                }
                var creating = this._creating.get(id);
                if (creating) {
                  creating.push(onComplete);
                  return;
                }
                this._creating.add(id, [onComplete]);
                handler(id, data, options, function (err, result) {
                  if (!err && result instanceof Asset) {
                    result._uuid = id;
                    cache(id, result, options.cacheAsset);
                  }
                  var callbacks = _this._creating.remove(id);
                  for (var i = 0, l = callbacks.length; i < l; i++) {
                    callbacks[i](err, result);
                  }
                });
              };
              return Factory;
            }();
            var factory = new Factory();

            var PACK_BIN_TYPE = 'BINP';
            var VERSION = 2;
            var UNIT_SIZE = 4;
            var LITTLE_ENDIAN = true;
            function binPackageUnpack(arrayBuffer) {
              var dataView = new DataView(arrayBuffer, 0, arrayBuffer.byteLength);
              var packBinType = String.fromCharCode.apply(String, new Uint8Array(arrayBuffer.slice(0, UNIT_SIZE)));
              if (packBinType !== PACK_BIN_TYPE) {
                throw new Error('Invalid bin package format');
              }
              var version = dataView.getUint32(UNIT_SIZE, LITTLE_ENDIAN);
              if (version !== VERSION) {
                return compatibleOlderVersion(arrayBuffer, dataView, version);
              }
              var filesCount = dataView.getUint32(UNIT_SIZE * 2, LITTLE_ENDIAN);
              var filesPosition = [];
              var headOffset = UNIT_SIZE * (3 + filesCount * 2);
              for (var i = 0; i < filesCount; i++) {
                var offset = dataView.getUint32(UNIT_SIZE * (3 + i * 2), LITTLE_ENDIAN) + headOffset;
                var size = dataView.getUint32(UNIT_SIZE * (3 + i * 2 + 1), LITTLE_ENDIAN);
                filesPosition.push({
                  offset: offset,
                  size: size
                });
              }
              return filesPosition.map(function (_ref) {
                var offset = _ref.offset,
                  size = _ref.size;
                return new Uint8Array(arrayBuffer, offset, size);
              });
            }
            function compatibleOlderVersion(arrayBuffer, dataView, version) {
              var map = {
                1: unpack_v1
              };
              return map[version](arrayBuffer, dataView);
            }
            function unpack_v1(arrayBuffer, dataView) {
              var filesCount = dataView.getUint32(UNIT_SIZE * 2, LITTLE_ENDIAN);
              var filesPosition = [];
              var offset = UNIT_SIZE * (3 + filesCount);
              for (var i = 0; i < filesCount; i++) {
                var size = dataView.getUint32(UNIT_SIZE * (3 + i), LITTLE_ENDIAN);
                filesPosition.push({
                  offset: offset,
                  size: size
                });
                offset += size;
              }
              return filesPosition.map(function (_ref2) {
                var offset = _ref2.offset,
                  size = _ref2.size;
                return new Uint8Array(arrayBuffer, offset, size);
              });
            }

            var PackManager = function () {
              function PackManager() {
                this._loading = new Cache();
                this._unpackers = {
                  '.json': this.unpackJson,
                  '.bin': this.unpackBin
                };
              }
              var _proto = PackManager.prototype;
              _proto.unpackJson = function unpackJson(pack, json, options, onComplete) {
                var out = createMap(true);
                var err = null;
                if (Array.isArray(json)) {
                  json = unpackJSONs(json);
                  if (json.length !== pack.length) {
                    errorID(4915);
                  }
                  for (var i = 0; i < pack.length; i++) {
                    out[pack[i] + "@import"] = json[i];
                  }
                } else {
                  var textureType = getClassId(Texture2D);
                  var imageAssetType = getClassId(ImageAsset);
                  if (json.type === textureType && json.data) {
                    var datas = json.data;
                    if (datas.length !== pack.length) {
                      errorID(4915);
                    }
                    for (var _i = 0; _i < pack.length; _i++) {
                      out[pack[_i] + "@import"] = packCustomObjData(textureType, {
                        base: datas[_i][0],
                        mipmaps: datas[_i][1]
                      });
                    }
                  } else if (json.type === imageAssetType && json.data) {
                    var _datas = json.data;
                    if (_datas.length !== pack.length) {
                      errorID(4915);
                    }
                    for (var _i2 = 0; _i2 < pack.length; _i2++) {
                      out[pack[_i2] + "@import"] = _datas[_i2];
                    }
                  } else {
                    err = new Error('unmatched type pack!');
                    onComplete(err, null);
                    return;
                  }
                }
                onComplete(err, out);
              };
              _proto.unpackBin = function unpackBin(pack, buffer, options, onComplete) {
                var out = createMap(true);
                var err = null;
                try {
                  var uint8Arrays = binPackageUnpack(buffer);
                  pack.forEach(function (uuid, index) {
                    return out[uuid + "@import"] = decodeCCONBinary(uint8Arrays[index]);
                  });
                } catch (e) {
                  err = e;
                }
                onComplete(err, out);
              };
              _proto.init = function init() {
                this._loading.clear();
              };
              _proto.register = function register(type, handler) {
                if (typeof type === 'object') {
                  mixin(this._unpackers, type);
                } else {
                  this._unpackers[type] = handler;
                }
              };
              _proto.unpack = function unpack(pack, data, type, options, onComplete) {
                if (!data) {
                  onComplete(new Error('package data is wrong!'));
                  return;
                }
                var unpacker = this._unpackers[type];
                unpacker(pack, data, options, onComplete);
              };
              _proto.load = function load(item, options, onComplete) {
                var _this = this;
                if (item.isNative || !item.info || !item.info.packs) {
                  downloader$1.download(item.id, item.url, item.ext, item.options, onComplete);
                  return;
                }
                if (files.has(item.id)) {
                  onComplete(null, files.get(item.id));
                  return;
                }
                var packs = item.info.packs;
                var loadingPack = packs.find(function (val) {
                  return _this._loading.has(val.uuid);
                });
                if (loadingPack) {
                  var req = this._loading.get(loadingPack.uuid);
                  assertIsTrue(req);
                  req.push({
                    onComplete: onComplete,
                    id: item.id
                  });
                  return;
                }
                var pack = packs[0];
                this._loading.add(pack.uuid, [{
                  onComplete: onComplete,
                  id: item.id
                }]);
                assertIsTrue(item.config);
                var url = transform(pack.uuid, {
                  ext: pack.ext,
                  bundle: item.config.name
                });
                var done = function done(err, data) {
                  files.remove(pack.uuid);
                  if (err) {
                    error(err.message, err.stack);
                  }
                  _this.unpack(pack.packedUuids, data, pack.ext, item.options, function (err2, result) {
                    if (!err2) {
                      for (var id in result) {
                        files.add(id, result[id]);
                      }
                    }
                    var callbacks = _this._loading.remove(pack.uuid);
                    assertIsTrue(callbacks);
                    for (var i = 0, l = callbacks.length; i < l; i++) {
                      var cb = callbacks[i];
                      if (err || err2) {
                        cb.onComplete(err || err2);
                        continue;
                      }
                      var unpackedData = result[cb.id];
                      if (!unpackedData) {
                        cb.onComplete(new Error('can not retrieve data from package'));
                      } else {
                        cb.onComplete(null, unpackedData);
                      }
                    }
                  });
                };
                if (pack.ext === '.bin') {
                  downloader$1._downloadArrayBuffer(url, item.options, done);
                } else if (pack.ext === '.json') {
                  downloader$1.download(pack.uuid, url, pack.ext, item.options, done);
                } else {
                  errorID(4916, pack.ext);
                }
              };
              return PackManager;
            }();
            var packManager = new PackManager();

            function fetch(task, done) {
              var firstTask = false;
              if (!task.progress) {
                task.progress = {
                  finish: 0,
                  total: task.input.length,
                  canInvoke: true
                };
                firstTask = true;
              }
              var options = task.options,
                progress = task.progress;
              var depends = [];
              var total = progress.total;
              var exclude = options.__exclude__ = options.__exclude__ || Object.create(null);
              task.output = [];
              forEach(task.input, function (item, cb) {
                if (!item.isNative && assets.has(item.uuid)) {
                  var asset = assets.get(item.uuid);
                  item.content = asset.addRef();
                  task.output.push(item);
                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }
                  cb();
                  return;
                }
                packManager.load(item, task.options, function (err, data) {
                  if (err) {
                    if (!task.isFinished) {
                      if (!cclegacy.assetManager.force || firstTask) {
                        error(err.message, err.stack);
                        progress.canInvoke = false;
                        done(err);
                      } else {
                        task.output.push(item);
                        if (progress.canInvoke) {
                          task.dispatch('progress', ++progress.finish, progress.total, item);
                        }
                      }
                    }
                  } else if (!task.isFinished) {
                    item.file = data;
                    task.output.push(item);
                    if (!item.isNative) {
                      exclude[item.uuid] = true;
                      getDepends(item.uuid, data, exclude, depends, item.config);
                      progress.total = total + depends.length;
                    }
                    if (progress.canInvoke) {
                      task.dispatch('progress', ++progress.finish, progress.total, item);
                    }
                  }
                  cb();
                });
              }, function () {
                if (task.isFinished) {
                  clear(task);
                  task.dispatch('error');
                  return;
                }
                if (depends.length > 0) {
                  var subTask = Task.create({
                    input: depends,
                    progress: progress,
                    options: options,
                    onProgress: task.onProgress,
                    onError: Task.prototype.recycle,
                    onComplete: function onComplete(err) {
                      if (!err) {
                        var _task$output;
                        (_task$output = task.output).push.apply(_task$output, subTask.output);
                        subTask.recycle();
                      }
                      if (firstTask) {
                        decreaseRef(task);
                      }
                      done(err);
                    }
                  });
                  fetchPipeline.async(subTask);
                  return;
                }
                if (firstTask) {
                  decreaseRef(task);
                }
                done();
              });
            }
            function decreaseRef(task) {
              var output = task.output;
              for (var i = 0, l = output.length; i < l; i++) {
                if (output[i].content) {
                  output[i].content.decRef(false);
                }
              }
            }

            var SAXParser = function () {
              function SAXParser() {
                this._parser = null;
                if (globalThis.DOMParser) {
                  this._parser = new DOMParser();
                }
              }
              var _proto = SAXParser.prototype;
              _proto.parse = function parse(xmlTxt) {
                return this._parseXML(xmlTxt);
              };
              _proto._parseXML = function _parseXML(textxml) {
                if (this._parser) {
                  return this._parser.parseFromString(textxml, 'text/xml');
                }
                throw new Error('Dom parser is not supported in this platform!');
              };
              return SAXParser;
            }();
            var PlistParser = function (_SAXParser) {
              _inheritsLoose(PlistParser, _SAXParser);
              function PlistParser() {
                return _SAXParser.apply(this, arguments) || this;
              }
              var _proto2 = PlistParser.prototype;
              _proto2.parse = function parse(xmlTxt) {
                var xmlDoc = this._parseXML(xmlTxt);
                var plist = xmlDoc.documentElement;
                if (plist.tagName !== 'plist') {
                  warnID(5100);
                  return {};
                }
                var node = null;
                for (var i = 0, len = plist.childNodes.length; i < len; i++) {
                  node = plist.childNodes[i];
                  if (node.nodeType === 1) {
                    break;
                  }
                }
                return this._parseNode(node);
              };
              _proto2._parseNode = function _parseNode(node) {
                var data = null;
                var tagName = node.tagName;
                if (tagName === 'dict') {
                  data = this._parseDict(node);
                } else if (tagName === 'array') {
                  data = this._parseArray(node);
                } else if (tagName === 'string') {
                  if (node.childNodes.length === 1) {
                    data = node.firstChild.nodeValue;
                  } else {
                    data = '';
                    for (var i = 0; i < node.childNodes.length; i++) {
                      data += node.childNodes[i].nodeValue;
                    }
                  }
                } else if (tagName === 'false') {
                  data = false;
                } else if (tagName === 'true') {
                  data = true;
                } else if (tagName === 'real') {
                  data = parseFloat(node.firstChild.nodeValue);
                } else if (tagName === 'integer') {
                  data = parseInt(node.firstChild.nodeValue, 10);
                }
                return data;
              };
              _proto2._parseArray = function _parseArray(node) {
                var data = [];
                for (var i = 0, len = node.childNodes.length; i < len; i++) {
                  var child = node.childNodes[i];
                  if (child.nodeType !== 1) {
                    continue;
                  }
                  data.push(this._parseNode(child));
                }
                return data;
              };
              _proto2._parseDict = function _parseDict(node) {
                var data = {};
                var key = '';
                for (var i = 0, len = node.childNodes.length; i < len; i++) {
                  var child = node.childNodes[i];
                  if (child.nodeType !== 1) {
                    continue;
                  }
                  if (child.tagName === 'key') {
                    key = child.firstChild.nodeValue;
                  } else {
                    data[key] = this._parseNode(child);
                  }
                }
                return data;
              };
              return PlistParser;
            }(SAXParser);
            var plistParser = new PlistParser();

            var Parser$1 = function () {
              function Parser() {
                this._parsing = new Cache();
                this._parsers = {
                  '.png': this.parseImage,
                  '.jpg': this.parseImage,
                  '.bmp': this.parseImage,
                  '.jpeg': this.parseImage,
                  '.gif': this.parseImage,
                  '.ico': this.parseImage,
                  '.tiff': this.parseImage,
                  '.webp': this.parseImage,
                  '.image': this.parseImage,
                  '.pvr': this.parsePVRTex,
                  '.pkm': this.parsePKMTex,
                  '.astc': this.parseASTCTex,
                  '.plist': this.parsePlist,
                  "import": this.parseImport,
                  '.ccon': this.parseImport,
                  '.cconb': this.parseImport
                };
              }
              var _proto = Parser.prototype;
              _proto.parseImage = function parseImage(file, options, onComplete) {
                if (file instanceof HTMLImageElement) {
                  onComplete(null, file);
                  return;
                }
                createImageBitmap(file, {
                  premultiplyAlpha: 'none'
                }).then(function (result) {
                  onComplete(null, result);
                }, function (err) {
                  onComplete(err, null);
                });
              };
              _proto.parsePVRTex = function parsePVRTex(file, options, onComplete) {
                var err = null;
                var out = null;
                try {
                  out = ImageAsset.parseCompressedTextures(file, 0);
                } catch (e) {
                  err = e;
                  warn(err);
                }
                onComplete(err, out);
              };
              _proto.parsePKMTex = function parsePKMTex(file, options, onComplete) {
                var err = null;
                var out = null;
                try {
                  out = ImageAsset.parseCompressedTextures(file, 1);
                } catch (e) {
                  err = e;
                  warn(err);
                }
                onComplete(err, out);
              };
              _proto.parseASTCTex = function parseASTCTex(file, options, onComplete) {
                var err = null;
                var out = null;
                try {
                  out = ImageAsset.parseCompressedTextures(file, 2);
                } catch (e) {
                  err = e;
                  warn(err);
                }
                onComplete(err, out);
              };
              _proto.parsePlist = function parsePlist(file, options, onComplete) {
                var err = null;
                var result = plistParser.parse(file);
                if (!result) {
                  err = new Error('parse failed');
                }
                onComplete(err, result);
              };
              _proto.parseImport = function parseImport(file, options, onComplete) {
                if (!file) {
                  onComplete(new Error(getError(3702, options.__uuid__)));
                  return;
                }
                var result = null;
                var err = null;
                try {
                  result = deserializeAsset(file, options);
                } catch (e) {
                  err = e;
                }
                onComplete(err, result);
              };
              _proto.init = function init() {
                this._parsing.clear();
              };
              _proto.register = function register(type, handler) {
                if (typeof type === 'object') {
                  mixin(this._parsers, type);
                } else {
                  this._parsers[type] = handler;
                }
              };
              _proto.parse = function parse(id, file, type, options, onComplete) {
                var _this = this;
                var parsedAsset = parsed.get(id);
                if (parsedAsset) {
                  onComplete(null, parsedAsset);
                  return;
                }
                var parsing = this._parsing.get(id);
                if (parsing) {
                  parsing.push(onComplete);
                  return;
                }
                var parseHandler = this._parsers[type];
                if (!parseHandler) {
                  onComplete(null, file);
                  return;
                }
                this._parsing.add(id, [onComplete]);
                parseHandler(file, options, function (err, data) {
                  if (err) {
                    files.remove(id);
                  } else if (!isScene(data)) {
                    parsed.add(id, data);
                  }
                  var callbacks = _this._parsing.remove(id);
                  for (var i = 0, l = callbacks.length; i < l; i++) {
                    callbacks[i](err, data);
                  }
                });
              };
              _createClass(Parser, null, [{
                key: "instance",
                get: function get() {
                  if (!this._instance) {
                    this._instance = new Parser();
                  }
                  return this._instance;
                }
              }]);
              return Parser;
            }();
            Parser$1._instance = undefined;
            var parser = Parser$1.instance;

            function load(task, done) {
              var firstTask = false;
              if (!task.progress) {
                task.progress = {
                  finish: 0,
                  total: task.input.length,
                  canInvoke: true
                };
                firstTask = true;
              }
              var options = task.options,
                progress = task.progress;
              options.__exclude__ = options.__exclude__ || Object.create(null);
              task.output = [];
              forEach(task.input, function (item, cb) {
                var subTask = Task.create({
                  input: item,
                  onProgress: task.onProgress,
                  options: options,
                  progress: progress,
                  onComplete: function onComplete(err, result) {
                    if (err && !task.isFinished) {
                      if (!cclegacy.assetManager.force || firstTask) {
                        {
                          error(err.message, err.stack);
                        }
                        progress.canInvoke = false;
                        done(err);
                      } else if (progress.canInvoke) {
                        task.dispatch('progress', ++progress.finish, progress.total, item);
                      }
                    }
                    task.output.push(result);
                    subTask.recycle();
                    cb(null);
                  }
                });
                loadOneAssetPipeline.async(subTask);
              }, function () {
                options.__exclude__ = null;
                if (task.isFinished) {
                  clear(task);
                  task.dispatch('error');
                  return;
                }
                gatherAsset(task);
                clear(task);
                done();
              });
            }
            var loadOneAssetPipeline = new Pipeline('loadOneAsset', [function fetch(task, done) {
              var item = task.output = task.input;
              var options = item.options,
                isNative = item.isNative,
                uuid = item.uuid,
                file = item.file;
              var reloadAsset = options.reloadAsset;
              if (file || !reloadAsset && !isNative && assets.has(uuid)) {
                done();
                return;
              }
              packManager.load(item, task.options, function (err, data) {
                item.file = data;
                done(err);
              });
            }, function parse(task, done) {
              var item = task.output = task.input;
              var progress = task.progress;
              var exclude = task.options.__exclude__;
              var id = item.id,
                file = item.file,
                options = item.options;
              if (item.isNative) {
                parser.parse(id, file, item.ext, options, function (err, asset) {
                  if (err) {
                    done(err);
                    return;
                  }
                  item.content = asset;
                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }
                  files.remove(id);
                  parsed.remove(id);
                  done();
                });
              } else {
                var uuid = item.uuid;
                if (uuid in exclude) {
                  var _exclude$uuid = exclude[uuid],
                    finish = _exclude$uuid.finish,
                    content = _exclude$uuid.content,
                    _err = _exclude$uuid.err,
                    callbacks = _exclude$uuid.callbacks;
                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }
                  if (finish || checkCircleReference(uuid, uuid, exclude)) {
                    if (content) {
                      content.addRef();
                    }
                    item.content = content;
                    done(_err);
                  } else {
                    callbacks.push({
                      done: done,
                      item: item
                    });
                  }
                } else if (!options.reloadAsset && assets.has(uuid)) {
                  var asset = assets.get(uuid);
                  item.content = asset.addRef();
                  if (progress.canInvoke) {
                    task.dispatch('progress', ++progress.finish, progress.total, item);
                  }
                  done();
                } else {
                  options.__uuid__ = uuid;
                  parser.parse(id, file, 'import', options, function (err, asset) {
                    if (err) {
                      done(err);
                      return;
                    }
                    loadDepends(task, asset, done);
                  });
                }
              }
            }]);
            function loadDepends(task, asset, done) {
              var item = task.input,
                progress = task.progress;
              var _ref = item,
                uuid = _ref.uuid,
                id = _ref.id,
                options = _ref.options,
                config = _ref.config;
              var cacheAsset = options.cacheAsset;
              var depends = [];
              if (asset.addRef) {
                asset.addRef();
              }
              getDepends(uuid, asset, Object.create(null), depends, config);
              if (progress.canInvoke) {
                task.dispatch('progress', ++progress.finish, progress.total += depends.length, item);
              }
              var repeatItem = task.options.__exclude__[uuid] = {
                content: asset,
                finish: false,
                callbacks: [{
                  done: done,
                  item: item
                }]
              };
              var subTask = Task.create({
                input: depends,
                options: task.options,
                onProgress: task.onProgress,
                onError: Task.prototype.recycle,
                progress: progress,
                onComplete: function onComplete(err) {
                  if (asset.decRef) {
                    asset.decRef(false);
                  }
                  repeatItem.finish = true;
                  repeatItem.err = err;
                  if (!err) {
                    var output = Array.isArray(subTask.output) ? subTask.output : [subTask.output];
                    var map = Object.create(null);
                    for (var _iterator = _createForOfIteratorHelperLoose(output), _step; !(_step = _iterator()).done;) {
                      var dependAsset = _step.value;
                      if (!dependAsset) {
                        continue;
                      }
                      map[dependAsset instanceof Asset ? dependAsset._uuid + "@import" : uuid + "@native"] = dependAsset;
                    }
                    setProperties(uuid, asset, map);
                    try {
                      if (typeof asset.onLoaded === 'function' && !onLoadedInvokedMap.has(asset) && !nativeDependMap.has(asset)) {
                        asset.onLoaded();
                        onLoadedInvokedMap.add(asset);
                      }
                    } catch (e) {
                      errorID(16352, uuid, e.message, e.stack);
                    }
                    files.remove(id);
                    parsed.remove(id);
                    cache(uuid, asset, cacheAsset);
                    subTask.recycle();
                  }
                  var callbacks = repeatItem.callbacks;
                  for (var i = 0, l = callbacks.length; i < l; i++) {
                    var cb = callbacks[i];
                    if (asset.addRef) {
                      asset.addRef();
                    }
                    cb.item.content = asset;
                    cb.done(err);
                  }
                  callbacks.length = 0;
                }
              });
              pipeline.async(subTask);
            }

            function preprocess(task, done) {
              var options = task.options;
              var subOptions = Object.create(null);
              var leftOptions = Object.create(null);
              for (var op in options) {
                switch (op) {
                  case "path":
                  case "uuid":
                  case "dir":
                  case "scene":
                  case "url":
                    break;
                  case '__requestType__':
                  case '__isNative__':
                  case 'ext':
                  case 'type':
                  case '__nativeName__':
                  case 'audioLoadMode':
                  case 'bundle':
                    subOptions[op] = options[op];
                    break;
                  case '__exclude__':
                  case '__outputAsArray__':
                    leftOptions[op] = options[op];
                    break;
                  default:
                    subOptions[op] = options[op];
                    leftOptions[op] = options[op];
                    break;
                }
              }
              task.options = leftOptions;
              var subTask = Task.create({
                input: task.input,
                options: subOptions
              });
              var err = null;
              try {
                task.output = task.source = transformPipeline.sync(subTask);
              } catch (e) {
                err = e;
                for (var i = 0, l = subTask.output.length; i < l; i++) {
                  subTask.output[i].recycle();
                }
              }
              subTask.recycle();
              done(err);
            }

            var RequestItem = function () {
              function RequestItem() {
                this.uuid = '';
                this.overrideUuid = '';
                this.url = '';
                this.ext = '.json';
                this.content = null;
                this.file = null;
                this.info = null;
                this.config = null;
                this.isNative = false;
                this.options = Object.create(null);
                this._id = '';
              }
              RequestItem.create = function create() {
                var out;
                if (RequestItem._deadPool.length !== 0) {
                  out = RequestItem._deadPool.pop();
                } else {
                  out = new RequestItem();
                }
                return out;
              };
              var _proto = RequestItem.prototype;
              _proto.recycle = function recycle() {
                if (RequestItem._deadPool.length === RequestItem.MAX_DEAD_NUM) {
                  return;
                }
                this._id = '';
                this.uuid = '';
                this.overrideUuid = '';
                this.url = '';
                this.ext = '.json';
                this.content = null;
                this.file = null;
                this.info = null;
                this.config = null;
                this.isNative = false;
                this.options = Object.create(null);
                RequestItem._deadPool.push(this);
              };
              _createClass(RequestItem, [{
                key: "id",
                get: function get() {
                  if (!this._id) {
                    this._id = (this.overrideUuid || this.uuid) + "@" + (this.isNative ? 'native' : 'import');
                  }
                  return this._id;
                }
              }]);
              return RequestItem;
            }();
            RequestItem.MAX_DEAD_NUM = 500;
            RequestItem._deadPool = [];

            var infos = [];
            function parse(task) {
              var options = task.options;
              var input = Array.isArray(task.input) ? task.input : [task.input];
              task.output = [];
              var _loop = function _loop() {
                var item = input[i];
                var out = RequestItem.create();
                var config = null;
                var info = null;
                if (typeof item === 'string') {
                  item = Object.create(null);
                  item[options.__requestType__ || "uuid"] = input[i];
                }
                if (typeof item === 'object') {
                  addon(item, options);
                  if (item.preset) {
                    addon(item, presets[item.preset]);
                  }
                  var _loop2 = function _loop2() {
                    var _info2;
                    switch (key) {
                      case "uuid":
                        {
                          var _info;
                          var uuid = out.uuid = decodeUuid(item.uuid);
                          if (!item.bundle) {
                            var bundle = bundles.find(function (bundle) {
                              return !!bundle.getAssetInfo(uuid);
                            });
                            item.bundle = bundle && bundle.name;
                          }
                          if (bundles.has(item.bundle)) {
                            config = bundles.get(item.bundle).config;
                            info = config.getAssetInfo(uuid);
                            if (info && info.redirect) {
                              if (!bundles.has(info.redirect)) {
                                throw new Error("Please load bundle " + info.redirect + " first");
                              }
                              config = bundles.get(info.redirect).config;
                              info = config.getAssetInfo(uuid);
                            }
                            out.config = config;
                            out.info = info;
                          }
                          out.ext = item.ext || ((_info = info) == null ? undefined : _info.extension) || '.json';
                          break;
                        }
                      case '__requestType__':
                      case 'ext':
                      case 'bundle':
                      case 'preset':
                      case 'type':
                        break;
                      case "dir":
                        if (bundles.has(item.bundle)) {
                          bundles.get(item.bundle).config.getDirWithPath(item.dir, item.type, infos);
                          for (var _iterator = _createForOfIteratorHelperLoose(infos), _step; !(_step = _iterator()).done;) {
                            var assetInfo = _step.value;
                            input.push({
                              uuid: assetInfo.uuid,
                              __isNative__: false,
                              ext: assetInfo.extension || '.json',
                              bundle: item.bundle
                            });
                          }
                          infos.length = 0;
                        }
                        out.recycle();
                        out = null;
                        break;
                      case "path":
                        if (bundles.has(item.bundle)) {
                          config = bundles.get(item.bundle).config;
                          info = config.getInfoWithPath(item.path, item.type);
                          if (info && info.redirect) {
                            if (!bundles.has(info.redirect)) {
                              throw new Error("you need to load bundle " + info.redirect + " first");
                            }
                            config = bundles.get(info.redirect).config;
                            info = config.getAssetInfo(info.uuid);
                          }
                          if (!info) {
                            out.recycle();
                            throw new Error("Bundle " + item.bundle + " doesn't contain " + item.path);
                          }
                          out.config = config;
                          out.uuid = info.uuid;
                          out.info = info;
                        }
                        out.ext = item.ext || ((_info2 = info) == null ? undefined : _info2.extension) || '.json';
                        break;
                      case "scene":
                        if (!item.bundle) {
                          var _bundle = bundles.find(function (bundle) {
                            return !!bundle.getSceneInfo(item.scene);
                          });
                          item.bundle = _bundle && _bundle.name;
                        }
                        if (bundles.has(item.bundle)) {
                          config = bundles.get(item.bundle).config;
                          info = config.getSceneInfo(item.scene);
                          if (info && info.redirect) {
                            if (!bundles.has(info.redirect)) {
                              throw new Error("you need to load bundle " + info.redirect + " first");
                            }
                            config = bundles.get(info.redirect).config;
                            info = config.getAssetInfo(info.uuid);
                          }
                          if (!info) {
                            out.recycle();
                            throw new Error("Bundle " + config.name + " doesn't contain scene " + item.scene);
                          }
                          out.config = config;
                          out.uuid = info.uuid;
                          out.info = info;
                        }
                        break;
                      case '__isNative__':
                        out.isNative = item.__isNative__;
                        break;
                      case "url":
                        out.url = item.url;
                        out.uuid = item.uuid || item.url;
                        out.ext = item.ext || extname(item.url);
                        out.isNative = item.__isNative__ !== undefined ? item.__isNative__ : true;
                        break;
                      default:
                        out.options[key] = item[key];
                    }
                    if (!out) {
                      return 1;
                    }
                  };
                  for (var key in item) {
                    if (_loop2()) break;
                  }
                }
                if (!out) {
                  return 1;
                }
                task.output.push(out);
                if (!out.uuid && !out.url) {
                  throw new Error("Can not parse this input:" + JSON.stringify(item));
                }
              };
              for (var i = 0; i < input.length; i++) {
                if (_loop()) continue;
              }
              return null;
            }
            function replaceOverrideAsset(task) {
              var input = task.output = task.input;
              var _loop3 = function _loop3() {
                var item = input[i];
                if (assetsOverrideMap.has(item.uuid)) {
                  var uuid = assetsOverrideMap.get(item.uuid);
                  var bundle = bundles.find(function (bundle) {
                    return !!bundle.getAssetInfo(uuid);
                  });
                  if (bundle) {
                    var _info3;
                    item.overrideUuid = uuid;
                    var config = bundle.config;
                    var info = config.getAssetInfo(uuid);
                    if (info && info.redirect) {
                      if (!bundles.has(info.redirect)) {
                        throw new Error("Please load bundle " + info.redirect + " first");
                      }
                      config = bundles.get(info.redirect).config;
                      info = config.getAssetInfo(uuid);
                    }
                    item.config = config;
                    item.info = info;
                    item.ext = item.isNative ? item.ext : ((_info3 = info) == null ? undefined : _info3.extension) || '.json';
                  } else {
                    warnID(16201, uuid, item.uuid);
                  }
                }
              };
              for (var i = 0; i < input.length; i++) {
                if (_loop3()) continue;
              }
            }
            function combine(task) {
              var input = task.output = task.input;
              for (var i = 0; i < input.length; i++) {
                var item = input[i];
                if (item.url) {
                  continue;
                }
                var url = '';
                var base = '';
                var config = item.config;
                if (item.isNative) {
                  base = config && config.nativeBase ? config.base + config.nativeBase : cclegacy.assetManager.generalNativeBase;
                } else {
                  base = config && config.importBase ? config.base + config.importBase : cclegacy.assetManager.generalImportBase;
                }
                var uuid = item.overrideUuid || item.uuid;
                var ver = '';
                if (item.info) {
                  if (item.isNative) {
                    ver = item.info.nativeVer ? "." + item.info.nativeVer : '';
                  } else {
                    ver = item.info.ver ? "." + item.info.ver : '';
                  }
                }
                if (item.ext === '.ttf') {
                  url = base + "/" + uuid.slice(0, 2) + "/" + uuid + ver + "/" + item.options.__nativeName__;
                } else {
                  url = base + "/" + uuid.slice(0, 2) + "/" + uuid + ver + item.ext;
                }
                item.url = url;
              }
              return null;
            }

            var querySettings$1 = settings.querySettings.bind(settings);
            var SETTINGS_CATEGORY_ASSETS = "assets";
            var EVENT_ASSET_MISSING = 'asset-missing';
            var AssetManager = exports("AssetManager", function () {
              function AssetManager() {
                this.pipeline = pipeline.append(preprocess).append(load);
                this.fetchPipeline = fetchPipeline.append(preprocess).append(fetch);
                this.transformPipeline = transformPipeline.append(parse).append(replaceOverrideAsset).append(combine);
                this.bundles = bundles;
                this.assets = assets;
                this.assetsOverrideMap = assetsOverrideMap;
                this.generalImportBase = '';
                this.generalNativeBase = '';
                this.dependUtil = dependUtil;
                this.force = PREVIEW;
                this.allowImageBitmap = false;
                this.utils = helper;
                this.downloader = downloader$1;
                this.parser = parser;
                this.packManager = packManager;
                this.cacheAsset = true;
                this.cacheManager = null;
                this.presets = presets;
                this.factory = factory;
                this.preprocessPipe = preprocess;
                this.fetchPipe = fetch;
                this.loadPipe = load;
                this.references = references;
                this._releaseManager = releaseManager;
                this._files = files;
                this._parsed = parsed;
                this._parsePipeline = null ;
                this._projectBundles = [];
                this._eventTarget = new EventTarget();
              }
              var _proto = AssetManager.prototype;
              _proto.getReleaseManager = function getReleaseManager() {
                return this._releaseManager;
              };
              _proto.onAssetMissing = function onAssetMissing(func, target) {
                this._eventTarget.on(EVENT_ASSET_MISSING, func, target);
              };
              _proto.offAssetMissing = function offAssetMissing(func, target) {
                this._eventTarget.off(EVENT_ASSET_MISSING, func, target);
              };
              _proto.dispatchAssetMissing = function dispatchAssetMissing(parentAsset, owner, propName, uuid) {
                this._eventTarget.emit(EVENT_ASSET_MISSING, parentAsset, owner, propName, uuid);
              };
              _proto.init = function init(options) {
                if (options === undefined) {
                  options = {};
                }
                var server = options.server || querySettings$1(SETTINGS_CATEGORY_ASSETS, 'server') || '';
                var bundleVers = options.bundleVers || querySettings$1(SETTINGS_CATEGORY_ASSETS, 'bundleVers') || {};
                var remoteBundles = options.remoteBundles || querySettings$1(SETTINGS_CATEGORY_ASSETS, 'remoteBundles') || [];
                var downloadMaxConcurrency = options.downloadMaxConcurrency || querySettings$1(SETTINGS_CATEGORY_ASSETS, 'downloadMaxConcurrency');
                if (downloadMaxConcurrency && downloadMaxConcurrency > 0) {
                  this.downloader.maxConcurrency = downloadMaxConcurrency;
                }
                this._files.clear();
                this._parsed.clear();
                this._releaseManager.init();
                this.assets.clear();
                this.bundles.clear();
                this.packManager.init();
                this.downloader.init(server, bundleVers, remoteBundles);
                this.parser.init();
                this.dependUtil.init();
                var importBase = options.importBase || querySettings$1(SETTINGS_CATEGORY_ASSETS, 'importBase') || '';
                if (importBase && importBase.endsWith('/')) {
                  importBase = importBase.substring(0, importBase.length - 1);
                }
                var nativeBase = options.nativeBase || querySettings$1(SETTINGS_CATEGORY_ASSETS, 'nativeBase') || '';
                if (nativeBase && nativeBase.endsWith('/')) {
                  nativeBase = nativeBase.substring(0, nativeBase.length - 1);
                }
                this.generalImportBase = importBase;
                this.generalNativeBase = nativeBase;
                this._projectBundles = querySettings$1(SETTINGS_CATEGORY_ASSETS, 'projectBundles') || [];
                var assetsOverride = querySettings$1(SETTINGS_CATEGORY_ASSETS, 'assetsOverrides') || {};
                for (var _key in assetsOverride) {
                  this.assetsOverrideMap.set(_key, assetsOverride[_key]);
                }
              };
              _proto.getBundle = function getBundle(name) {
                return bundles.get(name) || null;
              };
              _proto.removeBundle = function removeBundle(bundle) {
                bundle._destroy();
                bundles.remove(bundle.name);
              };
              _proto.loadAny = function loadAny(requests, options, onProgress, onComplete) {
                var _parseParameters = parseParameters(options, onProgress, onComplete),
                  opts = _parseParameters.options,
                  onProg = _parseParameters.onProgress,
                  onComp = _parseParameters.onComplete;
                opts.preset = opts.preset || 'default';
                requests = Array.isArray(requests) ? requests.slice() : requests;
                var task = Task.create({
                  input: requests,
                  onProgress: onProg,
                  onComplete: asyncify(onComp),
                  options: opts
                });
                pipeline.async(task);
              };
              _proto.preloadAny = function preloadAny(requests, options, onProgress, onComplete) {
                var _parseParameters2 = parseParameters(options, onProgress, onComplete),
                  opts = _parseParameters2.options,
                  onProg = _parseParameters2.onProgress,
                  onComp = _parseParameters2.onComplete;
                opts.preset = opts.preset || 'preload';
                requests = Array.isArray(requests) ? requests.slice() : requests;
                var task = Task.create({
                  input: requests,
                  onProgress: onProg,
                  onComplete: asyncify(onComp),
                  options: opts
                });
                fetchPipeline.async(task);
              };
              _proto.loadRemote = function loadRemote(url, options, onComplete) {
                var _parseParameters3 = parseParameters(options, undefined, onComplete),
                  opts = _parseParameters3.options,
                  onComp = _parseParameters3.onComplete;
                if (!opts.reloadAsset && this.assets.has(url)) {
                  asyncify(onComp)(null, this.assets.get(url));
                  return;
                }
                opts.__isNative__ = true;
                opts.preset = opts.preset || 'remote';
                this.loadAny({
                  url: url
                }, opts, null, function (err, data) {
                  if (err) {
                    error(err.message, err.stack);
                    if (onComp) {
                      onComp(err, data);
                    }
                  } else {
                    factory.create(url, data, opts.ext || extname(url), opts, function (p1, p2) {
                      if (onComp) {
                        onComp(p1, p2);
                      }
                    });
                  }
                });
              };
              _proto.loadBundle = function loadBundle(nameOrUrl, options, onComplete) {
                var _parseParameters4 = parseParameters(options, undefined, onComplete),
                  opts = _parseParameters4.options,
                  onComp = _parseParameters4.onComplete;
                var bundleName = basename(nameOrUrl);
                if (this.bundles.has(bundleName)) {
                  asyncify(onComp)(null, this.getBundle(bundleName));
                  return;
                }
                opts.preset = opts.preset || 'bundle';
                opts.ext = 'bundle';
                opts.__isNative__ = true;
                this.loadAny({
                  url: nameOrUrl
                }, opts, null, function (err, data) {
                  if (err) {
                    error(err.message, err.stack);
                    if (onComp) {
                      onComp(err, data);
                    }
                  } else {
                    factory.create(nameOrUrl, data, 'bundle', opts, function (p1, p2) {
                      if (onComp) {
                        onComp(p1, p2);
                      }
                    });
                  }
                });
              };
              _proto.releaseAsset = function releaseAsset(asset) {
                releaseManager.tryRelease(asset, true);
              };
              _proto.releaseUnusedAssets = function releaseUnusedAssets() {
                assets.forEach(function (asset) {
                  releaseManager.tryRelease(asset);
                });
              };
              _proto.releaseAll = function releaseAll() {
                assets.forEach(function (asset) {
                  releaseManager.tryRelease(asset, true);
                });
              };
              _proto.loadWithJson = function loadWithJson(json, options, onProgress, onComplete) {
                {
                  throw new Error('Only valid in Editor');
                }
              };
              _createClass(AssetManager, [{
                key: "files",
                get: function get() {
                  return this._files;
                }
              }, {
                key: "main",
                get: function get() {
                  return bundles.get("main") || null;
                }
              }, {
                key: "resources",
                get: function get() {
                  return bundles.get("resources") || null;
                }
              }], [{
                key: "instance",
                get: function get() {
                  if (!this._instance) {
                    this._instance = new AssetManager();
                  }
                  return this._instance;
                }
              }]);
              return AssetManager;
            }());
            AssetManager._instance = undefined;
            AssetManager.Pipeline = Pipeline;
            AssetManager.Task = Task;
            AssetManager.Cache = Cache;
            AssetManager.RequestItem = RequestItem;
            AssetManager.Bundle = Bundle;
            AssetManager.BuiltinBundleName = BuiltinBundleName;
            AssetManager.CacheManager = CacheManager;
            AssetManager.Downloader = Downloader;
            AssetManager.Parser = Parser$1;
            AssetManager.DependUtil = DependUtil;
            var assetManager = exports("assetManager", cclegacy.assetManager = AssetManager.instance);
            cclegacy.AssetManager = AssetManager;

            var BuiltinResMgr = exports("BuiltinResMgr", function () {
              function BuiltinResMgr() {
                this._resources = {};
                this._materialsToBeCompiled = [];
              }
              var _proto = BuiltinResMgr.prototype;
              _proto.init = function init() {
                var resources = this._resources;
                var len = 2;
                var numChannels = 4;
                var byteLength = len * len * numChannels;
                var blackValueView = new Uint8Array(byteLength);
                var emptyValueView = new Uint8Array(byteLength);
                var greyValueView = new Uint8Array(byteLength);
                var whiteValueView = new Uint8Array(byteLength);
                var normalValueView = new Uint8Array(byteLength);
                var offset = 0;
                for (var i = 0; i < len * len; i++) {
                  blackValueView[offset] = 0;
                  blackValueView[offset + 1] = 0;
                  blackValueView[offset + 2] = 0;
                  blackValueView[offset + 3] = 255;
                  emptyValueView[offset] = 0;
                  emptyValueView[offset + 1] = 0;
                  emptyValueView[offset + 2] = 0;
                  emptyValueView[offset + 3] = 0;
                  greyValueView[offset] = 119;
                  greyValueView[offset + 1] = 119;
                  greyValueView[offset + 2] = 119;
                  greyValueView[offset + 3] = 255;
                  whiteValueView[offset] = 255;
                  whiteValueView[offset + 1] = 255;
                  whiteValueView[offset + 2] = 255;
                  whiteValueView[offset + 3] = 255;
                  normalValueView[offset] = 127;
                  normalValueView[offset + 1] = 127;
                  normalValueView[offset + 2] = 255;
                  normalValueView[offset + 3] = 255;
                  offset += numChannels;
                }
                var defaultSize = 16;
                var halfDefaultSize = defaultSize / 2;
                var defaultValueView = new Uint8Array(defaultSize * defaultSize * numChannels);
                offset = 0;
                for (var _i = 0; _i < defaultSize * defaultSize; _i++) {
                  defaultValueView[offset] = 221;
                  defaultValueView[offset + 1] = 221;
                  defaultValueView[offset + 2] = 221;
                  defaultValueView[offset + 3] = 255;
                  offset += numChannels;
                }
                offset = 0;
                for (var _i2 = 0; _i2 < halfDefaultSize; _i2++) {
                  for (var j = 0; j < halfDefaultSize; j++) {
                    defaultValueView[offset] = 85;
                    defaultValueView[offset + 1] = 85;
                    defaultValueView[offset + 2] = 85;
                    defaultValueView[offset + 3] = 255;
                    offset += numChannels;
                  }
                  offset += halfDefaultSize * numChannels;
                }
                offset += halfDefaultSize * numChannels;
                for (var _i3 = 0; _i3 < halfDefaultSize; _i3++) {
                  for (var _j = 0; _j < halfDefaultSize; _j++) {
                    defaultValueView[offset] = 85;
                    defaultValueView[offset + 1] = 85;
                    defaultValueView[offset + 2] = 85;
                    defaultValueView[offset + 3] = 255;
                    offset += numChannels;
                  }
                  offset += halfDefaultSize * numChannels;
                }
                var blackMemImageSource = {
                  width: len,
                  height: len,
                  _data: blackValueView,
                  _compressed: false,
                  format: 35
                };
                var emptyMemImageSource = {
                  width: len,
                  height: len,
                  _data: emptyValueView,
                  _compressed: false,
                  format: 35
                };
                var greyMemImageSource = {
                  width: len,
                  height: len,
                  _data: greyValueView,
                  _compressed: false,
                  format: 35
                };
                var whiteMemImageSource = {
                  width: len,
                  height: len,
                  _data: whiteValueView,
                  _compressed: false,
                  format: 35
                };
                var normalMemImageSource = {
                  width: len,
                  height: len,
                  _data: normalValueView,
                  _compressed: false,
                  format: 35
                };
                var defaultMemImageSource = {
                  width: defaultSize,
                  height: defaultSize,
                  _data: defaultValueView,
                  _compressed: false,
                  format: 35
                };
                var imgAsset = new ImageAsset(blackMemImageSource);
                var blackTexture = new Texture2D();
                blackTexture._uuid = 'black-texture';
                blackTexture.image = imgAsset;
                resources[blackTexture._uuid] = blackTexture;
                var emptyImgAsset = new ImageAsset(emptyMemImageSource);
                var emptyTexture = new Texture2D();
                emptyTexture._uuid = 'empty-texture';
                emptyTexture.image = emptyImgAsset;
                resources[emptyTexture._uuid] = emptyTexture;
                var blackCubeTexture = new TextureCube();
                blackCubeTexture._uuid = 'black-cube-texture';
                blackCubeTexture.setMipFilter(1);
                blackCubeTexture.image = {
                  front: new ImageAsset(blackMemImageSource),
                  back: new ImageAsset(blackMemImageSource),
                  left: new ImageAsset(blackMemImageSource),
                  right: new ImageAsset(blackMemImageSource),
                  top: new ImageAsset(blackMemImageSource),
                  bottom: new ImageAsset(blackMemImageSource)
                };
                resources[blackCubeTexture._uuid] = blackCubeTexture;
                var greyImgAsset = new ImageAsset(greyMemImageSource);
                var greyTexture = new Texture2D();
                greyTexture._uuid = 'grey-texture';
                greyTexture.image = greyImgAsset;
                resources[greyTexture._uuid] = greyTexture;
                var greyCubeTexture = new TextureCube();
                greyCubeTexture._uuid = 'grey-cube-texture';
                greyCubeTexture.setMipFilter(1);
                greyCubeTexture.image = {
                  front: new ImageAsset(greyMemImageSource),
                  back: new ImageAsset(greyMemImageSource),
                  left: new ImageAsset(greyMemImageSource),
                  right: new ImageAsset(greyMemImageSource),
                  top: new ImageAsset(greyMemImageSource),
                  bottom: new ImageAsset(greyMemImageSource)
                };
                resources[greyCubeTexture._uuid] = greyCubeTexture;
                var whiteImgAsset = new ImageAsset(whiteMemImageSource);
                var whiteTexture = new Texture2D();
                whiteTexture._uuid = 'white-texture';
                whiteTexture.image = whiteImgAsset;
                resources[whiteTexture._uuid] = whiteTexture;
                var whiteCubeTexture = new TextureCube();
                whiteCubeTexture._uuid = 'white-cube-texture';
                whiteCubeTexture.setMipFilter(1);
                whiteCubeTexture.image = {
                  front: new ImageAsset(whiteMemImageSource),
                  back: new ImageAsset(whiteMemImageSource),
                  left: new ImageAsset(whiteMemImageSource),
                  right: new ImageAsset(whiteMemImageSource),
                  top: new ImageAsset(whiteMemImageSource),
                  bottom: new ImageAsset(whiteMemImageSource)
                };
                resources[whiteCubeTexture._uuid] = whiteCubeTexture;
                var normalImgAsset = new ImageAsset(normalMemImageSource);
                var normalTexture = new Texture2D();
                normalTexture._uuid = 'normal-texture';
                normalTexture.image = normalImgAsset;
                resources[normalTexture._uuid] = normalTexture;
                var defaultImgAsset = new ImageAsset(defaultMemImageSource);
                var defaultTexture = new Texture2D();
                defaultTexture._uuid = 'default-texture';
                defaultTexture.image = defaultImgAsset;
                resources[defaultTexture._uuid] = defaultTexture;
                var defaultCubeTexture = new TextureCube();
                defaultCubeTexture.setMipFilter(1);
                defaultCubeTexture._uuid = 'default-cube-texture';
                defaultCubeTexture.image = {
                  front: new ImageAsset(defaultMemImageSource),
                  back: new ImageAsset(defaultMemImageSource),
                  left: new ImageAsset(defaultMemImageSource),
                  right: new ImageAsset(defaultMemImageSource),
                  top: new ImageAsset(defaultMemImageSource),
                  bottom: new ImageAsset(defaultMemImageSource)
                };
                resources[defaultCubeTexture._uuid] = defaultCubeTexture;
                if (cclegacy.SpriteFrame) {
                  var spriteFrame = new cclegacy.SpriteFrame();
                  var image = imgAsset;
                  var texture = new Texture2D();
                  texture.image = image;
                  spriteFrame.texture = texture;
                  spriteFrame._uuid = 'default-spriteframe';
                  resources[spriteFrame._uuid] = spriteFrame;
                }
              };
              _proto.addAsset = function addAsset(key, asset) {
                this._resources[key] = asset;
              };
              _proto.get = function get(uuid) {
                return this._resources[uuid];
              };
              _proto.loadBuiltinAssets = function loadBuiltinAssets() {
                var _this = this;
                var builtinAssets = settings.querySettings("engine", 'builtinAssets');
                if (!builtinAssets) return Promise.resolve();
                var resources = this._resources;
                return new Promise(function (resolve, reject) {
                  assetManager.loadBundle("internal", function (err, bundle) {
                    if (err) {
                      reject(err);
                      return;
                    }
                    assetManager.loadAny(builtinAssets, function (err, assets) {
                      if (err) {
                        reject(err);
                      } else {
                        assets.forEach(function (asset) {
                          resources[asset.name] = asset;
                          {
                            releaseManager.addIgnoredAsset(asset);
                          }
                          if (asset instanceof cclegacy.Material) {
                            _this._materialsToBeCompiled.push(asset);
                          }
                        });
                        resolve();
                      }
                    });
                  });
                });
              };
              _proto.compileBuiltinMaterial = function compileBuiltinMaterial() {
                for (var i = 0; i < this._materialsToBeCompiled.length; ++i) {
                  var mat = this._materialsToBeCompiled[i];
                  for (var j = 0; j < mat.passes.length; ++j) {
                    mat.passes[j].tryCompile();
                  }
                }
                this._materialsToBeCompiled.length = 0;
              };
              return BuiltinResMgr;
            }());
            var builtinResMgr = exports("builtinResMgr", cclegacy.builtinResMgr = new BuiltinResMgr());

            var getPhaseID$1 = exports("getPhaseID", function () {
              var phases = new Map();
              var phaseNum = 0;
              return function (phaseName) {
                if (typeof phaseName === 'number') {
                  return phaseName;
                }
                if (!phases.has(phaseName)) {
                  phases.set(phaseName, 1 << phaseNum);
                  phaseNum++;
                }
                return phases.get(phaseName);
              };
            }());

            function instancingCompareFn(l, r) {
              var ls = l.sortRender;
              var rs = r.sortRender;
              return ls.hash - rs.hash || ls.shaderId - rs.shaderId;
            }
            var INITIAL_CAPACITY = 32;
            var MAX_CAPACITY = 1024;
            var InstancedBuffer = exports("InstancedBuffer", function () {
              function InstancedBuffer(pass) {
                this.instances = [];
                this.hasPendingModels = false;
                this.dynamicOffsets = [];
                this.sortRender = undefined;
                this._device = pass.device;
                this.pass = pass;
                this._passPool = getPassPool();
                this.sortRender = this._passPool.add();
              }
              var _proto = InstancedBuffer.prototype;
              _proto.destroy = function destroy() {
                this.instances.forEach(function (instance) {
                  instance.vb.destroy();
                  instance.ia.destroy();
                });
                this._passPool.reset();
                this.instances.length = 0;
              };
              _proto.merge = function merge(subModel, passIdx, shaderImplant) {
                if (shaderImplant === undefined) {
                  shaderImplant = null;
                }
                var attrs = subModel.instancedAttributeBlock;
                var stride = attrs.buffer.length;
                if (!stride) {
                  return;
                }
                var sourceIA = subModel.inputAssembler;
                var subModelDescriptorSet = subModel.descriptorSet;
                var lightingMap = subModelDescriptorSet.getTexture(UNIFORM_LIGHTMAP_TEXTURE_BINDING);
                var reflectionProbeCubemap = subModelDescriptorSet.getTexture(UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING);
                var reflectionProbePlanarMap = subModelDescriptorSet.getTexture(UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING);
                var reflectionProbeBlendCubemap = null;
                var useReflectionProbeType = subModel.useReflectionProbeType;
                var shader = shaderImplant;
                if (!shader) {
                  shader = subModel.shaders[passIdx];
                }
                var descriptorSet = subModel.descriptorSet;
                var hash = subModel.passes[passIdx].priority << 16 | subModel.priority << 8 | passIdx;
                this.sortRender.hash = hash;
                this.sortRender.shaderId = shader.typedID;
                this.sortRender.passIdx = passIdx;
                for (var i = 0; i < this.instances.length; ++i) {
                  var _instance$ia$indexBuf, _sourceIA$indexBuffer;
                  var instance = this.instances[i];
                  if (((_instance$ia$indexBuf = instance.ia.indexBuffer) == null ? undefined : _instance$ia$indexBuf.objectID) !== ((_sourceIA$indexBuffer = sourceIA.indexBuffer) == null ? undefined : _sourceIA$indexBuffer.objectID) || instance.count >= MAX_CAPACITY) {
                    continue;
                  }
                  if (instance.lightingMap.objectID !== lightingMap.objectID) {
                    continue;
                  }
                  if (instance.useReflectionProbeType !== useReflectionProbeType) {
                    continue;
                  }
                  if (instance.reflectionProbeCubemap.objectID !== reflectionProbeCubemap.objectID) {
                    continue;
                  }
                  if (instance.reflectionProbePlanarMap.objectID !== reflectionProbePlanarMap.objectID) {
                    continue;
                  }
                  if (instance.stride !== stride) {
                    continue;
                  }
                  if (instance.count >= instance.capacity) {
                    instance.capacity <<= 1;
                    var newSize = instance.stride * instance.capacity;
                    var oldData = instance.data;
                    instance.data = new Uint8Array(newSize);
                    instance.data.set(oldData);
                    instance.vb.resize(newSize);
                  }
                  instance.shader = shader;
                  instance.descriptorSet = descriptorSet;
                  instance.data.set(attrs.buffer, instance.stride * instance.count++);
                  this.hasPendingModels = true;
                  return;
                }
                var vb = this._device.createBuffer(new BufferInfo(8 | 2, 2 | 1, stride * INITIAL_CAPACITY, stride));
                var data = new Uint8Array(stride * INITIAL_CAPACITY);
                var vertexBuffers = sourceIA.vertexBuffers.slice();
                var attributes = sourceIA.attributes.slice();
                var indexBuffer = sourceIA.indexBuffer;
                for (var _i = 0; _i < attrs.attributes.length; _i++) {
                  var attr = attrs.attributes[_i];
                  var newAttr = new Attribute(attr.name, attr.format, attr.isNormalized, vertexBuffers.length, true);
                  attributes.push(newAttr);
                }
                data.set(attrs.buffer);
                vertexBuffers.push(vb);
                var iaInfo = new InputAssemblerInfo(attributes, vertexBuffers, indexBuffer);
                var ia = this._device.createInputAssembler(iaInfo);
                this.instances.push({
                  count: 1,
                  capacity: INITIAL_CAPACITY,
                  vb: vb,
                  data: data,
                  ia: ia,
                  stride: stride,
                  shader: shader,
                  descriptorSet: descriptorSet,
                  lightingMap: lightingMap,
                  reflectionProbeCubemap: reflectionProbeCubemap,
                  reflectionProbePlanarMap: reflectionProbePlanarMap,
                  useReflectionProbeType: useReflectionProbeType,
                  reflectionProbeBlendCubemap: reflectionProbeBlendCubemap
                });
                this.hasPendingModels = true;
              };
              _proto.uploadBuffers = function uploadBuffers(cmdBuff) {
                for (var i = 0; i < this.instances.length; ++i) {
                  var instance = this.instances[i];
                  if (!instance.count) {
                    continue;
                  }
                  instance.ia.instanceCount = instance.count;
                  cmdBuff.updateBuffer(instance.vb, instance.data);
                }
              };
              _proto.clear = function clear() {
                this.instances.forEach(function (instance) {
                  instance.count = 0;
                });
                this.hasPendingModels = false;
                this._passPool.reset();
              };
              return InstancedBuffer;
            }());

            var _bufferInfo = new BufferInfo(16 | 2, 1);
            var _bufferViewInfo = new BufferViewInfo(null);
            var _dsInfo$1 = new DescriptorSetInfo(null);
            var _materialSet = 1;
            var BatchingSchemes = {
              NONE: 0,
              INSTANCING: 1
            };
            var Pass = function () {
              Pass.fillPipelineInfo = function fillPipelineInfo(pass, info) {
                if (info.priority !== undefined) {
                  pass._priority = info.priority;
                }
                if (info.primitive !== undefined) {
                  pass._primitive = info.primitive;
                }
                if (info.stage !== undefined) {
                  pass._stage = info.stage;
                }
                if (info.dynamicStates !== undefined) {
                  pass._dynamicStates = info.dynamicStates;
                }
                if (info.phase !== undefined) {
                  pass._phase = getPhaseID$1(info.phase);
                }
                var bs = pass._bs;
                if (info.blendState) {
                  var bsInfo = info.blendState;
                  var targets = bsInfo.targets;
                  if (targets) {
                    targets.forEach(function (t, i) {
                      bs.setTarget(i, t);
                    });
                  }
                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }
                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }
                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }
                pass._rs.assign(info.rasterizerState);
                pass._dss.assign(info.depthStencilState);
              };
              Pass.getPassHash = function getPassHash(pass) {
                var shaderKey = '';
                if (cclegacy.rendering && cclegacy.rendering.enableEffectImport) {
                  var key = cclegacy.rendering.programLib.getKey(pass._phaseID, pass.program, pass.defines);
                  shaderKey = pass._phaseID.toString() + "," + key;
                } else {
                  shaderKey = programLib$1.getKey(pass.program, pass.defines);
                }
                var res = shaderKey + "," + pass._primitive + "," + pass._dynamicStates;
                res += serializeBlendState(pass._bs);
                res += serializeDepthStencilState(pass._dss);
                res += serializeRasterizerState(pass._rs);
                return murmurhash2_32_gc(res, 666);
              };
              function Pass(root) {
                this._rootBuffer = null;
                this._buffers = [];
                this._descriptorSet = null;
                this._pipelineLayout = null;
                this._passIndex = 0;
                this._propertyIndex = 0;
                this._programName = '';
                this._dynamics = {};
                this._propertyHandleMap = {};
                this._rootBlock = null;
                this._blocksInt = [];
                this._blocks = [];
                this._shaderInfo = null;
                this._defines = {};
                this._properties = {};
                this._shader = null;
                this._bs = new BlendState();
                this._dss = new DepthStencilState();
                this._rs = new RasterizerState();
                this._priority = 128;
                this._stage = 100;
                this._phase = getPhaseID$1('default');
                this._passID = 0xFFFFFFFF;
                this._subpassID = 0xFFFFFFFF;
                this._phaseID = 0xFFFFFFFF;
                this._primitive = 7;
                this._batchingScheme = 0;
                this._dynamicStates = 0;
                this._instancedBuffers = {};
                this._hash = 0;
                this._rootBufferDirty = false;
                this._root = root;
                this._device = deviceManager.gfxDevice;
              }
              var _proto = Pass.prototype;
              _proto.initialize = function initialize(info) {
                this._doInit(info);
                this.resetUBOs();
                this.resetTextures();
                this.tryCompile();
              };
              _proto.getHandle = function getHandle(name, offset, targetType) {
                if (offset === undefined) {
                  offset = 0;
                }
                if (targetType === undefined) {
                  targetType = 0;
                }
                var handle = this._propertyHandleMap[name];
                if (!handle) {
                  return 0;
                }
                if (targetType) {
                  handle = customizeType(handle, targetType);
                } else if (offset) {
                  handle = customizeType(handle, getTypeFromHandle(handle) - offset);
                }
                return handle + offset;
              };
              _proto.getBinding = function getBinding(name) {
                var handle = this.getHandle(name);
                if (!handle) {
                  return -1;
                }
                return getBindingFromHandle(handle);
              };
              _proto.setUniform = function setUniform(handle, value) {
                var binding = getBindingFromHandle(handle);
                var type = getTypeFromHandle(handle);
                var ofs = getOffsetFromHandle(handle);
                var block = this._getBlockView(type, binding);
                {
                  var validator = type2validator[type];
                  assertID(Boolean(validator && validator(value)), 12011, binding, Type[type]);
                }
                type2writer[type](block, value, ofs);
                this._rootBufferDirty = true;
              };
              _proto.getUniform = function getUniform(handle, out) {
                var binding = getBindingFromHandle(handle);
                var type = getTypeFromHandle(handle);
                var ofs = getOffsetFromHandle(handle);
                var block = this._getBlockView(type, binding);
                return type2reader[type](block, out, ofs);
              };
              _proto.setUniformArray = function setUniformArray(handle, value) {
                var binding = getBindingFromHandle(handle);
                var type = getTypeFromHandle(handle);
                var stride = GetTypeSize(type) >> 2;
                var block = this._getBlockView(type, binding);
                var ofs = getOffsetFromHandle(handle);
                for (var i = 0; i < value.length; i++, ofs += stride) {
                  if (value[i] === null) {
                    continue;
                  }
                  type2writer[type](block, value[i], ofs);
                }
                this._rootBufferDirty = true;
              };
              _proto.bindTexture = function bindTexture(binding, value, index) {
                this._descriptorSet.bindTexture(binding, value, index || 0);
              };
              _proto.bindSampler = function bindSampler(binding, value, index) {
                this._descriptorSet.bindSampler(binding, value, index || 0);
              };
              _proto.setDynamicState = function setDynamicState(state, value) {
                var ds = this._dynamics[state];
                if (ds && ds.value === value) {
                  return;
                }
                ds.value = value;
                ds.dirty = true;
              };
              _proto.overridePipelineStates = function overridePipelineStates(original, overrides) {
                warnID(12102);
              };
              _proto.update = function update() {
                if (!this._descriptorSet) {
                  errorID(12006);
                  return;
                }
                if (this._rootBuffer && this._rootBufferDirty) {
                  this._rootBuffer.update(this._rootBlock);
                  this._rootBufferDirty = false;
                }
                this._descriptorSet.update();
              };
              _proto.getInstancedBuffer = function getInstancedBuffer(extraKey) {
                if (extraKey === undefined) {
                  extraKey = 0;
                }
                return this._instancedBuffers[extraKey] || (this._instancedBuffers[extraKey] = new InstancedBuffer(this));
              };
              _proto.destroy = function destroy() {
                for (var i = 0; i < this._shaderInfo.blocks.length; i++) {
                  var u = this._shaderInfo.blocks[i];
                  this._buffers[u.binding].destroy();
                }
                this._buffers = [];
                if (this._rootBuffer) {
                  this._rootBuffer.destroy();
                  this._rootBuffer = null;
                }
                for (var ib in this._instancedBuffers) {
                  this._instancedBuffers[ib].destroy();
                }
                this._descriptorSet.destroy();
                this._rs.destroy();
                this._dss.destroy();
                this._bs.destroy();
              };
              _proto.resetUniform = function resetUniform(name) {
                var handle = this.getHandle(name);
                if (!handle) {
                  return;
                }
                var type = getTypeFromHandle(handle);
                var binding = getBindingFromHandle(handle);
                var ofs = getOffsetFromHandle(handle);
                var count = getCountFromHandle(handle);
                var block = this._getBlockView(type, binding);
                var info = this._properties[name];
                var givenDefault = info && info.value;
                var value = givenDefault || getDefaultFromType(type);
                var size = (GetTypeSize(type) >> 2) * count;
                for (var k = 0; k + value.length <= size; k += value.length) {
                  block.set(value, ofs + k);
                }
                this._rootBufferDirty = true;
              };
              _proto.resetTexture = function resetTexture(name, index) {
                var handle = this.getHandle(name);
                if (!handle) {
                  return;
                }
                var type = getTypeFromHandle(handle);
                var binding = getBindingFromHandle(handle);
                var info = this._properties[name];
                var value = info && info.value;
                var textureBase;
                if (typeof value === 'string') {
                  textureBase = builtinResMgr.get("" + value + getStringFromType(type));
                } else {
                  textureBase = value || builtinResMgr.get(getDefaultFromType(type));
                }
                var texture = textureBase && textureBase.getGFXTexture();
                var samplerInfo = info && info.samplerHash !== undefined ? Sampler.unpackFromHash(info.samplerHash) : textureBase && textureBase.getSamplerInfo();
                var sampler = this._device.getSampler(samplerInfo);
                this._descriptorSet.bindSampler(binding, sampler, index || 0);
                this._descriptorSet.bindTexture(binding, texture, index || 0);
              };
              _proto.resetUBOs = function resetUBOs() {
                for (var i = 0; i < this._shaderInfo.blocks.length; i++) {
                  var u = this._shaderInfo.blocks[i];
                  var ofs = 0;
                  for (var j = 0; j < u.members.length; j++) {
                    var cur = u.members[j];
                    var block = this._getBlockView(cur.type, u.binding);
                    var info = this._properties[cur.name];
                    var givenDefault = info && info.value;
                    var value = givenDefault || getDefaultFromType(cur.type);
                    var size = (GetTypeSize(cur.type) >> 2) * cur.count;
                    for (var k = 0; k + value.length <= size; k += value.length) {
                      block.set(value, ofs + k);
                    }
                    ofs += size;
                  }
                }
                this._rootBufferDirty = true;
              };
              _proto.resetTextures = function resetTextures() {
                var _this = this;
                if (cclegacy.rendering) {
                  var set = this._shaderInfo.descriptors[1];
                  set.samplerTextures.forEach(function (combined) {
                    for (var j = 0; j < combined.count; ++j) {
                      _this.resetTexture(combined.name, j);
                    }
                  });
                } else {
                  for (var i = 0; i < this._shaderInfo.samplerTextures.length; i++) {
                    var u = this._shaderInfo.samplerTextures[i];
                    for (var j = 0; j < u.count; j++) {
                      this.resetTexture(u.name, j);
                    }
                  }
                }
              };
              _proto.tryCompile = function tryCompile() {
                var pipeline = this._root.pipeline;
                if (!pipeline) {
                  return false;
                }
                this._syncBatchingScheme();
                if (cclegacy.rendering && cclegacy.rendering.enableEffectImport) {
                  var _programLib = cclegacy.rendering.programLib;
                  var program = _programLib.getProgramVariant(this._device, this._phaseID, this._programName, this._defines);
                  if (!program) {
                    warnID(12103, this._programName);
                    return false;
                  }
                  this._shader = program.shader;
                  this._pipelineLayout = _programLib.getPipelineLayout(this.device, this._phaseID, this._programName);
                } else {
                  var shader = programLib$1.getGFXShader(this._device, this._programName, this._defines, pipeline);
                  if (!shader) {
                    warnID(12104, this._programName);
                    return false;
                  }
                  this._shader = shader;
                  this._pipelineLayout = programLib$1.getTemplateInfo(this._programName).pipelineLayout;
                }
                this._hash = Pass.getPassHash(this);
                return true;
              };
              _proto.getShaderVariant = function getShaderVariant(patches) {
                if (patches === undefined) {
                  patches = null;
                }
                if (!this._shader && !this.tryCompile()) {
                  warnID(12105);
                  return null;
                }
                if (!patches) {
                  return this._shader;
                }
                var pipeline = this._root.pipeline;
                for (var _i = 0; _i < patches.length; _i++) {
                  var patch = patches[_i];
                  this._defines[patch.name] = patch.value;
                }
                if (this._isBlend) {
                  this._defines.CC_IS_TRANSPARENCY_PASS = 1;
                }
                var shader = null;
                if (cclegacy.rendering && cclegacy.rendering.enableEffectImport) {
                  var program = cclegacy.rendering.programLib.getProgramVariant(this._device, this._phaseID, this._programName, this._defines);
                  if (program) {
                    shader = program.shader;
                  }
                } else {
                  shader = programLib$1.getGFXShader(this._device, this._programName, this._defines, pipeline);
                }
                for (var _i2 = 0; _i2 < patches.length; _i2++) {
                  var _patch = patches[_i2];
                  delete this._defines[_patch.name];
                }
                return shader;
              };
              _proto.beginChangeStatesSilently = function beginChangeStatesSilently() {};
              _proto.endChangeStatesSilently = function endChangeStatesSilently() {};
              _proto._doInit = function _doInit(info, copyDefines) {
                var _cclegacy$rendering;
                if (copyDefines === undefined) {
                  copyDefines = false;
                }
                this._priority = 128;
                this._stage = 100;
                var enableEffectImport = (_cclegacy$rendering = cclegacy.rendering) == null ? undefined : _cclegacy$rendering.enableEffectImport;
                if (enableEffectImport) {
                  var r = cclegacy.rendering;
                  if (typeof info.phase === 'number') {
                    this._passID = info._passID;
                    this._subpassID = info._subpassID;
                    this._phaseID = info._phaseID;
                  } else {
                    this._passID = r.getPassID(info.pass);
                    if (this._passID !== r.INVALID_ID) {
                      if (info.subpass) {
                        this._subpassID = r.getSubpassID(this._passID, info.subpass);
                        this._phaseID = r.getPhaseID(this._subpassID, info.phase);
                      } else {
                        this._phaseID = r.getPhaseID(this._passID, info.phase);
                      }
                    }
                  }
                  if (this._passID === r.INVALID_ID) {
                    errorID(12107, info.program);
                    return;
                  }
                  if (this._phaseID === r.INVALID_ID) {
                    errorID(12108, info.program);
                    return;
                  }
                } else {
                  if (typeof info.phase === 'number') {
                    this._passID = info._passID;
                  } else if (info.pass && info.pass !== 'default') {
                    assertID(this._passID === 0xFFFFFFFF, 12110);
                    this._passID = 0;
                  }
                }
                this._phase = getPhaseID$1('default');
                this._primitive = 7;
                this._passIndex = info.passIndex;
                this._propertyIndex = info.propertyIndex !== undefined ? info.propertyIndex : info.passIndex;
                this._programName = info.program;
                this._defines = copyDefines ? _extends({}, info.defines) : info.defines;
                if (enableEffectImport) {
                  this._shaderInfo = cclegacy.rendering.programLib.getProgramInfo(this._phaseID, this._programName);
                } else {
                  this._shaderInfo = programLib$1.getTemplate(info.program);
                }
                this._properties = info.properties || this._properties;
                var device = this._device;
                Pass.fillPipelineInfo(this, info);
                if (info.stateOverrides) {
                  Pass.fillPipelineInfo(this, info.stateOverrides);
                }
                if (enableEffectImport) {
                  _dsInfo$1.layout = cclegacy.rendering.programLib.getMaterialDescriptorSetLayout(this._device, this._phaseID, info.program);
                } else {
                  _dsInfo$1.layout = programLib$1.getDescriptorSetLayout(this._device, info.program);
                }
                this._descriptorSet = this._device.createDescriptorSet(_dsInfo$1);
                var blocks = this._shaderInfo.blocks;
                var blockSizes;
                var handleMap;
                if (enableEffectImport) {
                  var _programLib2 = cclegacy.rendering.programLib;
                  blockSizes = _programLib2.getBlockSizes(this._phaseID, this._programName);
                  handleMap = _programLib2.getHandleMap(this._phaseID, this._programName);
                } else {
                  var tmplInfo = programLib$1.getTemplateInfo(info.program);
                  blockSizes = tmplInfo.blockSizes;
                  handleMap = tmplInfo.handleMap;
                }
                if (enableEffectImport) {
                  var _programLib3 = cclegacy.rendering.programLib;
                  var shaderInfo = _programLib3.getShaderInfo(this._phaseID, this.program);
                  this._buildMaterialUniformBlocks(device, shaderInfo.blocks, blockSizes);
                } else {
                  this._buildUniformBlocks(device, blocks, blockSizes);
                }
                var directHandleMap = this._propertyHandleMap = handleMap;
                var indirectHandleMap = {};
                for (var name in this._properties) {
                  var prop = this._properties[name];
                  if (!prop.handleInfo) {
                    continue;
                  }
                  indirectHandleMap[name] = this.getHandle.apply(this, prop.handleInfo);
                }
                Object.assign(directHandleMap, indirectHandleMap);
              };
              _proto._buildUniformBlocks = function _buildUniformBlocks(device, blocks, blockSizes) {
                var alignment = device.capabilities.uboOffsetAlignment;
                var startOffsets = [];
                var lastSize = 0;
                var lastOffset = 0;
                for (var i = 0; i < blocks.length; i++) {
                  var size = blockSizes[i];
                  startOffsets.push(lastOffset);
                  lastOffset += Math.ceil(size / alignment) * alignment;
                  lastSize = size;
                }
                var totalSize = startOffsets[startOffsets.length - 1] + Math.ceil(lastSize / 16) * 16;
                if (totalSize) {
                  _bufferInfo.size = Math.ceil(totalSize / 16) * 16;
                  this._rootBuffer = device.createBuffer(_bufferInfo);
                  this._rootBlock = new ArrayBuffer(totalSize);
                }
                for (var _i3 = 0, count = 0; _i3 < blocks.length; _i3++) {
                  var binding = blocks[_i3].binding;
                  var _size = blockSizes[_i3];
                  _bufferViewInfo.buffer = this._rootBuffer;
                  _bufferViewInfo.offset = startOffsets[count++];
                  _bufferViewInfo.range = Math.ceil(_size / 16) * 16;
                  var bufferView = this._buffers[binding] = device.createBuffer(_bufferViewInfo);
                  this._blocks[binding] = new Float32Array(this._rootBlock, _bufferViewInfo.offset, _size / 4);
                  this._blocksInt[binding] = new Int32Array(this._blocks[binding].buffer, this._blocks[binding].byteOffset, this._blocks[binding].length);
                  this._descriptorSet.bindBuffer(binding, bufferView);
                }
              };
              _proto._buildMaterialUniformBlocks = function _buildMaterialUniformBlocks(device, blocks, blockSizes) {
                var alignment = device.capabilities.uboOffsetAlignment;
                var startOffsets = [];
                var lastSize = 0;
                var lastOffset = 0;
                for (var i = 0; i < blocks.length; i++) {
                  var block = blocks[i];
                  if (block.set !== _materialSet) {
                    continue;
                  }
                  var size = blockSizes[i];
                  startOffsets.push(lastOffset);
                  lastOffset += Math.ceil(size / alignment) * alignment;
                  lastSize = size;
                }
                if (lastSize !== 0) {
                  var totalSize = startOffsets[startOffsets.length - 1] + lastSize;
                  if (totalSize) {
                    _bufferInfo.size = Math.ceil(totalSize / 16) * 16;
                    this._rootBuffer = device.createBuffer(_bufferInfo);
                    this._rootBlock = new ArrayBuffer(totalSize);
                  }
                }
                for (var _i4 = 0, count = 0; _i4 < blocks.length; _i4++) {
                  var _block = blocks[_i4];
                  if (_block.set !== _materialSet) {
                    continue;
                  }
                  var binding = blocks[_i4].binding;
                  var _size2 = blockSizes[_i4];
                  _bufferViewInfo.buffer = this._rootBuffer;
                  _bufferViewInfo.offset = startOffsets[count++];
                  _bufferViewInfo.range = Math.ceil(_size2 / 16) * 16;
                  var bufferView = this._buffers[binding] = device.createBuffer(_bufferViewInfo);
                  this._blocks[binding] = new Float32Array(this._rootBlock, _bufferViewInfo.offset, _size2 / 4);
                  this._blocksInt[binding] = new Int32Array(this._blocks[binding].buffer, this._blocks[binding].byteOffset, this._blocks[binding].length);
                  this._descriptorSet.bindBuffer(binding, bufferView);
                }
              };
              _proto._syncBatchingScheme = function _syncBatchingScheme() {
                if (this._defines.USE_INSTANCING) {
                  if (this._device.hasFeature(1)) {
                    this._batchingScheme = 1;
                  } else {
                    this._defines.USE_INSTANCING = false;
                    this._batchingScheme = 0;
                  }
                } else {
                  this._batchingScheme = 0;
                }
              };
              _proto._getBlockView = function _getBlockView(type, binding) {
                return type < 13 ? this._blocksInt[binding] : this._blocks[binding];
              };
              _proto._initPassFromTarget = function _initPassFromTarget(target, dss, hashFactor) {
                this._priority = target.priority;
                this._stage = target.stage;
                this._phase = target.phase;
                this._phaseID = target._phaseID;
                this._passID = target._passID;
                this._batchingScheme = target.batchingScheme;
                this._primitive = target.primitive;
                this._dynamicStates = target.dynamicStates;
                this._bs = target.blendState;
                this._dss = dss;
                this._descriptorSet = target.descriptorSet;
                this._rs = target.rasterizerState;
                this._passIndex = target.passIndex;
                this._propertyIndex = target.propertyIndex;
                this._programName = target.program;
                this._defines = target.defines;
                this._shaderInfo = target._shaderInfo;
                this._properties = target._properties;
                this._blocks = target._blocks;
                this._blocksInt = target._blocksInt;
                this._dynamics = target._dynamics;
                this._shader = target._shader;
                if (cclegacy.rendering && cclegacy.rendering.enableEffectImport) {
                  this._pipelineLayout = cclegacy.rendering.programLib.getPipelineLayout(this.device, this._phaseID, this._programName);
                } else {
                  this._pipelineLayout = programLib$1.getTemplateInfo(this._programName).pipelineLayout;
                }
                this._hash = target._hash ^ hashFactor;
              };
              _proto._updatePassHash = function _updatePassHash() {
                this._hash = Pass.getPassHash(this);
              };
              _proto.setRootBufferDirty = function setRootBufferDirty(val) {
                this._rootBufferDirty = val;
              };
              _proto.setPriority = function setPriority(val) {
                this._priority = val;
              };
              _createClass(Pass, [{
                key: "_isBlend",
                get: function get() {
                  return this.blendState.targets.some(function (target) {
                    return target.blend;
                  });
                }
              }, {
                key: "root",
                get: function get() {
                  return this._root;
                }
              }, {
                key: "device",
                get: function get() {
                  return this._device;
                }
              }, {
                key: "shaderInfo",
                get: function get() {
                  return this._shaderInfo;
                }
              }, {
                key: "localSetLayout",
                get: function get() {
                  if (cclegacy.rendering && cclegacy.rendering.enableEffectImport) {
                    return cclegacy.rendering.programLib.getLocalDescriptorSetLayout(this._device, this._phaseID, this._programName);
                  } else {
                    return programLib$1.getDescriptorSetLayout(this._device, this._programName, true);
                  }
                }
              }, {
                key: "program",
                get: function get() {
                  return this._programName;
                }
              }, {
                key: "properties",
                get: function get() {
                  return this._properties;
                }
              }, {
                key: "defines",
                get: function get() {
                  return this._defines;
                }
              }, {
                key: "passIndex",
                get: function get() {
                  return this._passIndex;
                }
              }, {
                key: "propertyIndex",
                get: function get() {
                  return this._propertyIndex;
                }
              }, {
                key: "dynamics",
                get: function get() {
                  return this._dynamics;
                }
              }, {
                key: "blocks",
                get: function get() {
                  return this._blocks;
                }
              }, {
                key: "blocksInt",
                get: function get() {
                  return this._blocksInt;
                }
              }, {
                key: "rootBufferDirty",
                get: function get() {
                  return this._rootBufferDirty;
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                }
              }, {
                key: "primitive",
                get: function get() {
                  return this._primitive;
                }
              }, {
                key: "stage",
                get: function get() {
                  return this._stage;
                }
              }, {
                key: "phase",
                get: function get() {
                  return this._phase;
                }
              }, {
                key: "passID",
                get: function get() {
                  return this._passID;
                }
              }, {
                key: "phaseID",
                get: function get() {
                  return this._phaseID;
                }
              }, {
                key: "rasterizerState",
                get: function get() {
                  return this._rs;
                }
              }, {
                key: "depthStencilState",
                get: function get() {
                  return this._dss;
                }
              }, {
                key: "blendState",
                get: function get() {
                  return this._bs;
                }
              }, {
                key: "dynamicStates",
                get: function get() {
                  return this._dynamicStates;
                }
              }, {
                key: "batchingScheme",
                get: function get() {
                  return this._batchingScheme;
                }
              }, {
                key: "descriptorSet",
                get: function get() {
                  return this._descriptorSet;
                }
              }, {
                key: "hash",
                get: function get() {
                  return this._hash;
                }
              }, {
                key: "pipelineLayout",
                get: function get() {
                  return this._pipelineLayout;
                }
              }]);
              return Pass;
            }();
            Pass.getTypeFromHandle = getTypeFromHandle;
            Pass.getBindingFromHandle = getBindingFromHandle;
            Pass.getCountFromHandle = getCountFromHandle;
            Pass.getOffsetFromHandle = getOffsetFromHandle;
            function serializeBlendState(bs) {
              var res = ",bs," + bs.isA2C;
              bs.targets.forEach(function (t) {
                res += ",bt," + t.blend + "," + t.blendEq + "," + t.blendAlphaEq + "," + t.blendColorMask;
                res += "," + t.blendSrc + "," + t.blendDst + "," + t.blendSrcAlpha + "," + t.blendDstAlpha;
              });
              return res;
            }
            function serializeRasterizerState(rs) {
              return ",rs," + rs.cullMode + "," + rs.depthBias + "," + rs.isFrontFaceCCW;
            }
            function serializeDepthStencilState(dss) {
              var res = ",dss," + dss.depthTest + "," + dss.depthWrite + "," + dss.depthFunc;
              res += "," + dss.stencilTestFront + "," + dss.stencilFuncFront + "," + dss.stencilRefFront + "," + dss.stencilReadMaskFront;
              res += "," + dss.stencilFailOpFront + "," + dss.stencilZFailOpFront + "," + dss.stencilPassOpFront + "," + dss.stencilWriteMaskFront;
              res += "," + dss.stencilTestBack + "," + dss.stencilFuncBack + "," + dss.stencilRefBack + "," + dss.stencilReadMaskBack;
              res += "," + dss.stencilFailOpBack + "," + dss.stencilZFailOpBack + "," + dss.stencilPassOpBack + "," + dss.stencilWriteMaskBack;
              return res;
            }

            var PipelineStateManager = exports("PipelineStateManager", function () {
              function PipelineStateManager() {}
              PipelineStateManager.getOrCreatePipelineState = function getOrCreatePipelineState(device, pass, shader, renderPass, ia) {
                var hash1 = pass.hash;
                var hash2 = renderPass.hash;
                var hash3 = ia.attributesHash;
                var hash4 = shader.typedID;
                var newHash = hash1 ^ hash2 ^ hash3 ^ hash4;
                var pso = this._PSOHashMap.get(newHash);
                if (!pso) {
                  var pipelineLayout = pass.pipelineLayout;
                  var inputState = new InputState(ia.attributes);
                  var psoInfo = new PipelineStateInfo(shader, pipelineLayout, renderPass, inputState, pass.rasterizerState, pass.depthStencilState, pass.blendState, pass.primitive, pass.dynamicStates);
                  pso = device.createPipelineState(psoInfo);
                  this._PSOHashMap.set(newHash, pso);
                }
                return pso;
              };
              return PipelineStateManager;
            }());
            PipelineStateManager._PSOHashMap = new Map();

            new Viewport();
            new Rect$1();
            function SRGBToLinear(out, gamma) {
              out.x = gamma.x * gamma.x;
              out.y = gamma.y * gamma.y;
              out.z = gamma.z * gamma.z;
            }
            function decideProfilerCamera(cameras) {
              for (var i = cameras.length - 1; i >= 0; --i) {
                var camera = cameras[i];
                if (camera.window.swapchain) {
                  return;
                }
              }
            }

            var _dec$x, _dec2$o, _class$x, _class2$t, _initializer$s, _initializer2$o, _initializer3$i, _initializer4$e, _initializer5$d;
            var v4_1 = new Vec4();
            var Material = exports("Material", (_dec$x = ccclass$6('cc.Material'), _dec2$o = type$5(EffectAsset), _dec$x(_class$x = (_class2$t = function (_Asset) {
              _inheritsLoose(Material, _Asset);
              Material.getHash = function getHash(material) {
                var hash = 0;
                for (var _iterator = _createForOfIteratorHelperLoose(material.passes), _step; !(_step = _iterator()).done;) {
                  var pass = _step.value;
                  hash ^= pass.hash;
                }
                return hash;
              };
              function Material(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this._effectAsset = _initializer$s && _initializer$s();
                _this._techIdx = _initializer2$o && _initializer2$o();
                _this._defines = _initializer3$i && _initializer3$i();
                _this._states = _initializer4$e && _initializer4$e();
                _this._props = _initializer5$d && _initializer5$d();
                _this._passes = [];
                _this._hash = 0;
                return _this;
              }
              var _proto = Material.prototype;
              _proto.initialize = function initialize(info) {
                if (this._passes.length) {
                  warnID(12005);
                  return;
                }
                if (!this._defines) {
                  this._defines = [];
                }
                if (!this._states) {
                  this._states = [];
                }
                if (!this._props) {
                  this._props = [];
                }
                this._fillInfo(info);
                this._update();
              };
              _proto.reset = function reset(info) {
                this.initialize(info);
              };
              _proto.destroy = function destroy() {
                this._doDestroy();
                return _Asset.prototype.destroy.call(this);
              };
              _proto.recompileShaders = function recompileShaders(overrides, passIdx) {
                warnID(16370, this.name);
              };
              _proto.overridePipelineStates = function overridePipelineStates(overrides, passIdx) {
                warnID(16371, this.name);
              };
              _proto.onLoaded = function onLoaded() {
                this._update();
              };
              _proto.resetUniforms = function resetUniforms(clearPasses) {
                if (clearPasses === undefined) {
                  clearPasses = true;
                }
                this._props.length = this._passes.length;
                for (var i = 0; i < this._props.length; i++) {
                  this._props[i] = {};
                }
                if (!clearPasses) {
                  return;
                }
                for (var _iterator2 = _createForOfIteratorHelperLoose(this._passes), _step2; !(_step2 = _iterator2()).done;) {
                  var pass = _step2.value;
                  pass.resetUBOs();
                  pass.resetTextures();
                }
              };
              _proto.setProperty = function setProperty(name, val, passIdx) {
                var success = false;
                if (passIdx === undefined) {
                  var passes = this._passes;
                  var len = passes.length;
                  for (var i = 0; i < len; i++) {
                    var pass = passes[i];
                    if (this._uploadProperty(pass, name, val)) {
                      this._props[pass.propertyIndex][name] = val;
                      success = true;
                    }
                  }
                } else {
                  if (passIdx >= this._passes.length) {
                    warnID(16372, passIdx);
                  }
                  var _pass = this._passes[passIdx];
                  if (this._uploadProperty(_pass, name, val)) {
                    this._props[_pass.propertyIndex][name] = val;
                    success = true;
                  }
                }
                if (!success) {
                  warnID(16373, name);
                }
              };
              _proto.getProperty = function getProperty(name, passIdx) {
                if (passIdx === undefined) {
                  var propsArray = this._props;
                  var len = propsArray.length;
                  for (var i = 0; i < len; i++) {
                    var props = propsArray[i];
                    if (name in props) {
                      return props[name];
                    }
                  }
                } else {
                  if (passIdx >= this._passes.length) {
                    warnID(16372, passIdx);
                    return null;
                  }
                  var _props = this._props[this._passes[passIdx].propertyIndex];
                  if (name in _props) {
                    return _props[name];
                  }
                }
                return null;
              };
              _proto.copy = function copy(mat, overrides) {
                this._techIdx = mat._techIdx;
                this._props.length = mat._props.length;
                for (var i = 0; i < mat._props.length; i++) {
                  this._props[i] = _extends({}, mat._props[i]);
                }
                this._defines.length = mat._defines.length;
                for (var _i = 0; _i < mat._defines.length; _i++) {
                  this._defines[_i] = _extends({}, mat._defines[_i]);
                }
                this._states.length = mat._states.length;
                for (var _i2 = 0; _i2 < mat._states.length; _i2++) {
                  this._states[_i2] = _extends({}, mat._states[_i2]);
                }
                this._effectAsset = mat._effectAsset;
                if (overrides) this._fillInfo(overrides);
                this._update();
              };
              _proto._fillInfo = function _fillInfo(info) {
                if (info.technique !== undefined) {
                  this._techIdx = info.technique;
                }
                if (info.effectAsset) {
                  this._effectAsset = info.effectAsset;
                } else if (info.effectName) {
                  this._effectAsset = EffectAsset.get(info.effectName);
                }
                if (info.defines) {
                  this._prepareInfo(info.defines, this._defines);
                }
                if (info.states) {
                  this._prepareInfo(info.states, this._states);
                }
              };
              _proto._prepareInfo = function _prepareInfo(patch, cur) {
                var patchArray = patch;
                if (!Array.isArray(patchArray)) {
                  var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                  patchArray = Array(len).fill(patchArray);
                }
                for (var i = 0; i < patchArray.length; ++i) {
                  Object.assign(cur[i] || (cur[i] = {}), patchArray[i]);
                }
              };
              _proto._createPasses = function _createPasses() {
                var tech = this._effectAsset.techniques[this._techIdx || 0];
                if (!tech) {
                  return [];
                }
                var passNum = tech.passes.length;
                var passes = [];
                for (var k = 0; k < passNum; ++k) {
                  var passInfo = tech.passes[k];
                  var propIdx = passInfo.passIndex = k;
                  var defines = passInfo.defines = this._defines[propIdx] || (this._defines[propIdx] = {});
                  passInfo.stateOverrides = this._states[propIdx] || (this._states[propIdx] = {});
                  if (passInfo.propertyIndex !== undefined) {
                    Object.assign(defines, this._defines[passInfo.propertyIndex]);
                  }
                  if (passInfo.embeddedMacros !== undefined) {
                    Object.assign(defines, passInfo.embeddedMacros);
                  }
                  if (passInfo["switch"] && !defines[passInfo["switch"]]) {
                    continue;
                  }
                  var pass = new Pass(cclegacy.director.root);
                  pass.initialize(passInfo);
                  passes.push(pass);
                }
                return passes;
              };
              _proto._update = function _update(keepProps) {
                var _this2 = this;
                if (keepProps === undefined) {
                  keepProps = true;
                }
                if (this._effectAsset) {
                  this._passes = this._createPasses();
                  var totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
                  this._props.length = totalPasses;
                  if (keepProps) {
                    this._passes.forEach(function (pass, i) {
                      var props = _this2._props[i];
                      if (!props) {
                        props = _this2._props[i] = {};
                      }
                      if (pass.propertyIndex !== undefined) {
                        Object.assign(props, _this2._props[pass.propertyIndex]);
                      }
                      for (var p in props) {
                        _this2._uploadProperty(pass, p, props[p]);
                      }
                    });
                  } else {
                    for (var i = 0; i < this._props.length; i++) {
                      this._props[i] = {};
                    }
                  }
                }
                this._hash = Material.getHash(this);
              };
              _proto._uploadProperty = function _uploadProperty(pass, name, val) {
                var _this3 = this;
                var handle = pass.getHandle(name);
                if (!handle) {
                  return false;
                }
                var type = getTypeFromHandle(handle);
                if (type < 26) {
                  if (Array.isArray(val)) {
                    pass.setUniformArray(handle, val);
                  } else if (val !== null) {
                    var _pass$properties$name;
                    if ((_pass$properties$name = pass.properties[name]) != null && _pass$properties$name.linear) {
                      var v4 = val;
                      SRGBToLinear(v4_1, v4);
                      v4_1.w = v4.w;
                      val = v4_1;
                    }
                    pass.setUniform(handle, val);
                  } else {
                    pass.resetUniform(name);
                  }
                } else if (Array.isArray(val)) {
                  val.forEach(function (v, i) {
                    _this3._bindTexture(pass, handle, v, i);
                  });
                } else if (val) {
                  this._bindTexture(pass, handle, val);
                } else {
                  pass.resetTexture(name);
                }
                return true;
              };
              _proto._bindTexture = function _bindTexture(pass, handle, val, index) {
                var binding = Pass.getBindingFromHandle(handle);
                if (val instanceof Texture) {
                  pass.bindTexture(binding, val, index);
                } else if (val instanceof TextureBase) {
                  var texture = val.getGFXTexture();
                  if (!texture || !texture.width || !texture.height) {
                    return;
                  }
                  pass.bindTexture(binding, texture, index);
                  pass.bindSampler(binding, val.getGFXSampler(), index);
                }
              };
              _proto._doDestroy = function _doDestroy() {
                if (this._passes && this._passes.length) {
                  for (var _iterator3 = _createForOfIteratorHelperLoose(this._passes), _step3; !(_step3 = _iterator3()).done;) {
                    var pass = _step3.value;
                    pass.destroy();
                  }
                }
                this._passes.length = 0;
              };
              _proto.initDefault = function initDefault(uuid) {
                _Asset.prototype.initDefault.call(this, uuid);
                this.initialize({
                  effectName: 'builtin-unlit',
                  defines: {
                    USE_COLOR: true
                  },
                  technique: 0
                });
                this.setProperty('mainColor', new Color('#ff00ff'));
              };
              _proto.validate = function validate() {
                return !!this._effectAsset && !this._effectAsset.isDefault && this.passes.length > 0;
              };
              _createClass(Material, [{
                key: "effectAsset",
                get: function get() {
                  return this._effectAsset;
                }
              }, {
                key: "effectName",
                get: function get() {
                  return this._effectAsset ? this._effectAsset.name : '';
                }
              }, {
                key: "technique",
                get: function get() {
                  return this._techIdx;
                }
              }, {
                key: "passes",
                get: function get() {
                  return this._passes;
                }
              }, {
                key: "hash",
                get: function get() {
                  return this._hash;
                }
              }, {
                key: "parent",
                get: function get() {
                  return null;
                }
              }, {
                key: "owner",
                get: function get() {
                  return null;
                }
              }]);
              return Material;
            }(Asset), (_initializer$s = applyDecoratedInitializer(_class2$t.prototype, "_effectAsset", [_dec2$o], function () {
              return null;
            }), _initializer2$o = applyDecoratedInitializer(_class2$t.prototype, "_techIdx", [serializable$5], function () {
              return 0;
            }), _initializer3$i = applyDecoratedInitializer(_class2$t.prototype, "_defines", [serializable$5], function () {
              return [];
            }), _initializer4$e = applyDecoratedInitializer(_class2$t.prototype, "_states", [serializable$5], function () {
              return [];
            }), _initializer5$d = applyDecoratedInitializer(_class2$t.prototype, "_props", [serializable$5], function () {
              return [];
            })), _class2$t)) || _class$x));
            cclegacy.Material = Material;

            var ShadowSize = Enum({
              Low_256x256: 256,
              Medium_512x512: 512,
              High_1024x1024: 1024,
              Ultra_2048x2048: 2048
            });
            var ShadowType = Enum({
              Planar: 0,
              ShadowMap: 1
            });
            var PCFType = Enum({
              HARD: 0,
              SOFT: 1,
              SOFT_2X: 2,
              SOFT_4X: 3
            });
            var CSMLevel = Enum({
              LEVEL_1: 1,
              LEVEL_2: 2,
              LEVEL_3: 3,
              LEVEL_4: 4
            });
            var CSMOptimizationMode = Enum({
              NONE: 1,
              RemoveDuplicates: 2,
              DisableRotationFix: 3
            });
            var SHADOW_TYPE_NONE = ShadowType.ShadowMap + 1;
            var Shadows = function () {
              function Shadows() {
                this.fixedSphere = new Sphere(0.0, 0.0, 0.0, 0.01);
                this.maxReceived = 4;
                this._matLight = new Mat4();
                this._material = null;
                this._instancingMaterial = null;
                this._enabled = false;
                this._type = SHADOW_TYPE_NONE;
                this._distance = 0;
                this._planeBias = 1.0;
                this._normal = new Vec3(0, 1, 0);
                this._shadowColor = new Color(0, 0, 0, 76);
                this._size = new Vec2(1024, 1024);
                this._shadowMapDirty = false;
              }
              var _proto = Shadows.prototype;
              _proto.getPlanarShader = function getPlanarShader(patches) {
                if (!this._material) {
                  this._material = new Material();
                  this._material.initialize({
                    effectName: 'pipeline/planar-shadow'
                  });
                }
                var passes = this._material.passes;
                {
                  assert(passes.length > 0, 'passes should not be empty!');
                }
                return passes.length > 0 ? passes[0].getShaderVariant(patches) : null;
              };
              _proto.initialize = function initialize(shadowsInfo) {
                this._enabled = shadowsInfo.enabled;
                this._type = this.enabled ? shadowsInfo.type : SHADOW_TYPE_NONE;
                this.normal = shadowsInfo.planeDirection;
                this.distance = shadowsInfo.planeHeight;
                this.planeBias = shadowsInfo.planeBias;
                this.shadowColor = shadowsInfo.shadowColor;
                this.maxReceived = shadowsInfo.maxReceived;
                if (shadowsInfo.shadowMapSize !== this._size.x) {
                  this.size.set(shadowsInfo.shadowMapSize, shadowsInfo.shadowMapSize);
                  this._shadowMapDirty = true;
                }
              };
              _proto.activate = function activate() {
                if (this._enabled) {
                  if (this.type === ShadowType.Planar) {
                    this._updatePlanarInfo();
                  } else {
                    var root = cclegacy.director.root;
                    var pipeline = root.pipeline;
                    pipeline.macros.CC_SHADOW_TYPE = 2;
                    root.onGlobalPipelineStateChanged();
                  }
                } else {
                  var _root = cclegacy.director.root;
                  var _pipeline = _root.pipeline;
                  _pipeline.macros.CC_SHADOW_TYPE = 0;
                  _root.onGlobalPipelineStateChanged();
                }
              };
              _proto._updatePlanarInfo = function _updatePlanarInfo() {
                if (!this._material) {
                  this._material = new Material();
                  this._material.initialize({
                    effectName: 'pipeline/planar-shadow'
                  });
                }
                var root = cclegacy.director.root;
                var pipeline = root.pipeline;
                pipeline.macros.CC_SHADOW_TYPE = 1;
                root.onGlobalPipelineStateChanged();
              };
              _proto.destroy = function destroy() {
                if (this._material) {
                  this._material.destroy();
                }
                if (this._instancingMaterial) {
                  this._instancingMaterial.destroy();
                }
                this.fixedSphere.destroy();
              };
              _createClass(Shadows, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                  this.activate();
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(val) {
                  this._type = this.enabled ? val : SHADOW_TYPE_NONE;
                  this.activate();
                }
              }, {
                key: "normal",
                get: function get() {
                  return this._normal;
                },
                set: function set(val) {
                  Vec3.copy(this._normal, val);
                }
              }, {
                key: "distance",
                get: function get() {
                  return this._distance;
                },
                set: function set(val) {
                  this._distance = val;
                }
              }, {
                key: "planeBias",
                get: function get() {
                  return this._planeBias;
                },
                set: function set(val) {
                  this._planeBias = val;
                }
              }, {
                key: "shadowColor",
                get: function get() {
                  return this._shadowColor;
                },
                set: function set(color) {
                  this._shadowColor = color;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(val) {
                  this._size.set(val);
                }
              }, {
                key: "shadowMapDirty",
                get: function get() {
                  return this._shadowMapDirty;
                },
                set: function set(val) {
                  this._shadowMapDirty = val;
                }
              }, {
                key: "matLight",
                get: function get() {
                  return this._matLight;
                }
              }, {
                key: "material",
                get: function get() {
                  return this._material;
                }
              }, {
                key: "instancingMaterial",
                get: function get() {
                  return this._instancingMaterial;
                }
              }]);
              return Shadows;
            }();
            Shadows.MAX_FAR = 2000.0;
            Shadows.COEFFICIENT_OF_EXPANSION = 2.0 * Math.sqrt(3.0);
            cclegacy.Shadows = Shadows;

            var PassInstance = function (_Pass) {
              _inheritsLoose(PassInstance, _Pass);
              function PassInstance(parent, owner) {
                var _this;
                _this = _Pass.call(this, parent.root) || this;
                _this._dontNotify = false;
                _this._parent = parent;
                _this._owner = owner;
                _this._doInit(_this._parent, true);
                _this._shaderInfo.blocks.forEach(function (u) {
                  var block = _this._blocks[u.binding];
                  var parentBlock = _this._parent.blocks[u.binding];
                  block.set(parentBlock);
                });
                _this._rootBufferDirty = true;
                var parentInstance = _this._parent;
                var thisDescriptorSet = _this._descriptorSet;
                _this._shaderInfo.samplerTextures.forEach(function (u) {
                  for (var j = 0; j < u.count; j++) {
                    var parentDescriptorSet = parentInstance._descriptorSet;
                    var binding = u.binding;
                    var sampler = parentDescriptorSet.getSampler(binding, j);
                    var texture = parentDescriptorSet.getTexture(binding, j);
                    thisDescriptorSet.bindSampler(binding, sampler, j);
                    thisDescriptorSet.bindTexture(binding, texture, j);
                  }
                });
                _Pass.prototype.tryCompile.call(_assertThisInitialized(_this));
                return _this;
              }
              var _proto = PassInstance.prototype;
              _proto.overridePipelineStates = function overridePipelineStates(original, overrides) {
                this._bs.reset();
                this._rs.reset();
                this._dss.reset();
                Pass.fillPipelineInfo(this, original);
                Pass.fillPipelineInfo(this, overrides);
                this._onStateChange();
              };
              _proto.tryCompile = function tryCompile(defineOverrides) {
                if (defineOverrides) {
                  if (!overrideMacros(this._defines, defineOverrides)) {
                    return false;
                  }
                }
                var res = _Pass.prototype.tryCompile.call(this);
                this._onStateChange();
                return res;
              };
              _proto.beginChangeStatesSilently = function beginChangeStatesSilently() {
                this._dontNotify = true;
              };
              _proto.endChangeStatesSilently = function endChangeStatesSilently() {
                this._dontNotify = false;
              };
              _proto._syncBatchingScheme = function _syncBatchingScheme() {
                this._defines.USE_INSTANCING = false;
                this._batchingScheme = 0;
              };
              _proto._onStateChange = function _onStateChange() {
                this._hash = Pass.getPassHash(this);
                this._owner.onPassStateChange(this._dontNotify);
              };
              _createClass(PassInstance, [{
                key: "parent",
                get: function get() {
                  return this._parent;
                }
              }]);
              return PassInstance;
            }(Pass);

            var MaterialInstance = function (_Material) {
              _inheritsLoose(MaterialInstance, _Material);
              function MaterialInstance(info) {
                var _this;
                _this = _Material.call(this) || this;
                _this._passes = [];
                _this._subModelIdx = 0;
                _this._parent = info.parent;
                _this._owner = info.owner || null;
                _this._subModelIdx = info.subModelIdx || 0;
                _this.copy(_this._parent);
                return _this;
              }
              var _proto = MaterialInstance.prototype;
              _proto.recompileShaders = function recompileShaders(overrides, passIdx) {
                if (!this._passes || !this.effectAsset) {
                  return;
                }
                if (passIdx === undefined) {
                  this._passes.forEach(function (pass) {
                    pass.tryCompile(overrides);
                  });
                } else {
                  this._passes[passIdx].tryCompile(overrides);
                }
              };
              _proto.overridePipelineStates = function overridePipelineStates(overrides, passIdx) {
                if (!this._passes || !this.effectAsset) {
                  return;
                }
                var passInfos = this.effectAsset.techniques[this.technique].passes;
                if (passIdx === undefined) {
                  for (var i = 0; i < this._passes.length; i++) {
                    var pass = this._passes[i];
                    var state = this._states[i] || (this._states[i] = {});
                    for (var key in overrides) {
                      state[key] = overrides[key];
                    }
                    pass.overridePipelineStates(passInfos[pass.passIndex], state);
                  }
                } else {
                  var _state = this._states[passIdx] || (this._states[passIdx] = {});
                  for (var _key in overrides) {
                    _state[_key] = overrides[_key];
                  }
                  this._passes[passIdx].overridePipelineStates(passInfos[passIdx], _state);
                }
              };
              _proto.destroy = function destroy() {
                this._doDestroy();
                return true;
              };
              _proto.onPassStateChange = function onPassStateChange(dontNotify) {
                this._hash = Material.getHash(this);
                if (!dontNotify && this._owner) {
                  this._owner._onRebuildPSO(this._subModelIdx, this);
                }
              };
              _proto._createPasses = function _createPasses() {
                var passes = [];
                var parentPasses = this._parent.passes;
                if (!parentPasses) {
                  return passes;
                }
                for (var k = 0; k < parentPasses.length; ++k) {
                  passes.push(new PassInstance(parentPasses[k], this));
                }
                return passes;
              };
              _createClass(MaterialInstance, [{
                key: "parent",
                get: function get() {
                  return this._parent;
                }
              }, {
                key: "owner",
                get: function get() {
                  return this._owner;
                }
              }]);
              return MaterialInstance;
            }(Material);

            var skybox_mesh = null;
            var skybox_material = null;
            var EnvironmentLightingType = {
              HEMISPHERE_DIFFUSE: 0,
              AUTOGEN_HEMISPHERE_DIFFUSE_WITH_REFLECTION: 1,
              DIFFUSEMAP_WITH_REFLECTION: 2
            };
            Enum(EnvironmentLightingType);
            var Skybox = function () {
              function Skybox() {
                this._envmapLDR = null;
                this._envmapHDR = null;
                this._diffuseMapLDR = null;
                this._diffuseMapHDR = null;
                this._globalDSManager = null;
                this._model = null;
                this._default = null;
                this._enabled = false;
                this._useIBL = false;
                this._useHDR = true;
                this._useDiffuseMap = false;
                this._editableMaterial = null;
                this._activated = false;
                this._reflectionHDR = null;
                this._reflectionLDR = null;
                this._rotationAngle = 0;
              }
              var _proto = Skybox.prototype;
              _proto.initialize = function initialize(skyboxInfo) {
                this._activated = false;
                this._enabled = skyboxInfo.enabled;
                this._useIBL = skyboxInfo.useIBL;
                this._useDiffuseMap = skyboxInfo.applyDiffuseMap;
                this._useHDR = skyboxInfo.useHDR;
              };
              _proto.setEnvMaps = function setEnvMaps(envmapHDR, envmapLDR) {
                this._envmapHDR = envmapHDR;
                this._envmapLDR = envmapLDR;
                this._updateGlobalBinding();
                this._updatePipeline();
              };
              _proto.setDiffuseMaps = function setDiffuseMaps(diffuseMapHDR, diffuseMapLDR) {
                this._diffuseMapHDR = diffuseMapHDR;
                this._diffuseMapLDR = diffuseMapLDR;
                this._updateGlobalBinding();
                this._updatePipeline();
              };
              _proto.setSkyboxMaterial = function setSkyboxMaterial(skyboxMat) {
                if (skyboxMat) {
                  this._editableMaterial = new MaterialInstance({
                    parent: skyboxMat
                  });
                  this._editableMaterial.recompileShaders({
                    USE_RGBE_CUBEMAP: this.isRGBE
                  });
                } else {
                  this._editableMaterial = null;
                }
                this._updatePipeline();
              };
              _proto.setReflectionMaps = function setReflectionMaps(reflectionHDR, reflectionLDR) {
                this._reflectionHDR = reflectionHDR;
                this._reflectionLDR = reflectionLDR;
                this._updateGlobalBinding();
                this._updatePipeline();
              };
              _proto.setRotationAngle = function setRotationAngle(angle) {
                this._rotationAngle = angle;
              };
              _proto.getRotationAngle = function getRotationAngle() {
                return this._rotationAngle;
              };
              _proto.updateMaterialRenderInfo = function updateMaterialRenderInfo() {
                this._updateGlobalBinding();
                this._updatePipeline();
              };
              _proto.activate = function activate() {
                var pipeline = cclegacy.director.root.pipeline;
                this._globalDSManager = pipeline.globalDSManager;
                this._default = builtinResMgr.get('default-cube-texture');
                if (!this._model) {
                  this._model = cclegacy.director.root.createModel(cclegacy.renderer.scene.Model);
                }
                var isRGBE = this._default.isRGBE;
                this._default.isUsingOfflineMipmaps();
                if (this.envmap) {
                  isRGBE = this.envmap.isRGBE;
                  this.envmap.isUsingOfflineMipmaps();
                }
                if (!skybox_material) {
                  var mat = new Material();
                  mat.initialize({
                    effectName: 'pipeline/skybox',
                    defines: {
                      USE_RGBE_CUBEMAP: isRGBE
                    }
                  });
                  skybox_material = new MaterialInstance({
                    parent: mat
                  });
                }
                if (this.enabled) {
                  if (!skybox_mesh) {
                    skybox_mesh = cclegacy.utils.createMesh(cclegacy.primitives.box({
                      width: 2,
                      height: 2,
                      length: 2
                    }));
                  }
                  if (this._editableMaterial) {
                    this._model.initSubModel(0, skybox_mesh.renderingSubMeshes[0], this._editableMaterial);
                  } else {
                    this._model.initSubModel(0, skybox_mesh.renderingSubMeshes[0], skybox_material);
                  }
                }
                if (!this.envmap) {
                  this.envmap = this._default;
                }
                if (!this.diffuseMap) {
                  this.diffuseMap = this._default;
                }
                this._updateGlobalBinding();
                this._updatePipeline();
                this._activated = true;
              };
              _proto._updatePipeline = function _updatePipeline() {
                var root = cclegacy.director.root;
                var pipeline = root.pipeline;
                var useIBLValue = this.useIBL ? this.isRGBE ? 2 : 1 : 0;
                var useDiffuseMapValue = this.useIBL && this.useDiffuseMap && this.diffuseMap && this.diffuseMap !== this._default ? this.isRGBE ? 2 : 1 : 0;
                var useHDRValue = this.useHDR;
                var useConvMapValue = this.useConvolutionMap;
                if (pipeline.macros.CC_USE_IBL !== useIBLValue || pipeline.macros.CC_USE_DIFFUSEMAP !== useDiffuseMapValue || pipeline.macros.CC_USE_HDR !== useHDRValue || pipeline.macros.CC_IBL_CONVOLUTED !== useConvMapValue) {
                  pipeline.macros.CC_USE_IBL = useIBLValue;
                  pipeline.macros.CC_USE_DIFFUSEMAP = useDiffuseMapValue;
                  pipeline.macros.CC_USE_HDR = useHDRValue;
                  pipeline.macros.CC_IBL_CONVOLUTED = useConvMapValue;
                  if (this._activated) {
                    root.onGlobalPipelineStateChanged();
                  }
                }
                if (this.enabled) {
                  var envmap = this.envmap ? this.envmap : this._default;
                  var skyboxMat = this._editableMaterial ? this._editableMaterial : skybox_material;
                  if (skyboxMat) {
                    skyboxMat.setProperty('environmentMap', envmap);
                    skyboxMat.recompileShaders({
                      USE_RGBE_CUBEMAP: this.isRGBE
                    });
                  }
                  if (this._model) {
                    this._model.setSubModelMaterial(0, skyboxMat);
                    this._updateSubModes();
                  }
                }
              };
              _proto._updateGlobalBinding = function _updateGlobalBinding() {
                if (cclegacy.rendering) {
                  return;
                }
                if (this._globalDSManager) {
                  var device = deviceManager.gfxDevice;
                  if (this.reflectionMap) {
                    var texture = this.reflectionMap.getGFXTexture();
                    var sampler = device.getSampler(this.reflectionMap.getSamplerInfo());
                    this._globalDSManager.bindSampler(UNIFORM_ENVIRONMENT_BINDING, sampler);
                    this._globalDSManager.bindTexture(UNIFORM_ENVIRONMENT_BINDING, texture);
                  } else {
                    var envmap = this.envmap ? this.envmap : this._default;
                    if (envmap) {
                      var _texture = envmap.getGFXTexture();
                      var _sampler = device.getSampler(envmap.getSamplerInfo());
                      this._globalDSManager.bindSampler(UNIFORM_ENVIRONMENT_BINDING, _sampler);
                      this._globalDSManager.bindTexture(UNIFORM_ENVIRONMENT_BINDING, _texture);
                    }
                  }
                  var diffuseMap = this.diffuseMap ? this.diffuseMap : this._default;
                  if (diffuseMap) {
                    var _texture2 = diffuseMap.getGFXTexture();
                    var _sampler2 = device.getSampler(diffuseMap.getSamplerInfo());
                    this._globalDSManager.bindSampler(UNIFORM_DIFFUSEMAP_BINDING, _sampler2);
                    this._globalDSManager.bindTexture(UNIFORM_DIFFUSEMAP_BINDING, _texture2);
                  }
                  this._globalDSManager.update();
                }
              };
              _proto._updateSubModes = function _updateSubModes() {
                if (this._model) {
                  var subModels = this._model.subModels;
                  for (var i = 0; i < subModels.length; i++) {
                    subModels[i].update();
                  }
                }
              };
              _createClass(Skybox, [{
                key: "model",
                get: function get() {
                  return this._model;
                }
              }, {
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                  if (val) this.activate();else this._updatePipeline();
                }
              }, {
                key: "useHDR",
                get: function get() {
                  return this._useHDR;
                },
                set: function set(val) {
                  this._useHDR = val;
                  this.setEnvMaps(this._envmapHDR, this._envmapLDR);
                }
              }, {
                key: "useIBL",
                get: function get() {
                  return this._useIBL;
                },
                set: function set(val) {
                  this._useIBL = val;
                  this._updatePipeline();
                }
              }, {
                key: "useDiffuseMap",
                get: function get() {
                  return this._useDiffuseMap;
                },
                set: function set(val) {
                  this._useDiffuseMap = val;
                  this._updatePipeline();
                }
              }, {
                key: "isRGBE",
                get: function get() {
                  if (this.envmap) {
                    return this.envmap.isRGBE;
                  } else {
                    return false;
                  }
                }
              }, {
                key: "useConvolutionMap",
                get: function get() {
                  if (this.reflectionMap) {
                    return this.reflectionMap.isUsingOfflineMipmaps();
                  }
                  if (this.envmap) {
                    return this.envmap.isUsingOfflineMipmaps();
                  }
                  return false;
                }
              }, {
                key: "envmap",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._envmapHDR;
                  } else {
                    return this._envmapLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this.setEnvMaps(val, this._envmapLDR);
                  } else {
                    this.setEnvMaps(this._envmapHDR, val);
                  }
                }
              }, {
                key: "diffuseMap",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._diffuseMapHDR;
                  } else {
                    return this._diffuseMapLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this.setDiffuseMaps(val, this._diffuseMapLDR);
                  } else {
                    this.setDiffuseMaps(this._diffuseMapHDR, val);
                  }
                }
              }, {
                key: "reflectionMap",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._reflectionHDR;
                  } else {
                    return this._reflectionLDR;
                  }
                }
              }, {
                key: "editableMaterial",
                get: function get() {
                  return this._editableMaterial;
                }
              }]);
              return Skybox;
            }();
            cclegacy.Skybox = Skybox;

            var _v4$1 = new Vec4();
            var FogType = Enum({
              LINEAR: 0,
              EXP: 1,
              EXP_SQUARED: 2,
              LAYERED: 3
            });
            var FOG_TYPE_NONE = FogType.LAYERED + 1;
            var Fog = function () {
              function Fog() {
                this._fogColor = new Color('#C8C8C8');
                this._colorArray = new Vec4(0.2, 0.2, 0.2, 1.0);
                this._enabled = false;
                this._accurate = false;
                this._type = 0;
                this._fogDensity = 0.3;
                this._fogStart = 0.5;
                this._fogEnd = 300;
                this._fogAtten = 5;
                this._fogTop = 1.5;
                this._fogRange = 1.2;
                this._activated = false;
              }
              var _proto = Fog.prototype;
              _proto.initialize = function initialize(fogInfo) {
                this._activated = false;
                this.fogColor = fogInfo.fogColor;
                this._enabled = fogInfo.enabled;
                this._type = this.enabled ? fogInfo.type : FOG_TYPE_NONE;
                this._accurate = fogInfo.accurate;
                this.fogDensity = fogInfo.fogDensity;
                this.fogStart = fogInfo.fogStart;
                this.fogEnd = fogInfo.fogEnd;
                this.fogAtten = fogInfo.fogAtten;
                this.fogTop = fogInfo.fogTop;
                this.fogRange = fogInfo.fogRange;
              };
              _proto.activate = function activate() {
                this._updatePipeline();
                this._activated = true;
              };
              _proto._updatePipeline = function _updatePipeline() {
                var root = cclegacy.director.root;
                var value = this.enabled ? this.type : FOG_TYPE_NONE;
                var accurateValue = this.accurate ? 1 : 0;
                var pipeline = root.pipeline;
                if (pipeline.macros.CC_USE_FOG === value && pipeline.macros.CC_USE_ACCURATE_FOG === accurateValue) {
                  return;
                }
                pipeline.macros.CC_USE_FOG = value;
                pipeline.macros.CC_USE_ACCURATE_FOG = accurateValue;
                if (this._activated) {
                  root.onGlobalPipelineStateChanged();
                }
              };
              _createClass(Fog, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                  if (!val) {
                    this._type = FOG_TYPE_NONE;
                    this._updatePipeline();
                  } else {
                    this.activate();
                  }
                }
              }, {
                key: "accurate",
                get: function get() {
                  return this._accurate;
                },
                set: function set(val) {
                  this._accurate = val;
                  this._updatePipeline();
                }
              }, {
                key: "fogColor",
                get: function get() {
                  return this._fogColor;
                },
                set: function set(val) {
                  this._fogColor.set(val);
                  _v4$1.set(val.x, val.y, val.z, val.w);
                  SRGBToLinear(this._colorArray, _v4$1);
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(val) {
                  this._type = this.enabled ? val : FOG_TYPE_NONE;
                  if (this.enabled) this._updatePipeline();
                }
              }, {
                key: "fogDensity",
                get: function get() {
                  return this._fogDensity;
                },
                set: function set(val) {
                  this._fogDensity = val;
                }
              }, {
                key: "fogStart",
                get: function get() {
                  return this._fogStart;
                },
                set: function set(val) {
                  this._fogStart = val;
                }
              }, {
                key: "fogEnd",
                get: function get() {
                  return this._fogEnd;
                },
                set: function set(val) {
                  this._fogEnd = val;
                }
              }, {
                key: "fogAtten",
                get: function get() {
                  return this._fogAtten;
                },
                set: function set(val) {
                  this._fogAtten = val;
                }
              }, {
                key: "fogTop",
                get: function get() {
                  return this._fogTop;
                },
                set: function set(val) {
                  this._fogTop = val;
                }
              }, {
                key: "fogRange",
                get: function get() {
                  return this._fogRange;
                },
                set: function set(val) {
                  this._fogRange = val;
                }
              }, {
                key: "colorArray",
                get: function get() {
                  return this._colorArray;
                }
              }]);
              return Fog;
            }();
            cclegacy.Fog = Fog;

            var ToneMappingType = Enum({
              DEFAULT: 0,
              LINEAR: 1
            });
            var PostSettings = function () {
              function PostSettings() {
                this._toneMappingType = ToneMappingType.DEFAULT;
                this._activated = false;
              }
              var _proto = PostSettings.prototype;
              _proto.initialize = function initialize(postSettingsInfo) {
                this._toneMappingType = postSettingsInfo.toneMappingType;
              };
              _proto.activate = function activate() {
                this._updatePipeline();
                this._activated = true;
              };
              _proto._updatePipeline = function _updatePipeline() {
                var root = cclegacy.director.root;
                var pipeline = root.pipeline;
                pipeline.macros.CC_TONE_MAPPING_TYPE = this._toneMappingType;
                if (this._activated) {
                  root.onGlobalPipelineStateChanged();
                }
              };
              _createClass(PostSettings, [{
                key: "toneMappingType",
                get: function get() {
                  return this._toneMappingType;
                },
                set: function set(val) {
                  this._toneMappingType = val;
                  this._updatePipeline();
                }
              }]);
              return PostSettings;
            }();

            var _dec$w, _dec2$n, _dec3$l, _dec4$e, _dec5$b, _class$w, _class2$s, _initializer$r, _initializer2$n, _initializer3$h, _initializer4$d, _initializer5$c, _initializer6$9, _dec6$b, _dec7$9, _dec8$8, _dec9$7, _dec10$6, _dec11$4, _dec12$4, _dec13$3, _dec14$3, _dec15$3, _dec16$2, _dec17$2, _dec18$2, _dec19$2, _dec20$2, _class4$5, _class5$5, _initializer7$8, _initializer8$8, _initializer9$7, _initializer10$6, _initializer11$5, _initializer12$4, _initializer13$4, _initializer14$4, _initializer15$4, _initializer16$4, _initializer17$4, _dec21$2, _dec22$2, _dec23$2, _dec24$2, _dec25$2, _dec26$2, _dec27$2, _dec28$2, _class7$1, _class8$1, _initializer18$4, _initializer19$4, _initializer20$3, _initializer21$3, _initializer22$2, _initializer23$1, _initializer24$1, _initializer25$1, _initializer26$1, _initializer27, _class9, _dec29$1, _dec30$1, _dec31$1, _dec32$1, _dec33$1, _dec34$1, _class10$1, _class11$1, _initializer28, _initializer29, _initializer30, _initializer31, _initializer32, _initializer33, _initializer34, _initializer35, _dec35$1, _dec36$1, _class13$1, _class14$1, _initializer36, _initializer37, _initializer38, _initializer39, _dec37$1, _dec38$1, _dec39$1, _class16$1, _class17$1, _initializer40, _initializer41, _initializer42, _dec40, _dec41, _class19$1, _class20$1, _initializer43, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _class22$1, _class23$1, _initializer44, _initializer45, _initializer46, _initializer47, _initializer48, _initializer49, _initializer50, _initializer51, _initializer52, _dec48, _dec49, _class25, _class26, _initializer53, _initializer54, _initializer55, _initializer56, _initializer57, _initializer58, _initializer59, _initializer60, _initializer61, _initializer62;
            var _up = new Vec3(0, 1, 0);
            var _v3$1 = new Vec3();
            var _v4 = new Vec4();
            var _col = new Color();
            var _qt$1 = new Quat();
            var normalizeHDRColor = function normalizeHDRColor(color) {
              var intensity = 1.0 / Math.max(Math.max(Math.max(color.x, color.y), color.z), 0.0001);
              if (intensity < 1.0) {
                color.x *= intensity;
                color.y *= intensity;
                color.z *= intensity;
              }
            };
            var AmbientInfo = exports("AmbientInfo", (_dec$w = ccclass$6('cc.AmbientInfo'), _dec2$n = type$5(CCFloat), _dec3$l = formerlySerializedAs$3('_skyColor'), _dec4$e = formerlySerializedAs$3('_skyIllum'), _dec5$b = formerlySerializedAs$3('_groundAlbedo'), _dec$w(_class$w = (_class2$s = function () {
              function AmbientInfo() {
                this._skyColorHDR = _initializer$r && _initializer$r();
                this._skyIllumHDR = _initializer2$n && _initializer2$n();
                this._groundAlbedoHDR = _initializer3$h && _initializer3$h();
                this._skyColorLDR = _initializer4$d && _initializer4$d();
                this._skyIllumLDR = _initializer5$c && _initializer5$c();
                this._groundAlbedoLDR = _initializer6$9 && _initializer6$9();
                this._resource = null;
              }
              var _proto = AmbientInfo.prototype;
              _proto.activate = function activate(resource) {
                this._resource = resource;
                resource.initialize(this);
              };
              _createClass(AmbientInfo, [{
                key: "skyColorHDR",
                get: function get() {
                  return this._skyColorHDR;
                }
              }, {
                key: "groundAlbedoHDR",
                get: function get() {
                  return this._groundAlbedoHDR;
                }
              }, {
                key: "skyIllumHDR",
                get: function get() {
                  return this._skyIllumHDR;
                }
              }, {
                key: "skyColorLDR",
                get: function get() {
                  return this._skyColorLDR;
                }
              }, {
                key: "groundAlbedoLDR",
                get: function get() {
                  return this._groundAlbedoLDR;
                }
              }, {
                key: "skyIllumLDR",
                get: function get() {
                  return this._skyIllumLDR;
                }
              }, {
                key: "skyLightingColor",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  _v4.set(isHDR ? this._skyColorHDR : this._skyColorLDR);
                  normalizeHDRColor(_v4);
                  return _col.set(_v4.x * 255, _v4.y * 255, _v4.z * 255, 255);
                },
                set: function set(val) {
                  _v4.set(val.x, val.y, val.z, val.w);
                  if (getPipelineSceneData().isHDR) {
                    this._skyColorHDR.set(_v4);
                  } else {
                    this._skyColorLDR.set(_v4);
                  }
                  if (this._resource) {
                    this._resource.skyColor.set(_v4);
                  }
                }
              }, {
                key: "skyColor",
                set: function set(val) {
                  if (getPipelineSceneData().isHDR) {
                    this._skyColorHDR.set(val);
                  } else {
                    this._skyColorLDR.set(val);
                  }
                  if (this._resource) {
                    this._resource.skyColor.set(val);
                  }
                }
              }, {
                key: "skyIllum",
                get: function get() {
                  if (getPipelineSceneData().isHDR) {
                    return this._skyIllumHDR;
                  } else {
                    return this._skyIllumLDR;
                  }
                },
                set: function set(val) {
                  if (getPipelineSceneData().isHDR) {
                    this._skyIllumHDR = val;
                  } else {
                    this._skyIllumLDR = val;
                  }
                  if (this._resource) {
                    this._resource.skyIllum = val;
                  }
                }
              }, {
                key: "groundLightingColor",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  _v4.set(isHDR ? this._groundAlbedoHDR : this._groundAlbedoLDR);
                  normalizeHDRColor(_v4);
                  return _col.set(_v4.x * 255, _v4.y * 255, _v4.z * 255, 255);
                },
                set: function set(val) {
                  _v4.set(val.x, val.y, val.z, val.w);
                  if (getPipelineSceneData().isHDR) {
                    this._groundAlbedoHDR.set(_v4);
                  } else {
                    this._groundAlbedoLDR.set(_v4);
                  }
                  if (this._resource) {
                    this._resource.groundAlbedo.set(_v4);
                  }
                }
              }, {
                key: "groundAlbedo",
                set: function set(val) {
                  if (getPipelineSceneData().isHDR) {
                    this._groundAlbedoHDR.set(val);
                  } else {
                    this._groundAlbedoLDR.set(val);
                  }
                  if (this._resource) {
                    this._resource.groundAlbedo.set(val);
                  }
                }
              }]);
              return AmbientInfo;
            }(), (_applyDecoratedDescriptor(_class2$s.prototype, "skyIllum", [_dec2$n], Object.getOwnPropertyDescriptor(_class2$s.prototype, "skyIllum"), _class2$s.prototype), _initializer$r = applyDecoratedInitializer(_class2$s.prototype, "_skyColorHDR", [serializable$5, _dec3$l], function () {
              return new Vec4(0.2, 0.5, 0.8, 1.0);
            }), _initializer2$n = applyDecoratedInitializer(_class2$s.prototype, "_skyIllumHDR", [serializable$5, _dec4$e], function () {
              return Ambient.SKY_ILLUM;
            }), _initializer3$h = applyDecoratedInitializer(_class2$s.prototype, "_groundAlbedoHDR", [serializable$5, _dec5$b], function () {
              return new Vec4(0.2, 0.2, 0.2, 1.0);
            }), _initializer4$d = applyDecoratedInitializer(_class2$s.prototype, "_skyColorLDR", [serializable$5], function () {
              return new Vec4(0.2, 0.5, 0.8, 1.0);
            }), _initializer5$c = applyDecoratedInitializer(_class2$s.prototype, "_skyIllumLDR", [serializable$5], function () {
              return Ambient.SKY_ILLUM;
            }), _initializer6$9 = applyDecoratedInitializer(_class2$s.prototype, "_groundAlbedoLDR", [serializable$5], function () {
              return new Vec4(0.2, 0.2, 0.2, 1.0);
            })), _class2$s)) || _class$w));
            legacyCC.AmbientInfo = AmbientInfo;
            var SkyboxInfo = exports("SkyboxInfo", (_dec6$b = ccclass$6('cc.SkyboxInfo'), _dec7$9 = type$5(EnvironmentLightingType), _dec8$8 = type$5(TextureCube), _dec9$7 = type$5(CCFloat), _dec10$6 = type$5(TextureCube), _dec11$4 = type$5(TextureCube), _dec12$4 = type$5(Material), _dec13$3 = type$5(TextureCube), _dec14$3 = formerlySerializedAs$3('_envmap'), _dec15$3 = type$5(TextureCube), _dec16$2 = type$5(TextureCube), _dec17$2 = type$5(TextureCube), _dec18$2 = type$5(Material), _dec19$2 = type$5(TextureCube), _dec20$2 = type$5(TextureCube), _dec6$b(_class4$5 = (_class5$5 = function () {
              function SkyboxInfo() {
                this._envLightingType = _initializer7$8 && _initializer7$8();
                this._envmapHDR = _initializer8$8 && _initializer8$8();
                this._envmapLDR = _initializer9$7 && _initializer9$7();
                this._diffuseMapHDR = _initializer10$6 && _initializer10$6();
                this._diffuseMapLDR = _initializer11$5 && _initializer11$5();
                this._enabled = _initializer12$4 && _initializer12$4();
                this._useHDR = _initializer13$4 && _initializer13$4();
                this._editableMaterial = _initializer14$4 && _initializer14$4();
                this._reflectionHDR = _initializer15$4 && _initializer15$4();
                this._reflectionLDR = _initializer16$4 && _initializer16$4();
                this._rotationAngle = _initializer17$4 && _initializer17$4();
                this._resource = null;
              }
              var _proto2 = SkyboxInfo.prototype;
              _proto2.activate = function activate(resource) {
                this.envLightingType = this._envLightingType;
                this._resource = resource;
                resource.initialize(this);
                resource.setEnvMaps(this._envmapHDR, this._envmapLDR);
                resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);
                resource.setSkyboxMaterial(this._editableMaterial);
                resource.setReflectionMaps(this._reflectionHDR, this._reflectionLDR);
                resource.setRotationAngle(this._rotationAngle);
                resource.activate();
              };
              _proto2.updateEnvMap = function updateEnvMap(val) {
                if (!val) {
                  this.applyDiffuseMap = false;
                  this.useIBL = false;
                  this.envLightingType = 0;
                  warnID(15001);
                }
                var resource = this._resource;
                if (resource) {
                  resource.setEnvMaps(this._envmapHDR, this._envmapLDR);
                  resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);
                  resource.setReflectionMaps(this._reflectionHDR, this._reflectionLDR);
                  resource.useDiffuseMap = this.applyDiffuseMap;
                  resource.envmap = val;
                }
              };
              _proto2.setMaterialProperty = function setMaterialProperty(name, val, passIdx) {
                var resource = this._resource;
                if (!resource) return;
                var editableMaterial = resource.editableMaterial;
                if (resource.enabled && editableMaterial) {
                  editableMaterial.setProperty(name, val, passIdx);
                  editableMaterial.passes.forEach(function (pass) {
                    pass.update();
                  });
                }
              };
              _createClass(SkyboxInfo, [{
                key: "applyDiffuseMap",
                get: function get() {
                  if (2 === this._envLightingType) {
                    return true;
                  }
                  return false;
                },
                set: function set(val) {
                  if (this._resource) {
                    this._resource.useDiffuseMap = val;
                  }
                }
              }, {
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  if (this._enabled === val) return;
                  this._enabled = val;
                  if (this._resource) {
                    this._resource.enabled = this._enabled;
                  }
                }
              }, {
                key: "envLightingType",
                get: function get() {
                  return this._envLightingType;
                },
                set: function set(val) {
                  if (!this.envmap && 0 !== val) {
                    this.useIBL = false;
                    this.applyDiffuseMap = false;
                    this._envLightingType = 0;
                    warnID(15001);
                  } else {
                    if (0 === val) {
                      this.useIBL = false;
                      this.applyDiffuseMap = false;
                    } else if (1 === val) {
                      this.useIBL = true;
                      this.applyDiffuseMap = false;
                    } else if (2 === val) {
                      this.useIBL = true;
                      this.applyDiffuseMap = true;
                    }
                    this._envLightingType = val;
                  }
                }
              }, {
                key: "useIBL",
                get: function get() {
                  if (0 !== this._envLightingType) {
                    return true;
                  }
                  return false;
                },
                set: function set(val) {
                  if (this._resource) {
                    this._resource.useIBL = val;
                  }
                }
              }, {
                key: "useHDR",
                get: function get() {
                  getPipelineSceneData().isHDR = this._useHDR;
                  return this._useHDR;
                },
                set: function set(val) {
                  getPipelineSceneData().isHDR = val;
                  this._useHDR = val;
                  var resource = this._resource;
                  if (resource) {
                    if (this.envLightingType === 2) {
                      if (this.diffuseMap === null) {
                        this.envLightingType = 1;
                        warnID(15000);
                      } else if (this.diffuseMap.isDefault) {
                        warnID(15002);
                      }
                    }
                  }
                  if (resource) {
                    resource.useHDR = this._useHDR;
                    resource.updateMaterialRenderInfo();
                  }
                }
              }, {
                key: "envmap",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._envmapHDR;
                  } else {
                    return this._envmapLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._envmapHDR = val;
                    this._reflectionHDR = null;
                  } else {
                    this._envmapLDR = val;
                    this._reflectionLDR = null;
                  }
                  if (!val) {
                    if (isHDR) {
                      this._diffuseMapHDR = null;
                    } else {
                      this._diffuseMapLDR = null;
                    }
                    this.applyDiffuseMap = false;
                    this.useIBL = false;
                    this.envLightingType = 0;
                    warnID(15001);
                  }
                  var resource = this._resource;
                  if (resource) {
                    resource.setEnvMaps(this._envmapHDR, this._envmapLDR);
                    resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);
                    resource.setReflectionMaps(this._reflectionHDR, this._reflectionLDR);
                    resource.useDiffuseMap = this.applyDiffuseMap;
                    resource.envmap = val;
                  }
                }
              }, {
                key: "rotationAngle",
                get: function get() {
                  return this._rotationAngle;
                },
                set: function set(val) {
                  this._rotationAngle = val;
                  if (this._resource) {
                    this._resource.setRotationAngle(this._rotationAngle);
                  }
                }
              }, {
                key: "diffuseMap",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._diffuseMapHDR;
                  } else {
                    return this._diffuseMapLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._diffuseMapHDR = val;
                  } else {
                    this._diffuseMapLDR = val;
                  }
                  if (this._resource) {
                    this._resource.setDiffuseMaps(this._diffuseMapHDR, this._diffuseMapLDR);
                  }
                }
              }, {
                key: "reflectionMap",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._reflectionHDR;
                  } else {
                    return this._reflectionLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._reflectionHDR = val;
                  } else {
                    this._reflectionLDR = val;
                  }
                  if (this._resource) {
                    this._resource.setReflectionMaps(this._reflectionHDR, this._reflectionLDR);
                  }
                }
              }, {
                key: "skyboxMaterial",
                get: function get() {
                  return this._editableMaterial;
                },
                set: function set(val) {
                  this._editableMaterial = val;
                  if (this._resource) {
                    this._resource.setSkyboxMaterial(this._editableMaterial);
                  }
                }
              }]);
              return SkyboxInfo;
            }(), (_applyDecoratedDescriptor(_class5$5.prototype, "envLightingType", [_dec7$9], Object.getOwnPropertyDescriptor(_class5$5.prototype, "envLightingType"), _class5$5.prototype), _applyDecoratedDescriptor(_class5$5.prototype, "envmap", [_dec8$8], Object.getOwnPropertyDescriptor(_class5$5.prototype, "envmap"), _class5$5.prototype), _applyDecoratedDescriptor(_class5$5.prototype, "rotationAngle", [_dec9$7], Object.getOwnPropertyDescriptor(_class5$5.prototype, "rotationAngle"), _class5$5.prototype), _applyDecoratedDescriptor(_class5$5.prototype, "diffuseMap", [_dec10$6], Object.getOwnPropertyDescriptor(_class5$5.prototype, "diffuseMap"), _class5$5.prototype), _applyDecoratedDescriptor(_class5$5.prototype, "reflectionMap", [_dec11$4], Object.getOwnPropertyDescriptor(_class5$5.prototype, "reflectionMap"), _class5$5.prototype), _applyDecoratedDescriptor(_class5$5.prototype, "skyboxMaterial", [_dec12$4], Object.getOwnPropertyDescriptor(_class5$5.prototype, "skyboxMaterial"), _class5$5.prototype), _initializer7$8 = applyDecoratedInitializer(_class5$5.prototype, "_envLightingType", [serializable$5], function () {
              return 0;
            }), _initializer8$8 = applyDecoratedInitializer(_class5$5.prototype, "_envmapHDR", [serializable$5, _dec13$3, _dec14$3], function () {
              return null;
            }), _initializer9$7 = applyDecoratedInitializer(_class5$5.prototype, "_envmapLDR", [serializable$5, _dec15$3], function () {
              return null;
            }), _initializer10$6 = applyDecoratedInitializer(_class5$5.prototype, "_diffuseMapHDR", [serializable$5, _dec16$2], function () {
              return null;
            }), _initializer11$5 = applyDecoratedInitializer(_class5$5.prototype, "_diffuseMapLDR", [serializable$5, _dec17$2], function () {
              return null;
            }), _initializer12$4 = applyDecoratedInitializer(_class5$5.prototype, "_enabled", [serializable$5], function () {
              return false;
            }), _initializer13$4 = applyDecoratedInitializer(_class5$5.prototype, "_useHDR", [serializable$5], function () {
              return true;
            }), _initializer14$4 = applyDecoratedInitializer(_class5$5.prototype, "_editableMaterial", [serializable$5, _dec18$2], function () {
              return null;
            }), _initializer15$4 = applyDecoratedInitializer(_class5$5.prototype, "_reflectionHDR", [serializable$5, _dec19$2], function () {
              return null;
            }), _initializer16$4 = applyDecoratedInitializer(_class5$5.prototype, "_reflectionLDR", [serializable$5, _dec20$2], function () {
              return null;
            }), _initializer17$4 = applyDecoratedInitializer(_class5$5.prototype, "_rotationAngle", [serializable$5], function () {
              return 0;
            })), _class5$5)) || _class4$5));
            legacyCC.SkyboxInfo = SkyboxInfo;
            var FogInfo = exports("FogInfo", (_dec21$2 = ccclass$6('cc.FogInfo'), _dec22$2 = type$5(FogType), _dec23$2 = type$5(CCFloat), _dec24$2 = type$5(CCFloat), _dec25$2 = type$5(CCFloat), _dec26$2 = type$5(CCFloat), _dec27$2 = type$5(CCFloat), _dec28$2 = type$5(CCFloat), _dec21$2(_class7$1 = (_class8$1 = (_class9 = function () {
              function FogInfo() {
                this._type = _initializer18$4 && _initializer18$4();
                this._fogColor = _initializer19$4 && _initializer19$4();
                this._enabled = _initializer20$3 && _initializer20$3();
                this._fogDensity = _initializer21$3 && _initializer21$3();
                this._fogStart = _initializer22$2 && _initializer22$2();
                this._fogEnd = _initializer23$1 && _initializer23$1();
                this._fogAtten = _initializer24$1 && _initializer24$1();
                this._fogTop = _initializer25$1 && _initializer25$1();
                this._fogRange = _initializer26$1 && _initializer26$1();
                this._accurate = _initializer27 && _initializer27();
                this._resource = null;
              }
              var _proto3 = FogInfo.prototype;
              _proto3.activate = function activate(resource) {
                this._resource = resource;
                resource.initialize(this);
                resource.activate();
              };
              _createClass(FogInfo, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  if (this._enabled === val) return;
                  this._enabled = val;
                  var resource = this._resource;
                  if (resource) {
                    resource.enabled = val;
                    if (val) {
                      resource.type = this._type;
                    }
                  }
                }
              }, {
                key: "accurate",
                get: function get() {
                  return this._accurate;
                },
                set: function set(val) {
                  if (this._accurate === val) return;
                  this._accurate = val;
                  var resource = this._resource;
                  if (resource) {
                    resource.accurate = val;
                    if (val) {
                      resource.type = this._type;
                    }
                  }
                }
              }, {
                key: "fogColor",
                get: function get() {
                  return this._fogColor;
                },
                set: function set(val) {
                  this._fogColor.set(val);
                  if (this._resource) {
                    this._resource.fogColor = this._fogColor;
                  }
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(val) {
                  this._type = val;
                  if (this._resource) {
                    this._resource.type = val;
                  }
                }
              }, {
                key: "fogDensity",
                get: function get() {
                  return this._fogDensity;
                },
                set: function set(val) {
                  this._fogDensity = val;
                  if (this._resource) {
                    this._resource.fogDensity = val;
                  }
                }
              }, {
                key: "fogStart",
                get: function get() {
                  return this._fogStart;
                },
                set: function set(val) {
                  this._fogStart = val;
                  if (this._resource) {
                    this._resource.fogStart = val;
                  }
                }
              }, {
                key: "fogEnd",
                get: function get() {
                  return this._fogEnd;
                },
                set: function set(val) {
                  this._fogEnd = val;
                  if (this._resource) {
                    this._resource.fogEnd = val;
                  }
                }
              }, {
                key: "fogAtten",
                get: function get() {
                  return this._fogAtten;
                },
                set: function set(val) {
                  this._fogAtten = val;
                  if (this._resource) {
                    this._resource.fogAtten = val;
                  }
                }
              }, {
                key: "fogTop",
                get: function get() {
                  return this._fogTop;
                },
                set: function set(val) {
                  this._fogTop = val;
                  if (this._resource) {
                    this._resource.fogTop = val;
                  }
                }
              }, {
                key: "fogRange",
                get: function get() {
                  return this._fogRange;
                },
                set: function set(val) {
                  this._fogRange = val;
                  if (this._resource) {
                    this._resource.fogRange = val;
                  }
                }
              }]);
              return FogInfo;
            }(), _class9.FogType = FogType, _class9), (_applyDecoratedDescriptor(_class8$1.prototype, "type", [_dec22$2], Object.getOwnPropertyDescriptor(_class8$1.prototype, "type"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogDensity", [_dec23$2], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogDensity"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogStart", [_dec24$2], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogStart"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogEnd", [_dec25$2], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogEnd"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogAtten", [_dec26$2], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogAtten"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogTop", [_dec27$2], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogTop"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogRange", [_dec28$2], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogRange"), _class8$1.prototype), _initializer18$4 = applyDecoratedInitializer(_class8$1.prototype, "_type", [serializable$5], function () {
              return FogType.LINEAR;
            }), _initializer19$4 = applyDecoratedInitializer(_class8$1.prototype, "_fogColor", [serializable$5], function () {
              return new Color('#C8C8C8');
            }), _initializer20$3 = applyDecoratedInitializer(_class8$1.prototype, "_enabled", [serializable$5], function () {
              return false;
            }), _initializer21$3 = applyDecoratedInitializer(_class8$1.prototype, "_fogDensity", [serializable$5], function () {
              return 0.3;
            }), _initializer22$2 = applyDecoratedInitializer(_class8$1.prototype, "_fogStart", [serializable$5], function () {
              return 0.5;
            }), _initializer23$1 = applyDecoratedInitializer(_class8$1.prototype, "_fogEnd", [serializable$5], function () {
              return 300;
            }), _initializer24$1 = applyDecoratedInitializer(_class8$1.prototype, "_fogAtten", [serializable$5], function () {
              return 5;
            }), _initializer25$1 = applyDecoratedInitializer(_class8$1.prototype, "_fogTop", [serializable$5], function () {
              return 1.5;
            }), _initializer26$1 = applyDecoratedInitializer(_class8$1.prototype, "_fogRange", [serializable$5], function () {
              return 1.2;
            }), _initializer27 = applyDecoratedInitializer(_class8$1.prototype, "_accurate", [serializable$5], function () {
              return false;
            })), _class8$1)) || _class7$1));
            var ShadowsInfo = exports("ShadowsInfo", (_dec29$1 = ccclass$6('cc.ShadowsInfo'), _dec30$1 = type$5(ShadowType), _dec31$1 = type$5(CCFloat), _dec32$1 = type$5(CCFloat), _dec33$1 = type$5(CCInteger), _dec34$1 = type$5(ShadowSize), _dec29$1(_class10$1 = (_class11$1 = function () {
              function ShadowsInfo() {
                this._enabled = _initializer28 && _initializer28();
                this._type = _initializer29 && _initializer29();
                this._normal = _initializer30 && _initializer30();
                this._distance = _initializer31 && _initializer31();
                this._planeBias = _initializer32 && _initializer32();
                this._shadowColor = _initializer33 && _initializer33();
                this._maxReceived = _initializer34 && _initializer34();
                this._size = _initializer35 && _initializer35();
                this._resource = null;
              }
              var _proto4 = ShadowsInfo.prototype;
              _proto4.setPlaneFromNode = function setPlaneFromNode(node) {
                node.getWorldRotation(_qt$1);
                this.planeDirection = Vec3.transformQuat(_v3$1, _up, _qt$1);
                node.getWorldPosition(_v3$1);
                this.planeHeight = Vec3.dot(this._normal, _v3$1);
              };
              _proto4.activate = function activate(resource) {
                this._resource = resource;
                resource.initialize(this);
                resource.activate();
              };
              _createClass(ShadowsInfo, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  if (this._enabled === val) return;
                  this._enabled = val;
                  var resource = this._resource;
                  if (resource) {
                    resource.enabled = val;
                    if (val) {
                      resource.type = this._type;
                    }
                  }
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(val) {
                  this._type = val;
                  if (this._resource) {
                    this._resource.type = val;
                  }
                }
              }, {
                key: "shadowColor",
                get: function get() {
                  return this._shadowColor;
                },
                set: function set(val) {
                  this._shadowColor.set(val);
                  if (this._resource) {
                    this._resource.shadowColor = val;
                  }
                }
              }, {
                key: "planeDirection",
                get: function get() {
                  return this._normal;
                },
                set: function set(val) {
                  Vec3.copy(this._normal, val);
                  if (this._resource) {
                    this._resource.normal = val;
                  }
                }
              }, {
                key: "planeHeight",
                get: function get() {
                  return this._distance;
                },
                set: function set(val) {
                  this._distance = val;
                  if (this._resource) {
                    this._resource.distance = val;
                  }
                }
              }, {
                key: "planeBias",
                get: function get() {
                  return this._planeBias;
                },
                set: function set(val) {
                  this._planeBias = val;
                  if (this._resource) {
                    this._resource.planeBias = val;
                  }
                }
              }, {
                key: "maxReceived",
                get: function get() {
                  return this._maxReceived;
                },
                set: function set(val) {
                  this._maxReceived = val;
                  if (this._resource) {
                    this._resource.maxReceived = val;
                  }
                }
              }, {
                key: "shadowMapSize",
                get: function get() {
                  return this._size.x;
                },
                set: function set(value) {
                  var resource = this._resource;
                  this._size.set(value, value);
                  if (resource) {
                    resource.size.set(value, value);
                    resource.shadowMapDirty = true;
                  }
                }
              }]);
              return ShadowsInfo;
            }(), (_applyDecoratedDescriptor(_class11$1.prototype, "type", [_dec30$1], Object.getOwnPropertyDescriptor(_class11$1.prototype, "type"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "planeHeight", [_dec31$1], Object.getOwnPropertyDescriptor(_class11$1.prototype, "planeHeight"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "planeBias", [_dec32$1], Object.getOwnPropertyDescriptor(_class11$1.prototype, "planeBias"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "maxReceived", [_dec33$1], Object.getOwnPropertyDescriptor(_class11$1.prototype, "maxReceived"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowMapSize", [_dec34$1], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowMapSize"), _class11$1.prototype), _initializer28 = applyDecoratedInitializer(_class11$1.prototype, "_enabled", [serializable$5], function () {
              return false;
            }), _initializer29 = applyDecoratedInitializer(_class11$1.prototype, "_type", [serializable$5], function () {
              return ShadowType.Planar;
            }), _initializer30 = applyDecoratedInitializer(_class11$1.prototype, "_normal", [serializable$5], function () {
              return new Vec3(0, 1, 0);
            }), _initializer31 = applyDecoratedInitializer(_class11$1.prototype, "_distance", [serializable$5], function () {
              return 0;
            }), _initializer32 = applyDecoratedInitializer(_class11$1.prototype, "_planeBias", [serializable$5], function () {
              return 1.0;
            }), _initializer33 = applyDecoratedInitializer(_class11$1.prototype, "_shadowColor", [serializable$5], function () {
              return new Color(0, 0, 0, 76);
            }), _initializer34 = applyDecoratedInitializer(_class11$1.prototype, "_maxReceived", [serializable$5], function () {
              return 4;
            }), _initializer35 = applyDecoratedInitializer(_class11$1.prototype, "_size", [serializable$5], function () {
              return new Vec2(1024, 1024);
            })), _class11$1)) || _class10$1));
            legacyCC.ShadowsInfo = ShadowsInfo;
            var DEFAULT_WORLD_MIN_POS = exports("DEFAULT_WORLD_MIN_POS", new Vec3(-1024, -1024, -1024));
            var DEFAULT_WORLD_MAX_POS = exports("DEFAULT_WORLD_MAX_POS", new Vec3(1024.0, 1024.0, 1024.0));
            var DEFAULT_OCTREE_DEPTH = exports("DEFAULT_OCTREE_DEPTH", 8);
            var OctreeInfo = exports("OctreeInfo", (_dec35$1 = ccclass$6('cc.OctreeInfo'), _dec36$1 = type$5(CCInteger), _dec35$1(_class13$1 = (_class14$1 = function () {
              function OctreeInfo() {
                this._enabled = _initializer36 && _initializer36();
                this._minPos = _initializer37 && _initializer37();
                this._maxPos = _initializer38 && _initializer38();
                this._depth = _initializer39 && _initializer39();
                this._resource = null;
              }
              var _proto5 = OctreeInfo.prototype;
              _proto5.activate = function activate(resource) {
                this._resource = resource;
                resource.initialize(this);
              };
              _createClass(OctreeInfo, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  if (this._enabled === val) return;
                  this._enabled = val;
                  if (this._resource) {
                    this._resource.enabled = val;
                  }
                }
              }, {
                key: "minPos",
                get: function get() {
                  return this._minPos;
                },
                set: function set(val) {
                  this._minPos = val;
                  if (this._resource) {
                    this._resource.minPos = val;
                  }
                }
              }, {
                key: "maxPos",
                get: function get() {
                  return this._maxPos;
                },
                set: function set(val) {
                  this._maxPos = val;
                  if (this._resource) {
                    this._resource.maxPos = val;
                  }
                }
              }, {
                key: "depth",
                get: function get() {
                  return this._depth;
                },
                set: function set(val) {
                  this._depth = val;
                  if (this._resource) {
                    this._resource.depth = val;
                  }
                }
              }]);
              return OctreeInfo;
            }(), (_applyDecoratedDescriptor(_class14$1.prototype, "depth", [_dec36$1], Object.getOwnPropertyDescriptor(_class14$1.prototype, "depth"), _class14$1.prototype), _initializer36 = applyDecoratedInitializer(_class14$1.prototype, "_enabled", [serializable$5], function () {
              return false;
            }), _initializer37 = applyDecoratedInitializer(_class14$1.prototype, "_minPos", [serializable$5], function () {
              return new Vec3(DEFAULT_WORLD_MIN_POS);
            }), _initializer38 = applyDecoratedInitializer(_class14$1.prototype, "_maxPos", [serializable$5], function () {
              return new Vec3(DEFAULT_WORLD_MAX_POS);
            }), _initializer39 = applyDecoratedInitializer(_class14$1.prototype, "_depth", [serializable$5], function () {
              return DEFAULT_OCTREE_DEPTH;
            })), _class14$1)) || _class13$1));
            legacyCC.OctreeInfo = OctreeInfo;
            var SkinInfo = exports("SkinInfo", (_dec37$1 = ccclass$6('cc.SkinInfo'), _dec38$1 = type$5(CCFloat), _dec39$1 = type$5(CCFloat), _dec37$1(_class16$1 = (_class17$1 = function () {
              function SkinInfo() {
                this._enabled = _initializer40 && _initializer40();
                this._blurRadius = _initializer41 && _initializer41();
                this._sssIntensity = _initializer42 && _initializer42();
                this._resource = null;
              }
              var _proto6 = SkinInfo.prototype;
              _proto6.activate = function activate(resource) {
                this._resource = resource;
                resource.initialize(this);
              };
              _createClass(SkinInfo, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  if (this._enabled === val) return;
                  this._enabled = val;
                  if (this._resource) {
                    this._resource.enabled = val;
                  }
                }
              }, {
                key: "blurRadius",
                get: function get() {
                  return this._blurRadius;
                },
                set: function set(val) {
                  this._blurRadius = val;
                  if (this._resource) {
                    this._resource.blurRadius = val;
                  }
                }
              }, {
                key: "sssIntensity",
                get: function get() {
                  return this._sssIntensity;
                },
                set: function set(val) {
                  this._sssIntensity = val;
                  if (this._resource) {
                    this._resource.sssIntensity = val;
                  }
                }
              }]);
              return SkinInfo;
            }(), (_applyDecoratedDescriptor(_class17$1.prototype, "blurRadius", [_dec38$1], Object.getOwnPropertyDescriptor(_class17$1.prototype, "blurRadius"), _class17$1.prototype), _applyDecoratedDescriptor(_class17$1.prototype, "sssIntensity", [_dec39$1], Object.getOwnPropertyDescriptor(_class17$1.prototype, "sssIntensity"), _class17$1.prototype), _initializer40 = applyDecoratedInitializer(_class17$1.prototype, "_enabled", [serializable$5], function () {
              return true;
            }), _initializer41 = applyDecoratedInitializer(_class17$1.prototype, "_blurRadius", [serializable$5], function () {
              return 0.01;
            }), _initializer42 = applyDecoratedInitializer(_class17$1.prototype, "_sssIntensity", [serializable$5], function () {
              return 3.0;
            })), _class17$1)) || _class16$1));
            legacyCC.SkinInfo = SkinInfo;
            var PostSettingsInfo = exports("PostSettingsInfo", (_dec40 = ccclass$6('cc.PostSettingsInfo'), _dec41 = type$5(ToneMappingType), _dec40(_class19$1 = (_class20$1 = function () {
              function PostSettingsInfo() {
                this._toneMappingType = _initializer43 && _initializer43();
                this._resource = null;
              }
              var _proto7 = PostSettingsInfo.prototype;
              _proto7.activate = function activate(resource) {
                this._resource = resource;
                resource.initialize(this);
                resource.activate();
              };
              _createClass(PostSettingsInfo, [{
                key: "toneMappingType",
                get: function get() {
                  return this._toneMappingType;
                },
                set: function set(val) {
                  this._toneMappingType = val;
                  if (this._resource) {
                    this._resource.toneMappingType = val;
                  }
                }
              }]);
              return PostSettingsInfo;
            }(), (_applyDecoratedDescriptor(_class20$1.prototype, "toneMappingType", [_dec41], Object.getOwnPropertyDescriptor(_class20$1.prototype, "toneMappingType"), _class20$1.prototype), _initializer43 = applyDecoratedInitializer(_class20$1.prototype, "_toneMappingType", [serializable$5], function () {
              return ToneMappingType.DEFAULT;
            })), _class20$1)) || _class19$1));
            legacyCC.PostSettingsInfo = PostSettingsInfo;
            var LightProbeInfo = exports("LightProbeInfo", (_dec42 = ccclass$6('cc.LightProbeInfo'), _dec43 = type$5(CCFloat), _dec44 = type$5(CCInteger), _dec45 = type$5(CCInteger), _dec46 = type$5(CCFloat), _dec47 = type$5(CCFloat), _dec42(_class22$1 = (_class23$1 = function () {
              function LightProbeInfo() {
                this._giScale = _initializer44 && _initializer44();
                this._giSamples = _initializer45 && _initializer45();
                this._bounces = _initializer46 && _initializer46();
                this._reduceRinging = _initializer47 && _initializer47();
                this._showProbe = _initializer48 && _initializer48();
                this._showWireframe = _initializer49 && _initializer49();
                this._showConvex = _initializer50 && _initializer50();
                this._data = _initializer51 && _initializer51();
                this._lightProbeSphereVolume = _initializer52 && _initializer52();
                this._nodes = [];
                this._scene = null;
                this._resource = null;
              }
              var _proto8 = LightProbeInfo.prototype;
              _proto8.activate = function activate(scene, resource) {
                this._scene = scene;
                this._resource = resource;
                resource.initialize(this);
              };
              _proto8.onProbeBakeFinished = function onProbeBakeFinished() {
                this.onProbeBakingChanged(this._scene);
              };
              _proto8.onProbeBakeCleared = function onProbeBakeCleared() {
                this.clearSHCoefficients();
                this.onProbeBakingChanged(this._scene);
              };
              _proto8.onProbeBakingChanged = function onProbeBakingChanged(node) {
                var _this = this;
                if (!node) {
                  return;
                }
                node.emit("light-probe-baking-changed");
                node.children.forEach(function (child) {
                  _this.onProbeBakingChanged(child);
                });
              };
              _proto8.clearSHCoefficients = function clearSHCoefficients() {
                if (!this._data) {
                  return;
                }
                this._data.probes.forEach(function (probe) {
                  probe.coefficients.length = 0;
                });
                this.clearAllSHUBOs();
              };
              _proto8.isUniqueNode = function isUniqueNode() {
                return this._nodes.length === 1;
              };
              _proto8.addNode = function addNode(node) {
                if (!node) {
                  return false;
                }
                for (var i = 0; i < this._nodes.length; i++) {
                  if (this._nodes[i].node === node) {
                    return false;
                  }
                }
                this._nodes.push({
                  node: node,
                  probes: null
                });
                return true;
              };
              _proto8.removeNode = function removeNode(node) {
                if (!node) {
                  return false;
                }
                var index = this._nodes.findIndex(function (element) {
                  return element.node === node;
                });
                if (index === -1) {
                  return false;
                }
                this._nodes.splice(index, 1);
                return true;
              };
              _proto8.syncData = function syncData(node, probes) {
                for (var i = 0; i < this._nodes.length; i++) {
                  if (this._nodes[i].node === node) {
                    this._nodes[i].probes = probes;
                    return;
                  }
                }
              };
              _proto8.update = function update(updateTet) {
                if (updateTet === undefined) {
                  updateTet = true;
                }
                if (!cclegacy.internal.LightProbesData) {
                  return;
                }
                if (!this._data) {
                  this._data = new cclegacy.internal.LightProbesData();
                  if (this._resource) {
                    this._resource.data = this._data;
                  }
                }
                var points = [];
                for (var i = 0; i < this._nodes.length; i++) {
                  var probeNode = this._nodes[i];
                  var node = probeNode.node;
                  var probes = probeNode.probes;
                  var worldPosition = node.worldPosition;
                  if (!probes) {
                    continue;
                  }
                  for (var j = 0; j < probes.length; j++) {
                    var position = v3();
                    Vec3.add(position, probes[j], worldPosition);
                    points.push(position);
                  }
                }
                var pointCount = points.length;
                if (pointCount < 4) {
                  this.resetAllTetraIndices();
                  this._data.reset();
                  return;
                }
                this._data.updateProbes(points);
                if (updateTet) {
                  this.resetAllTetraIndices();
                  this._data.updateTetrahedrons();
                }
              };
              _proto8.clearAllSHUBOs = function clearAllSHUBOs() {
                if (!this._scene) {
                  return;
                }
                var renderScene = this._scene.renderScene;
                if (!renderScene) {
                  return;
                }
                var models = renderScene.models;
                models.forEach(function (model) {
                  model.clearSHUBOs();
                });
              };
              _proto8.resetAllTetraIndices = function resetAllTetraIndices() {
                if (!this._scene) {
                  return;
                }
                var renderScene = this._scene.renderScene;
                if (!renderScene) {
                  return;
                }
                var models = renderScene.models;
                models.forEach(function (model) {
                  model.tetrahedronIndex = -1;
                });
              };
              _createClass(LightProbeInfo, [{
                key: "giScale",
                get: function get() {
                  return this._giScale;
                },
                set: function set(val) {
                  if (this._giScale === val) return;
                  this._giScale = val;
                  if (this._resource) {
                    this._resource.giScale = val;
                  }
                }
              }, {
                key: "giSamples",
                get: function get() {
                  return this._giSamples;
                },
                set: function set(val) {
                  if (this._giSamples === val) return;
                  this._giSamples = val;
                  if (this._resource) {
                    this._resource.giSamples = val;
                  }
                }
              }, {
                key: "bounces",
                get: function get() {
                  return this._bounces;
                },
                set: function set(val) {
                  if (this._bounces === val) return;
                  this._bounces = val;
                  if (this._resource) {
                    this._resource.bounces = val;
                  }
                }
              }, {
                key: "reduceRinging",
                get: function get() {
                  return this._reduceRinging;
                },
                set: function set(val) {
                  if (this._reduceRinging === val) return;
                  this._reduceRinging = val;
                  if (this._resource) {
                    this._resource.reduceRinging = val;
                  }
                }
              }, {
                key: "showProbe",
                get: function get() {
                  return this._showProbe;
                },
                set: function set(val) {
                  if (this._showProbe === val) return;
                  this._showProbe = val;
                  if (this._resource) {
                    this._resource.showProbe = val;
                  }
                }
              }, {
                key: "showWireframe",
                get: function get() {
                  return this._showWireframe;
                },
                set: function set(val) {
                  if (this._showWireframe === val) return;
                  this._showWireframe = val;
                  if (this._resource) {
                    this._resource.showWireframe = val;
                  }
                }
              }, {
                key: "showConvex",
                get: function get() {
                  return this._showConvex;
                },
                set: function set(val) {
                  if (this._showConvex === val) return;
                  this._showConvex = val;
                  if (this._resource) {
                    this._resource.showConvex = val;
                  }
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                },
                set: function set(val) {
                  if (this._data === val) return;
                  this._data = val;
                  if (this._resource) {
                    this._resource.data = val;
                  }
                }
              }, {
                key: "lightProbeSphereVolume",
                get: function get() {
                  return this._lightProbeSphereVolume;
                },
                set: function set(val) {
                  if (this._lightProbeSphereVolume === val) return;
                  this._lightProbeSphereVolume = val;
                  if (this._resource) {
                    this._resource.lightProbeSphereVolume = val;
                  }
                }
              }]);
              return LightProbeInfo;
            }(), (_applyDecoratedDescriptor(_class23$1.prototype, "giScale", [_dec43], Object.getOwnPropertyDescriptor(_class23$1.prototype, "giScale"), _class23$1.prototype), _applyDecoratedDescriptor(_class23$1.prototype, "giSamples", [_dec44], Object.getOwnPropertyDescriptor(_class23$1.prototype, "giSamples"), _class23$1.prototype), _applyDecoratedDescriptor(_class23$1.prototype, "bounces", [_dec45], Object.getOwnPropertyDescriptor(_class23$1.prototype, "bounces"), _class23$1.prototype), _applyDecoratedDescriptor(_class23$1.prototype, "reduceRinging", [_dec46], Object.getOwnPropertyDescriptor(_class23$1.prototype, "reduceRinging"), _class23$1.prototype), _applyDecoratedDescriptor(_class23$1.prototype, "lightProbeSphereVolume", [_dec47], Object.getOwnPropertyDescriptor(_class23$1.prototype, "lightProbeSphereVolume"), _class23$1.prototype), _initializer44 = applyDecoratedInitializer(_class23$1.prototype, "_giScale", [serializable$5], function () {
              return 1.0;
            }), _initializer45 = applyDecoratedInitializer(_class23$1.prototype, "_giSamples", [serializable$5], function () {
              return 1024;
            }), _initializer46 = applyDecoratedInitializer(_class23$1.prototype, "_bounces", [serializable$5], function () {
              return 2;
            }), _initializer47 = applyDecoratedInitializer(_class23$1.prototype, "_reduceRinging", [serializable$5], function () {
              return 0.0;
            }), _initializer48 = applyDecoratedInitializer(_class23$1.prototype, "_showProbe", [serializable$5], function () {
              return true;
            }), _initializer49 = applyDecoratedInitializer(_class23$1.prototype, "_showWireframe", [serializable$5], function () {
              return true;
            }), _initializer50 = applyDecoratedInitializer(_class23$1.prototype, "_showConvex", [serializable$5], function () {
              return false;
            }), _initializer51 = applyDecoratedInitializer(_class23$1.prototype, "_data", [serializable$5], function () {
              return null;
            }), _initializer52 = applyDecoratedInitializer(_class23$1.prototype, "_lightProbeSphereVolume", [serializable$5], function () {
              return 1.0;
            })), _class23$1)) || _class22$1));
            var SceneGlobals = exports("SceneGlobals", (_dec48 = ccclass$6('cc.SceneGlobals'), _dec49 = type$5(SkyboxInfo), _dec48(_class25 = (_class26 = function () {
              function SceneGlobals() {
                this.ambient = _initializer53 && _initializer53();
                this.shadows = _initializer54 && _initializer54();
                this._skybox = _initializer55 && _initializer55();
                this.fog = _initializer56 && _initializer56();
                this.octree = _initializer57 && _initializer57();
                this.skin = _initializer58 && _initializer58();
                this.lightProbeInfo = _initializer59 && _initializer59();
                this.postSettings = _initializer60 && _initializer60();
                this.bakedWithStationaryMainLight = _initializer61 && _initializer61();
                this.bakedWithHighpLightmap = _initializer62 && _initializer62();
                this.disableLightmap = false;
              }
              var _proto9 = SceneGlobals.prototype;
              _proto9.activate = function activate(scene) {
                var sceneData = legacyCC.director.root.pipeline.pipelineSceneData;
                this.skybox.activate(sceneData.skybox);
                this.ambient.activate(sceneData.ambient);
                this.shadows.activate(sceneData.shadows);
                this.fog.activate(sceneData.fog);
                this.octree.activate(sceneData.octree);
                this.skin.activate(sceneData.skin);
                this.postSettings.activate(sceneData.postSettings);
                if (this.lightProbeInfo && sceneData.lightProbes) {
                  this.lightProbeInfo.activate(scene, sceneData.lightProbes);
                }
                var root = legacyCC.director.root;
                root.onGlobalPipelineStateChanged();
              };
              _createClass(SceneGlobals, [{
                key: "skybox",
                get: function get() {
                  return this._skybox;
                },
                set: function set(value) {
                  this._skybox = value;
                }
              }]);
              return SceneGlobals;
            }(), (_initializer53 = applyDecoratedInitializer(_class26.prototype, "ambient", [serializable$5], function () {
              return new AmbientInfo();
            }), _initializer54 = applyDecoratedInitializer(_class26.prototype, "shadows", [serializable$5], function () {
              return new ShadowsInfo();
            }), _initializer55 = applyDecoratedInitializer(_class26.prototype, "_skybox", [serializable$5], function () {
              return new SkyboxInfo();
            }), _initializer56 = applyDecoratedInitializer(_class26.prototype, "fog", [serializable$5], function () {
              return new FogInfo();
            }), _applyDecoratedDescriptor(_class26.prototype, "skybox", [_dec49], Object.getOwnPropertyDescriptor(_class26.prototype, "skybox"), _class26.prototype), _initializer57 = applyDecoratedInitializer(_class26.prototype, "octree", [serializable$5], function () {
              return new OctreeInfo();
            }), _initializer58 = applyDecoratedInitializer(_class26.prototype, "skin", [serializable$5], function () {
              return new SkinInfo();
            }), _initializer59 = applyDecoratedInitializer(_class26.prototype, "lightProbeInfo", [serializable$5], function () {
              return new LightProbeInfo();
            }), _initializer60 = applyDecoratedInitializer(_class26.prototype, "postSettings", [serializable$5], function () {
              return new PostSettingsInfo();
            }), _initializer61 = applyDecoratedInitializer(_class26.prototype, "bakedWithStationaryMainLight", [serializable$5], function () {
              return false;
            }), _initializer62 = applyDecoratedInitializer(_class26.prototype, "bakedWithHighpLightmap", [serializable$5], function () {
              return false;
            })), _class26)) || _class25));
            legacyCC.SceneGlobals = SceneGlobals;

            var _dec$v, _dec2$m, _class$v, _class2$r, _initializer$q, _dec3$k, _dec4$d, _dec5$a, _dec6$a, _dec7$8, _dec8$7, _class4$4, _class5$4, _initializer2$m, _initializer3$g, _initializer4$c, _initializer5$b, _initializer6$8, _dec9$6, _class7, _class8, _initializer7$7, _dec10$5, _dec11$3, _dec12$3, _class10, _class11, _initializer8$7, _initializer9$6, _initializer10$5, _dec13$2, _dec14$2, _dec15$2, _class13, _class14, _initializer11$4, _initializer12$3, _dec16$1, _dec17$1, _dec18$1, _class16, _class17, _initializer13$3, _initializer14$3, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _class19, _class20, _initializer15$3, _initializer16$3, _initializer17$3, _initializer18$3, _initializer19$3, _initializer20$2, _dec25$1, _dec26$1, _dec27$1, _dec28$1, _class22, _class23, _initializer21$2, _initializer22$1, _initializer23, _initializer24, _initializer25, _initializer26;
            var TargetInfo = (_dec$v = ccclass$6('cc.TargetInfo'), _dec2$m = type$5([CCString]), _dec$v(_class$v = (_class2$r = function TargetInfo() {
              this.localID = _initializer$q && _initializer$q();
            }, (_initializer$q = applyDecoratedInitializer(_class2$r.prototype, "localID", [serializable$5, _dec2$m], function () {
              return [];
            })), _class2$r)) || _class$v);
            var TargetOverrideInfo = (_dec3$k = ccclass$6('cc.TargetOverrideInfo'), _dec4$d = type$5(CCObject), _dec5$a = type$5(TargetInfo), _dec6$a = type$5([CCString]), _dec7$8 = type$5(Node$1), _dec8$7 = type$5(TargetInfo), _dec3$k(_class4$4 = (_class5$4 = function TargetOverrideInfo() {
              this.source = _initializer2$m && _initializer2$m();
              this.sourceInfo = _initializer3$g && _initializer3$g();
              this.propertyPath = _initializer4$c && _initializer4$c();
              this.target = _initializer5$b && _initializer5$b();
              this.targetInfo = _initializer6$8 && _initializer6$8();
            }, (_initializer2$m = applyDecoratedInitializer(_class5$4.prototype, "source", [serializable$5, _dec4$d], function () {
              return null;
            }), _initializer3$g = applyDecoratedInitializer(_class5$4.prototype, "sourceInfo", [serializable$5, _dec5$a], function () {
              return null;
            }), _initializer4$c = applyDecoratedInitializer(_class5$4.prototype, "propertyPath", [serializable$5, _dec6$a], function () {
              return [];
            }), _initializer5$b = applyDecoratedInitializer(_class5$4.prototype, "target", [serializable$5, _dec7$8], function () {
              return null;
            }), _initializer6$8 = applyDecoratedInitializer(_class5$4.prototype, "targetInfo", [serializable$5, _dec8$7], function () {
              return null;
            })), _class5$4)) || _class4$4);
            var CompPrefabInfo = (_dec9$6 = ccclass$6('cc.CompPrefabInfo'), _dec9$6(_class7 = (_class8 = function CompPrefabInfo() {
              this.fileId = _initializer7$7 && _initializer7$7();
            }, (_initializer7$7 = applyDecoratedInitializer(_class8.prototype, "fileId", [serializable$5], function () {
              return '';
            })), _class8)) || _class7);
            var PropertyOverrideInfo = (_dec10$5 = ccclass$6('CCPropertyOverrideInfo'), _dec11$3 = type$5(TargetInfo), _dec12$3 = type$5([CCString]), _dec10$5(_class10 = (_class11 = function () {
              function PropertyOverrideInfo() {
                this.targetInfo = _initializer8$7 && _initializer8$7();
                this.propertyPath = _initializer9$6 && _initializer9$6();
                this.value = _initializer10$5 && _initializer10$5();
              }
              var _proto = PropertyOverrideInfo.prototype;
              _proto.isTarget = function isTarget(localID, propPath) {
              };
              return PropertyOverrideInfo;
            }(), (_initializer8$7 = applyDecoratedInitializer(_class11.prototype, "targetInfo", [serializable$5, _dec11$3], function () {
              return null;
            }), _initializer9$6 = applyDecoratedInitializer(_class11.prototype, "propertyPath", [serializable$5, _dec12$3], function () {
              return [];
            }), _initializer10$5 = applyDecoratedInitializer(_class11.prototype, "value", [serializable$5], null)), _class11)) || _class10);
            var MountedChildrenInfo = (_dec13$2 = ccclass$6('cc.MountedChildrenInfo'), _dec14$2 = type$5(TargetInfo), _dec15$2 = type$5([Node$1]), _dec13$2(_class13 = (_class14 = function () {
              function MountedChildrenInfo() {
                this.targetInfo = _initializer11$4 && _initializer11$4();
                this.nodes = _initializer12$3 && _initializer12$3();
              }
              var _proto2 = MountedChildrenInfo.prototype;
              _proto2.isTarget = function isTarget(localID) {
              };
              return MountedChildrenInfo;
            }(), (_initializer11$4 = applyDecoratedInitializer(_class14.prototype, "targetInfo", [serializable$5, _dec14$2], function () {
              return null;
            }), _initializer12$3 = applyDecoratedInitializer(_class14.prototype, "nodes", [serializable$5, _dec15$2], function () {
              return [];
            })), _class14)) || _class13);
            var MountedComponentsInfo = (_dec16$1 = ccclass$6('cc.MountedComponentsInfo'), _dec17$1 = type$5(TargetInfo), _dec18$1 = type$5([Component]), _dec16$1(_class16 = (_class17 = function () {
              function MountedComponentsInfo() {
                this.targetInfo = _initializer13$3 && _initializer13$3();
                this.components = _initializer14$3 && _initializer14$3();
              }
              var _proto3 = MountedComponentsInfo.prototype;
              _proto3.isTarget = function isTarget(localID) {
              };
              return MountedComponentsInfo;
            }(), (_initializer13$3 = applyDecoratedInitializer(_class17.prototype, "targetInfo", [serializable$5, _dec17$1], function () {
              return null;
            }), _initializer14$3 = applyDecoratedInitializer(_class17.prototype, "components", [serializable$5, _dec18$1], function () {
              return [];
            })), _class17)) || _class16);
            var PrefabInstance = (_dec19$1 = ccclass$6('cc.PrefabInstance'), _dec20$1 = type$5(Node$1), _dec21$1 = type$5([MountedChildrenInfo]), _dec22$1 = type$5([MountedComponentsInfo]), _dec23$1 = type$5([PropertyOverrideInfo]), _dec24$1 = type$5([TargetInfo]), _dec19$1(_class19 = (_class20 = function () {
              function PrefabInstance() {
                this.fileId = _initializer15$3 && _initializer15$3();
                this.prefabRootNode = _initializer16$3 && _initializer16$3();
                this.mountedChildren = _initializer17$3 && _initializer17$3();
                this.mountedComponents = _initializer18$3 && _initializer18$3();
                this.propertyOverrides = _initializer19$3 && _initializer19$3();
                this.removedComponents = _initializer20$2 && _initializer20$2();
                this.targetMap = {};
                this.expanded = false;
              }
              var _proto4 = PrefabInstance.prototype;
              _proto4.findPropertyOverride = function findPropertyOverride(localID, propPath) {
              };
              _proto4.removePropertyOverride = function removePropertyOverride(localID, propPath) {
              };
              return PrefabInstance;
            }(), (_initializer15$3 = applyDecoratedInitializer(_class20.prototype, "fileId", [serializable$5], function () {
              return '';
            }), _initializer16$3 = applyDecoratedInitializer(_class20.prototype, "prefabRootNode", [serializable$5, _dec20$1], null), _initializer17$3 = applyDecoratedInitializer(_class20.prototype, "mountedChildren", [serializable$5, _dec21$1], function () {
              return [];
            }), _initializer18$3 = applyDecoratedInitializer(_class20.prototype, "mountedComponents", [serializable$5, _dec22$1], function () {
              return [];
            }), _initializer19$3 = applyDecoratedInitializer(_class20.prototype, "propertyOverrides", [serializable$5, _dec23$1], function () {
              return [];
            }), _initializer20$2 = applyDecoratedInitializer(_class20.prototype, "removedComponents", [serializable$5, _dec24$1], function () {
              return [];
            })), _class20)) || _class19);
            var PrefabInfo = (_dec25$1 = ccclass$6('cc.PrefabInfo'), _dec26$1 = type$5(Node$1), _dec27$1 = type$5(PrefabInstance), _dec28$1 = type$5([TargetOverrideInfo]), _dec25$1(_class22 = (_class23 = function PrefabInfo() {
              this.root = _initializer21$2 && _initializer21$2();
              this.asset = _initializer22$1 && _initializer22$1();
              this.fileId = _initializer23 && _initializer23();
              this.instance = _initializer24 && _initializer24();
              this.targetOverrides = _initializer25 && _initializer25();
              this.nestedPrefabInstanceRoots = _initializer26 && _initializer26();
            }, (_initializer21$2 = applyDecoratedInitializer(_class23.prototype, "root", [serializable$5, _dec26$1], null), _initializer22$1 = applyDecoratedInitializer(_class23.prototype, "asset", [serializable$5], null), _initializer23 = applyDecoratedInitializer(_class23.prototype, "fileId", [serializable$5], function () {
              return '';
            }), _initializer24 = applyDecoratedInitializer(_class23.prototype, "instance", [serializable$5, _dec27$1], null), _initializer25 = applyDecoratedInitializer(_class23.prototype, "targetOverrides", [serializable$5, _dec28$1], null), _initializer26 = applyDecoratedInitializer(_class23.prototype, "nestedPrefabInstanceRoots", [serializable$5], null)), _class23)) || _class22);
            cclegacy._PrefabInfo = PrefabInfo;

            function createNodeWithPrefab(node) {
              var prefabInfo = node == null ? undefined : node.prefab;
              if (!prefabInfo) {
                return;
              }
              var prefabInstance = prefabInfo.instance;
              if (!prefabInstance) {
                return;
              }
              if (!prefabInfo.asset) {
                {
                  errorID(3701, node.name);
                }
                prefabInfo.instance = undefined;
                return;
              }
              var _objFlags = node._objFlags;
              var _parent = node.getParent();
              var _id = node.uuid;
              node[editorExtrasTag];
              cclegacy.game._isCloning = true;
              {
                prefabInfo.asset._doInstantiate(node);
              }
              cclegacy.game._isCloning = false;
              node._objFlags = _objFlags;
              node.modifyParent(_parent);
              node.id = _id;
              if (node.prefab) {
                node.prefab.instance = prefabInfo.instance;
              }
            }
            function generateTargetMap(node, targetMap, isRoot) {
              var _node$prefab;
              if (!targetMap) {
                return;
              }
              if (!node) {
                return;
              }
              var curTargetMap = targetMap;
              var prefabInstance = (_node$prefab = node.prefab) == null ? undefined : _node$prefab.instance;
              if (!isRoot && prefabInstance) {
                targetMap[prefabInstance.fileId] = {};
                curTargetMap = targetMap[prefabInstance.fileId];
              }
              var prefabInfo = node.prefab;
              if (prefabInfo) {
                curTargetMap[prefabInfo.fileId] = node;
              }
              node.components.forEach(function (comp) {
                if (comp.__prefab) {
                  curTargetMap[comp.__prefab.fileId] = comp;
                }
              });
              node.children.forEach(function (childNode) {
                generateTargetMap(childNode, curTargetMap, false);
              });
            }
            function getTarget(localID, targetMap) {
              if (!localID) {
                return null;
              }
              var target = null;
              var targetIter = targetMap;
              for (var i = 0; i < localID.length; i++) {
                if (!targetIter) {
                  return null;
                }
                targetIter = targetIter[localID[i]];
              }
              target = targetIter;
              return target;
            }
            function applyMountedChildren(node, mountedChildren, targetMap) {
              if (!mountedChildren) {
                return;
              }
              for (var i = 0; i < mountedChildren.length; i++) {
                var childInfo = mountedChildren[i];
                if (childInfo && childInfo.targetInfo) {
                  var target = getTarget(childInfo.targetInfo.localID, targetMap);
                  if (!target) {
                    continue;
                  }
                  var curTargetMap = targetMap;
                  var localID = childInfo.targetInfo.localID;
                  if (localID.length > 0) {
                    for (var _i = 0; _i < localID.length - 1; _i++) {
                      curTargetMap = curTargetMap[localID[_i]];
                    }
                  }
                  if (childInfo.nodes) {
                    for (var _i2 = 0; _i2 < childInfo.nodes.length; _i2++) {
                      var childNode = childInfo.nodes[_i2];
                      if (!childNode || target.children.includes(childNode)) {
                        continue;
                      }
                      target.children.push(childNode);
                      childNode.modifyParent(target);
                      generateTargetMap(childNode, curTargetMap, false);
                      childNode.siblingIndex = target.children.length - 1;
                      expandPrefabInstanceNode(childNode, true);
                    }
                  }
                }
              }
            }
            function applyMountedComponents(node, mountedComponents, targetMap) {
              if (!mountedComponents) {
                return;
              }
              for (var i = 0; i < mountedComponents.length; i++) {
                var componentsInfo = mountedComponents[i];
                if (componentsInfo && componentsInfo.targetInfo) {
                  var target = getTarget(componentsInfo.targetInfo.localID, targetMap);
                  if (!target) {
                    continue;
                  }
                  if (componentsInfo.components) {
                    for (var _i3 = 0; _i3 < componentsInfo.components.length; _i3++) {
                      var comp = componentsInfo.components[_i3];
                      if (!comp) {
                        continue;
                      }
                      comp.node = target;
                      target.getWritableComponents().push(comp);
                    }
                  }
                }
              }
            }
            function applyRemovedComponents(node, removedComponents, targetMap) {
              if (!removedComponents) {
                return;
              }
              for (var i = 0; i < removedComponents.length; i++) {
                var targetInfo = removedComponents[i];
                if (targetInfo) {
                  var target = getTarget(targetInfo.localID, targetMap);
                  if (!target || !target.node) {
                    continue;
                  }
                  var index = target.node.components.indexOf(target);
                  if (index >= 0) {
                    target.node.getWritableComponents().splice(index, 1);
                  }
                }
              }
            }
            function applyPropertyOverrides(node, propertyOverrides, targetMap) {
              if (propertyOverrides.length <= 0) {
                return;
              }
              var target = null;
              for (var i = 0; i < propertyOverrides.length; i++) {
                var propOverride = propertyOverrides[i];
                if (propOverride && propOverride.targetInfo) {
                  var targetInfo = propOverride.targetInfo;
                  target = getTarget(targetInfo.localID, targetMap);
                  if (!target) {
                    continue;
                  }
                  var targetPropOwner = target;
                  var propertyPath = propOverride.propertyPath.slice();
                  if (propertyPath.length > 0) {
                    var targetPropName = propertyPath.pop();
                    if (!targetPropName) {
                      continue;
                    }
                    for (var _i4 = 0; _i4 < propertyPath.length; _i4++) {
                      var propName = propertyPath[_i4];
                      targetPropOwner = targetPropOwner[propName];
                      if (!targetPropOwner) {
                        break;
                      }
                    }
                    if (!targetPropOwner) {
                      continue;
                    }
                    if (Array.isArray(targetPropOwner)) {
                      if (targetPropName === 'length') {
                        targetPropOwner[targetPropName] = propOverride.value;
                      } else {
                        var index = Number.parseInt(targetPropName);
                        if (Number.isInteger(index) && index < targetPropOwner.length) {
                          targetPropOwner[targetPropName] = propOverride.value;
                        }
                      }
                    } else if (targetPropOwner[targetPropName] instanceof ValueType) {
                      targetPropOwner[targetPropName].set(propOverride.value);
                    } else {
                      targetPropOwner[targetPropName] = propOverride.value;
                    }
                  }
                }
              }
            }
            function applyTargetOverrides(node) {
              var _node$prefab2;
              var targetOverrides = (_node$prefab2 = node.prefab) == null ? undefined : _node$prefab2.targetOverrides;
              if (targetOverrides) {
                for (var i = 0; i < targetOverrides.length; i++) {
                  var _targetAsNode$prefab;
                  var targetOverride = targetOverrides[i];
                  var source = targetOverride.source;
                  var sourceInfo = targetOverride.sourceInfo;
                  if (sourceInfo) {
                    var _src$prefab;
                    var src = targetOverride.source;
                    var sourceInstance = src == null ? undefined : (_src$prefab = src.prefab) == null ? undefined : _src$prefab.instance;
                    if (sourceInstance && sourceInstance.targetMap) {
                      source = getTarget(sourceInfo.localID, sourceInstance.targetMap);
                    }
                  }
                  if (!source) {
                    continue;
                  }
                  var target = null;
                  var targetInfo = targetOverride.targetInfo;
                  if (!targetInfo) {
                    continue;
                  }
                  var targetAsNode = targetOverride.target;
                  var targetInstance = targetAsNode == null ? undefined : (_targetAsNode$prefab = targetAsNode.prefab) == null ? undefined : _targetAsNode$prefab.instance;
                  if (!targetInstance || !targetInstance.targetMap) {
                    continue;
                  }
                  target = getTarget(targetInfo.localID, targetInstance.targetMap);
                  if (!target) {
                    continue;
                  }
                  var propertyPath = targetOverride.propertyPath.slice();
                  var targetPropOwner = source;
                  if (propertyPath.length > 0) {
                    var targetPropName = propertyPath.pop();
                    if (!targetPropName) {
                      return;
                    }
                    for (var _i5 = 0; _i5 < propertyPath.length; _i5++) {
                      var propName = propertyPath[_i5];
                      targetPropOwner = targetPropOwner[propName];
                      if (!targetPropOwner) {
                        break;
                      }
                    }
                    if (!targetPropOwner) {
                      continue;
                    }
                    targetPropOwner[targetPropName] = target;
                  }
                }
              }
            }
            function expandPrefabInstanceNode(node, recursively) {
              var _node$prefab3;
              if (recursively === undefined) {
                recursively = false;
              }
              var prefabInstance = node == null ? undefined : (_node$prefab3 = node.prefab) == null ? undefined : _node$prefab3.instance;
              if (prefabInstance && !prefabInstance.expanded) {
                createNodeWithPrefab(node);
                if (recursively) {
                  if (node && node.children) {
                    node.children.forEach(function (child) {
                      expandPrefabInstanceNode(child, true);
                    });
                  }
                }
                var targetMap = {};
                prefabInstance.targetMap = targetMap;
                generateTargetMap(node, targetMap, true);
                applyMountedChildren(node, prefabInstance.mountedChildren, targetMap);
                applyRemovedComponents(node, prefabInstance.removedComponents, targetMap);
                applyMountedComponents(node, prefabInstance.mountedComponents, targetMap);
                applyPropertyOverrides(node, prefabInstance.propertyOverrides, targetMap);
                prefabInstance.expanded = true;
              } else if (recursively) {
                if (node && node.children) {
                  node.children.forEach(function (child) {
                    expandPrefabInstanceNode(child, true);
                  });
                }
              }
            }
            function expandNestedPrefabInstanceNode(node) {
              var prefabInfo = node.prefab;
              if (prefabInfo && prefabInfo.nestedPrefabInstanceRoots) {
                prefabInfo.nestedPrefabInstanceRoots.forEach(function (instanceNode) {
                  expandPrefabInstanceNode(instanceNode);
                });
              }
            }
            function applyNodeAndComponentId(prefabInstanceNode, rootId) {
              var components = prefabInstanceNode.components,
                children = prefabInstanceNode.children;
              for (var i = 0; i < components.length; i++) {
                var _comp$__prefab$fileId, _comp$__prefab;
                var comp = components[i];
                var fileID = (_comp$__prefab$fileId = (_comp$__prefab = comp.__prefab) == null ? undefined : _comp$__prefab.fileId) !== null && _comp$__prefab$fileId !== undefined ? _comp$__prefab$fileId : '';
                comp._id = "" + rootId + fileID;
              }
              for (var _i6 = 0; _i6 < children.length; _i6++) {
                var child = children[_i6];
                var prefabInfo = child.prefab;
                var fileId = prefabInfo != null && prefabInfo.instance ? prefabInfo.instance.fileId : prefabInfo == null ? undefined : prefabInfo.fileId;
                if (!fileId) continue;
                child.id = "" + rootId + fileId;
                if (!(prefabInfo != null && prefabInfo.instance)) {
                  applyNodeAndComponentId(child, rootId);
                }
              }
            }

            var utils$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                CompPrefabInfo: CompPrefabInfo,
                MountedChildrenInfo: MountedChildrenInfo,
                MountedComponentsInfo: MountedComponentsInfo,
                PrefabInfo: PrefabInfo,
                PrefabInstance: PrefabInstance,
                PropertyOverrideInfo: PropertyOverrideInfo,
                TargetInfo: TargetInfo,
                TargetOverrideInfo: TargetOverrideInfo,
                applyMountedChildren: applyMountedChildren,
                applyMountedComponents: applyMountedComponents,
                applyNodeAndComponentId: applyNodeAndComponentId,
                applyPropertyOverrides: applyPropertyOverrides,
                applyRemovedComponents: applyRemovedComponents,
                applyTargetOverrides: applyTargetOverrides,
                createNodeWithPrefab: createNodeWithPrefab,
                expandNestedPrefabInstanceNode: expandNestedPrefabInstanceNode,
                expandPrefabInstanceNode: expandPrefabInstanceNode,
                generateTargetMap: generateTargetMap,
                getTarget: getTarget
            });

            var _dec$u, _class$u, _class2$q, _initializer$p, _initializer2$l;
            var Scene = exports("Scene", (_dec$u = ccclass$6('cc.Scene'), _dec$u(_class$u = (_class2$q = function (_Node) {
              _inheritsLoose(Scene, _Node);
              var _proto = Scene.prototype;
              _proto._updateScene = function _updateScene() {
                this._scene = this;
              };
              function Scene(name) {
                var _this;
                _this = _Node.call(this, name) || this;
                _this.autoReleaseAssets = _initializer$p && _initializer$p();
                _this._globals = _initializer2$l && _initializer2$l();
                _this.dependAssets = null;
                _this._renderScene = null;
                _this._prefabSyncedInLiveReload = false;
                _this._activeInHierarchy = false;
                if (legacyCC.director && legacyCC.director.root) {
                  _this._renderScene = legacyCC.director.root.createScene({});
                }
                _this._inited = legacyCC.game ? !legacyCC.game._isCloning : true;
                return _this;
              }
              _proto.destroy = function destroy() {
                var success = CCObject.prototype.destroy.call(this);
                if (success) {
                  var children = this._children;
                  for (var i = 0; i < children.length; ++i) {
                    children[i].active = false;
                  }
                }
                if (this._renderScene) legacyCC.director.root.destroyScene(this._renderScene);
                this._active = false;
                this._activeInHierarchy = false;
                return success;
              };
              _proto.addComponent = function addComponent() {
                throw new Error(getError(3822));
              };
              _proto._onHierarchyChanged = function _onHierarchyChanged() {};
              _proto._onPostActivated = function _onPostActivated(active) {};
              _proto._onBatchCreated = function _onBatchCreated(dontSyncChildPrefab) {
                var len = this._children.length;
                for (var i = 0; i < len; ++i) {
                  this._children[i]._siblingIndex = i;
                  this._children[i]._onBatchCreated(dontSyncChildPrefab);
                }
              };
              _proto.updateWorldTransform = function updateWorldTransform() {};
              _proto._instantiate = function _instantiate(cloned, isSyncedNode) {
                return null;
              };
              _proto._load = function _load() {
                if (!this._inited) {
                  expandNestedPrefabInstanceNode(this);
                  applyTargetOverrides(this);
                  this._onBatchCreated(EDITOR);
                  this._inited = true;
                }
                this.walk(Node$1._setScene);
              };
              _proto._activate = function _activate(active) {
                if (active === undefined) {
                  active = true;
                }
                legacyCC.director._nodeActivator.activateNode(this, active);
                {
                  this._globals.activate(this);
                }
              };
              _createClass(Scene, [{
                key: "renderScene",
                get: function get() {
                  return this._renderScene;
                }
              }, {
                key: "globals",
                get: function get() {
                  return this._globals;
                }
              }]);
              return Scene;
            }(Node$1), (_initializer$p = applyDecoratedInitializer(_class2$q.prototype, "autoReleaseAssets", [serializable$5], function () {
              return false;
            }), _initializer2$l = applyDecoratedInitializer(_class2$q.prototype, "_globals", [serializable$5], function () {
              return new SceneGlobals();
            })), _class2$q)) || _class$u));
            legacyCC.Scene = Scene;

            var _dec$t, _class$t, _class2$p, _initializer$o;
            var SceneAsset = exports("SceneAsset", (_dec$t = ccclass$6('cc.SceneAsset'), _dec$t(_class$t = (_class2$p = function (_Asset) {
              _inheritsLoose(SceneAsset, _Asset);
              function SceneAsset(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this.scene = _initializer$o && _initializer$o();
                return _this;
              }
              var _proto = SceneAsset.prototype;
              _proto.initDefault = function initDefault(uuid) {
                _Asset.prototype.initDefault.call(this, uuid);
                this.scene = new Scene('New Scene');
              };
              _proto.validate = function validate() {
                return !!this.scene;
              };
              return SceneAsset;
            }(Asset), (_initializer$o = applyDecoratedInitializer(_class2$p.prototype, "scene", [serializable$5], function () {
              return null;
            })), _class2$p)) || _class$t));
            cclegacy.SceneAsset = SceneAsset;

            function createMorphRendering(mesh, gfxDevice) {
              return new StdMorphRendering(mesh, gfxDevice);
            }
            var StdMorphRendering = function () {
              function StdMorphRendering(mesh, gfxDevice) {
                this._subMeshRenderings = [];
                this._mesh = mesh;
                if (!this._mesh.struct.morph) {
                  return;
                }
                var nSubMeshes = this._mesh.struct.primitives.length;
                this._subMeshRenderings = new Array(nSubMeshes).fill(null);
                for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  var subMeshMorph = this._mesh.struct.morph.subMeshMorphs[iSubMesh];
                  if (!subMeshMorph) {
                    continue;
                  }
                  if (subMeshMorph.targets.length > 60) {
                    this._subMeshRenderings[iSubMesh] = new CpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice);
                  } else {
                    this._subMeshRenderings[iSubMesh] = new GpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice);
                  }
                }
              }
              var _proto = StdMorphRendering.prototype;
              _proto.createInstance = function createInstance() {
                var _this = this;
                var nSubMeshes = this._mesh.struct.primitives.length;
                var subMeshInstances = new Array(nSubMeshes);
                for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  var _this$_subMeshRenderi, _this$_subMeshRenderi2;
                  subMeshInstances[iSubMesh] = (_this$_subMeshRenderi = (_this$_subMeshRenderi2 = this._subMeshRenderings[iSubMesh]) == null ? undefined : _this$_subMeshRenderi2.createInstance()) !== null && _this$_subMeshRenderi !== undefined ? _this$_subMeshRenderi : null;
                }
                return {
                  setWeights: function setWeights(subMeshIndex, weights) {
                    var _subMeshInstances$sub;
                    (_subMeshInstances$sub = subMeshInstances[subMeshIndex]) == null ? undefined : _subMeshInstances$sub.setWeights(weights);
                  },
                  requiredPatches: function requiredPatches(subMeshIndex) {
                    assertIsNonNullable(_this._mesh.struct.morph);
                    var subMeshMorph = _this._mesh.struct.morph.subMeshMorphs[subMeshIndex];
                    var subMeshRenderingInstance = subMeshInstances[subMeshIndex];
                    if (subMeshRenderingInstance === null) {
                      return null;
                    }
                    assertIsNonNullable(subMeshMorph);
                    var patches = [{
                      name: 'CC_USE_MORPH',
                      value: true
                    }, {
                      name: 'CC_MORPH_TARGET_COUNT',
                      value: subMeshMorph.targets.length
                    }];
                    if (subMeshMorph.attributes.includes("a_position")) {
                      patches.push({
                        name: 'CC_MORPH_TARGET_HAS_POSITION',
                        value: true
                      });
                    }
                    if (subMeshMorph.attributes.includes("a_normal")) {
                      patches.push({
                        name: 'CC_MORPH_TARGET_HAS_NORMAL',
                        value: true
                      });
                    }
                    if (subMeshMorph.attributes.includes("a_tangent")) {
                      patches.push({
                        name: 'CC_MORPH_TARGET_HAS_TANGENT',
                        value: true
                      });
                    }
                    patches.push.apply(patches, subMeshRenderingInstance.requiredPatches());
                    return patches;
                  },
                  adaptPipelineState: function adaptPipelineState(subMeshIndex, descriptorSet) {
                    var _subMeshInstances$sub2;
                    (_subMeshInstances$sub2 = subMeshInstances[subMeshIndex]) == null ? undefined : _subMeshInstances$sub2.adaptPipelineState(descriptorSet);
                  },
                  destroy: function destroy() {
                    subMeshInstances.forEach(function (subMeshInstance) {
                      if (subMeshInstance) subMeshInstance.destroy();
                    });
                  }
                };
              };
              return StdMorphRendering;
            }();
            var GpuComputing = function () {
              function GpuComputing(mesh, subMeshIndex, morph, gfxDevice) {
                this._gfxDevice = gfxDevice;
                var subMeshMorph = morph.subMeshMorphs[subMeshIndex];
                assertIsNonNullable(subMeshMorph);
                this._subMeshMorph = subMeshMorph;
                enableVertexId(mesh, subMeshIndex, gfxDevice);
                var nVertices = mesh.struct.vertexBundles[mesh.struct.primitives[subMeshIndex].vertexBundelIndices[0]].view.count;
                this._verticesCount = nVertices;
                var nTargets = subMeshMorph.targets.length;
                var vec4Required = nVertices * nTargets;
                var vec4TextureFactory = createVec4TextureFactory(gfxDevice, vec4Required);
                this._textureInfo = {
                  width: vec4TextureFactory.width,
                  height: vec4TextureFactory.height
                };
                this._attributes = subMeshMorph.attributes.map(function (attributeName, attributeIndex) {
                  var vec4Tex = vec4TextureFactory.create();
                  var valueView = vec4Tex.valueView;
                  subMeshMorph.targets.forEach(function (morphTarget, morphTargetIndex) {
                    var displacementsView = morphTarget.displacements[attributeIndex];
                    var displacements = new Float32Array(mesh.data.buffer, mesh.data.byteOffset + displacementsView.offset, displacementsView.count);
                    var displacementsOffset = nVertices * morphTargetIndex * 4;
                    for (var iVertex = 0; iVertex < nVertices; ++iVertex) {
                      valueView[displacementsOffset + 4 * iVertex + 0] = displacements[3 * iVertex + 0];
                      valueView[displacementsOffset + 4 * iVertex + 1] = displacements[3 * iVertex + 1];
                      valueView[displacementsOffset + 4 * iVertex + 2] = displacements[3 * iVertex + 2];
                    }
                  });
                  vec4Tex.updatePixels();
                  return {
                    name: attributeName,
                    morphTexture: vec4Tex
                  };
                });
              }
              var _proto2 = GpuComputing.prototype;
              _proto2.destroy = function destroy() {
                this._attributes.forEach(function (attribute) {
                  attribute.morphTexture.destroy();
                });
              };
              _proto2.createInstance = function createInstance() {
                var _this2 = this;
                var morphUniforms = new MorphUniforms(this._gfxDevice, this._subMeshMorph.targets.length);
                morphUniforms.setMorphTextureInfo(this._textureInfo.width, this._textureInfo.height);
                morphUniforms.setVerticesCount(this._verticesCount);
                morphUniforms.commit();
                return {
                  setWeights: function setWeights(weights) {
                    morphUniforms.setWeights(weights);
                    morphUniforms.commit();
                  },
                  requiredPatches: function requiredPatches() {
                    return [{
                      name: 'CC_MORPH_TARGET_USE_TEXTURE',
                      value: true
                    }];
                  },
                  adaptPipelineState: function adaptPipelineState(descriptorSet) {
                    for (var i = 0; i < _this2._attributes.length; ++i) {
                      var attribute = _this2._attributes[i];
                      var binding = undefined;
                      switch (attribute.name) {
                        case "a_position":
                          binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING;
                          break;
                        case "a_normal":
                          binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING;
                          break;
                        case "a_tangent":
                          binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING;
                          break;
                        default:
                          warnID(16374);
                          break;
                      }
                      if (binding !== undefined) {
                        descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);
                        descriptorSet.bindTexture(binding, attribute.morphTexture.texture);
                      }
                    }
                    descriptorSet.bindBuffer(UBOMorph.BINDING, morphUniforms.buffer);
                    descriptorSet.update();
                  },
                  destroy: function destroy() {}
                };
              };
              return GpuComputing;
            }();
            var CpuComputing = function () {
              function CpuComputing(mesh, subMeshIndex, morph, gfxDevice) {
                this._attributes = [];
                this._gfxDevice = gfxDevice;
                var subMeshMorph = morph.subMeshMorphs[subMeshIndex];
                assertIsNonNullable(subMeshMorph);
                enableVertexId(mesh, subMeshIndex, gfxDevice);
                this._attributes = subMeshMorph.attributes.map(function (attributeName, attributeIndex) {
                  return {
                    name: attributeName,
                    targets: subMeshMorph.targets.map(function (attributeDisplacement) {
                      return {
                        displacements: new Float32Array(mesh.data.buffer, mesh.data.byteOffset + attributeDisplacement.displacements[attributeIndex].offset, attributeDisplacement.displacements[attributeIndex].count)
                      };
                    })
                  };
                });
              }
              var _proto3 = CpuComputing.prototype;
              _proto3.createInstance = function createInstance() {
                return new CpuComputingRenderingInstance(this, this._attributes[0].targets[0].displacements.length / 3, this._gfxDevice);
              };
              _createClass(CpuComputing, [{
                key: "data",
                get: function get() {
                  return this._attributes;
                }
              }]);
              return CpuComputing;
            }();
            var CpuComputingRenderingInstance = function () {
              function CpuComputingRenderingInstance(owner, nVertices, gfxDevice) {
                this._owner = owner;
                this._morphUniforms = new MorphUniforms(gfxDevice, 0);
                var vec4TextureFactory = createVec4TextureFactory(gfxDevice, nVertices);
                this._morphUniforms.setMorphTextureInfo(vec4TextureFactory.width, vec4TextureFactory.height);
                this._morphUniforms.commit();
                this._attributes = this._owner.data.map(function (attributeMorph, attributeIndex) {
                  var morphTexture = vec4TextureFactory.create();
                  return {
                    attributeName: attributeMorph.name,
                    morphTexture: morphTexture
                  };
                });
              }
              var _proto4 = CpuComputingRenderingInstance.prototype;
              _proto4.setWeights = function setWeights(weights) {
                for (var iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {
                  var myAttribute = this._attributes[iAttribute];
                  var valueView = myAttribute.morphTexture.valueView;
                  var attributeMorph = this._owner.data[iAttribute];
                  assertIsTrue(weights.length === attributeMorph.targets.length);
                  for (var iTarget = 0; iTarget < attributeMorph.targets.length; ++iTarget) {
                    var targetDisplacements = attributeMorph.targets[iTarget].displacements;
                    var weight = weights[iTarget];
                    var nVertices = targetDisplacements.length / 3;
                    if (iTarget === 0) {
                      for (var iVertex = 0; iVertex < nVertices; ++iVertex) {
                        valueView[4 * iVertex + 0] = targetDisplacements[3 * iVertex + 0] * weight;
                        valueView[4 * iVertex + 1] = targetDisplacements[3 * iVertex + 1] * weight;
                        valueView[4 * iVertex + 2] = targetDisplacements[3 * iVertex + 2] * weight;
                      }
                    } else if (weight !== 0.0) {
                      for (var _iVertex = 0; _iVertex < nVertices; ++_iVertex) {
                        valueView[4 * _iVertex + 0] += targetDisplacements[3 * _iVertex + 0] * weight;
                        valueView[4 * _iVertex + 1] += targetDisplacements[3 * _iVertex + 1] * weight;
                        valueView[4 * _iVertex + 2] += targetDisplacements[3 * _iVertex + 2] * weight;
                      }
                    }
                  }
                  myAttribute.morphTexture.updatePixels();
                }
              };
              _proto4.requiredPatches = function requiredPatches() {
                return [{
                  name: 'CC_MORPH_TARGET_USE_TEXTURE',
                  value: true
                }, {
                  name: 'CC_MORPH_PRECOMPUTED',
                  value: true
                }];
              };
              _proto4.adaptPipelineState = function adaptPipelineState(descriptorSet) {
                for (var i = 0; i < this._attributes.length; ++i) {
                  var attribute = this._attributes[i];
                  var attributeName = attribute.attributeName;
                  var binding = undefined;
                  switch (attributeName) {
                    case "a_position":
                      binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING;
                      break;
                    case "a_normal":
                      binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING;
                      break;
                    case "a_tangent":
                      binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING;
                      break;
                    default:
                      warnID(16374);
                      break;
                  }
                  if (binding !== undefined) {
                    descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);
                    descriptorSet.bindTexture(binding, attribute.morphTexture.texture);
                  }
                }
                descriptorSet.bindBuffer(UBOMorph.BINDING, this._morphUniforms.buffer);
                descriptorSet.update();
              };
              _proto4.destroy = function destroy() {
                this._morphUniforms.destroy();
                for (var iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {
                  var myAttribute = this._attributes[iAttribute];
                  myAttribute.morphTexture.destroy();
                }
              };
              return CpuComputingRenderingInstance;
            }();
            var MorphUniforms = function () {
              function MorphUniforms(gfxDevice, targetCount) {
                this._targetCount = targetCount;
                this._localBuffer = new DataView(new ArrayBuffer(256));
                this._remoteBuffer = gfxDevice.createBuffer(new BufferInfo(16 | 2, 2 | 1, 256, 256));
              }
              var _proto5 = MorphUniforms.prototype;
              _proto5.destroy = function destroy() {
                this._remoteBuffer.destroy();
              };
              _proto5.setWeights = function setWeights(weights) {
                assertIsTrue(weights.length === this._targetCount);
                var isLittleEndian = cclegacy.sys.isLittleEndian;
                for (var iWeight = 0; iWeight < weights.length; ++iWeight) {
                  this._localBuffer.setFloat32(0 + 4 * iWeight, weights[iWeight], isLittleEndian);
                }
              };
              _proto5.setMorphTextureInfo = function setMorphTextureInfo(width, height) {
                var isLittleEndian = cclegacy.sys.isLittleEndian;
                this._localBuffer.setFloat32(240, width, isLittleEndian);
                this._localBuffer.setFloat32(244, height, isLittleEndian);
              };
              _proto5.setVerticesCount = function setVerticesCount(count) {
                var isLittleEndian = cclegacy.sys.isLittleEndian;
                this._localBuffer.setFloat32(248, count, isLittleEndian);
              };
              _proto5.commit = function commit() {
                this._remoteBuffer.update(this._localBuffer.buffer);
              };
              _createClass(MorphUniforms, [{
                key: "buffer",
                get: function get() {
                  return this._remoteBuffer;
                }
              }]);
              return MorphUniforms;
            }();
            function createVec4TextureFactory(gfxDevice, vec4Capacity) {
              var hasFeatureFloatTexture = gfxDevice.getFormatFeatures(44) & 2;
              var pixelRequired;
              var pixelFormat;
              var pixelBytes;
              var UpdateViewConstructor;
              if (hasFeatureFloatTexture) {
                pixelRequired = vec4Capacity;
                pixelBytes = 16;
                pixelFormat = 44;
                UpdateViewConstructor = Float32Array;
              } else {
                pixelRequired = 4 * vec4Capacity;
                pixelBytes = 4;
                pixelFormat = 35;
                UpdateViewConstructor = Uint8Array;
              }
              var _bestSizeToHavePixels = bestSizeToHavePixels(pixelRequired),
                width = _bestSizeToHavePixels.width,
                height = _bestSizeToHavePixels.height;
              assertIsTrue(width * height >= pixelRequired);
              return {
                width: width,
                height: height,
                create: function create() {
                  var arrayBuffer = new ArrayBuffer(width * height * pixelBytes);
                  var valueView = new Float32Array(arrayBuffer);
                  var updateView = UpdateViewConstructor === Float32Array ? valueView : new UpdateViewConstructor(arrayBuffer);
                  var image = new ImageAsset({
                    width: width,
                    height: height,
                    _data: updateView,
                    _compressed: false,
                    format: pixelFormat
                  });
                  var textureAsset = new Texture2D();
                  textureAsset.setFilters(1, 1);
                  textureAsset.setMipFilter(0);
                  textureAsset.setWrapMode(2, 2, 2);
                  textureAsset.image = image;
                  if (!textureAsset.getGFXTexture()) {
                    warnID(16375);
                  }
                  var sampler = gfxDevice.getSampler(textureAsset.getSamplerInfo());
                  return {
                    get texture() {
                      return textureAsset.getGFXTexture();
                    },
                    get sampler() {
                      return sampler;
                    },
                    get valueView() {
                      return valueView;
                    },
                    destroy: function destroy() {
                      textureAsset.destroy();
                    },
                    updatePixels: function updatePixels() {
                      textureAsset.uploadData(updateView);
                    }
                  };
                }
              };
            }
            function enableVertexId(mesh, subMeshIndex, gfxDevice) {
              mesh.renderingSubMeshes[subMeshIndex].enableVertexIdChannel(gfxDevice);
            }
            function bestSizeToHavePixels(nPixels) {
              if (nPixels < 5) {
                nPixels = 5;
              }
              var aligned = nextPow2(nPixels);
              var epxSum = log2(aligned);
              var h = epxSum >> 1;
              var w = epxSum & 1 ? h + 1 : h;
              return {
                width: 1 << w,
                height: 1 << h
              };
            }

            deprecateModuleExportedName({
              SystemEventType: {
                newName: 'Input.EventType',
                since: '3.3.0',
                removed: false
              }
            });

            deprecateModuleExportedName({
              SystemEvent: {
                newName: 'Input',
                since: '3.4.0',
                removed: false
              },
              systemEvent: {
                newName: 'input',
                since: '3.4.0',
                removed: false
              }
            });

            var AccelerometerInputSource = function () {
              function AccelerometerInputSource() {
                this._intervalInMileSeconds = 200;
                this._accelTimer = 0;
                this._eventTarget = new EventTarget();
                this._globalEventClass = window.DeviceMotionEvent || window.DeviceOrientationEvent;
                if (systemInfo.browserType === BrowserType.MOBILE_QQ) {
                  this._globalEventClass = window.DeviceOrientationEvent;
                }
                this._deviceEventName = this._globalEventClass === window.DeviceMotionEvent ? 'devicemotion' : 'deviceorientation';
                this._didAccelerateFunc = this._didAccelerate.bind(this);
              }
              var _proto = AccelerometerInputSource.prototype;
              _proto._registerEvent = function _registerEvent() {
                this._accelTimer = performance.now();
                window.addEventListener(this._deviceEventName, this._didAccelerateFunc, false);
              };
              _proto._unregisterEvent = function _unregisterEvent() {
                this._accelTimer = 0;
                window.removeEventListener(this._deviceEventName, this._didAccelerateFunc, false);
              };
              _proto._didAccelerate = function _didAccelerate(event) {
                var now = performance.now();
                if (now - this._accelTimer < this._intervalInMileSeconds) {
                  return;
                }
                this._accelTimer = now;
                var x = 0;
                var y = 0;
                var z = 0;
                if (this._globalEventClass === window.DeviceMotionEvent) {
                  var deviceMotionEvent = event;
                  var _eventAcceleration = deviceMotionEvent.accelerationIncludingGravity;
                  x = ((_eventAcceleration == null ? undefined : _eventAcceleration.x) || 0) * 0.1;
                  y = ((_eventAcceleration == null ? undefined : _eventAcceleration.y) || 0) * 0.1;
                  z = ((_eventAcceleration == null ? undefined : _eventAcceleration.z) || 0) * 0.1;
                } else {
                  var deviceOrientationEvent = event;
                  x = (deviceOrientationEvent.gamma || 0) / 90 * 0.981;
                  y = -((deviceOrientationEvent.beta || 0) / 90) * 0.981;
                  z = (deviceOrientationEvent.alpha || 0) / 90 * 0.981;
                }
                if (screenAdapter.isFrameRotated) {
                  var tmp = x;
                  x = -y;
                  y = tmp;
                }
                var LANDSCAPE_LEFT = -90;
                var PORTRAIT_UPSIDE_DOWN = 180;
                var LANDSCAPE_RIGHT = 90;
                var tmpX = x;
                if (window.orientation === LANDSCAPE_RIGHT) {
                  x = -y;
                  y = tmpX;
                } else if (window.orientation === LANDSCAPE_LEFT) {
                  x = y;
                  y = -tmpX;
                } else if (window.orientation === PORTRAIT_UPSIDE_DOWN) {
                  x = -x;
                  y = -y;
                }
                if (systemInfo.os === OS.ANDROID && systemInfo.browserType !== BrowserType.MOBILE_QQ) {
                  x = -x;
                  y = -y;
                }
                var timestamp = performance.now();
                var acceleration = new Acceleration(x, y, z, timestamp);
                var eventAcceleration = new EventAcceleration(acceleration);
                this._eventTarget.emit("devicemotion", eventAcceleration);
              };
              _proto.start = function start() {
                var _this = this;
                if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
                  DeviceMotionEvent.requestPermission().then(function (response) {
                    if (response === 'granted') {
                      _this._registerEvent();
                    }
                  })["catch"](function (e) {
                    warn(e);
                  });
                } else {
                  this._registerEvent();
                }
              };
              _proto.stop = function stop() {
                this._unregisterEvent();
              };
              _proto.setInterval = function setInterval(intervalInMileSeconds) {
                this._intervalInMileSeconds = intervalInMileSeconds;
              };
              _proto.on = function on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              };
              return AccelerometerInputSource;
            }();

            var InputSource = function InputSource() {};
            var InputSourceAxis1D = function (_InputSource) {
              _inheritsLoose(InputSourceAxis1D, _InputSource);
              function InputSourceAxis1D() {
                return _InputSource.apply(this, arguments) || this;
              }
              var _proto = InputSourceAxis1D.prototype;
              _proto.getValue = function getValue() {
                throw new Error('Method not implemented.');
              };
              return InputSourceAxis1D;
            }(InputSource);
            var InputSourceAxis2D = function (_InputSource2) {
              _inheritsLoose(InputSourceAxis2D, _InputSource2);
              function InputSourceAxis2D() {
                return _InputSource2.apply(this, arguments) || this;
              }
              var _proto2 = InputSourceAxis2D.prototype;
              _proto2.getValue = function getValue() {
                throw new Error('Method not implemented.');
              };
              return InputSourceAxis2D;
            }(InputSource);
            var InputSourceAxis3D = function (_InputSource3) {
              _inheritsLoose(InputSourceAxis3D, _InputSource3);
              function InputSourceAxis3D() {
                return _InputSource3.apply(this, arguments) || this;
              }
              var _proto3 = InputSourceAxis3D.prototype;
              _proto3.getValue = function getValue() {
                throw new Error('Method not implemented.');
              };
              return InputSourceAxis3D;
            }(InputSource);
            var InputSourceQuat = function (_InputSource4) {
              _inheritsLoose(InputSourceQuat, _InputSource4);
              function InputSourceQuat() {
                return _InputSource4.apply(this, arguments) || this;
              }
              var _proto4 = InputSourceQuat.prototype;
              _proto4.getValue = function getValue() {
                throw new Error('Method not implemented.');
              };
              return InputSourceQuat;
            }(InputSource);
            var CompositeInputSourceAxis1D = function (_InputSourceAxis1D) {
              _inheritsLoose(CompositeInputSourceAxis1D, _InputSourceAxis1D);
              function CompositeInputSourceAxis1D(options) {
                var _this;
                _this = _InputSourceAxis1D.call(this) || this;
                _this.positive = options.positive;
                _this.negative = options.negative;
                return _this;
              }
              var _proto5 = CompositeInputSourceAxis1D.prototype;
              _proto5.getValue = function getValue() {
                var positiveValue = this.positive.getValue();
                var negativeValue = this.negative.getValue();
                if (Math.abs(positiveValue) > Math.abs(negativeValue)) {
                  return positiveValue;
                }
                return -negativeValue;
              };
              return CompositeInputSourceAxis1D;
            }(InputSourceAxis1D);
            var CompositeInputSourceAxis2D = function (_InputSourceAxis2D) {
              _inheritsLoose(CompositeInputSourceAxis2D, _InputSourceAxis2D);
              function CompositeInputSourceAxis2D(options) {
                var _this2;
                _this2 = _InputSourceAxis2D.call(this) || this;
                _this2.up = options.up;
                _this2.down = options.down;
                _this2.left = options.left;
                _this2.right = options.right;
                _this2.xAxis = new CompositeInputSourceAxis1D({
                  positive: _this2.right,
                  negative: _this2.left
                });
                _this2.yAxis = new CompositeInputSourceAxis1D({
                  positive: _this2.up,
                  negative: _this2.down
                });
                return _this2;
              }
              var _proto6 = CompositeInputSourceAxis2D.prototype;
              _proto6.getValue = function getValue() {
                return new Vec2(this.xAxis.getValue(), this.yAxis.getValue());
              };
              return CompositeInputSourceAxis2D;
            }(InputSourceAxis2D);
            (function (_InputSourceAxis3D) {
              _inheritsLoose(CompositeInputSourceAxis3D, _InputSourceAxis3D);
              function CompositeInputSourceAxis3D(options) {
                var _this3;
                _this3 = _InputSourceAxis3D.call(this) || this;
                _this3.up = options.up;
                _this3.down = options.down;
                _this3.left = options.left;
                _this3.right = options.right;
                _this3.forward = options.forward;
                _this3.backward = options.backward;
                _this3.xAxis = new CompositeInputSourceAxis1D({
                  positive: _this3.right,
                  negative: _this3.left
                });
                _this3.yAxis = new CompositeInputSourceAxis1D({
                  positive: _this3.up,
                  negative: _this3.down
                });
                _this3.zAxis = new CompositeInputSourceAxis1D({
                  positive: _this3.forward,
                  negative: _this3.backward
                });
                return _this3;
              }
              var _proto7 = CompositeInputSourceAxis3D.prototype;
              _proto7.getValue = function getValue() {
                return new Vec3(this.xAxis.getValue(), this.yAxis.getValue(), this.zAxis.getValue());
              };
              return CompositeInputSourceAxis3D;
            })(InputSourceAxis3D);
            var InputSourceButton = function (_InputSourceAxis1D2) {
              _inheritsLoose(InputSourceButton, _InputSourceAxis1D2);
              function InputSourceButton() {
                return _InputSourceAxis1D2.apply(this, arguments) || this;
              }
              var _proto8 = InputSourceButton.prototype;
              _proto8.getValue = function getValue() {
                return _InputSourceAxis1D2.prototype.getValue.call(this);
              };
              return InputSourceButton;
            }(InputSourceAxis1D);
            var InputSourceDpad = function (_CompositeInputSource) {
              _inheritsLoose(InputSourceDpad, _CompositeInputSource);
              function InputSourceDpad() {
                return _CompositeInputSource.apply(this, arguments) || this;
              }
              return InputSourceDpad;
            }(CompositeInputSourceAxis2D);
            var InputSourceStick = function (_CompositeInputSource2) {
              _inheritsLoose(InputSourceStick, _CompositeInputSource2);
              function InputSourceStick() {
                return _CompositeInputSource2.apply(this, arguments) || this;
              }
              return InputSourceStick;
            }(CompositeInputSourceAxis2D);
            var InputSourceOrientation = function (_InputSourceQuat) {
              _inheritsLoose(InputSourceOrientation, _InputSourceQuat);
              function InputSourceOrientation() {
                return _InputSourceQuat.apply(this, arguments) || this;
              }
              var _proto9 = InputSourceOrientation.prototype;
              _proto9.getValue = function getValue() {
                return _InputSourceQuat.prototype.getValue.call(this);
              };
              return InputSourceOrientation;
            }(InputSourceQuat);
            var InputSourcePosition = function (_InputSourceAxis3D2) {
              _inheritsLoose(InputSourcePosition, _InputSourceAxis3D2);
              function InputSourcePosition() {
                return _InputSourceAxis3D2.apply(this, arguments) || this;
              }
              var _proto10 = InputSourcePosition.prototype;
              _proto10.getValue = function getValue() {
                return _InputSourceAxis3D2.prototype.getValue.call(this);
              };
              return InputSourcePosition;
            }(InputSourceAxis3D);
            var InputSourceTouch = function (_InputSourceAxis1D3) {
              _inheritsLoose(InputSourceTouch, _InputSourceAxis1D3);
              function InputSourceTouch() {
                return _InputSourceAxis1D3.apply(this, arguments) || this;
              }
              var _proto11 = InputSourceTouch.prototype;
              _proto11.getValue = function getValue() {
                return _InputSourceAxis1D3.prototype.getValue.call(this);
              };
              return InputSourceTouch;
            }(InputSourceAxis1D);

            var BUTTON_SOUTH = 0;
            var BUTTON_EAST = 1;
            var BUTTON_WEST = 2;
            var BUTTON_NORTH = 3;
            var BUTTON_L1 = 4;
            var BUTTON_R1 = 5;
            var BUTTON_L2 = 6;
            var BUTTON_R2 = 7;
            var BUTTON_SHARE = 8;
            var BUTTON_OPTIONS = 9;
            var BUTTON_L3 = 10;
            var BUTTON_R3 = 11;
            var BUTTON_DPAD_UP = 12;
            var BUTTON_DPAD_DOWN = 13;
            var BUTTON_DPAD_LEFT = 14;
            var BUTTON_DPAD_RIGHT = 15;
            var AXIS_LEFT_STICK_X = 0;
            var AXIS_LEFT_STICK_Y = 1;
            var AXIS_RIGHT_STICK_X = 2;
            var AXIS_RIGHT_STICK_Y = 3;
            var XR_TRIGGER = 0;
            var XR_GRIP = 1;
            var XR_TOUCHPAD = 2;
            var XR_STICK = 3;
            var XR_BUTTON_1 = 4;
            var XR_BUTTON_2 = 5;
            var EPSILON = 0.01;
            var XRLeftHandedness = 'left';
            var XRRightHandedness = 'right';
            var devicesTmp = [];
            var Pose$1;
            (function (Pose) {
              Pose[Pose["HAND_LEFT"] = 1] = "HAND_LEFT";
              Pose[Pose["HAND_RIGHT"] = 4] = "HAND_RIGHT";
              Pose[Pose["AIM_LEFT"] = 2] = "AIM_LEFT";
              Pose[Pose["AIM_RIGHT"] = 5] = "AIM_RIGHT";
            })(Pose$1 || (Pose$1 = {}));
            var GamepadInputDevice = function () {
              function GamepadInputDevice(deviceId) {
                var _this$_webPoseState;
                this._deviceId = -1;
                this._connected = false;
                this._webPoseState = (_this$_webPoseState = {}, _this$_webPoseState[Pose$1.HAND_LEFT] = {
                  position: Vec3.ZERO,
                  orientation: Quat.IDENTITY
                }, _this$_webPoseState[Pose$1.HAND_RIGHT] = {
                  position: Vec3.ZERO,
                  orientation: Quat.IDENTITY
                }, _this$_webPoseState[Pose$1.AIM_LEFT] = {
                  position: Vec3.ZERO,
                  orientation: Quat.IDENTITY
                }, _this$_webPoseState[Pose$1.AIM_RIGHT] = {
                  position: Vec3.ZERO,
                  orientation: Quat.IDENTITY
                }, _this$_webPoseState);
                this._deviceId = deviceId;
                this._initInputSource();
              }
              GamepadInputDevice._init = function _init() {
                if (!systemInfo.hasFeature(Feature.EVENT_GAMEPAD)) {
                  return;
                }
                GamepadInputDevice._registerEvent();
              };
              GamepadInputDevice._on = function _on(eventType, cb, target) {
                GamepadInputDevice._eventTarget.on(eventType, cb, target);
              };
              GamepadInputDevice._removeInputDevice = function _removeInputDevice(id) {
                var removeIndex = GamepadInputDevice.all.findIndex(function (device) {
                  return device.deviceId === id;
                });
                if (removeIndex === -1) {
                  return;
                }
                fastRemoveAt$2(GamepadInputDevice.all, removeIndex);
              };
              GamepadInputDevice._getOrCreateInputDevice = function _getOrCreateInputDevice(id, connected) {
                var device = GamepadInputDevice.all.find(function (device) {
                  return device.deviceId === id;
                });
                if (!device) {
                  device = new GamepadInputDevice(id);
                  GamepadInputDevice.all.push(device);
                }
                device._connected = connected;
                return device;
              };
              GamepadInputDevice._ensureDirectorDefined = function _ensureDirectorDefined(callback) {
                GamepadInputDevice._intervalId = setInterval(function () {
                  if (legacyCC.director && legacyCC.Director) {
                    clearInterval(GamepadInputDevice._intervalId);
                    GamepadInputDevice._intervalId = -1;
                    callback();
                  }
                }, 50);
              };
              GamepadInputDevice._updateGamepadCnt = function _updateGamepadCnt() {
                var cnt = 0;
                for (var i = 0, l = GamepadInputDevice._cachedWebGamepads.length; i < l; i++) {
                  if (GamepadInputDevice._cachedWebGamepads[i]) cnt++;
                }
                GamepadInputDevice._totalGamepadCnt = cnt;
              };
              GamepadInputDevice._registerEvent = function _registerEvent() {
                GamepadInputDevice._ensureDirectorDefined(function () {
                  GamepadInputDevice._cachedWebGamepads = GamepadInputDevice._getWebGamePads();
                  GamepadInputDevice._updateGamepadCnt();
                  legacyCC.director.on(legacyCC.Director.EVENT_BEGIN_FRAME, GamepadInputDevice._scanGamepads);
                });
                window.addEventListener('gamepadconnected', function (e) {
                  GamepadInputDevice._cachedWebGamepads[e.gamepad.index] = e.gamepad;
                  GamepadInputDevice._updateGamepadCnt();
                  var device = GamepadInputDevice._getOrCreateInputDevice(e.gamepad.index, true);
                  GamepadInputDevice._eventTarget.emit("gamepad-change", new EventGamepad("gamepad-change", device));
                });
                window.addEventListener('gamepaddisconnected', function (e) {
                  GamepadInputDevice._cachedWebGamepads[e.gamepad.index] = null;
                  GamepadInputDevice._updateGamepadCnt();
                  var device = GamepadInputDevice._getOrCreateInputDevice(e.gamepad.index, false);
                  GamepadInputDevice._removeInputDevice(e.gamepad.index);
                  GamepadInputDevice._eventTarget.emit("gamepad-change", new EventGamepad("gamepad-change", device));
                });
              };
              GamepadInputDevice._scanWebGamepads = function _scanWebGamepads(devices) {
                var allDisconnected = GamepadInputDevice._totalGamepadCnt === 0;
                if (allDisconnected) return;
                var webGamepads = GamepadInputDevice._getWebGamePads();
                if (!webGamepads) {
                  return;
                }
                for (var i = 0; i < webGamepads.length; ++i) {
                  var webGamepad = webGamepads[i];
                  if (!webGamepad) {
                    continue;
                  }
                  var cachedWebGamepad = GamepadInputDevice._cachedWebGamepads[webGamepad.index];
                  if (cachedWebGamepad) {
                    var device = undefined;
                    var cachedButtons = cachedWebGamepad.buttons;
                    for (var j = 0; j < cachedButtons.length; ++j) {
                      var cachedButton = cachedButtons[j];
                      var button = webGamepad.buttons[j];
                      if (Math.abs(cachedButton.value - button.value) > EPSILON) {
                        device = GamepadInputDevice._getOrCreateInputDevice(webGamepad.index, true);
                        break;
                      }
                    }
                    if (device) {
                      devices.push(device);
                      continue;
                    }
                    var cachedAxes = cachedWebGamepad.axes;
                    for (var _j = 0; _j < cachedAxes.length; ++_j) {
                      var cachedAxisValue = cachedAxes[_j];
                      var axisValue = webGamepad.axes[_j];
                      if (Math.abs(cachedAxisValue - axisValue) > EPSILON) {
                        device = GamepadInputDevice._getOrCreateInputDevice(webGamepad.index, true);
                        break;
                      }
                    }
                    if (device) {
                      devices.push(device);
                      continue;
                    }
                  }
                }
                GamepadInputDevice._cachedWebGamepads = webGamepads;
              };
              GamepadInputDevice._scanGamepads = function _scanGamepads() {
                devicesTmp.length = 0;
                GamepadInputDevice._scanWebGamepads(devicesTmp);
                GamepadInputDevice._scanWebXRGamepads(devicesTmp);
                for (var i = 0; i < devicesTmp.length; ++i) {
                  var device = devicesTmp[i];
                  GamepadInputDevice._eventTarget.emit("gamepad-input", new EventGamepad("gamepad-input", device));
                }
                GamepadInputDevice._scanWebXRGamepadsPose();
              };
              GamepadInputDevice._scanWebXRGamepads = function _scanWebXRGamepads(devices) {
                return;
              };
              GamepadInputDevice.checkGamepadChanged = function checkGamepadChanged(currGamepad, cachedGamepad) {
                if (!currGamepad && !cachedGamepad) {
                  return false;
                } else if (!currGamepad || !cachedGamepad) {
                  return true;
                }
                var cachedButtons = cachedGamepad.buttons;
                for (var j = 0; j < cachedButtons.length; ++j) {
                  var cachedButton = cachedButtons[j];
                  var button = currGamepad.buttons[j];
                  if (button.value !== 0 || cachedButton !== 0) {
                    return true;
                  }
                }
                var cachedAxes = cachedGamepad.axes;
                for (var _j2 = 0; _j2 < cachedAxes.length; ++_j2) {
                  var cachedAxisValue = cachedAxes[_j2];
                  var axisValue = currGamepad.axes[_j2];
                  if (axisValue !== 0 || cachedAxisValue !== 0) {
                    return true;
                  }
                }
                return false;
              };
              GamepadInputDevice._copyCacheGamepadValue = function _copyCacheGamepadValue(gamepad) {
                if (!gamepad) {
                  return undefined;
                }
                var cacheGamepad = {
                  buttons: new Array(gamepad.buttons.length),
                  axes: new Array(gamepad.axes.length)
                };
                for (var j = 0; j < gamepad.buttons.length; ++j) {
                  cacheGamepad.buttons[j] = gamepad.buttons[j].value;
                }
                for (var _j3 = 0; _j3 < gamepad.axes.length; ++_j3) {
                  cacheGamepad.axes[_j3] = gamepad.axes[_j3];
                }
                return cacheGamepad;
              };
              GamepadInputDevice._scanWebXRGamepadsPose = function _scanWebXRGamepadsPose() {
                return;
              };
              GamepadInputDevice._getWebXRGamepadMap = function _getWebXRGamepadMap() {
                var _globalThis$__globalX2;
                return (_globalThis$__globalX2 = globalThis.__globalXR) == null ? undefined : _globalThis$__globalX2.webxrGamepadMap;
              };
              GamepadInputDevice._getWebGamePads = function _getWebGamePads() {
                if (typeof navigator.getGamepads === 'function') {
                  return navigator.getGamepads();
                } else if (typeof navigator.webkitGetGamepads === 'function') {
                  return navigator.webkitGetGamepads();
                }
                return [];
              };
              GamepadInputDevice._getWebGamepad = function _getWebGamepad(deviceId) {
                var webGamepads = GamepadInputDevice._getWebGamePads();
                for (var i = 0; i < webGamepads.length; ++i) {
                  var webGamepad = webGamepads[i];
                  if (webGamepad && webGamepad.index === deviceId) {
                    return webGamepad;
                  }
                }
                return undefined;
              };
              var _proto = GamepadInputDevice.prototype;
              _proto._axisToButtons = function _axisToButtons(axisValue) {
                var value = Math.abs(axisValue);
                if (axisValue > 0) {
                  return {
                    negative: 0,
                    positive: value
                  };
                } else if (axisValue < 0) {
                  return {
                    negative: value,
                    positive: 0
                  };
                } else {
                  return {
                    negative: 0,
                    positive: 0
                  };
                }
              };
              _proto._updateWebPoseState = function _updateWebPoseState(info) {
                if (info.code !== Pose$1.HAND_LEFT && info.code !== Pose$1.AIM_LEFT && info.code !== Pose$1.HAND_RIGHT && info.code !== Pose$1.AIM_RIGHT) {
                  return;
                }
                this._webPoseState[info.code] = {
                  position: new Vec3(info.position.x, info.position.y, info.position.z),
                  orientation: new Quat(info.orientation.x, info.orientation.y, info.orientation.z, info.orientation.w)
                };
              };
              _proto._initInputSource = function _initInputSource() {
                var _this = this;
                this._buttonNorth = new InputSourceButton();
                this._buttonNorth.getValue = function () {
                  if (_this.deviceId === -1) {
                    var _GamepadInputDevice$_3;
                    var webxrGamepad = (_GamepadInputDevice$_3 = GamepadInputDevice._getWebXRGamepadMap()) == null ? undefined : _GamepadInputDevice$_3.get(XRLeftHandedness);
                    if (webxrGamepad && webxrGamepad.buttons.length > XR_BUTTON_2) {
                      return webxrGamepad.buttons[XR_BUTTON_2].value;
                    }
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_NORTH].value;
                  }
                  return 0;
                };
                this._buttonEast = new InputSourceButton();
                this._buttonEast.getValue = function () {
                  if (_this.deviceId === -1) {
                    var _GamepadInputDevice$_4;
                    var webxrGamepad = (_GamepadInputDevice$_4 = GamepadInputDevice._getWebXRGamepadMap()) == null ? undefined : _GamepadInputDevice$_4.get(XRRightHandedness);
                    if (webxrGamepad && webxrGamepad.buttons.length > XR_BUTTON_2) {
                      return webxrGamepad.buttons[XR_BUTTON_2].value;
                    }
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_EAST].value;
                  }
                  return 0;
                };
                this._buttonWest = new InputSourceButton();
                this._buttonWest.getValue = function () {
                  if (_this.deviceId === -1) {
                    var _GamepadInputDevice$_5;
                    var webxrGamepad = (_GamepadInputDevice$_5 = GamepadInputDevice._getWebXRGamepadMap()) == null ? undefined : _GamepadInputDevice$_5.get(XRLeftHandedness);
                    if (webxrGamepad && webxrGamepad.buttons.length > XR_BUTTON_1) {
                      return webxrGamepad.buttons[XR_BUTTON_1].value;
                    }
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_WEST].value;
                  }
                  return 0;
                };
                this._buttonSouth = new InputSourceButton();
                this._buttonSouth.getValue = function () {
                  if (_this.deviceId === -1) {
                    var _GamepadInputDevice$_6;
                    var webxrGamepad = (_GamepadInputDevice$_6 = GamepadInputDevice._getWebXRGamepadMap()) == null ? undefined : _GamepadInputDevice$_6.get(XRRightHandedness);
                    if (webxrGamepad && webxrGamepad.buttons.length > XR_BUTTON_1) {
                      return webxrGamepad.buttons[XR_BUTTON_1].value;
                    }
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_SOUTH].value;
                  }
                  return 0;
                };
                this._buttonL1 = new InputSourceButton();
                this._buttonL1.getValue = function () {
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_L1].value;
                  }
                  return 0;
                };
                this._buttonL2 = new InputSourceButton();
                this._buttonL2.getValue = function () {
                  if (_this.deviceId === -1) {
                    var _GamepadInputDevice$_7;
                    var webxrGamepad = (_GamepadInputDevice$_7 = GamepadInputDevice._getWebXRGamepadMap()) == null ? undefined : _GamepadInputDevice$_7.get(XRLeftHandedness);
                    if (webxrGamepad && webxrGamepad.buttons.length > XR_TRIGGER) {
                      return webxrGamepad.buttons[XR_TRIGGER].value;
                    }
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_L2].value;
                  }
                  return 0;
                };
                this._buttonL3 = new InputSourceButton();
                this._buttonL3.getValue = function () {
                  if (_this.deviceId === -1) {
                    var _GamepadInputDevice$_8;
                    var webxrGamepad = (_GamepadInputDevice$_8 = GamepadInputDevice._getWebXRGamepadMap()) == null ? undefined : _GamepadInputDevice$_8.get(XRLeftHandedness);
                    if (webxrGamepad) {
                      if (webxrGamepad.buttons.length > XR_STICK && webxrGamepad.buttons[XR_STICK].value !== 0) {
                        return webxrGamepad.buttons[XR_STICK].value;
                      } else if (webxrGamepad.buttons.length > XR_TOUCHPAD && webxrGamepad.buttons[XR_TOUCHPAD].value !== 0) {
                        return webxrGamepad.buttons[XR_TOUCHPAD].value;
                      }
                    }
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_L3].value;
                  }
                  return 0;
                };
                this._buttonR1 = new InputSourceButton();
                this._buttonR1.getValue = function () {
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_R1].value;
                  }
                  return 0;
                };
                this._buttonR2 = new InputSourceButton();
                this._buttonR2.getValue = function () {
                  if (_this.deviceId === -1) {
                    var _GamepadInputDevice$_9;
                    var webxrGamepad = (_GamepadInputDevice$_9 = GamepadInputDevice._getWebXRGamepadMap()) == null ? undefined : _GamepadInputDevice$_9.get(XRRightHandedness);
                    if (webxrGamepad && webxrGamepad.buttons.length > XR_TRIGGER) {
                      return webxrGamepad.buttons[XR_TRIGGER].value;
                    }
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_R2].value;
                  }
                  return 0;
                };
                this._buttonR3 = new InputSourceButton();
                this._buttonR3.getValue = function () {
                  if (_this.deviceId === -1) {
                    var _GamepadInputDevice$_10;
                    var webxrGamepad = (_GamepadInputDevice$_10 = GamepadInputDevice._getWebXRGamepadMap()) == null ? undefined : _GamepadInputDevice$_10.get(XRRightHandedness);
                    if (webxrGamepad) {
                      if (webxrGamepad.buttons.length > XR_STICK && webxrGamepad.buttons[XR_STICK].value !== 0) {
                        return webxrGamepad.buttons[XR_STICK].value;
                      } else if (webxrGamepad.buttons.length > XR_TOUCHPAD && webxrGamepad.buttons[XR_TOUCHPAD].value !== 0) {
                        return webxrGamepad.buttons[XR_TOUCHPAD].value;
                      }
                    }
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_R3].value;
                  }
                  return 0;
                };
                this._buttonShare = new InputSourceButton();
                this._buttonShare.getValue = function () {
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_SHARE].value;
                  }
                  return 0;
                };
                this._buttonOptions = new InputSourceButton();
                this._buttonOptions.getValue = function () {
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_OPTIONS].value;
                  }
                  return 0;
                };
                var dpadUp = new InputSourceButton();
                dpadUp.getValue = function () {
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_DPAD_UP].value;
                  }
                  return 0;
                };
                var dpadDown = new InputSourceButton();
                dpadDown.getValue = function () {
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_DPAD_DOWN].value;
                  }
                  return 0;
                };
                var dpadLeft = new InputSourceButton();
                dpadLeft.getValue = function () {
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_DPAD_LEFT].value;
                  }
                  return 0;
                };
                var dpadRight = new InputSourceButton();
                dpadRight.getValue = function () {
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return webGamepad.buttons[BUTTON_DPAD_RIGHT].value;
                  }
                  return 0;
                };
                this._dpad = new InputSourceDpad({
                  up: dpadUp,
                  down: dpadDown,
                  left: dpadLeft,
                  right: dpadRight
                });
                var leftStickUp = new InputSourceButton();
                leftStickUp.getValue = function () {
                  if (_this.deviceId === -1) {
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return _this._axisToButtons(webGamepad.axes[AXIS_LEFT_STICK_Y]).negative;
                  }
                  return 0;
                };
                var leftStickDown = new InputSourceButton();
                leftStickDown.getValue = function () {
                  if (_this.deviceId === -1) {
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return _this._axisToButtons(webGamepad.axes[AXIS_LEFT_STICK_Y]).positive;
                  }
                  return 0;
                };
                var leftStickLeft = new InputSourceButton();
                leftStickLeft.getValue = function () {
                  if (_this.deviceId === -1) {
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return _this._axisToButtons(webGamepad.axes[AXIS_LEFT_STICK_X]).negative;
                  }
                  return 0;
                };
                var leftStickRight = new InputSourceButton();
                leftStickRight.getValue = function () {
                  if (_this.deviceId === -1) {
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return _this._axisToButtons(webGamepad.axes[AXIS_LEFT_STICK_X]).positive;
                  }
                  return 0;
                };
                this._leftStick = new InputSourceStick({
                  up: leftStickUp,
                  down: leftStickDown,
                  left: leftStickLeft,
                  right: leftStickRight
                });
                var rightStickUp = new InputSourceButton();
                rightStickUp.getValue = function () {
                  if (_this.deviceId === -1) {
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return _this._axisToButtons(webGamepad.axes[AXIS_RIGHT_STICK_Y]).negative;
                  }
                  return 0;
                };
                var rightStickDown = new InputSourceButton();
                rightStickDown.getValue = function () {
                  if (_this.deviceId === -1) {
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return _this._axisToButtons(webGamepad.axes[AXIS_RIGHT_STICK_Y]).positive;
                  }
                  return 0;
                };
                var rightStickLeft = new InputSourceButton();
                rightStickLeft.getValue = function () {
                  if (_this.deviceId === -1) {
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return _this._axisToButtons(webGamepad.axes[AXIS_RIGHT_STICK_X]).negative;
                  }
                  return 0;
                };
                var rightStickRight = new InputSourceButton();
                rightStickRight.getValue = function () {
                  if (_this.deviceId === -1) {
                    return 0;
                  }
                  var webGamepad = GamepadInputDevice._getWebGamepad(_this.deviceId);
                  if (webGamepad) {
                    return _this._axisToButtons(webGamepad.axes[AXIS_RIGHT_STICK_X]).positive;
                  }
                  return 0;
                };
                this._rightStick = new InputSourceStick({
                  up: rightStickUp,
                  down: rightStickDown,
                  left: rightStickLeft,
                  right: rightStickRight
                });
                this._buttonStart = new InputSourceButton();
                this._buttonStart.getValue = function () {
                  return 0;
                };
                this._gripLeft = new InputSourceButton();
                this._gripLeft.getValue = function () {
                  if (_this.deviceId === -1) ;
                  return 0;
                };
                this._gripRight = new InputSourceButton();
                this._gripRight.getValue = function () {
                  if (_this.deviceId === -1) {
                    var _GamepadInputDevice$_20;
                    var webxrGamepad = (_GamepadInputDevice$_20 = GamepadInputDevice._getWebXRGamepadMap()) == null ? undefined : _GamepadInputDevice$_20.get(XRRightHandedness);
                    if (webxrGamepad && webxrGamepad.buttons.length > XR_GRIP) {
                      return webxrGamepad.buttons[XR_GRIP].value;
                    }
                  }
                  return 0;
                };
                this._handLeftPosition = new InputSourcePosition();
                this._handLeftPosition.getValue = function () {
                  return _this._webPoseState[Pose$1.HAND_LEFT].position;
                };
                this._handLeftOrientation = new InputSourceOrientation();
                this._handLeftOrientation.getValue = function () {
                  return _this._webPoseState[Pose$1.HAND_LEFT].orientation;
                };
                this._handRightPosition = new InputSourcePosition();
                this._handRightPosition.getValue = function () {
                  return _this._webPoseState[Pose$1.HAND_RIGHT].position;
                };
                this._handRightOrientation = new InputSourceOrientation();
                this._handRightOrientation.getValue = function () {
                  return _this._webPoseState[Pose$1.HAND_RIGHT].orientation;
                };
                this._aimLeftPosition = new InputSourcePosition();
                this._aimLeftPosition.getValue = function () {
                  return _this._webPoseState[Pose$1.AIM_LEFT].position;
                };
                this._aimLeftOrientation = new InputSourceOrientation();
                this._aimLeftOrientation.getValue = function () {
                  return _this._webPoseState[Pose$1.AIM_LEFT].orientation;
                };
                this._aimRightPosition = new InputSourcePosition();
                this._aimRightPosition.getValue = function () {
                  return _this._webPoseState[Pose$1.AIM_RIGHT].position;
                };
                this._aimRightOrientation = new InputSourceOrientation();
                this._aimRightOrientation.getValue = function () {
                  return _this._webPoseState[Pose$1.AIM_RIGHT].orientation;
                };
              };
              _createClass(GamepadInputDevice, [{
                key: "buttonNorth",
                get: function get() {
                  return this._buttonNorth;
                }
              }, {
                key: "buttonEast",
                get: function get() {
                  return this._buttonEast;
                }
              }, {
                key: "buttonWest",
                get: function get() {
                  return this._buttonWest;
                }
              }, {
                key: "buttonSouth",
                get: function get() {
                  return this._buttonSouth;
                }
              }, {
                key: "buttonL1",
                get: function get() {
                  return this._buttonL1;
                }
              }, {
                key: "buttonL2",
                get: function get() {
                  return this._buttonL2;
                }
              }, {
                key: "buttonL3",
                get: function get() {
                  return this._buttonL3;
                }
              }, {
                key: "buttonR1",
                get: function get() {
                  return this._buttonR1;
                }
              }, {
                key: "buttonR2",
                get: function get() {
                  return this._buttonR2;
                }
              }, {
                key: "buttonR3",
                get: function get() {
                  return this._buttonR3;
                }
              }, {
                key: "buttonShare",
                get: function get() {
                  return this._buttonShare;
                }
              }, {
                key: "buttonOptions",
                get: function get() {
                  return this._buttonOptions;
                }
              }, {
                key: "dpad",
                get: function get() {
                  return this._dpad;
                }
              }, {
                key: "leftStick",
                get: function get() {
                  return this._leftStick;
                }
              }, {
                key: "rightStick",
                get: function get() {
                  return this._rightStick;
                }
              }, {
                key: "buttonStart",
                get: function get() {
                  return this._buttonStart;
                }
              }, {
                key: "gripLeft",
                get: function get() {
                  return this._gripLeft;
                }
              }, {
                key: "gripRight",
                get: function get() {
                  return this._gripRight;
                }
              }, {
                key: "handLeftPosition",
                get: function get() {
                  return this._handLeftPosition;
                }
              }, {
                key: "handLeftOrientation",
                get: function get() {
                  return this._handLeftOrientation;
                }
              }, {
                key: "handRightPosition",
                get: function get() {
                  return this._handRightPosition;
                }
              }, {
                key: "handRightOrientation",
                get: function get() {
                  return this._handRightOrientation;
                }
              }, {
                key: "aimLeftPosition",
                get: function get() {
                  return this._aimLeftPosition;
                }
              }, {
                key: "aimLeftOrientation",
                get: function get() {
                  return this._aimLeftOrientation;
                }
              }, {
                key: "aimRightPosition",
                get: function get() {
                  return this._aimRightPosition;
                }
              }, {
                key: "aimRightOrientation",
                get: function get() {
                  return this._aimRightOrientation;
                }
              }, {
                key: "deviceId",
                get: function get() {
                  return this._deviceId;
                }
              }, {
                key: "connected",
                get: function get() {
                  return this._connected;
                }
              }]);
              return GamepadInputDevice;
            }();
            GamepadInputDevice.all = [];
            GamepadInputDevice.xr = null;
            GamepadInputDevice._eventTarget = new EventTarget();
            GamepadInputDevice._cachedWebGamepads = [];
            GamepadInputDevice._cachedWebXRGamepadMap = null;
            GamepadInputDevice._intervalId = -1;
            GamepadInputDevice._totalGamepadCnt = 0;

            var Button;
            (function (Button) {
              Button[Button["BUTTON_EAST"] = 0] = "BUTTON_EAST";
              Button[Button["BUTTON_SOUTH"] = 1] = "BUTTON_SOUTH";
              Button[Button["BUTTON_WEST"] = 2] = "BUTTON_WEST";
              Button[Button["BUTTON_NORTH"] = 3] = "BUTTON_NORTH";
              Button[Button["BUTTON_TRIGGER_LEFT"] = 4] = "BUTTON_TRIGGER_LEFT";
              Button[Button["BUTTON_TRIGGER_RIGHT"] = 5] = "BUTTON_TRIGGER_RIGHT";
              Button[Button["TRIGGER_LEFT"] = 6] = "TRIGGER_LEFT";
              Button[Button["TRIGGER_RIGHT"] = 7] = "TRIGGER_RIGHT";
              Button[Button["GRIP_LEFT"] = 8] = "GRIP_LEFT";
              Button[Button["GRIP_RIGHT"] = 9] = "GRIP_RIGHT";
              Button[Button["BUTTON_LEFT_STICK"] = 10] = "BUTTON_LEFT_STICK";
              Button[Button["LEFT_STICK_UP"] = 11] = "LEFT_STICK_UP";
              Button[Button["LEFT_STICK_DOWN"] = 12] = "LEFT_STICK_DOWN";
              Button[Button["LEFT_STICK_LEFT"] = 13] = "LEFT_STICK_LEFT";
              Button[Button["LEFT_STICK_RIGHT"] = 14] = "LEFT_STICK_RIGHT";
              Button[Button["BUTTON_RIGHT_STICK"] = 15] = "BUTTON_RIGHT_STICK";
              Button[Button["RIGHT_STICK_UP"] = 16] = "RIGHT_STICK_UP";
              Button[Button["RIGHT_STICK_DOWN"] = 17] = "RIGHT_STICK_DOWN";
              Button[Button["RIGHT_STICK_LEFT"] = 18] = "RIGHT_STICK_LEFT";
              Button[Button["RIGHT_STICK_RIGHT"] = 19] = "RIGHT_STICK_RIGHT";
              Button[Button["ROKID_MENU"] = 20] = "ROKID_MENU";
              Button[Button["ROKID_START"] = 21] = "ROKID_START";
            })(Button || (Button = {}));
            var KeyEventType;
            (function (KeyEventType) {
              KeyEventType[KeyEventType["KET_CLICK"] = 0] = "KET_CLICK";
              KeyEventType[KeyEventType["KET_STICK"] = 1] = "KET_STICK";
              KeyEventType[KeyEventType["KET_GRAB"] = 2] = "KET_GRAB";
              KeyEventType[KeyEventType["KET_TOUCH"] = 3] = "KET_TOUCH";
            })(KeyEventType || (KeyEventType = {}));
            var StickKeyCode;
            (function (StickKeyCode) {
              StickKeyCode[StickKeyCode["UNDEFINE"] = 0] = "UNDEFINE";
              StickKeyCode[StickKeyCode["A"] = 1] = "A";
              StickKeyCode[StickKeyCode["B"] = 2] = "B";
              StickKeyCode[StickKeyCode["X"] = 3] = "X";
              StickKeyCode[StickKeyCode["Y"] = 4] = "Y";
              StickKeyCode[StickKeyCode["L1"] = 5] = "L1";
              StickKeyCode[StickKeyCode["R1"] = 6] = "R1";
              StickKeyCode[StickKeyCode["MINUS"] = 7] = "MINUS";
              StickKeyCode[StickKeyCode["PLUS"] = 8] = "PLUS";
              StickKeyCode[StickKeyCode["L3"] = 9] = "L3";
              StickKeyCode[StickKeyCode["R3"] = 10] = "R3";
              StickKeyCode[StickKeyCode["MENU"] = 11] = "MENU";
              StickKeyCode[StickKeyCode["START"] = 12] = "START";
              StickKeyCode[StickKeyCode["TRIGGER_LEFT"] = 13] = "TRIGGER_LEFT";
              StickKeyCode[StickKeyCode["TRIGGER_RIGHT"] = 14] = "TRIGGER_RIGHT";
            })(StickKeyCode || (StickKeyCode = {}));
            var StickAxisCode;
            (function (StickAxisCode) {
              StickAxisCode[StickAxisCode["UNDEFINE"] = 0] = "UNDEFINE";
              StickAxisCode[StickAxisCode["X"] = 1] = "X";
              StickAxisCode[StickAxisCode["Y"] = 2] = "Y";
              StickAxisCode[StickAxisCode["LEFT_STICK_X"] = 3] = "LEFT_STICK_X";
              StickAxisCode[StickAxisCode["LEFT_STICK_Y"] = 4] = "LEFT_STICK_Y";
              StickAxisCode[StickAxisCode["RIGHT_STICK_X"] = 5] = "RIGHT_STICK_X";
              StickAxisCode[StickAxisCode["RIGHT_STICK_Y"] = 6] = "RIGHT_STICK_Y";
              StickAxisCode[StickAxisCode["L2"] = 7] = "L2";
              StickAxisCode[StickAxisCode["R2"] = 8] = "R2";
              StickAxisCode[StickAxisCode["LEFT_GRIP"] = 9] = "LEFT_GRIP";
              StickAxisCode[StickAxisCode["RIGHT_GRIP"] = 10] = "RIGHT_GRIP";
            })(StickAxisCode || (StickAxisCode = {}));
            var StickTouchCode;
            (function (StickTouchCode) {
              StickTouchCode[StickTouchCode["UNDEFINE"] = 0] = "UNDEFINE";
              StickTouchCode[StickTouchCode["A"] = 1] = "A";
              StickTouchCode[StickTouchCode["B"] = 2] = "B";
              StickTouchCode[StickTouchCode["X"] = 3] = "X";
              StickTouchCode[StickTouchCode["Y"] = 4] = "Y";
              StickTouchCode[StickTouchCode["LEFT_TRIGGER"] = 5] = "LEFT_TRIGGER";
              StickTouchCode[StickTouchCode["RIGHT_TRIGGER"] = 6] = "RIGHT_TRIGGER";
              StickTouchCode[StickTouchCode["LEFT_THUMBSTICK"] = 7] = "LEFT_THUMBSTICK";
              StickTouchCode[StickTouchCode["RIGHT_THUMBSTICK"] = 8] = "RIGHT_THUMBSTICK";
            })(StickTouchCode || (StickTouchCode = {}));
            var _nativeButtonMap = {
              1: Button.BUTTON_EAST,
              2: Button.BUTTON_SOUTH,
              3: Button.BUTTON_NORTH,
              4: Button.BUTTON_WEST,
              9: Button.BUTTON_LEFT_STICK,
              10: Button.BUTTON_RIGHT_STICK,
              11: Button.ROKID_MENU,
              12: Button.ROKID_START,
              13: Button.BUTTON_TRIGGER_LEFT,
              14: Button.BUTTON_TRIGGER_RIGHT
            };
            var HandleInputDevice = function () {
              function HandleInputDevice() {
                var _this$_nativeButtonSt,
                  _this$_nativeTouchSta,
                  _this = this;
                this._eventTarget = new EventTarget();
                this._nativeButtonState = (_this$_nativeButtonSt = {}, _this$_nativeButtonSt[Button.BUTTON_SOUTH] = 0, _this$_nativeButtonSt[Button.BUTTON_EAST] = 0, _this$_nativeButtonSt[Button.BUTTON_WEST] = 0, _this$_nativeButtonSt[Button.BUTTON_NORTH] = 0, _this$_nativeButtonSt[Button.BUTTON_TRIGGER_LEFT] = 0, _this$_nativeButtonSt[Button.BUTTON_TRIGGER_RIGHT] = 0, _this$_nativeButtonSt[Button.TRIGGER_LEFT] = 0, _this$_nativeButtonSt[Button.TRIGGER_RIGHT] = 0, _this$_nativeButtonSt[Button.GRIP_LEFT] = 0, _this$_nativeButtonSt[Button.GRIP_RIGHT] = 0, _this$_nativeButtonSt[Button.LEFT_STICK_UP] = 0, _this$_nativeButtonSt[Button.LEFT_STICK_DOWN] = 0, _this$_nativeButtonSt[Button.LEFT_STICK_LEFT] = 0, _this$_nativeButtonSt[Button.LEFT_STICK_RIGHT] = 0, _this$_nativeButtonSt[Button.RIGHT_STICK_UP] = 0, _this$_nativeButtonSt[Button.RIGHT_STICK_DOWN] = 0, _this$_nativeButtonSt[Button.RIGHT_STICK_LEFT] = 0, _this$_nativeButtonSt[Button.RIGHT_STICK_RIGHT] = 0, _this$_nativeButtonSt[Button.BUTTON_LEFT_STICK] = 0, _this$_nativeButtonSt[Button.BUTTON_RIGHT_STICK] = 0, _this$_nativeButtonSt[Button.ROKID_MENU] = 0, _this$_nativeButtonSt[Button.ROKID_START] = 0, _this$_nativeButtonSt);
                this._nativeTouchState = (_this$_nativeTouchSta = {}, _this$_nativeTouchSta[StickTouchCode.UNDEFINE] = 0, _this$_nativeTouchSta[StickTouchCode.A] = 0, _this$_nativeTouchSta[StickTouchCode.B] = 0, _this$_nativeTouchSta[StickTouchCode.X] = 0, _this$_nativeTouchSta[StickTouchCode.Y] = 0, _this$_nativeTouchSta[StickTouchCode.LEFT_TRIGGER] = 0, _this$_nativeTouchSta[StickTouchCode.RIGHT_TRIGGER] = 0, _this$_nativeTouchSta[StickTouchCode.LEFT_THUMBSTICK] = 0, _this$_nativeTouchSta[StickTouchCode.RIGHT_THUMBSTICK] = 0, _this$_nativeTouchSta);
                this._initInputSource();
                window.addEventListener('xr-remote-input', function (evt) {
                  var remoteInputEvent = evt;
                  var keyEventType = remoteInputEvent.detail.keyEventType;
                  var stickAxisCode = remoteInputEvent.detail.stickAxisCode;
                  var stickAxisValue = remoteInputEvent.detail.stickAxisValue;
                  var stickKeyCode = remoteInputEvent.detail.stickKeyCode;
                  var isButtonPressed = remoteInputEvent.detail.isButtonPressed;
                  var touchCode = remoteInputEvent.detail.touchCode;
                  var touchValue = remoteInputEvent.detail.touchValue;
                  if (keyEventType === KeyEventType.KET_CLICK) {
                    var button = _nativeButtonMap[stickKeyCode];
                    _this._nativeButtonState[button] = isButtonPressed ? 1 : 0;
                  } else if (keyEventType === KeyEventType.KET_STICK || keyEventType === KeyEventType.KET_GRAB) {
                    var negativeButton;
                    var positiveButton;
                    var axisValue;
                    switch (stickAxisCode) {
                      case StickAxisCode.LEFT_STICK_X:
                        negativeButton = Button.LEFT_STICK_LEFT;
                        positiveButton = Button.LEFT_STICK_RIGHT;
                        axisValue = _this._axisToButtons(stickAxisValue);
                        break;
                      case StickAxisCode.LEFT_STICK_Y:
                        negativeButton = Button.LEFT_STICK_DOWN;
                        positiveButton = Button.LEFT_STICK_UP;
                        axisValue = _this._axisToButtons(stickAxisValue);
                        break;
                      case StickAxisCode.RIGHT_STICK_X:
                        negativeButton = Button.RIGHT_STICK_LEFT;
                        positiveButton = Button.RIGHT_STICK_RIGHT;
                        axisValue = _this._axisToButtons(stickAxisValue);
                        break;
                      case StickAxisCode.RIGHT_STICK_Y:
                        negativeButton = Button.RIGHT_STICK_DOWN;
                        positiveButton = Button.RIGHT_STICK_UP;
                        axisValue = _this._axisToButtons(stickAxisValue);
                        break;
                      case StickAxisCode.L2:
                        _this._nativeButtonState[Button.TRIGGER_LEFT] = stickAxisValue;
                        break;
                      case StickAxisCode.R2:
                        _this._nativeButtonState[Button.TRIGGER_RIGHT] = stickAxisValue;
                        break;
                      case StickAxisCode.LEFT_GRIP:
                        _this._nativeButtonState[Button.GRIP_LEFT] = stickAxisValue;
                        break;
                      case StickAxisCode.RIGHT_GRIP:
                        _this._nativeButtonState[Button.GRIP_RIGHT] = stickAxisValue;
                        break;
                    }
                    if (negativeButton && positiveButton && axisValue) {
                      _this._nativeButtonState[negativeButton] = axisValue.negative;
                      _this._nativeButtonState[positiveButton] = axisValue.positive;
                    }
                  } else if (keyEventType === KeyEventType.KET_TOUCH) {
                    switch (touchCode) {
                      case StickTouchCode.A:
                      case StickTouchCode.B:
                      case StickTouchCode.X:
                      case StickTouchCode.Y:
                      case StickTouchCode.LEFT_TRIGGER:
                      case StickTouchCode.RIGHT_TRIGGER:
                      case StickTouchCode.LEFT_THUMBSTICK:
                      case StickTouchCode.RIGHT_THUMBSTICK:
                        _this._nativeTouchState[touchCode] = touchValue;
                        break;
                    }
                  }
                  _this._eventTarget.emit("handle-input", new EventHandle("handle-input", _this));
                });
              }
              var _proto = HandleInputDevice.prototype;
              _proto._axisToButtons = function _axisToButtons(axisValue) {
                var value = Math.abs(axisValue);
                if (axisValue > 0) {
                  return {
                    negative: 0,
                    positive: value
                  };
                } else if (axisValue < 0) {
                  return {
                    negative: value,
                    positive: 0
                  };
                } else {
                  return {
                    negative: 0,
                    positive: 0
                  };
                }
              };
              _proto._on = function _on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              };
              _proto._initInputSource = function _initInputSource() {
                var _this2 = this;
                this._buttonNorth = new InputSourceButton();
                this._buttonNorth.getValue = function () {
                  return _this2._nativeButtonState[Button.BUTTON_NORTH];
                };
                this._buttonEast = new InputSourceButton();
                this._buttonEast.getValue = function () {
                  return _this2._nativeButtonState[Button.BUTTON_EAST];
                };
                this._buttonWest = new InputSourceButton();
                this._buttonWest.getValue = function () {
                  return _this2._nativeButtonState[Button.BUTTON_WEST];
                };
                this._buttonSouth = new InputSourceButton();
                this._buttonSouth.getValue = function () {
                  return _this2._nativeButtonState[Button.BUTTON_SOUTH];
                };
                this._buttonTriggerLeft = new InputSourceButton();
                this._buttonTriggerLeft.getValue = function () {
                  return _this2._nativeButtonState[Button.BUTTON_TRIGGER_LEFT];
                };
                this._buttonTriggerRight = new InputSourceButton();
                this._buttonTriggerRight.getValue = function () {
                  return _this2._nativeButtonState[Button.BUTTON_TRIGGER_RIGHT];
                };
                this._triggerLeft = new InputSourceButton();
                this._triggerLeft.getValue = function () {
                  return _this2._nativeButtonState[Button.TRIGGER_LEFT];
                };
                this._triggerRight = new InputSourceButton();
                this._triggerRight.getValue = function () {
                  return _this2._nativeButtonState[Button.TRIGGER_RIGHT];
                };
                this._gripLeft = new InputSourceButton();
                this._gripLeft.getValue = function () {
                  return _this2._nativeButtonState[Button.GRIP_LEFT];
                };
                this._gripRight = new InputSourceButton();
                this._gripRight.getValue = function () {
                  return _this2._nativeButtonState[Button.GRIP_RIGHT];
                };
                this._buttonLeftStick = new InputSourceButton();
                this._buttonLeftStick.getValue = function () {
                  return _this2._nativeButtonState[Button.BUTTON_LEFT_STICK];
                };
                var leftStickUp = new InputSourceButton();
                leftStickUp.getValue = function () {
                  return _this2._nativeButtonState[Button.LEFT_STICK_UP];
                };
                var leftStickDown = new InputSourceButton();
                leftStickDown.getValue = function () {
                  return _this2._nativeButtonState[Button.LEFT_STICK_DOWN];
                };
                var leftStickLeft = new InputSourceButton();
                leftStickLeft.getValue = function () {
                  return _this2._nativeButtonState[Button.LEFT_STICK_LEFT];
                };
                var leftStickRight = new InputSourceButton();
                leftStickRight.getValue = function () {
                  return _this2._nativeButtonState[Button.LEFT_STICK_RIGHT];
                };
                this._leftStick = new InputSourceStick({
                  up: leftStickUp,
                  down: leftStickDown,
                  left: leftStickLeft,
                  right: leftStickRight
                });
                this._buttonRightStick = new InputSourceButton();
                this._buttonRightStick.getValue = function () {
                  return _this2._nativeButtonState[Button.BUTTON_RIGHT_STICK];
                };
                var rightStickUp = new InputSourceButton();
                rightStickUp.getValue = function () {
                  return _this2._nativeButtonState[Button.RIGHT_STICK_UP];
                };
                var rightStickDown = new InputSourceButton();
                rightStickDown.getValue = function () {
                  return _this2._nativeButtonState[Button.RIGHT_STICK_DOWN];
                };
                var rightStickLeft = new InputSourceButton();
                rightStickLeft.getValue = function () {
                  return _this2._nativeButtonState[Button.RIGHT_STICK_LEFT];
                };
                var rightStickRight = new InputSourceButton();
                rightStickRight.getValue = function () {
                  return _this2._nativeButtonState[Button.RIGHT_STICK_RIGHT];
                };
                this._rightStick = new InputSourceStick({
                  up: rightStickUp,
                  down: rightStickDown,
                  left: rightStickLeft,
                  right: rightStickRight
                });
                this._buttonOptions = new InputSourceButton();
                this._buttonOptions.getValue = function () {
                  return _this2._nativeButtonState[Button.ROKID_MENU];
                };
                this._buttonStart = new InputSourceButton();
                this._buttonStart.getValue = function () {
                  return _this2._nativeButtonState[Button.ROKID_START];
                };
                this._handLeftPosition = new InputSourcePosition();
                this._handLeftPosition.getValue = function () {
                  return Vec3.ZERO;
                };
                this._handLeftOrientation = new InputSourceOrientation();
                this._handLeftOrientation.getValue = function () {
                  return Quat.IDENTITY;
                };
                this._handRightPosition = new InputSourcePosition();
                this._handRightPosition.getValue = function () {
                  return Vec3.ZERO;
                };
                this._handRightOrientation = new InputSourceOrientation();
                this._handRightOrientation.getValue = function () {
                  return Quat.IDENTITY;
                };
                this._aimLeftPosition = new InputSourcePosition();
                this._aimLeftPosition.getValue = function () {
                  return Vec3.ZERO;
                };
                this._aimLeftOrientation = new InputSourceOrientation();
                this._aimLeftOrientation.getValue = function () {
                  return Quat.IDENTITY;
                };
                this._aimRightPosition = new InputSourcePosition();
                this._aimRightPosition.getValue = function () {
                  return Vec3.ZERO;
                };
                this._aimRightOrientation = new InputSourceOrientation();
                this._aimRightOrientation.getValue = function () {
                  return Quat.IDENTITY;
                };
                this._touchButtonA = new InputSourceTouch();
                this._touchButtonA.getValue = function () {
                  return _this2._nativeTouchState[StickTouchCode.A];
                };
                this._touchButtonB = new InputSourceTouch();
                this._touchButtonB.getValue = function () {
                  return _this2._nativeTouchState[StickTouchCode.B];
                };
                this._touchButtonX = new InputSourceTouch();
                this._touchButtonX.getValue = function () {
                  return _this2._nativeTouchState[StickTouchCode.X];
                };
                this._touchButtonY = new InputSourceTouch();
                this._touchButtonY.getValue = function () {
                  return _this2._nativeTouchState[StickTouchCode.Y];
                };
                this._touchButtonTriggerLeft = new InputSourceTouch();
                this._touchButtonTriggerLeft.getValue = function () {
                  return _this2._nativeTouchState[StickTouchCode.LEFT_TRIGGER];
                };
                this._touchButtonTriggerRight = new InputSourceTouch();
                this._touchButtonTriggerRight.getValue = function () {
                  return _this2._nativeTouchState[StickTouchCode.RIGHT_TRIGGER];
                };
                this._touchButtonThumbStickLeft = new InputSourceTouch();
                this._touchButtonThumbStickLeft.getValue = function () {
                  return _this2._nativeTouchState[StickTouchCode.LEFT_THUMBSTICK];
                };
                this._touchButtonThumbStickRight = new InputSourceTouch();
                this._touchButtonThumbStickRight.getValue = function () {
                  return _this2._nativeTouchState[StickTouchCode.RIGHT_THUMBSTICK];
                };
              };
              _createClass(HandleInputDevice, [{
                key: "buttonNorth",
                get: function get() {
                  return this._buttonNorth;
                }
              }, {
                key: "buttonEast",
                get: function get() {
                  return this._buttonEast;
                }
              }, {
                key: "buttonWest",
                get: function get() {
                  return this._buttonWest;
                }
              }, {
                key: "buttonSouth",
                get: function get() {
                  return this._buttonSouth;
                }
              }, {
                key: "buttonTriggerLeft",
                get: function get() {
                  return this._buttonTriggerLeft;
                }
              }, {
                key: "buttonTriggerRight",
                get: function get() {
                  return this._buttonTriggerRight;
                }
              }, {
                key: "triggerLeft",
                get: function get() {
                  return this._triggerLeft;
                }
              }, {
                key: "triggerRight",
                get: function get() {
                  return this._triggerRight;
                }
              }, {
                key: "gripLeft",
                get: function get() {
                  return this._gripLeft;
                }
              }, {
                key: "gripRight",
                get: function get() {
                  return this._gripRight;
                }
              }, {
                key: "leftStick",
                get: function get() {
                  return this._leftStick;
                }
              }, {
                key: "rightStick",
                get: function get() {
                  return this._rightStick;
                }
              }, {
                key: "buttonLeftStick",
                get: function get() {
                  return this._buttonLeftStick;
                }
              }, {
                key: "buttonRightStick",
                get: function get() {
                  return this._buttonRightStick;
                }
              }, {
                key: "buttonOptions",
                get: function get() {
                  return this._buttonOptions;
                }
              }, {
                key: "buttonStart",
                get: function get() {
                  return this._buttonStart;
                }
              }, {
                key: "handLeftPosition",
                get: function get() {
                  return this._handLeftPosition;
                }
              }, {
                key: "handLeftOrientation",
                get: function get() {
                  return this._handLeftOrientation;
                }
              }, {
                key: "handRightPosition",
                get: function get() {
                  return this._handRightPosition;
                }
              }, {
                key: "handRightOrientation",
                get: function get() {
                  return this._handRightOrientation;
                }
              }, {
                key: "aimLeftPosition",
                get: function get() {
                  return this._aimLeftPosition;
                }
              }, {
                key: "aimLeftOrientation",
                get: function get() {
                  return this._aimLeftOrientation;
                }
              }, {
                key: "aimRightPosition",
                get: function get() {
                  return this._aimRightPosition;
                }
              }, {
                key: "aimRightOrientation",
                get: function get() {
                  return this._aimRightOrientation;
                }
              }, {
                key: "touchButtonA",
                get: function get() {
                  return this._touchButtonA;
                }
              }, {
                key: "touchButtonB",
                get: function get() {
                  return this._touchButtonB;
                }
              }, {
                key: "touchButtonX",
                get: function get() {
                  return this._touchButtonX;
                }
              }, {
                key: "touchButtonY",
                get: function get() {
                  return this._touchButtonY;
                }
              }, {
                key: "touchButtonTriggerLeft",
                get: function get() {
                  return this._touchButtonTriggerLeft;
                }
              }, {
                key: "touchButtonTriggerRight",
                get: function get() {
                  return this._touchButtonTriggerRight;
                }
              }, {
                key: "touchButtonThumbStickLeft",
                get: function get() {
                  return this._touchButtonThumbStickLeft;
                }
              }, {
                key: "touchButtonThumbStickRight",
                get: function get() {
                  return this._touchButtonThumbStickRight;
                }
              }]);
              return HandleInputDevice;
            }();

            var Pose;
            (function (Pose) {
              Pose[Pose["VIEW_LEFT"] = 0] = "VIEW_LEFT";
              Pose[Pose["VIEW_RIGHT"] = 3] = "VIEW_RIGHT";
              Pose[Pose["HEAD_MIDDLE"] = 6] = "HEAD_MIDDLE";
            })(Pose || (Pose = {}));
            var HMDInputDevice = function () {
              function HMDInputDevice() {
                var _this$_webPoseState;
                this._eventTarget = new EventTarget();
                this._intervalId = -1;
                this._webPoseState = (_this$_webPoseState = {}, _this$_webPoseState[Pose.VIEW_LEFT] = {
                  position: Vec3.ZERO,
                  orientation: Quat.IDENTITY
                }, _this$_webPoseState[Pose.VIEW_RIGHT] = {
                  position: Vec3.ZERO,
                  orientation: Quat.IDENTITY
                }, _this$_webPoseState[Pose.HEAD_MIDDLE] = {
                  position: Vec3.ZERO,
                  orientation: Quat.IDENTITY
                }, _this$_webPoseState);
                this._initInputSource();
                this._registerEvent();
              }
              var _proto = HMDInputDevice.prototype;
              _proto._ensureDirectorDefined = function _ensureDirectorDefined() {
                var _this = this;
                return new Promise(function (resolve) {
                  _this._intervalId = setInterval(function () {
                    if (legacyCC.director && legacyCC.Director) {
                      clearInterval(_this._intervalId);
                      _this._intervalId = -1;
                      resolve();
                    }
                  }, 50);
                });
              };
              _proto._registerEvent = function _registerEvent() {
                var _this2 = this;
                this._ensureDirectorDefined().then(function () {
                  legacyCC.director.on(legacyCC.Director.EVENT_BEGIN_FRAME, _this2._scanHmd, _this2);
                })["catch"](function (e) {});
              };
              _proto._scanHmd = function _scanHmd() {
                var _globalThis$__globalX;
                var infoList = (_globalThis$__globalX = globalThis.__globalXR) == null ? undefined : _globalThis$__globalX.webxrHmdPoseInfos;
                if (!infoList) {
                  return;
                }
                for (var i = 0; i < infoList.length; ++i) {
                  var info = infoList[i];
                  this._updateWebPoseState(info);
                }
                this._eventTarget.emit("hmd-pose-input", new EventHMD("hmd-pose-input", this));
              };
              _proto._on = function _on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              };
              _proto._updateWebPoseState = function _updateWebPoseState(info) {
                if (info.code !== Pose.VIEW_LEFT && info.code !== Pose.VIEW_RIGHT && info.code !== Pose.HEAD_MIDDLE) {
                  return;
                }
                this._webPoseState[info.code] = {
                  position: new Vec3(info.position.x, info.position.y, info.position.z),
                  orientation: new Quat(info.orientation.x, info.orientation.y, info.orientation.z, info.orientation.w)
                };
              };
              _proto._initInputSource = function _initInputSource() {
                var _this3 = this;
                this._viewLeftPosition = new InputSourcePosition();
                this._viewLeftPosition.getValue = function () {
                  return _this3._webPoseState[Pose.VIEW_LEFT].position;
                };
                this._viewLeftOrientation = new InputSourceOrientation();
                this._viewLeftOrientation.getValue = function () {
                  return _this3._webPoseState[Pose.VIEW_LEFT].orientation;
                };
                this._viewRightPosition = new InputSourcePosition();
                this._viewRightPosition.getValue = function () {
                  return _this3._webPoseState[Pose.VIEW_RIGHT].position;
                };
                this._viewRightOrientation = new InputSourceOrientation();
                this._viewRightOrientation.getValue = function () {
                  return _this3._webPoseState[Pose.VIEW_RIGHT].orientation;
                };
                this._headMiddlePosition = new InputSourcePosition();
                this._headMiddlePosition.getValue = function () {
                  return _this3._webPoseState[Pose.HEAD_MIDDLE].position;
                };
                this._headMiddleOrientation = new InputSourceOrientation();
                this._headMiddleOrientation.getValue = function () {
                  return _this3._webPoseState[Pose.HEAD_MIDDLE].orientation;
                };
              };
              _createClass(HMDInputDevice, [{
                key: "viewLeftPosition",
                get: function get() {
                  return this._viewLeftPosition;
                }
              }, {
                key: "viewLeftOrientation",
                get: function get() {
                  return this._viewLeftOrientation;
                }
              }, {
                key: "viewRightPosition",
                get: function get() {
                  return this._viewRightPosition;
                }
              }, {
                key: "viewRightOrientation",
                get: function get() {
                  return this._viewRightOrientation;
                }
              }, {
                key: "headMiddlePosition",
                get: function get() {
                  return this._headMiddlePosition;
                }
              }, {
                key: "headMiddleOrientation",
                get: function get() {
                  return this._headMiddleOrientation;
                }
              }]);
              return HMDInputDevice;
            }();

            var HandheldInputDevice = function () {
              function HandheldInputDevice() {
                this._eventTarget = new EventTarget();
                this._initInputSource();
              }
              var _proto = HandheldInputDevice.prototype;
              _proto._on = function _on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              };
              _proto._initInputSource = function _initInputSource() {
                this._handheldPosition = new InputSourcePosition();
                this._handheldPosition.getValue = function () {
                  return Vec3.ZERO;
                };
                this._handheldOrientation = new InputSourceOrientation();
                this._handheldOrientation.getValue = function () {
                  return Quat.IDENTITY;
                };
              };
              _createClass(HandheldInputDevice, [{
                key: "handheldPosition",
                get: function get() {
                  return this._handheldPosition;
                }
              }, {
                key: "handheldOrientation",
                get: function get() {
                  return this._handheldOrientation;
                }
              }]);
              return HandheldInputDevice;
            }();

            var code2KeyCode = {
              Backspace: 8,
              Tab: 9,
              Enter: 13,
              ShiftLeft: 16,
              ControlLeft: 17,
              AltLeft: 18,
              ShiftRight: 2000,
              ControlRight: 2001,
              AltRight: 2002,
              Pause: 19,
              CapsLock: 20,
              Escape: 27,
              Space: 32,
              PageUp: 33,
              PageDown: 34,
              End: 35,
              Home: 36,
              ArrowLeft: 37,
              ArrowUp: 38,
              ArrowRight: 39,
              ArrowDown: 40,
              Insert: 45,
              Delete: 46,
              Digit0: 48,
              Digit1: 49,
              Digit2: 50,
              Digit3: 51,
              Digit4: 52,
              Digit5: 53,
              Digit6: 54,
              Digit7: 55,
              Digit8: 56,
              Digit9: 57,
              KeyA: 65,
              KeyB: 66,
              KeyC: 67,
              KeyD: 68,
              KeyE: 69,
              KeyF: 70,
              KeyG: 71,
              KeyH: 72,
              KeyI: 73,
              KeyJ: 74,
              KeyK: 75,
              KeyL: 76,
              KeyM: 77,
              KeyN: 78,
              KeyO: 79,
              KeyP: 80,
              KeyQ: 81,
              KeyR: 82,
              KeyS: 83,
              KeyT: 84,
              KeyU: 85,
              KeyV: 86,
              KeyW: 87,
              KeyX: 88,
              KeyY: 89,
              KeyZ: 90,
              Numpad0: 96,
              Numpad1: 97,
              Numpad2: 98,
              Numpad3: 99,
              Numpad4: 100,
              Numpad5: 101,
              Numpad6: 102,
              Numpad7: 103,
              Numpad8: 104,
              Numpad9: 105,
              NumpadMultiply: 106,
              NumpadAdd: 107,
              NumpadSubtract: 109,
              NumpadDecimal: 110,
              NumpadDivide: 111,
              NumpadEnter: 2003,
              F1: 112,
              F2: 113,
              F3: 114,
              F4: 115,
              F5: 116,
              F6: 117,
              F7: 118,
              F8: 119,
              F9: 120,
              F10: 121,
              F11: 122,
              F12: 123,
              NumLock: 144,
              ScrollLock: 145,
              Semicolon: 186,
              Equal: 187,
              Comma: 188,
              Minus: 189,
              Period: 190,
              Slash: 191,
              Backquote: 192,
              BracketLeft: 219,
              Backslash: 220,
              BracketRight: 221,
              Quote: 222
            };

            function getKeyCode(code) {
              return code2KeyCode[code] || 0;
            }
            var KeyboardInputSource = function () {
              function KeyboardInputSource() {
                this._eventTarget = new EventTarget();
                this._registerEvent();
              }
              var _proto = KeyboardInputSource.prototype;
              _proto.dispatchKeyboardDownEvent = function dispatchKeyboardDownEvent(nativeKeyboardEvent) {
                this._handleKeyboardDown(nativeKeyboardEvent);
              };
              _proto.dispatchKeyboardUpEvent = function dispatchKeyboardUpEvent(nativeKeyboardEvent) {
                this._handleKeyboardUp(nativeKeyboardEvent);
              };
              _proto.on = function on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              };
              _proto._registerEvent = function _registerEvent() {
                var canvas = document.getElementById('GameCanvas');
                canvas == null ? undefined : canvas.addEventListener('keydown', this._handleKeyboardDown.bind(this));
                canvas == null ? undefined : canvas.addEventListener('keyup', this._handleKeyboardUp.bind(this));
              };
              _proto._getInputEvent = function _getInputEvent(event, eventType) {
                var keyCode = getKeyCode(event.code);
                var eventKeyboard = new EventKeyboard(keyCode, eventType);
                return eventKeyboard;
              };
              _proto._handleKeyboardDown = function _handleKeyboardDown(event) {
                event.stopPropagation();
                event.preventDefault();
                if (!event.repeat) {
                  var keyDownInputEvent = this._getInputEvent(event, "keydown");
                  this._eventTarget.emit("keydown", keyDownInputEvent);
                } else {
                  var keyPressingInputEvent = this._getInputEvent(event, "key-pressing");
                  this._eventTarget.emit("key-pressing", keyPressingInputEvent);
                }
              };
              _proto._handleKeyboardUp = function _handleKeyboardUp(event) {
                var inputEvent = this._getInputEvent(event, "keyup");
                event.stopPropagation();
                event.preventDefault();
                this._eventTarget.emit("keyup", inputEvent);
              };
              return KeyboardInputSource;
            }();

            var MouseInputSource = function () {
              function MouseInputSource() {
                this._canvas = undefined;
                this._eventTarget = new EventTarget();
                this._pointLocked = false;
                this._isPressed = false;
                this._preMousePos = new Vec2();
                this._handleMouseDown = undefined;
                this._handleMouseMove = undefined;
                this._handleMouseUp = undefined;
                if (systemInfo.hasFeature(Feature.EVENT_MOUSE)) {
                  this._canvas = document.getElementById('GameCanvas');
                  if (!this._canvas && true && true) {
                    warn('failed to access canvas');
                  }
                  this._handleMouseDown = this._createCallback("mouse-down");
                  this._handleMouseMove = this._createCallback("mouse-move");
                  this._handleMouseUp = this._createCallback("mouse-up");
                  {
                    this._registerEvent();
                  }
                }
              }
              var _proto = MouseInputSource.prototype;
              _proto.dispatchMouseDownEvent = function dispatchMouseDownEvent(nativeMouseEvent) {
                this._handleMouseDown(nativeMouseEvent);
              };
              _proto.dispatchMouseMoveEvent = function dispatchMouseMoveEvent(nativeMouseEvent) {
                this._handleMouseMove(nativeMouseEvent);
              };
              _proto.dispatchMouseUpEvent = function dispatchMouseUpEvent(nativeMouseEvent) {
                this._handleMouseUp(nativeMouseEvent);
              };
              _proto.dispatchScrollEvent = function dispatchScrollEvent(nativeMouseEvent) {
                this._handleMouseWheel(nativeMouseEvent);
              };
              _proto.on = function on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              };
              _proto._getCanvasRect = function _getCanvasRect() {
                var canvas = this._canvas;
                var box = canvas == null ? undefined : canvas.getBoundingClientRect();
                if (box) {
                  return new Rect(box.x, box.y, box.width, box.height);
                }
                return new Rect(0, 0, 0, 0);
              };
              _proto._getLocation = function _getLocation(mouseEvent) {
                var canvasRect = this._getCanvasRect();
                var dpr = screenAdapter.devicePixelRatio;
                var x = this._pointLocked ? this._preMousePos.x / dpr + mouseEvent.movementX : mouseEvent.clientX - canvasRect.x;
                var y = this._pointLocked ? this._preMousePos.y / dpr - mouseEvent.movementY : canvasRect.y + canvasRect.height - mouseEvent.clientY;
                x *= dpr;
                y *= dpr;
                return new Vec2(x, y);
              };
              _proto._registerEvent = function _registerEvent() {
                var _this = this,
                  _this$_canvas,
                  _this$_canvas2,
                  _this$_canvas3,
                  _this$_canvas4,
                  _this$_canvas5,
                  _this$_canvas6;
                window.addEventListener('mousedown', function () {
                  _this._isPressed = true;
                });
                (_this$_canvas = this._canvas) == null ? undefined : _this$_canvas.addEventListener('mousedown', this._handleMouseDown);
                (_this$_canvas2 = this._canvas) == null ? undefined : _this$_canvas2.addEventListener('mousemove', this._handleMouseMove);
                window.addEventListener('mouseup', this._handleMouseUp);
                (_this$_canvas3 = this._canvas) == null ? undefined : _this$_canvas3.addEventListener('mouseup', this._handleMouseUp);
                (_this$_canvas4 = this._canvas) == null ? undefined : _this$_canvas4.addEventListener('wheel', this._handleMouseWheel.bind(this));
                this._registerPointerLockEvent();
                (_this$_canvas5 = this._canvas) == null ? undefined : _this$_canvas5.addEventListener('mouseleave', this._handleMouseLeave.bind(this));
                (_this$_canvas6 = this._canvas) == null ? undefined : _this$_canvas6.addEventListener('mouseenter', this._handleMouseEnter.bind(this));
              };
              _proto._registerPointerLockEvent = function _registerPointerLockEvent() {
                var _this2 = this;
                var lockChangeAlert = function lockChangeAlert() {
                  var canvas = _this2._canvas;
                  if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
                    _this2._pointLocked = true;
                  } else {
                    _this2._pointLocked = false;
                  }
                };
                if ('onpointerlockchange' in document) {
                  document.addEventListener('pointerlockchange', lockChangeAlert, false);
                } else if ('onmozpointerlockchange' in document) {
                  document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
                }
              };
              _proto._createCallback = function _createCallback(eventType) {
                var _this3 = this;
                return function (mouseEvent) {
                  var _this3$_canvas;
                  var location = _this3._getLocation(mouseEvent);
                  var button = mouseEvent.button,
                    buttons = mouseEvent.buttons;
                  var targetButton = button;
                  switch (eventType) {
                    case "mouse-down":
                      (_this3$_canvas = _this3._canvas) == null ? undefined : _this3$_canvas.focus();
                      _this3._isPressed = true;
                      break;
                    case "mouse-up":
                      _this3._isPressed = false;
                      break;
                    case "mouse-move":
                      if (1 & buttons) {
                        targetButton = EventMouse.BUTTON_LEFT;
                      } else if (2 & buttons) {
                        targetButton = EventMouse.BUTTON_RIGHT;
                      } else if (4 & buttons) {
                        targetButton = EventMouse.BUTTON_MIDDLE;
                      } else {
                        targetButton = EventMouse.BUTTON_MISSING;
                      }
                      break;
                  }
                  var eventMouse = new EventMouse(eventType, false, _this3._preMousePos);
                  eventMouse.setLocation(location.x, location.y);
                  eventMouse.setButton(targetButton);
                  eventMouse.movementX = mouseEvent.movementX;
                  eventMouse.movementY = mouseEvent.movementY;
                  _this3._preMousePos.set(location.x, location.y);
                  mouseEvent.stopPropagation();
                  if (mouseEvent.target === _this3._canvas) {
                    mouseEvent.preventDefault();
                  }
                  _this3._eventTarget.emit(eventType, eventMouse);
                };
              };
              _proto._handleMouseWheel = function _handleMouseWheel(mouseEvent) {
                var eventType = "mouse-wheel";
                var location = this._getLocation(mouseEvent);
                var button = mouseEvent.button;
                var eventMouse = new EventMouse(eventType, false, this._preMousePos);
                eventMouse.setLocation(location.x, location.y);
                eventMouse.setButton(button);
                eventMouse.movementX = mouseEvent.movementX;
                eventMouse.movementY = mouseEvent.movementY;
                var wheelSensitivityFactor = 5;
                eventMouse.setScrollData(mouseEvent.deltaX * wheelSensitivityFactor, -mouseEvent.deltaY * wheelSensitivityFactor);
                this._preMousePos.set(location.x, location.y);
                mouseEvent.stopPropagation();
                if (mouseEvent.target === this._canvas) {
                  mouseEvent.preventDefault();
                }
                this._eventTarget.emit(eventType, eventMouse);
              };
              _proto._handleMouseLeave = function _handleMouseLeave(mouseEvent) {
                var eventType = "mouse-leave-window";
                var eventMouse = new EventMouse(eventType, false);
                this._eventTarget.emit(eventType, eventMouse);
              };
              _proto._handleMouseEnter = function _handleMouseEnter(mouseEvent) {
                var eventType = "mouse-enter-window";
                var eventMouse = new EventMouse(eventType, false);
                this._eventTarget.emit(eventType, eventMouse);
              };
              _proto.dispatchEventsInCache = function dispatchEventsInCache() {};
              return MouseInputSource;
            }();

            var tempVec2 = new Vec2();
            var TouchManager = function () {
              function TouchManager() {
                this._touchMap = new Map();
                this._maxTouches = 8;
              }
              var _proto = TouchManager.prototype;
              _proto._createTouch = function _createTouch(touchID, x, y) {
                if (this._touchMap.has(touchID)) {
                  logID(2301);
                  return undefined;
                }
                var checkResult = this._checkTouchMapSizeMoreThanMax(touchID);
                if (checkResult) {
                  logID(2300);
                  return undefined;
                }
                var touch = new Touch(x, y, touchID);
                this._touchMap.set(touchID, touch);
                this._updateTouch(touch, x, y);
                return touch;
              };
              _proto.releaseTouch = function releaseTouch(touchID) {
                if (!this._touchMap.has(touchID)) {
                  return;
                }
                this._touchMap["delete"](touchID);
              };
              _proto.getTouch = function getTouch(touchID) {
                return this._touchMap.get(touchID);
              };
              _proto.getOrCreateTouch = function getOrCreateTouch(touchID, x, y) {
                var touch = this.getTouch(touchID);
                if (!touch) {
                  touch = this._createTouch(touchID, x, y);
                } else {
                  this._updateTouch(touch, x, y);
                }
                return touch;
              };
              _proto.getAllTouches = function getAllTouches() {
                var touches = [];
                this._touchMap.forEach(function (touch) {
                  if (touch) {
                    touches.push(touch);
                  }
                });
                return touches;
              };
              _proto.getTouchCount = function getTouchCount() {
                return this._touchMap.size;
              };
              _proto._updateTouch = function _updateTouch(touch, x, y) {
                touch.getLocation(tempVec2);
                touch.setPrevPoint(tempVec2);
                touch.setPoint(x, y);
              };
              _proto._checkTouchMapSizeMoreThanMax = function _checkTouchMapSizeMoreThanMax(touchID) {
                var _this = this;
                if (this._touchMap.has(touchID)) {
                  return false;
                }
                var maxSize = macro.ENABLE_MULTI_TOUCH ? this._maxTouches : 1;
                if (this._touchMap.size < maxSize) {
                  return false;
                }
                var now = performance.now();
                this._touchMap.forEach(function (touch) {
                  if (now - touch.lastModified > macro.TOUCH_TIMEOUT) {
                    logID(2302, touch.getID());
                    _this.releaseTouch(touch.getID());
                  }
                });
                return maxSize >= this._touchMap.size;
              };
              return TouchManager;
            }();
            var touchManager = new TouchManager();

            var TouchInputSource = function () {
              function TouchInputSource() {
                this._canvas = undefined;
                this._eventTarget = new EventTarget();
                if (systemInfo.hasFeature(Feature.INPUT_TOUCH)) {
                  this._canvas = document.getElementById('GameCanvas');
                  if (!this._canvas && true && true) {
                    warn('failed to access canvas');
                  }
                  {
                    this._registerEvent();
                  }
                }
              }
              var _proto = TouchInputSource.prototype;
              _proto._registerEvent = function _registerEvent() {
                var _this$_canvas, _this$_canvas2, _this$_canvas3, _this$_canvas4;
                (_this$_canvas = this._canvas) == null ? undefined : _this$_canvas.addEventListener('touchstart', this._createCallback("touch-start"));
                (_this$_canvas2 = this._canvas) == null ? undefined : _this$_canvas2.addEventListener('touchmove', this._createCallback("touch-move"));
                (_this$_canvas3 = this._canvas) == null ? undefined : _this$_canvas3.addEventListener('touchend', this._createCallback("touch-end"));
                (_this$_canvas4 = this._canvas) == null ? undefined : _this$_canvas4.addEventListener('touchcancel', this._createCallback("touch-cancel"));
              };
              _proto._createCallback = function _createCallback(eventType) {
                var _this = this;
                return function (event) {
                  var canvasRect = _this._getCanvasRect();
                  var handleTouches = [];
                  var length = event.changedTouches.length;
                  for (var i = 0; i < length; ++i) {
                    var changedTouch = event.changedTouches[i];
                    var touchID = changedTouch.identifier;
                    if (touchID === null) {
                      continue;
                    }
                    var location = _this._getLocation(changedTouch, canvasRect);
                    var touch = touchManager.getOrCreateTouch(touchID, location.x, location.y);
                    if (!touch) {
                      continue;
                    }
                    if (eventType === "touch-end" || eventType === "touch-cancel") {
                      touchManager.releaseTouch(touchID);
                    }
                    handleTouches.push(touch);
                  }
                  event.stopPropagation();
                  if (event.target === _this._canvas) {
                    event.preventDefault();
                  }
                  if (eventType === "touch-start") {
                    var _this$_canvas5;
                    (_this$_canvas5 = _this._canvas) == null ? undefined : _this$_canvas5.focus();
                  }
                  if (handleTouches.length > 0) {
                    var eventTouch = new EventTouch(handleTouches, false, eventType, touchManager.getAllTouches());
                    _this._eventTarget.emit(eventType, eventTouch);
                  }
                };
              };
              _proto._getCanvasRect = function _getCanvasRect() {
                var canvas = this._canvas;
                var box = canvas == null ? undefined : canvas.getBoundingClientRect();
                if (box) {
                  return new Rect(box.x, box.y, box.width, box.height);
                }
                return new Rect(0, 0, 0, 0);
              };
              _proto._getLocation = function _getLocation(touch, canvasRect) {
                var x = touch.clientX - canvasRect.x;
                var y = canvasRect.y + canvasRect.height - touch.clientY;
                if (screenAdapter.isFrameRotated) {
                  var tmp = x;
                  x = canvasRect.height - y;
                  y = tmp;
                }
                var dpr = screenAdapter.devicePixelRatio;
                x *= dpr;
                y *= dpr;
                return new Vec2(x, y);
              };
              _proto.on = function on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
              };
              _proto.dispatchEventsInCache = function dispatchEventsInCache() {};
              return TouchInputSource;
            }();

            var _pointerEventTypeMap;
            var InputEventDispatcher = function () {
              function InputEventDispatcher(inputEventTarget) {
                this.priority = 0;
                this._inputEventTarget = inputEventTarget;
              }
              var _proto = InputEventDispatcher.prototype;
              _proto.onThrowException = function onThrowException() {};
              _proto.dispatchEvent = function dispatchEvent(event) {
                this._inputEventTarget.emit(event.type, event);
                return true;
              };
              return InputEventDispatcher;
            }();
            var pointerEventTypeMap = (_pointerEventTypeMap = {}, _pointerEventTypeMap["mouse-down"] = "touch-start", _pointerEventTypeMap["mouse-move"] = "touch-move", _pointerEventTypeMap["mouse-up"] = "touch-end", _pointerEventTypeMap);
            var Input = exports("Input", function () {
              function Input() {
                this._eventTarget = new EventTarget();
                this._touchInput = new TouchInputSource();
                this._mouseInput = new MouseInputSource();
                this._keyboardInput = new KeyboardInputSource();
                this._accelerometerInput = new AccelerometerInputSource();
                this._eventKeyboardList = [];
                this._eventAccelerationList = [];
                this._eventGamepadList = [];
                this._eventHandleList = [];
                this._eventHMDList = [];
                this._eventHandheldList = [];
                this._needSimulateTouchMoveEvent = false;
                this._eventDispatcherList = [];
                {
                  this._handleInput = new HandleInputDevice();
                  this._hmdInput = new HMDInputDevice();
                  this._handheldInput = new HandheldInputDevice();
                }
                this._registerEvent();
                this._inputEventDispatcher = new InputEventDispatcher(this._eventTarget);
                this._registerEventDispatcher(this._inputEventDispatcher);
                {
                  GamepadInputDevice._init();
                }
              }
              var _proto2 = Input.prototype;
              _proto2._dispatchMouseDownEvent = function _dispatchMouseDownEvent(nativeMouseEvent) {
                var _this$_mouseInput$dis, _this$_mouseInput;
                (_this$_mouseInput$dis = (_this$_mouseInput = this._mouseInput).dispatchMouseDownEvent) == null ? undefined : _this$_mouseInput$dis.call(_this$_mouseInput, nativeMouseEvent);
              };
              _proto2._dispatchMouseMoveEvent = function _dispatchMouseMoveEvent(nativeMouseEvent) {
                var _this$_mouseInput$dis2, _this$_mouseInput2;
                (_this$_mouseInput$dis2 = (_this$_mouseInput2 = this._mouseInput).dispatchMouseMoveEvent) == null ? undefined : _this$_mouseInput$dis2.call(_this$_mouseInput2, nativeMouseEvent);
              };
              _proto2._dispatchMouseUpEvent = function _dispatchMouseUpEvent(nativeMouseEvent) {
                var _this$_mouseInput$dis3, _this$_mouseInput3;
                (_this$_mouseInput$dis3 = (_this$_mouseInput3 = this._mouseInput).dispatchMouseUpEvent) == null ? undefined : _this$_mouseInput$dis3.call(_this$_mouseInput3, nativeMouseEvent);
              };
              _proto2._dispatchMouseScrollEvent = function _dispatchMouseScrollEvent(nativeMouseEvent) {
                var _this$_mouseInput$dis4, _this$_mouseInput4;
                (_this$_mouseInput$dis4 = (_this$_mouseInput4 = this._mouseInput).dispatchScrollEvent) == null ? undefined : _this$_mouseInput$dis4.call(_this$_mouseInput4, nativeMouseEvent);
              };
              _proto2._dispatchKeyboardDownEvent = function _dispatchKeyboardDownEvent(nativeKeyboardEvent) {
                var _this$_keyboardInput$, _this$_keyboardInput;
                (_this$_keyboardInput$ = (_this$_keyboardInput = this._keyboardInput).dispatchKeyboardDownEvent) == null ? undefined : _this$_keyboardInput$.call(_this$_keyboardInput, nativeKeyboardEvent);
              };
              _proto2._dispatchKeyboardUpEvent = function _dispatchKeyboardUpEvent(nativeKeyboardEvent) {
                var _this$_keyboardInput$2, _this$_keyboardInput2;
                (_this$_keyboardInput$2 = (_this$_keyboardInput2 = this._keyboardInput).dispatchKeyboardUpEvent) == null ? undefined : _this$_keyboardInput$2.call(_this$_keyboardInput2, nativeKeyboardEvent);
              };
              _proto2.on = function on(eventType, callback, target) {
                this._eventTarget.on(eventType, callback, target);
                return callback;
              };
              _proto2.once = function once(eventType, callback, target) {
                this._eventTarget.once(eventType, callback, target);
                return callback;
              };
              _proto2.off = function off(eventType, callback, target) {
                this._eventTarget.off(eventType, callback, target);
              };
              _proto2.getTouch = function getTouch(touchID) {
                return touchManager.getTouch(touchID);
              };
              _proto2.getAllTouches = function getAllTouches() {
                return touchManager.getAllTouches();
              };
              _proto2.getTouchCount = function getTouchCount() {
                return touchManager.getTouchCount();
              };
              _proto2.setAccelerometerEnabled = function setAccelerometerEnabled(isEnable) {
                if (isEnable) {
                  this._accelerometerInput.start();
                } else {
                  this._accelerometerInput.stop();
                }
              };
              _proto2.setAccelerometerInterval = function setAccelerometerInterval(intervalInMileSeconds) {
                this._accelerometerInput.setInterval(intervalInMileSeconds);
              };
              _proto2._simulateEventTouch = function _simulateEventTouch(eventMouse) {
                var eventType = pointerEventTypeMap[eventMouse.type];
                var touchID = 0;
                var touch = touchManager.getOrCreateTouch(touchID, eventMouse.getLocationX(), eventMouse.getLocationY());
                if (!touch) {
                  return;
                }
                var changedTouches = [touch];
                var eventTouch = new EventTouch(changedTouches, false, eventType, eventType === "touch-end" ? [] : changedTouches);
                eventTouch.windowId = eventMouse.windowId;
                if (eventType === "touch-end") {
                  touchManager.releaseTouch(touchID);
                }
                this._dispatchEventTouch(eventTouch);
              };
              _proto2._registerEventDispatcher = function _registerEventDispatcher(eventDispatcher) {
                this._eventDispatcherList.push(eventDispatcher);
                this._eventDispatcherList.sort(function (a, b) {
                  return b.priority - a.priority;
                });
              };
              _proto2._emitEvent = function _emitEvent(event) {
                var length = this._eventDispatcherList.length;
                for (var i = 0; i < length; ++i) {
                  var dispatcher = this._eventDispatcherList[i];
                  try {
                    if (!dispatcher.dispatchEvent(event)) {
                      break;
                    }
                  } catch (e) {
                    this._clearEvents();
                    dispatcher.onThrowException();
                    throw e;
                  }
                }
              };
              _proto2._registerEvent = function _registerEvent() {
                var self = this;
                var touchInput = self._touchInput;
                var mouseInput = self._mouseInput;
                var keyboardInput = self._keyboardInput;
                var handleInput = self._handleInput;
                if (sys.hasFeature(sys.Feature.INPUT_TOUCH)) {
                  touchInput.on("touch-start", function (event) {
                    self._dispatchEventTouch(event);
                  });
                  touchInput.on("touch-move", function (event) {
                    self._dispatchEventTouch(event);
                  });
                  touchInput.on("touch-end", function (event) {
                    self._dispatchEventTouch(event);
                  });
                  touchInput.on("touch-cancel", function (event) {
                    self._dispatchEventTouch(event);
                  });
                }
                if (sys.hasFeature(sys.Feature.EVENT_MOUSE)) {
                  mouseInput.on("mouse-down", function (event) {
                    self._needSimulateTouchMoveEvent = true;
                    self._simulateEventTouch(event);
                    self._dispatchEventMouse(event);
                  });
                  mouseInput.on("mouse-move", function (event) {
                    if (self._needSimulateTouchMoveEvent) {
                      self._simulateEventTouch(event);
                    }
                    self._dispatchEventMouse(event);
                  });
                  mouseInput.on("mouse-up", function (event) {
                    self._needSimulateTouchMoveEvent = false;
                    self._simulateEventTouch(event);
                    self._dispatchEventMouse(event);
                  });
                  mouseInput.on("mouse-wheel", function (event) {
                    self._dispatchEventMouse(event);
                  });
                  mouseInput.on("mouse-leave-window", function (event) {
                    self._dispatchEventMouse(event);
                  });
                  mouseInput.on("mouse-enter-window", function (event) {
                    self._dispatchEventMouse(event);
                  });
                }
                if (sys.hasFeature(sys.Feature.EVENT_KEYBOARD)) {
                  var eventKeyboardList = self._eventKeyboardList;
                  keyboardInput.on("keydown", function (event) {
                    self._dispatchOrPushEvent(event, eventKeyboardList);
                  });
                  keyboardInput.on("key-pressing", function (event) {
                    self._dispatchOrPushEvent(event, eventKeyboardList);
                  });
                  keyboardInput.on("keyup", function (event) {
                    self._dispatchOrPushEvent(event, eventKeyboardList);
                  });
                }
                if (sys.hasFeature(sys.Feature.EVENT_ACCELEROMETER)) {
                  var eventAccelerationList = self._eventAccelerationList;
                  self._accelerometerInput.on("devicemotion", function (event) {
                    self._dispatchOrPushEvent(event, eventAccelerationList);
                  });
                }
                {
                  if (sys.hasFeature(sys.Feature.EVENT_GAMEPAD)) {
                    var eventGamepadList = self._eventGamepadList;
                    GamepadInputDevice._on("gamepad-change", function (event) {
                      self._dispatchOrPushEvent(event, eventGamepadList);
                    });
                    GamepadInputDevice._on("gamepad-input", function (event) {
                      self._dispatchOrPushEvent(event, eventGamepadList);
                    });
                    GamepadInputDevice._on("handle-pose-input", function (event) {
                      self._dispatchOrPushEvent(event, eventGamepadList);
                    });
                  }
                  if (sys.hasFeature(sys.Feature.EVENT_HANDLE)) {
                    var eventHandleList = self._eventHandleList;
                    handleInput._on("handle-input", function (event) {
                      self._dispatchOrPushEvent(event, eventHandleList);
                    });
                    handleInput._on("handle-pose-input", function (event) {
                      self._dispatchOrPushEvent(event, eventHandleList);
                    });
                  }
                  if (sys.hasFeature(sys.Feature.EVENT_HMD)) {
                    var eventHMDList = self._eventHMDList;
                    self._hmdInput._on("hmd-pose-input", function (event) {
                      self._dispatchOrPushEvent(event, eventHMDList);
                    });
                  }
                  if (sys.hasFeature(sys.Feature.EVENT_HANDHELD)) {
                    var eventHandheldList = self._eventHandheldList;
                    self._handheldInput._on("handheld-pose-input", function (event) {
                      self._dispatchOrPushEvent(event, eventHandheldList);
                    });
                  }
                }
              };
              _proto2._clearEvents = function _clearEvents() {
                this._eventKeyboardList.length = 0;
                this._eventAccelerationList.length = 0;
                this._eventGamepadList.length = 0;
                this._eventHandleList.length = 0;
                this._eventHMDList.length = 0;
              };
              _proto2._dispatchOrPushEvent = function _dispatchOrPushEvent(event, eventList) {
                {
                  this._emitEvent(event);
                }
              };
              _proto2._dispatchEventMouse = function _dispatchEventMouse(event) {
                this._emitEvent(event);
              };
              _proto2._dispatchEventTouch = function _dispatchEventTouch(eventTouch) {
                var touches = eventTouch.getTouches();
                var touchesLength = touches.length;
                for (var i = 0; i < touchesLength; ++i) {
                  eventTouch.touch = touches[i];
                  eventTouch.propagationStopped = eventTouch.propagationImmediateStopped = false;
                  this._emitEvent(eventTouch);
                }
              };
              _proto2._frameDispatchEvents = function _frameDispatchEvents() {
                return;
              };
              return Input;
            }());
            Input.EventType = InputEventType;
            var input = exports("input", new Input());

            var SystemEvent = exports("SystemEvent", function (_EventTarget) {
              _inheritsLoose(SystemEvent, _EventTarget);
              function SystemEvent() {
                var _this;
                _this = _EventTarget.call(this) || this;
                input.on("mouse-down", function (e) {
                  _this.emit("mouse-down", e);
                });
                input.on("mouse-move", function (e) {
                  _this.emit("mouse-move", e);
                });
                input.on("mouse-up", function (e) {
                  _this.emit("mouse-up", e);
                });
                input.on("mouse-wheel", function (e) {
                  _this.emit("mouse-wheel", e);
                });
                input.on("touch-start", function (e) {
                  _this.emit("touch-start", e.touch, e);
                });
                input.on("touch-move", function (e) {
                  _this.emit("touch-move", e.touch, e);
                });
                input.on("touch-end", function (e) {
                  _this.emit("touch-end", e.touch, e);
                });
                input.on("touch-cancel", function (e) {
                  _this.emit("touch-cancel", e.touch, e);
                });
                input.on("keydown", function (e) {
                  _this.emit("keydown", e);
                });
                input.on("key-pressing", function (e) {
                  _this.emit("keydown", e);
                });
                input.on("keyup", function (e) {
                  _this.emit("keyup", e);
                });
                input.on("devicemotion", function (e) {
                  _this.emit("devicemotion", e);
                });
                return _this;
              }
              var _proto = SystemEvent.prototype;
              _proto.setAccelerometerEnabled = function setAccelerometerEnabled(isEnabled) {
                input.setAccelerometerEnabled(isEnabled);
              };
              _proto.setAccelerometerInterval = function setAccelerometerInterval(interval) {
                input.setAccelerometerInterval(interval);
              };
              _proto.on = function on(type, callback, target, once) {
                _EventTarget.prototype.on.call(this, type, callback, target, once);
                return callback;
              };
              _proto.off = function off(type, callback, target) {
                _EventTarget.prototype.off.call(this, type, callback, target);
              };
              return SystemEvent;
            }(EventTarget));
            SystemEvent.EventType = SystemEventType;
            cclegacy.SystemEvent = SystemEvent;
            var systemEvent = exports("systemEvent", new SystemEvent());
            cclegacy.systemEvent = systemEvent;

            replaceProperty(SystemEventType, 'Node.EventType', [{
              name: 'POSITION_PART',
              newName: 'TRANSFORM_CHANGED'
            }, {
              name: 'ROTATION_PART',
              newName: 'TRANSFORM_CHANGED'
            }, {
              name: 'SCALE_PART',
              newName: 'TRANSFORM_CHANGED'
            }]);
            replaceProperty(Event, 'Event', [{
              name: 'ACCELERATION',
              newName: 'DEVICEMOTION',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(Event, 'Event', [{
              name: 'TOUCH',
              suggest: 'please use SystemEvent.EventType.TOUCH_START, SystemEvent.EventType.TOUCH_MOVE, SystemEvent.EventType.TOUCH_END and SystemEvent.EventType.TOUCH_CANCEL instead'
            }, {
              name: 'MOUSE',
              suggest: 'please use SystemEvent.EventType.MOUSE_DOWN, SystemEvent.EventType.MOUSE_MOVE, SystemEvent.EventType.MOUSE_UP, SystemEvent.EventType.MOUSE_WHEEL, Node.EventType.MOUSE_ENTER and Node.EventType.MOUSE_LEAVE instead'
            }, {
              name: 'KEYBOARD',
              suggest: 'please use SystemEvent.EventType.KEY_DOWN and SystemEvent.EventType.KEY_UP instead'
            }]);
            replaceProperty(EventMouse, 'EventMouse', ['DOWN', 'UP', 'MOVE'].map(function (item) {
              return {
                name: item,
                newName: "MOUSE_" + item,
                target: SystemEvent.EventType,
                targetName: 'SystemEvent.EventType'
              };
            }));
            replaceProperty(EventMouse, 'EventMouse', [{
              name: 'SCROLL',
              newName: 'MOUSE_WHEEL',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(EventMouse.prototype, 'EventMouse.prototype', [{
              name: 'eventType',
              suggest: 'please use EventMouse.prototype.type instead'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'BEGAN',
              newName: 'TOUCH_START',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'MOVED',
              newName: 'TOUCH_MOVE',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'ENDED',
              newName: 'TOUCH_END',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            replaceProperty(EventTouch, 'EventTouch', [{
              name: 'CANCELLED',
              newName: 'TOUCH_CANCEL',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            markAsWarning(EventTouch.prototype, 'EventTouch.prototype', [{
              name: 'getEventCode',
              suggest: 'please use EventTouch.prototype.type instead'
            }]);
            replaceProperty(EventTouch.prototype, 'EventTouch.prototype', [{
              name: 'getUILocationInView',
              newName: 'getLocationInView',
              target: EventTouch,
              targetName: 'EventTouch'
            }]);
            markAsWarning(macro.KEY, 'macro.KEY', ['back', 'menu', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '*', '+', '-', '/', ';', '=', ',', '.', '[', ']', 'dpadLeft', 'dpadRight', 'dpadUp', 'dpadDown', 'dpadCenter'].map(function (item) {
              return {
                name: item
              };
            }));
            markAsWarning(macro.KEY, 'macro.KEY', [{
              name: 'shift',
              suggest: 'please use KeyCode.SHIFT_LEFT instead'
            }]);
            markAsWarning(macro.KEY, 'macro.KEY', [{
              name: 'ctrl',
              suggest: 'please use KeyCode.CTRL_LEFT instead'
            }]);
            markAsWarning(macro.KEY, 'macro.KEY', [{
              name: 'alt',
              suggest: 'please use KeyCode.ALT_LEFT instead'
            }]);
            markAsWarning(macro, 'macro', [{
              name: 'KEY',
              suggest: 'please use KeyCode instead'
            }]);

            var DebugView = exports("DebugView", function () {
              function DebugView() {
                this._singleMode = 0;
                this._compositeModeValue = 0;
                this._lightingWithAlbedo = true;
                this._csmLayerColoration = false;
                this._activate();
              }
              var _proto = DebugView.prototype;
              _proto.isCompositeModeEnabled = function isCompositeModeEnabled(val) {
                var mode = this._compositeModeValue & 1 << val;
                return mode !== 0;
              };
              _proto.enableCompositeMode = function enableCompositeMode(val, enable) {
                this._enableCompositeMode(val, enable);
                this._updatePipeline();
              };
              _proto.enableAllCompositeMode = function enableAllCompositeMode(enable) {
                this._enableAllCompositeMode(enable);
                this._updatePipeline();
              };
              _proto.isEnabled = function isEnabled() {
                return this._getType() !== 0;
              };
              _proto.reset = function reset() {
                this._activate();
                this._updatePipeline();
              };
              _proto._activate = function _activate() {
                this._singleMode = 0;
                this._enableAllCompositeMode(true);
                this._lightingWithAlbedo = true;
                this._csmLayerColoration = false;
              };
              _proto._updatePipeline = function _updatePipeline() {
                var root = cclegacy.director.root;
                var pipeline = root.pipeline;
                var useDebugView = this._getType();
                if (pipeline.macros.CC_USE_DEBUG_VIEW !== useDebugView) {
                  pipeline.macros.CC_USE_DEBUG_VIEW = useDebugView;
                  root.onGlobalPipelineStateChanged();
                }
              };
              _proto._enableCompositeMode = function _enableCompositeMode(val, enable) {
                if (enable) {
                  this._compositeModeValue |= 1 << val;
                } else {
                  this._compositeModeValue &= ~(1 << val);
                }
              };
              _proto._enableAllCompositeMode = function _enableAllCompositeMode(enable) {
                for (var i = 0; i < 17; i++) {
                  if (enable) {
                    this._compositeModeValue |= 1 << i;
                  } else {
                    this._compositeModeValue &= ~(1 << i);
                  }
                }
              };
              _proto._getType = function _getType() {
                if (this._singleMode !== 0) {
                  return 1;
                } else if (this._lightingWithAlbedo !== true || this._csmLayerColoration !== false) {
                  return 2;
                } else {
                  for (var i = 0; i < 17; i++) {
                    if (!this.isCompositeModeEnabled(i)) {
                      return 2;
                    }
                  }
                }
                return 0;
              };
              _createClass(DebugView, [{
                key: "singleMode",
                get: function get() {
                  return this._singleMode;
                },
                set: function set(val) {
                  this._singleMode = val;
                  this._updatePipeline();
                }
              }, {
                key: "lightingWithAlbedo",
                get: function get() {
                  return this._lightingWithAlbedo;
                },
                set: function set(val) {
                  this._lightingWithAlbedo = val;
                  this._updatePipeline();
                }
              }, {
                key: "csmLayerColoration",
                get: function get() {
                  return this._csmLayerColoration;
                },
                set: function set(val) {
                  this._csmLayerColoration = val;
                  this._updatePipeline();
                }
              }, {
                key: "debugViewType",
                get: function get() {
                  return this._getType();
                }
              }]);
              return DebugView;
            }());

            var CameraFOVAxis = {
              VERTICAL: 0,
              HORIZONTAL: 1
            };
            var CameraProjection = {
              ORTHO: 0,
              PERSPECTIVE: 1
            };
            var CameraAperture = {
              F1_8: 0,
              F2_0: 1,
              F2_2: 2,
              F2_5: 3,
              F2_8: 4,
              F3_2: 5,
              F3_5: 6,
              F4_0: 7,
              F4_5: 8,
              F5_0: 9,
              F5_6: 10,
              F6_3: 11,
              F7_1: 12,
              F8_0: 13,
              F9_0: 14,
              F10_0: 15,
              F11_0: 16,
              F13_0: 17,
              F14_0: 18,
              F16_0: 19,
              F18_0: 20,
              F20_0: 21,
              F22_0: 22
            };
            var CameraISO = {
              ISO100: 0,
              ISO200: 1,
              ISO400: 2,
              ISO800: 3
            };
            var CameraShutter = {
              D1: 0,
              D2: 1,
              D4: 2,
              D8: 3,
              D15: 4,
              D30: 5,
              D60: 6,
              D125: 7,
              D250: 8,
              D500: 9,
              D1000: 10,
              D2000: 11,
              D4000: 12
            };
            var CameraType = {
              DEFAULT: -1,
              LEFT_EYE: 0,
              RIGHT_EYE: 1,
              MAIN: 2
            };
            var TrackingType = {
              NO_TRACKING: 0,
              POSITION_AND_ROTATION: 1,
              POSITION: 2,
              ROTATION: 3
            };
            var CameraUsage = {
              EDITOR: 0,
              GAME_VIEW: 1,
              SCENE_VIEW: 2,
              PREVIEW: 3,
              GAME: 100
            };
            var FSTOPS = [1.8, 2.0, 2.2, 2.5, 2.8, 3.2, 3.5, 4.0, 4.5, 5.0, 5.6, 6.3, 7.1, 8.0, 9.0, 10.0, 11.0, 13.0, 14.0, 16.0, 18.0, 20.0, 22.0];
            var SHUTTERS = [1.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 15.0, 1.0 / 30.0, 1.0 / 60.0, 1.0 / 125.0, 1.0 / 250.0, 1.0 / 500.0, 1.0 / 1000.0, 1.0 / 2000.0, 1.0 / 4000.0];
            var ISOS = [100.0, 200.0, 400.0, 800.0];
            var v_a = v3();
            var v_b = v3();
            var _tempMat1 = mat4();
            var SkyBoxFlagValue = {
              VALUE: 8
            };
            var SKYBOX_FLAG = 8;
            var correctionMatrices = [];
            var _cameraCount = 0;
            var Camera$1 = function () {
              function Camera(device) {
                this.isWindowSize = true;
                this.screenScale = 1;
                this.postProcess = null;
                this.usePostProcess = false;
                this.pipeline = '';
                this.pipelineSettings = null;
                this._scene = null;
                this._node = null;
                this._name = null;
                this._enabled = false;
                this._proj = -1;
                this._aspect = 1;
                this._orthoHeight = 10.0;
                this._fovAxis = 0;
                this._fov = toRadian(45);
                this._nearClip = 1.0;
                this._farClip = 1000.0;
                this._clearColor = new Color$1(0.2, 0.2, 0.2, 1);
                this._viewport = rect(0, 0, 1, 1);
                this._orientedViewport = rect(0, 0, 1, 1);
                this._curTransform = 0;
                this._isProjDirty = true;
                this._matView = mat4();
                this._matProj = mat4();
                this._matProjInv = mat4();
                this._matViewProj = mat4();
                this._matViewProjInv = mat4();
                this._frustum = new Frustum();
                this._forward = v3();
                this._position = v3();
                this._priority = 0;
                this._aperture = 19;
                this._shutter = 7;
                this._shutterValue = 0.0;
                this._iso = 0;
                this._isoValue = 0.0;
                this._window = null;
                this._width = 1;
                this._height = 1;
                this._clearFlag = 0;
                this._clearDepth = 1.0;
                this._visibility = CAMERA_DEFAULT_MASK;
                this._exposure = 0;
                this._clearStencil = 0;
                this._geometryRenderer = null;
                this._windowId = 0;
                this._cameraType = -1;
                this._trackingType = 0;
                this._usage = 100;
                this._cameraId = _cameraCount++;
                this._device = device;
                this._apertureValue = FSTOPS[this._aperture];
                this._shutterValue = SHUTTERS[this._shutter];
                this._isoValue = ISOS[this._iso];
                this._frustum.accurate = true;
                if (!correctionMatrices.length) {
                  var ySign = device.capabilities.clipSpaceSignY;
                  correctionMatrices[0] = new Mat4(1, 0, 0, 0, 0, ySign);
                  correctionMatrices[1] = new Mat4(0, 1, 0, 0, -ySign, 0);
                  correctionMatrices[2] = new Mat4(-1, 0, 0, 0, 0, -ySign);
                  correctionMatrices[3] = new Mat4(0, -1, 0, 0, ySign, 0);
                }
              }
              var _proto = Camera.prototype;
              _proto._updateAspect = function _updateAspect(oriented) {
                if (oriented === undefined) {
                  oriented = true;
                }
                this._aspect = this.window.width * this._viewport.width / (this.window.height * this._viewport.height);
                if (oriented) {
                  var swapchain = this.window.swapchain;
                  var orientation = swapchain && swapchain.surfaceTransform || 0;
                  if (orientation % 2) this._aspect = 1 / this._aspect;
                }
                this._isProjDirty = true;
              };
              _proto.initialize = function initialize(info) {
                if (info.usage !== undefined) {
                  this._usage = info.usage;
                } else {
                  this.setDefaultUsage();
                }
                if (info.trackingType !== undefined) {
                  this._trackingType = info.trackingType;
                }
                if (info.cameraType !== undefined) {
                  this._cameraType = info.cameraType;
                }
                this.node = info.node;
                this._width = 1;
                this._height = 1;
                this.clearFlag = 0;
                this.clearDepth = 1.0;
                this.visibility = CAMERA_DEFAULT_MASK;
                this._name = info.name;
                this._proj = info.projection;
                this._priority = info.priority || 0;
                this._aspect = this.screenScale = 1;
                this.updateExposure();
                this.changeTargetWindow(info.window);
              };
              _proto.destroy = function destroy() {
                var _this$_geometryRender;
                this._node = null;
                this.detachFromScene();
                if (this._window) {
                  this._window.detachCamera(this);
                  this.window = null;
                }
                this._name = null;
                (_this$_geometryRender = this._geometryRenderer) == null ? undefined : _this$_geometryRender.destroy();
              };
              _proto.attachToScene = function attachToScene(scene) {
                this._enabled = true;
                this._scene = scene;
              };
              _proto.detachFromScene = function detachFromScene() {
                this._enabled = false;
                this._scene = null;
              };
              _proto.resize = function resize(width, height) {
                if (!this._window) return;
                this._width = width;
                this._height = height;
                this._aspect = width * this._viewport.width / (height * this._viewport.height);
                this._isProjDirty = true;
              };
              _proto.setFixedSize = function setFixedSize(width, height) {
                this._width = width;
                this._height = height;
                this._updateAspect();
                this.isWindowSize = false;
              };
              _proto.syncCameraEditor = function syncCameraEditor(camera) {
              };
              _proto.update = function update(forceUpdate) {
                var _this$window;
                if (forceUpdate === undefined) {
                  forceUpdate = false;
                }
                if (!this._node) return;
                var viewProjDirty = false;
                var forward = this._forward;
                var matView = this._matView;
                var matProj = this._matProj;
                if (this._node.hasChangedFlags || forceUpdate) {
                  Mat4.invert(matView, this._node.worldMatrix);
                  forward.x = -matView.m02;
                  forward.y = -matView.m06;
                  forward.z = -matView.m10;
                  Mat4.multiply(matView, new Mat4().scale(this._node.worldScale), matView);
                  this._node.getWorldPosition(this._position);
                  viewProjDirty = true;
                }
                var swapchain = (_this$window = this.window) == null ? undefined : _this$window.swapchain;
                var orientation = swapchain && swapchain.surfaceTransform || 0;
                if (this._isProjDirty || this._curTransform !== orientation) {
                  this._curTransform = orientation;
                  var projectionSignY = this._device.capabilities.clipSpaceSignY;
                  if (this._proj === 1) {
                    {
                      Mat4.perspective(matProj, this._fov, this._aspect, this._nearClip, this._farClip, this._fovAxis === 0, this._device.capabilities.clipSpaceMinZ, projectionSignY, orientation);
                    }
                  } else {
                    var _x = this._orthoHeight * this._aspect;
                    var y = this._orthoHeight;
                    Mat4.ortho(matProj, -_x, _x, -y, y, this._nearClip, this._farClip, this._device.capabilities.clipSpaceMinZ, projectionSignY, orientation);
                  }
                  Mat4.invert(this._matProjInv, matProj);
                  viewProjDirty = true;
                  this._isProjDirty = false;
                }
                if (viewProjDirty) {
                  Mat4.multiply(this._matViewProj, matProj, matView);
                  Mat4.invert(this._matViewProjInv, this._matViewProj);
                  this._frustum.update(this._matViewProj, this._matViewProjInv);
                }
              };
              _proto.setViewportInOrientedSpace = function setViewportInOrientedSpace(val) {
                var _this$window2;
                var x = val.x,
                  width = val.width,
                  height = val.height;
                var y = this._device.capabilities.screenSpaceSignY < 0 ? 1 - val.y - height : val.y;
                var swapchain = (_this$window2 = this.window) == null ? undefined : _this$window2.swapchain;
                var orientation = swapchain && swapchain.surfaceTransform || 0;
                switch (orientation) {
                  case 1:
                    this._viewport.x = 1 - y - height;
                    this._viewport.y = x;
                    this._viewport.width = height;
                    this._viewport.height = width;
                    break;
                  case 2:
                    this._viewport.x = 1 - x - width;
                    this._viewport.y = 1 - y - height;
                    this._viewport.width = width;
                    this._viewport.height = height;
                    break;
                  case 3:
                    this._viewport.x = y;
                    this._viewport.y = 1 - x - width;
                    this._viewport.width = height;
                    this._viewport.height = width;
                    break;
                  case 0:
                    this._viewport.x = x;
                    this._viewport.y = y;
                    this._viewport.width = width;
                    this._viewport.height = height;
                    break;
                }
                this._orientedViewport.x = x;
                this._orientedViewport.y = y;
                this._orientedViewport.width = width;
                this._orientedViewport.height = height;
                this.resize(this.width, this.height);
              };
              _proto.initGeometryRenderer = function initGeometryRenderer() {
                if (!this._geometryRenderer) {
                  var _this$_geometryRender2;
                  var _GeometryRenderer = cclegacy.internal.GeometryRenderer;
                  this._geometryRenderer = _GeometryRenderer ? new _GeometryRenderer() : null;
                  (_this$_geometryRender2 = this._geometryRenderer) == null ? undefined : _this$_geometryRender2.activate(this._device);
                }
              };
              _proto.changeTargetWindow = function changeTargetWindow(window) {
                if (window === undefined) {
                  window = null;
                }
                if (this._window) {
                  this._window.detachCamera(this);
                }
                var win = window || cclegacy.director.root.mainWindow;
                if (win) {
                  win.attachCamera(this);
                  this.window = win;
                  var swapchain = win.swapchain;
                  var orientation = swapchain && swapchain.surfaceTransform || 0;
                  if (orientation % 2) this.resize(win.height, win.width);else this.resize(win.width, win.height);
                }
              };
              _proto.detachCamera = function detachCamera() {
                if (this._window) {
                  this._window.detachCamera(this);
                }
              };
              _proto.screenPointToRay = function screenPointToRay(out, x, y) {
                if (!this._node) return null;
                var width = this.width;
                var height = this.height;
                var cx = this._orientedViewport.x * width;
                var cy = this._orientedViewport.y * height;
                var cw = this._orientedViewport.width * width;
                var ch = this._orientedViewport.height * height;
                var isProj = this._proj === 1;
                var ySign = this._device.capabilities.clipSpaceSignY;
                var preTransform = preTransforms[this._curTransform];
                Vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, isProj ? 1 : -1);
                var ox = v_a.x,
                  oy = v_a.y;
                v_a.x = ox * preTransform[0] + oy * preTransform[2] * ySign;
                v_a.y = ox * preTransform[1] + oy * preTransform[3] * ySign;
                Vec3.transformMat4(isProj ? v_a : out.o, v_a, this._matViewProjInv);
                if (isProj) {
                  this._node.getWorldPosition(v_b);
                  Ray.fromPoints(out, v_b, v_a);
                } else {
                  Vec3.transformQuat(out.d, Vec3.FORWARD, this._node.worldRotation);
                }
                return out;
              };
              _proto.screenToWorld = function screenToWorld(out, screenPos) {
                var width = this.width;
                var height = this.height;
                var cx = this._orientedViewport.x * width;
                var cy = this._orientedViewport.y * height;
                var cw = this._orientedViewport.width * width;
                var ch = this._orientedViewport.height * height;
                var ySign = this._device.capabilities.clipSpaceSignY;
                var preTransform = preTransforms[this._curTransform];
                if (this._proj === 1) {
                  Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1.0);
                  var x = out.x,
                    y = out.y;
                  out.x = x * preTransform[0] + y * preTransform[2] * ySign;
                  out.y = x * preTransform[1] + y * preTransform[3] * ySign;
                  Vec3.transformMat4(out, out, this._matViewProjInv);
                  if (this._node) {
                    this._node.getWorldPosition(v_a);
                  }
                  Vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z));
                } else {
                  Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, screenPos.z * 2 - 1);
                  var _x2 = out.x,
                    _y = out.y;
                  out.x = _x2 * preTransform[0] + _y * preTransform[2] * ySign;
                  out.y = _x2 * preTransform[1] + _y * preTransform[3] * ySign;
                  Vec3.transformMat4(out, out, this._matViewProjInv);
                }
                return out;
              };
              _proto.worldToScreen = function worldToScreen(out, worldPos) {
                var ySign = this._device.capabilities.clipSpaceSignY;
                var preTransform = preTransforms[this._curTransform];
                Vec3.transformMat4(out, worldPos, this._matViewProj);
                var x = out.x,
                  y = out.y;
                out.x = x * preTransform[0] + y * preTransform[2] * ySign;
                out.y = x * preTransform[1] + y * preTransform[3] * ySign;
                var width = this.width;
                var height = this.height;
                var cx = this._orientedViewport.x * width;
                var cy = this._orientedViewport.y * height;
                var cw = this._orientedViewport.width * width;
                var ch = this._orientedViewport.height * height;
                out.x = cx + (out.x + 1) * 0.5 * cw;
                out.y = cy + (out.y + 1) * 0.5 * ch;
                out.z = out.z * 0.5 + 0.5;
                return out;
              };
              _proto.worldMatrixToScreen = function worldMatrixToScreen(out, worldMatrix, width, height) {
                Mat4.multiply(out, this._matViewProj, worldMatrix);
                Mat4.multiply(out, correctionMatrices[this._curTransform], out);
                var halfWidth = width / 2;
                var halfHeight = height / 2;
                Mat4.identity(_tempMat1);
                Mat4.transform(_tempMat1, _tempMat1, Vec3.set(v_a, halfWidth, halfHeight, 0));
                Mat4.scale(_tempMat1, _tempMat1, Vec3.set(v_a, halfWidth, halfHeight, 1));
                Mat4.multiply(out, _tempMat1, out);
                return out;
              };
              _proto.calculateObliqueMat = function calculateObliqueMat(viewSpacePlane) {
                var clipFar = new Vec4(Math.sign(viewSpacePlane.x), Math.sign(viewSpacePlane.y), 1.0, 1.0);
                var viewFar = clipFar.transformMat4(this._matProjInv);
                var m4 = new Vec4(this._matProj.m03, this._matProj.m07, this._matProj.m11, this._matProj.m15);
                var scale = 2.0 / Vec4.dot(viewSpacePlane, viewFar);
                var newViewSpaceNearPlane = viewSpacePlane.multiplyScalar(scale);
                var m3 = newViewSpaceNearPlane.subtract(m4);
                this._matProj.m02 = m3.x;
                this._matProj.m06 = m3.y;
                this._matProj.m10 = m3.z;
                this._matProj.m14 = m3.w;
              };
              _proto.getClipSpaceMinz = function getClipSpaceMinz() {
                return this._device.capabilities.clipSpaceMinZ;
              };
              _proto.setExposure = function setExposure(ev100) {
                this._exposure = 0.833333 / Math.pow(2.0, ev100);
              };
              _proto.updateExposure = function updateExposure() {
                var ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100.0 / this._isoValue);
                this.setExposure(ev100);
              };
              _proto.setDefaultUsage = function setDefaultUsage() {
                {
                  this._usage = 100;
                }
              };
              _createClass(Camera, [{
                key: "name",
                get: function get() {
                  return this._name;
                }
              }, {
                key: "scene",
                get: function get() {
                  return this._scene;
                }
              }, {
                key: "node",
                get: function get() {
                  return this._node;
                },
                set: function set(val) {
                  this._node = val;
                }
              }, {
                key: "systemWindowId",
                get: function get() {
                  return this._windowId;
                }
              }, {
                key: "window",
                get: function get() {
                  return this._window;
                },
                set: function set(val) {
                  this._window = val;
                }
              }, {
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                }
              }, {
                key: "visibility",
                get: function get() {
                  return this._visibility;
                },
                set: function set(vis) {
                  this._visibility = vis;
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(val) {
                  this._priority = val;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
              }, {
                key: "position",
                get: function get() {
                  return this._position;
                },
                set: function set(val) {
                  this._position = val;
                }
              }, {
                key: "forward",
                get: function get() {
                  return this._forward;
                },
                set: function set(val) {
                  this._forward = val;
                }
              }, {
                key: "aperture",
                get: function get() {
                  return this._aperture;
                },
                set: function set(val) {
                  this._aperture = val;
                  this._apertureValue = FSTOPS[this._aperture];
                  this.updateExposure();
                }
              }, {
                key: "apertureValue",
                get: function get() {
                  return this._apertureValue;
                }
              }, {
                key: "shutter",
                get: function get() {
                  return this._shutter;
                },
                set: function set(val) {
                  this._shutter = val;
                  this._shutterValue = SHUTTERS[this._shutter];
                  this.updateExposure();
                }
              }, {
                key: "shutterValue",
                get: function get() {
                  return this._shutterValue;
                }
              }, {
                key: "iso",
                get: function get() {
                  return this._iso;
                },
                set: function set(val) {
                  this._iso = val;
                  this._isoValue = ISOS[this._iso];
                  this.updateExposure();
                }
              }, {
                key: "isoValue",
                get: function get() {
                  return this._isoValue;
                }
              }, {
                key: "exposure",
                get: function get() {
                  return this._exposure;
                }
              }, {
                key: "clearFlag",
                get: function get() {
                  return this._clearFlag;
                },
                set: function set(flag) {
                  this._clearFlag = flag;
                }
              }, {
                key: "clearColor",
                get: function get() {
                  return this._clearColor;
                },
                set: function set(val) {
                  this._clearColor.x = val.x;
                  this._clearColor.y = val.y;
                  this._clearColor.z = val.z;
                  this._clearColor.w = val.w;
                }
              }, {
                key: "clearDepth",
                get: function get() {
                  return this._clearDepth;
                },
                set: function set(depth) {
                  this._clearDepth = depth;
                }
              }, {
                key: "clearStencil",
                get: function get() {
                  return this._clearStencil;
                },
                set: function set(stencil) {
                  this._clearStencil = stencil;
                }
              }, {
                key: "projectionType",
                get: function get() {
                  return this._proj;
                },
                set: function set(val) {
                  this._proj = val;
                  this._isProjDirty = true;
                }
              }, {
                key: "aspect",
                get: function get() {
                  return this._aspect;
                }
              }, {
                key: "orthoHeight",
                get: function get() {
                  return this._orthoHeight;
                },
                set: function set(val) {
                  this._orthoHeight = val;
                  this._isProjDirty = true;
                }
              }, {
                key: "fovAxis",
                get: function get() {
                  return this._fovAxis;
                },
                set: function set(axis) {
                  this._fovAxis = axis;
                  this._isProjDirty = true;
                }
              }, {
                key: "fov",
                get: function get() {
                  return this._fov;
                },
                set: function set(fov) {
                  this._fov = fov;
                  this._isProjDirty = true;
                }
              }, {
                key: "nearClip",
                get: function get() {
                  return this._nearClip;
                },
                set: function set(nearClip) {
                  this._nearClip = nearClip;
                  this._isProjDirty = true;
                }
              }, {
                key: "farClip",
                get: function get() {
                  return this._farClip;
                },
                set: function set(farClip) {
                  this._farClip = farClip;
                  this._isProjDirty = true;
                }
              }, {
                key: "viewport",
                get: function get() {
                  return this._viewport;
                },
                set: function set(val) {
                  warnID(8302);
                  this.setViewportInOrientedSpace(val);
                }
              }, {
                key: "frustum",
                get: function get() {
                  return this._frustum;
                },
                set: function set(val) {
                  this._frustum = val;
                }
              }, {
                key: "matView",
                get: function get() {
                  return this._matView;
                }
              }, {
                key: "matProj",
                get: function get() {
                  return this._matProj;
                }
              }, {
                key: "matProjInv",
                get: function get() {
                  return this._matProjInv;
                }
              }, {
                key: "matViewProj",
                get: function get() {
                  return this._matViewProj;
                }
              }, {
                key: "matViewProjInv",
                get: function get() {
                  return this._matViewProjInv;
                }
              }, {
                key: "cameraId",
                get: function get() {
                  return this._cameraId;
                }
              }, {
                key: "surfaceTransform",
                get: function get() {
                  return this._curTransform;
                }
              }, {
                key: "geometryRenderer",
                get: function get() {
                  return this._geometryRenderer;
                }
              }, {
                key: "cameraType",
                get: function get() {
                  return this._cameraType;
                },
                set: function set(type) {
                  this._cameraType = type;
                }
              }, {
                key: "trackingType",
                get: function get() {
                  return this._trackingType;
                },
                set: function set(type) {
                  this._trackingType = type;
                }
              }, {
                key: "cameraUsage",
                get: function get() {
                  return this._usage;
                },
                set: function set(usage) {
                  this._usage = usage;
                }
              }], [{
                key: "standardExposureValue",
                get: function get() {
                  return 1.0 / 38400.0;
                }
              }, {
                key: "standardLightMeterScale",
                get: function get() {
                  return 10000.0;
                }
              }]);
              return Camera;
            }();

            var _dsInfo = new DescriptorSetInfo(null);
            var MAX_PASS_COUNT = 8;
            var SubModel = function () {
              function SubModel() {
                this._device = null;
                this._passes = null;
                this._shaders = null;
                this._subMesh = null;
                this._patches = null;
                this._priority = 128;
                this._inputAssembler = null;
                this._descriptorSet = null;
                this._worldBoundDescriptorSet = null;
                this._instancedAttributeBlock = {
                  buffer: null,
                  views: [],
                  attributes: []
                };
                this._instancedWorldMatrixIndex = -1;
                this._instancedSHIndex = -1;
                this._useReflectionProbeType = 0;
              }
              var _proto = SubModel.prototype;
              _proto.initialize = function initialize(subMesh, passes, patches) {
                if (patches === undefined) {
                  patches = null;
                }
                cclegacy.director.root;
                this._device = deviceManager.gfxDevice;
                _dsInfo.layout = passes[0].localSetLayout;
                this._inputAssembler = this._device.createInputAssembler(subMesh.iaInfo);
                this._descriptorSet = this._device.createDescriptorSet(_dsInfo);
                var pipeline = cclegacy.director.root.pipeline;
                var occlusionPass = pipeline.pipelineSceneData.getOcclusionQueryPass();
                if (occlusionPass) {
                  var occlusionDSInfo = new DescriptorSetInfo(null);
                  occlusionDSInfo.layout = occlusionPass.localSetLayout;
                  this._worldBoundDescriptorSet = this._device.createDescriptorSet(occlusionDSInfo);
                }
                this._subMesh = subMesh;
                this._patches = patches ? patches.sort() : null;
                this._passes = passes;
                this._flushPassInfo();
                this.priority = 128;
              };
              _proto.destroy = function destroy() {
                this._descriptorSet.destroy();
                this._descriptorSet = null;
                this._inputAssembler.destroy();
                this._inputAssembler = null;
                if (this._worldBoundDescriptorSet) {
                  this._worldBoundDescriptorSet.destroy();
                }
                this._worldBoundDescriptorSet = null;
                this.priority = 128;
                this._patches = null;
                this._subMesh = null;
                this._passes = null;
                this._shaders = null;
              };
              _proto.update = function update() {
                for (var i = 0; i < this._passes.length; ++i) {
                  var pass = this._passes[i];
                  pass.update();
                }
                this._descriptorSet.update();
                if (this._worldBoundDescriptorSet) this._worldBoundDescriptorSet.update();
              };
              _proto._updatePasses = function _updatePasses() {
                var passes = this._passes;
                if (!passes) {
                  return;
                }
                passes.forEach(function (pass) {
                  pass.beginChangeStatesSilently();
                  pass.tryCompile();
                  pass.endChangeStatesSilently();
                });
                this._flushPassInfo();
              };
              _proto.onPipelineStateChanged = function onPipelineStateChanged() {
                this._updatePasses();
              };
              _proto.onMacroPatchesStateChanged = function onMacroPatchesStateChanged(patches) {
                if (!patches && !this._patches) {
                  return;
                } else if (patches) {
                  patches = patches.sort();
                  if (this._patches && patches.length === this._patches.length) {
                    var patchesStateUnchanged = JSON.stringify(patches) === JSON.stringify(this._patches);
                    if (patchesStateUnchanged) return;
                  }
                }
                this._patches = patches;
                this._updatePasses();
              };
              _proto.onGeometryChanged = function onGeometryChanged() {
                if (!this._subMesh) {
                  return;
                }
                var drawInfo = this._subMesh.drawInfo;
                if (this._inputAssembler && drawInfo) {
                  var dirtyDrawInfo = this._inputAssembler.drawInfo;
                  Object.keys(drawInfo).forEach(function (key) {
                    dirtyDrawInfo[key] = drawInfo[key];
                  });
                  this._inputAssembler.drawInfo = dirtyDrawInfo;
                }
              };
              _proto.getInstancedAttributeIndex = function getInstancedAttributeIndex(name) {
                var attributes = this.instancedAttributeBlock.attributes;
                for (var i = 0; i < attributes.length; i++) {
                  if (attributes[i].name === name) {
                    return i;
                  }
                }
                return -1;
              };
              _proto.updateInstancedWorldMatrix = function updateInstancedWorldMatrix(mat, idx) {
                var attrs = this.instancedAttributeBlock.views;
                var v1 = attrs[idx];
                var v2 = attrs[idx + 1];
                var v3 = attrs[idx + 2];
                v1[0] = mat.m00;
                v1[1] = mat.m01;
                v1[2] = mat.m02;
                v1[3] = mat.m12;
                v2[0] = mat.m04;
                v2[1] = mat.m05;
                v2[2] = mat.m06;
                v2[3] = mat.m13;
                v3[0] = mat.m08;
                v3[1] = mat.m09;
                v3[2] = mat.m10;
                v3[3] = mat.m14;
              };
              _proto.updateInstancedSH = function updateInstancedSH(data, idx) {
                var attrs = this.instancedAttributeBlock.views;
                var count = (12 - 0) / 4;
                var offset = 0;
                for (var i = idx; i < idx + count; i++) {
                  for (var k = 0; k < 4; k++) {
                    attrs[i][k] = data[offset++];
                  }
                }
              };
              _proto.UpdateInstancedAttributes = function UpdateInstancedAttributes(attributes) {
                this.instancedWorldMatrixIndex = -1;
                this.instancedSHIndex = -1;
                var pass = this.passes[0];
                if (!pass.device.hasFeature(1)) {
                  return;
                }
                var size = 0;
                for (var j = 0; j < attributes.length; j++) {
                  var attribute = attributes[j];
                  if (!attribute.isInstanced) {
                    continue;
                  }
                  size += FormatInfos[attribute.format].size;
                }
                var attrs = this.instancedAttributeBlock;
                attrs.buffer = new Uint8Array(size);
                attrs.views.length = attrs.attributes.length = 0;
                var offset = 0;
                for (var _j = 0; _j < attributes.length; _j++) {
                  var _attribute = attributes[_j];
                  if (!_attribute.isInstanced) {
                    continue;
                  }
                  var attr = new Attribute();
                  attr.format = _attribute.format;
                  attr.name = _attribute.name;
                  attr.isNormalized = _attribute.isNormalized;
                  attr.location = _attribute.location;
                  attrs.attributes.push(attr);
                  var info = FormatInfos[_attribute.format];
                  var typeViewArray = new (getTypedArrayConstructor(info))(attrs.buffer.buffer, offset, info.count);
                  attrs.views.push(typeViewArray);
                  offset += info.size;
                }
                if (pass.batchingScheme === 1) {
                  pass.getInstancedBuffer().destroy();
                }
                this.instancedWorldMatrixIndex = this.getInstancedAttributeIndex(INST_MAT_WORLD);
                this.instancedSHIndex = this.getInstancedAttributeIndex(INST_SH);
              };
              _proto._flushPassInfo = function _flushPassInfo() {
                var passes = this._passes;
                if (!passes) {
                  return;
                }
                if (!this._shaders) {
                  this._shaders = [];
                }
                this._shaders.length = passes.length;
                for (var i = 0, len = passes.length; i < len; i++) {
                  this._shaders[i] = passes[i].getShaderVariant(this.patches);
                }
              };
              _createClass(SubModel, [{
                key: "passes",
                get: function get() {
                  return this._passes;
                },
                set: function set(passes) {
                  var passLengh = passes.length;
                  if (passLengh > MAX_PASS_COUNT) {
                    errorID(12004, MAX_PASS_COUNT);
                    return;
                  }
                  this._passes = passes;
                  this._flushPassInfo();
                  if (this._descriptorSet) {
                    this._descriptorSet.destroy();
                    _dsInfo.layout = passes[0].localSetLayout;
                    this._descriptorSet = this._device.createDescriptorSet(_dsInfo);
                  }
                }
              }, {
                key: "shaders",
                get: function get() {
                  return this._shaders;
                }
              }, {
                key: "subMesh",
                get: function get() {
                  return this._subMesh;
                },
                set: function set(subMesh) {
                  this._inputAssembler.destroy();
                  this._inputAssembler = this._device.createInputAssembler(subMesh.iaInfo);
                  this._subMesh = subMesh;
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(val) {
                  this._priority = val;
                }
              }, {
                key: "inputAssembler",
                get: function get() {
                  return this._inputAssembler;
                }
              }, {
                key: "descriptorSet",
                get: function get() {
                  return this._descriptorSet;
                }
              }, {
                key: "worldBoundDescriptorSet",
                get: function get() {
                  return this._worldBoundDescriptorSet;
                }
              }, {
                key: "patches",
                get: function get() {
                  return this._patches;
                }
              }, {
                key: "instancedAttributeBlock",
                get: function get() {
                  return this._instancedAttributeBlock;
                }
              }, {
                key: "instancedWorldMatrixIndex",
                get: function get() {
                  return this._instancedWorldMatrixIndex;
                },
                set: function set(val) {
                  this._instancedWorldMatrixIndex = val;
                }
              }, {
                key: "instancedSHIndex",
                get: function get() {
                  return this._instancedSHIndex;
                },
                set: function set(val) {
                  this._instancedSHIndex = val;
                }
              }, {
                key: "useReflectionProbeType",
                get: function get() {
                  return this._useReflectionProbeType;
                },
                set: function set(val) {
                  this._useReflectionProbeType = val;
                }
              }]);
              return SubModel;
            }();

            var m4_1$3 = new Mat4();
            var shadowMapPatches = [{
              name: 'CC_RECEIVE_SHADOW',
              value: true
            }];
            var staticLightMapPatches = [{
              name: 'CC_USE_LIGHTMAP',
              value: 1
            }];
            var stationaryLightMapPatches = [{
              name: 'CC_USE_LIGHTMAP',
              value: 2
            }];
            var highpLightMapPatches = [{
              name: 'CC_LIGHT_MAP_VERSION',
              value: 2
            }];
            var lightProbePatches = [{
              name: 'CC_USE_LIGHT_PROBE',
              value: true
            }];
            var CC_USE_REFLECTION_PROBE = 'CC_USE_REFLECTION_PROBE';
            var CC_DISABLE_DIRECTIONAL_LIGHT = 'CC_DISABLE_DIRECTIONAL_LIGHT';
            var ModelType = {
              DEFAULT: 0,
              SKINNING: 1,
              BAKED_SKINNING: 2,
              BATCH_2D: 3,
              PARTICLE_BATCH: 4,
              LINE: 5
            };
            var lightmapSamplerHash = new SamplerInfo(2, 2, 0, 2, 2, 2);
            var lightmapSamplerWithMipHash = new SamplerInfo(2, 2, 2, 2, 2, 2);
            var Model = function () {
              function Model() {
                this.type = 0;
                this.scene = null;
                this.isDynamicBatching = false;
                this._worldBounds = null;
                this._modelBounds = null;
                this._subModels = [];
                this._node = null;
                this._transform = null;
                this._inited = false;
                this._descriptorSetCount = 1;
                this._updateStamp = -1;
                this._localDataUpdated = true;
                this._localData = new Float32Array(56);
                this._localBuffer = null;
                this._localSHData = null;
                this._localSHBuffer = null;
                this._lightmap = null;
                this._lightmapUVParam = v4();
                this._tetrahedronIndex = -1;
                this._lastWorldBoundCenter = v3(Infinity, Infinity, Infinity);
                this._useLightProbe = false;
                this._worldBoundBuffer = null;
                this._receiveShadow = false;
                this._castShadow = false;
                this._receiveDirLight = true;
                this._shadowBias = 0;
                this._shadowNormalBias = 0;
                this._reflectionProbeId = -1;
                this._reflectionProbeBlendId = -1;
                this._reflectionProbeBlendWeight = 0;
                this._enabled = true;
                this._visFlags = Layers.Enum.NONE;
                this._priority = 0;
                this._bakeToReflectionProbe = true;
                this._reflectionProbeType = 0;
                this._device = deviceManager.gfxDevice;
              }
              var _proto = Model.prototype;
              _proto.initialize = function initialize() {
                if (this._inited) {
                  return;
                }
                this._receiveShadow = true;
                this.castShadow = false;
                this.enabled = true;
                this.visFlags = Layers.Enum.NONE;
                this._inited = true;
                this._bakeToReflectionProbe = true;
                this._reflectionProbeType = 0;
              };
              _proto.destroy = function destroy() {
                var subModels = this._subModels;
                for (var i = 0; i < subModels.length; i++) {
                  this._subModels[i].destroy();
                }
                if (this._localBuffer) {
                  this._localBuffer.destroy();
                  this._localBuffer = null;
                }
                if (this._localSHBuffer) {
                  this._localSHBuffer.destroy();
                  this._localSHBuffer = null;
                }
                if (this._worldBoundBuffer) {
                  this._worldBoundBuffer.destroy();
                  this._worldBoundBuffer = null;
                }
                this._worldBounds = null;
                this._modelBounds = null;
                this._subModels.length = 0;
                this._inited = false;
                this._localDataUpdated = true;
                this._transform = null;
                this._node = null;
                this.isDynamicBatching = false;
              };
              _proto.attachToScene = function attachToScene(scene) {
                this.scene = scene;
                this._localDataUpdated = true;
              };
              _proto.detachFromScene = function detachFromScene() {
                this.scene = null;
              };
              _proto.updateTransform = function updateTransform(stamp) {
                var node = this.transform;
                if (node.hasChangedFlags || node.isTransformDirty()) {
                  node.updateWorldTransform();
                  this._localDataUpdated = true;
                  var worldBounds = this._worldBounds;
                  if (this._modelBounds && worldBounds) {
                    this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                  }
                }
              };
              _proto.updateWorldBound = function updateWorldBound() {
                var node = this.transform;
                if (node !== null) {
                  node.updateWorldTransform();
                  this._localDataUpdated = true;
                  var worldBounds = this._worldBounds;
                  if (this._modelBounds && worldBounds) {
                    this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                  }
                }
              };
              _proto.updateUBOs = function updateUBOs(stamp) {
                var subModels = this._subModels;
                for (var i = 0; i < subModels.length; i++) {
                  subModels[i].update();
                }
                this._updateStamp = stamp;
                this.updateSHUBOs();
                var shadows = this.node.scene.globals.shadows;
                var forceUpdateUBO = shadows.enabled && shadows.type === ShadowType.Planar;
                if (!this._localDataUpdated) {
                  return;
                }
                this._localDataUpdated = false;
                var worldMatrix = this.transform._mat;
                var hasNonInstancingPass = false;
                for (var _i = 0; _i < subModels.length; _i++) {
                  var subModel = subModels[_i];
                  var idx = subModel.instancedWorldMatrixIndex;
                  if (idx >= 0) {
                    subModel.updateInstancedWorldMatrix(worldMatrix, idx);
                  } else {
                    hasNonInstancingPass = true;
                  }
                }
                if ((hasNonInstancingPass || forceUpdateUBO) && this._localBuffer) {
                  Mat4.toArray(this._localData, worldMatrix, 0);
                  Mat4.invert(m4_1$3, worldMatrix);
                  Mat4.transpose(m4_1$3, m4_1$3);
                  Mat4.toArray(this._localData, m4_1$3, 16);
                  this._localBuffer.update(this._localData);
                }
              };
              _proto.invalidateLocalData = function invalidateLocalData() {
                this._localDataUpdated = true;
              };
              _proto.showTetrahedron = function showTetrahedron() {
                return this.isLightProbeAvailable();
              };
              _proto.isLightProbeAvailable = function isLightProbeAvailable() {
                if (!this._useLightProbe) {
                  return false;
                }
                var lightProbes = getPipelineSceneData().lightProbes;
                if (!lightProbes || lightProbes.empty()) {
                  return false;
                }
                if (!this._worldBounds) {
                  return false;
                }
                return true;
              };
              _proto.updateSHBuffer = function updateSHBuffer() {
                if (!this._localSHData) {
                  return;
                }
                var subModels = this._subModels;
                var hasNonInstancingPass = false;
                for (var i = 0; i < subModels.length; i++) {
                  var subModel = subModels[i];
                  var idx = subModel.instancedSHIndex;
                  if (idx >= 0) {
                    subModel.updateInstancedSH(this._localSHData, idx);
                  } else {
                    hasNonInstancingPass = true;
                  }
                }
                if (hasNonInstancingPass && this._localSHBuffer) {
                  this._localSHBuffer.update(this._localSHData);
                }
              };
              _proto.clearSHUBOs = function clearSHUBOs() {
                if (!this._localSHData) {
                  return;
                }
                for (var i = 0; i < 28; i++) {
                  this._localSHData[i] = 0.0;
                }
                this.updateSHBuffer();
              };
              _proto.updateSHUBOs = function updateSHUBOs() {
                if (!this.isLightProbeAvailable()) {
                  return;
                }
                var center = this._worldBounds.center;
                if (center.equals(this._lastWorldBoundCenter, EPSILON$1)) {
                  return;
                }
                var coefficients = [];
                var weights = new Vec4();
                var lightProbes = cclegacy.director.root.pipeline.pipelineSceneData.lightProbes;
                this._lastWorldBoundCenter.set(center);
                this._tetrahedronIndex = lightProbes.data.getInterpolationWeights(center, this._tetrahedronIndex, weights);
                var result = lightProbes.data.getInterpolationSHCoefficients(this._tetrahedronIndex, weights, coefficients);
                if (!result) {
                  return;
                }
                if (!this._localSHData) {
                  return;
                }
                var SHCls = cclegacy.internal.SH;
                SHCls.reduceRinging(coefficients, lightProbes.reduceRinging);
                SHCls.updateUBOData(this._localSHData, 0, coefficients);
                this.updateSHBuffer();
              };
              _proto.createBoundingShape = function createBoundingShape(minPos, maxPos) {
                if (!minPos || !maxPos) {
                  return;
                }
                if (!this._modelBounds) {
                  this._modelBounds = AABB.create();
                }
                if (!this._worldBounds) {
                  this._worldBounds = AABB.create();
                }
                AABB.fromPoints(this._modelBounds, minPos, maxPos);
                this._worldBounds.copy(this._modelBounds);
              };
              _proto._createSubModel = function _createSubModel() {
                return new SubModel();
              };
              _proto.initSubModel = function initSubModel(idx, subMeshData, mat) {
                this.initialize();
                if (this._subModels[idx] == null) {
                  this._subModels[idx] = this._createSubModel();
                } else {
                  this._subModels[idx].destroy();
                }
                this._subModels[idx].initialize(subMeshData, mat.passes, this.getMacroPatches(idx));
                this._updateAttributesAndBinding(idx);
              };
              _proto.setSubModelMesh = function setSubModelMesh(idx, subMesh) {
                if (!this._subModels[idx]) {
                  return;
                }
                this._subModels[idx].subMesh = subMesh;
              };
              _proto.setSubModelMaterial = function setSubModelMaterial(idx, mat) {
                if (!this._subModels[idx]) {
                  return;
                }
                this._subModels[idx].passes = mat.passes;
                this._updateAttributesAndBinding(idx);
              };
              _proto.onGlobalPipelineStateChanged = function onGlobalPipelineStateChanged() {
                var subModels = this._subModels;
                for (var i = 0; i < subModels.length; i++) {
                  subModels[i].onPipelineStateChanged();
                }
              };
              _proto.onMacroPatchesStateChanged = function onMacroPatchesStateChanged() {
                var subModels = this._subModels;
                for (var i = 0; i < subModels.length; i++) {
                  subModels[i].onMacroPatchesStateChanged(this.getMacroPatches(i));
                }
              };
              _proto.onGeometryChanged = function onGeometryChanged() {
                var subModels = this._subModels;
                for (var i = 0; i < subModels.length; i++) {
                  subModels[i].onGeometryChanged();
                }
              };
              _proto.initLightingmap = function initLightingmap(texture, uvParam) {
                this._lightmap = texture;
                this._lightmapUVParam = uvParam;
              };
              _proto.updateLightingmap = function updateLightingmap(texture, uvParam) {
                Vec4.toArray(this._localData, uvParam, 32);
                this._localDataUpdated = true;
                this._lightmap = texture;
                this._lightmapUVParam = uvParam;
                this.onMacroPatchesStateChanged();
                if (!texture) {
                  texture = builtinResMgr.get('empty-texture');
                }
                var gfxTexture = texture.getGFXTexture();
                if (gfxTexture) {
                  var sampler = this._device.getSampler(texture.mipmaps.length > 1 ? lightmapSamplerWithMipHash : lightmapSamplerHash);
                  var subModels = this._subModels;
                  for (var i = 0; i < subModels.length; i++) {
                    var descriptorSet = subModels[i].descriptorSet;
                    descriptorSet.bindTexture(UNIFORM_LIGHTMAP_TEXTURE_BINDING, gfxTexture);
                    descriptorSet.bindSampler(UNIFORM_LIGHTMAP_TEXTURE_BINDING, sampler);
                    descriptorSet.update();
                  }
                }
              };
              _proto.updateReflectionProbeCubemap = function updateReflectionProbeCubemap(texture) {
                this._localDataUpdated = true;
                this.onMacroPatchesStateChanged();
                if (!texture) {
                  texture = builtinResMgr.get('default-cube-texture');
                }
                var gfxTexture = texture.getGFXTexture();
                if (gfxTexture) {
                  var reflectionSampler = this._device.getSampler(texture.getSamplerInfo());
                  var subModels = this._subModels;
                  for (var i = 0; i < subModels.length; i++) {
                    var descriptorSet = subModels[i].descriptorSet;
                    if (descriptorSet) {
                      descriptorSet.bindSampler(UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING, reflectionSampler);
                      descriptorSet.bindTexture(UNIFORM_REFLECTION_PROBE_CUBEMAP_BINDING, gfxTexture);
                      descriptorSet.update();
                    }
                  }
                }
              };
              _proto.updateReflectionProbeBlendCubemap = function updateReflectionProbeBlendCubemap(texture) {
                {
                  return;
                }
              };
              _proto.updateReflectionProbePlanarMap = function updateReflectionProbePlanarMap(texture) {
                this._localDataUpdated = true;
                this.onMacroPatchesStateChanged();
                var sampler = this._device.getSampler(new SamplerInfo(2, 2, 0, 2, 2, 2));
                if (!texture) {
                  texture = builtinResMgr.get('empty-texture').getGFXTexture();
                }
                if (texture) {
                  var subModels = this._subModels;
                  for (var i = 0; i < subModels.length; i++) {
                    var descriptorSet = subModels[i].descriptorSet;
                    if (descriptorSet) {
                      descriptorSet.bindTexture(UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING, texture);
                      descriptorSet.bindSampler(UNIFORM_REFLECTION_PROBE_TEXTURE_BINDING, sampler);
                      descriptorSet.update();
                    }
                  }
                }
              };
              _proto.updateReflectionProbeDataMap = function updateReflectionProbeDataMap(texture) {
                this._localDataUpdated = true;
                this.onMacroPatchesStateChanged();
                if (!texture) {
                  texture = builtinResMgr.get('empty-texture');
                }
                var gfxTexture = texture.getGFXTexture();
                if (gfxTexture) {
                  var subModels = this._subModels;
                  for (var i = 0; i < subModels.length; i++) {
                    var descriptorSet = subModels[i].descriptorSet;
                    if (descriptorSet) {
                      descriptorSet.bindTexture(UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING, gfxTexture);
                      descriptorSet.bindSampler(UNIFORM_REFLECTION_PROBE_DATA_MAP_BINDING, texture.getGFXSampler());
                      descriptorSet.update();
                    }
                  }
                }
              };
              _proto.updateLocalShadowBias = function updateLocalShadowBias() {
                var sv = this._localData;
                sv[36 + 0] = this._shadowBias;
                sv[36 + 1] = this._shadowNormalBias;
                this._localDataUpdated = true;
              };
              _proto.updateReflectionProbeId = function updateReflectionProbeId() {
                var sv = this._localData;
                sv[36 + 2] = this._reflectionProbeId;
                sv[36 + 3] = this._reflectionProbeBlendId;
                var probe = null;
                var blendProbe = null;
                if (cclegacy.internal.reflectionProbeManager) {
                  probe = cclegacy.internal.reflectionProbeManager.getProbeById(this._reflectionProbeId);
                  blendProbe = cclegacy.internal.reflectionProbeManager.getProbeById(this._reflectionProbeBlendId);
                }
                if (probe) {
                  if (probe.probeType === 1) {
                    sv[40] = probe.node.up.x;
                    sv[40 + 1] = probe.node.up.y;
                    sv[40 + 2] = probe.node.up.z;
                    sv[40 + 3] = 1.0;
                    sv[44] = 1.0;
                    sv[44 + 1] = 0.0;
                    sv[44 + 2] = 0.0;
                    sv[44 + 3] = 1.0;
                  } else {
                    sv[40] = probe.node.worldPosition.x;
                    sv[40 + 1] = probe.node.worldPosition.y;
                    sv[40 + 2] = probe.node.worldPosition.z;
                    sv[40 + 3] = 0.0;
                    sv[44] = probe.size.x;
                    sv[44 + 1] = probe.size.y;
                    sv[44 + 2] = probe.size.z;
                    var mipAndUseRGBE = probe.isRGBE() ? 1000 : 0;
                    sv[44 + 3] = probe.cubemap ? probe.cubemap.mipmapLevel + mipAndUseRGBE : 1.0 + mipAndUseRGBE;
                  }
                  if (this._reflectionProbeType === 3 || this._reflectionProbeType === 4) {
                    if (blendProbe) {
                      sv[48] = blendProbe.node.worldPosition.x;
                      sv[48 + 1] = blendProbe.node.worldPosition.y;
                      sv[48 + 2] = blendProbe.node.worldPosition.z;
                      sv[48 + 3] = this.reflectionProbeBlendWeight;
                      sv[52] = blendProbe.size.x;
                      sv[52 + 1] = blendProbe.size.y;
                      sv[52 + 2] = blendProbe.size.z;
                      var _mipAndUseRGBE = blendProbe.isRGBE() ? 1000 : 0;
                      sv[52 + 3] = blendProbe.cubemap ? blendProbe.cubemap.mipmapLevel + _mipAndUseRGBE : 1.0 + _mipAndUseRGBE;
                    } else if (this._reflectionProbeType === 4) {
                      sv[48 + 3] = this.reflectionProbeBlendWeight;
                    }
                  }
                }
                this._localDataUpdated = true;
              };
              _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
                var patches = this.receiveShadow ? shadowMapPatches : null;
                if (this._lightmap != null && this.node && this.node.scene) {
                  var sceneGlobals = this.node.scene.globals;
                  if (!sceneGlobals.disableLightmap) {
                    var mainLightIsStationary = sceneGlobals.bakedWithStationaryMainLight;
                    var lightmapPathes = mainLightIsStationary ? stationaryLightMapPatches : staticLightMapPatches;
                    patches = patches ? patches.concat(lightmapPathes) : lightmapPathes;
                    if (sceneGlobals.bakedWithHighpLightmap) {
                      patches = patches.concat(highpLightMapPatches);
                    }
                  }
                }
                if (this._useLightProbe) {
                  patches = patches ? patches.concat(lightProbePatches) : lightProbePatches;
                }
                var reflectionProbePatches = [{
                  name: CC_USE_REFLECTION_PROBE,
                  value: this._reflectionProbeType
                }];
                patches = patches ? patches.concat(reflectionProbePatches) : reflectionProbePatches;
                var receiveDirLightPatches = [{
                  name: CC_DISABLE_DIRECTIONAL_LIGHT,
                  value: !this._receiveDirLight
                }];
                patches = patches ? patches.concat(receiveDirLightPatches) : receiveDirLightPatches;
                return patches;
              };
              _proto._updateAttributesAndBinding = function _updateAttributesAndBinding(subModelIndex) {
                var subModel = this._subModels[subModelIndex];
                if (!subModel) {
                  return;
                }
                this._initLocalDescriptors(subModelIndex);
                this._updateLocalDescriptors(subModelIndex, subModel.descriptorSet);
                this._initLocalSHDescriptors(subModelIndex);
                this._updateLocalSHDescriptors(subModelIndex, subModel.descriptorSet);
                this._initWorldBoundDescriptors(subModelIndex);
                if (subModel.worldBoundDescriptorSet) {
                  this._updateWorldBoundDescriptors(subModelIndex, subModel.worldBoundDescriptorSet);
                }
                var attributes = [];
                var attributeSet = new Set();
                subModel.passes.forEach(function (pass) {
                  var shader = pass.getShaderVariant(subModel.patches);
                  shader.attributes.forEach(function (attr) {
                    if (!attributeSet.has(attr.name)) {
                      attributes.push(attr);
                      attributeSet.add(attr.name);
                    }
                  });
                });
                this._updateInstancedAttributes(attributes, subModel);
              };
              _proto._updateInstancedAttributes = function _updateInstancedAttributes(attributes, subModel) {
                subModel.UpdateInstancedAttributes(attributes);
                this._localDataUpdated = true;
              };
              _proto._initLocalDescriptors = function _initLocalDescriptors(subModelIndex) {
                if (!this._localBuffer) {
                  this._localBuffer = this._device.createBuffer(new BufferInfo(16 | 2, 1, 224, 224));
                }
              };
              _proto._initLocalSHDescriptors = function _initLocalSHDescriptors(subModelIndex) {
                if (!this._useLightProbe) {
                  return;
                }
                if (!this._localSHData) {
                  this._localSHData = new Float32Array(28);
                }
                if (!this._localSHBuffer) {
                  this._localSHBuffer = this._device.createBuffer(new BufferInfo(16 | 2, 1, 112, 112));
                }
              };
              _proto._initWorldBoundDescriptors = function _initWorldBoundDescriptors(subModelIndex) {
                if (!this._worldBoundBuffer) {
                  this._worldBoundBuffer = this._device.createBuffer(new BufferInfo(16 | 2, 1, UBOWorldBound.SIZE, UBOWorldBound.SIZE));
                }
              };
              _proto._updateLocalDescriptors = function _updateLocalDescriptors(subModelIndex, descriptorSet) {
                if (this._localBuffer) descriptorSet.bindBuffer(0, this._localBuffer);
              };
              _proto._updateLocalSHDescriptors = function _updateLocalSHDescriptors(subModelIndex, descriptorSet) {
                if (this._localSHBuffer) descriptorSet.bindBuffer(6, this._localSHBuffer);
              };
              _proto._updateWorldBoundDescriptors = function _updateWorldBoundDescriptors(subModelIndex, descriptorSet) {
                if (this._worldBoundBuffer) descriptorSet.bindBuffer(UBOWorldBound.BINDING, this._worldBoundBuffer);
              };
              _createClass(Model, [{
                key: "subModels",
                get: function get() {
                  return this._subModels;
                }
              }, {
                key: "inited",
                get: function get() {
                  return this._inited;
                }
              }, {
                key: "worldBounds",
                get: function get() {
                  return this._worldBounds;
                }
              }, {
                key: "modelBounds",
                get: function get() {
                  return this._modelBounds;
                }
              }, {
                key: "localBuffer",
                get: function get() {
                  return this._localBuffer;
                }
              }, {
                key: "localSHBuffer",
                get: function get() {
                  return this._localSHBuffer;
                }
              }, {
                key: "worldBoundBuffer",
                get: function get() {
                  return this._worldBoundBuffer;
                }
              }, {
                key: "updateStamp",
                get: function get() {
                  return this._updateStamp;
                }
              }, {
                key: "useLightProbe",
                get: function get() {
                  return this._useLightProbe;
                },
                set: function set(val) {
                  this._useLightProbe = val;
                  this.onMacroPatchesStateChanged();
                }
              }, {
                key: "tetrahedronIndex",
                get: function get() {
                  return this._tetrahedronIndex;
                },
                set: function set(index) {
                  this._tetrahedronIndex = index;
                }
              }, {
                key: "shadowBias",
                get: function get() {
                  return this._shadowBias;
                },
                set: function set(val) {
                  this._shadowBias = val;
                }
              }, {
                key: "shadowNormalBias",
                get: function get() {
                  return this._shadowNormalBias;
                },
                set: function set(val) {
                  this._shadowNormalBias = val;
                }
              }, {
                key: "receiveShadow",
                get: function get() {
                  return this._receiveShadow;
                },
                set: function set(val) {
                  this._receiveShadow = val;
                  this.onMacroPatchesStateChanged();
                }
              }, {
                key: "castShadow",
                get: function get() {
                  return this._castShadow;
                },
                set: function set(val) {
                  this._castShadow = val;
                }
              }, {
                key: "receiveDirLight",
                get: function get() {
                  return this._receiveDirLight;
                },
                set: function set(val) {
                  this._receiveDirLight = val;
                  this.onMacroPatchesStateChanged();
                }
              }, {
                key: "node",
                get: function get() {
                  return this._node;
                },
                set: function set(n) {
                  this._node = n;
                }
              }, {
                key: "transform",
                get: function get() {
                  return this._transform;
                },
                set: function set(n) {
                  this._transform = n;
                }
              }, {
                key: "visFlags",
                get: function get() {
                  return this._visFlags;
                },
                set: function set(val) {
                  this._visFlags = val;
                }
              }, {
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(val) {
                  this._priority = val;
                }
              }, {
                key: "bakeToReflectionProbe",
                get: function get() {
                  return this._bakeToReflectionProbe;
                },
                set: function set(val) {
                  this._bakeToReflectionProbe = val;
                }
              }, {
                key: "reflectionProbeType",
                get: function get() {
                  return this._reflectionProbeType;
                },
                set: function set(val) {
                  this._reflectionProbeType = val;
                  var subModels = this._subModels;
                  for (var i = 0; i < subModels.length; i++) {
                    subModels[i].useReflectionProbeType = val;
                  }
                  this.onMacroPatchesStateChanged();
                }
              }, {
                key: "reflectionProbeId",
                get: function get() {
                  return this._reflectionProbeId;
                },
                set: function set(val) {
                  this._reflectionProbeId = val;
                }
              }, {
                key: "reflectionProbeBlendId",
                get: function get() {
                  return this._reflectionProbeBlendId;
                },
                set: function set(val) {
                  this._reflectionProbeBlendId = val;
                }
              }, {
                key: "reflectionProbeBlendWeight",
                get: function get() {
                  return this._reflectionProbeBlendWeight;
                },
                set: function set(val) {
                  this._reflectionProbeBlendWeight = val;
                }
              }]);
              return Model;
            }();

            var Octree = function () {
              function Octree() {
                this._enabled = false;
                this._minPos = new Vec3(0, 0, 0);
                this._maxPos = new Vec3(0, 0, 0);
                this._depth = 0;
              }
              var _proto = Octree.prototype;
              _proto.initialize = function initialize(octreeInfo) {
                this._enabled = octreeInfo.enabled;
                this._minPos = octreeInfo.minPos;
                this._maxPos = octreeInfo.maxPos;
                this._depth = octreeInfo.depth;
              };
              _createClass(Octree, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                }
              }, {
                key: "minPos",
                get: function get() {
                  return this._minPos;
                },
                set: function set(val) {
                  this._minPos = val;
                }
              }, {
                key: "maxPos",
                get: function get() {
                  return this._maxPos;
                },
                set: function set(val) {
                  this._maxPos = val;
                }
              }, {
                key: "depth",
                get: function get() {
                  return this._depth;
                },
                set: function set(val) {
                  this._depth = val;
                }
              }]);
              return Octree;
            }();

            var Skin = function () {
              function Skin() {
                this._enabled = true;
                this._blurRadius = 0.01;
                this._sssIntensity = 3.0;
              }
              var _proto = Skin.prototype;
              _proto.initialize = function initialize(skinInfo) {
                this._enabled = skinInfo.enabled;
                this._blurRadius = skinInfo.blurRadius;
                this._sssIntensity = skinInfo.sssIntensity;
              };
              _createClass(Skin, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                }
              }, {
                key: "blurRadius",
                get: function get() {
                  return this._blurRadius;
                },
                set: function set(val) {
                  this._blurRadius = val;
                }
              }, {
                key: "sssIntensity",
                get: function get() {
                  return this._sssIntensity;
                },
                set: function set(val) {
                  this._sssIntensity = val;
                }
              }]);
              return Skin;
            }();

            function ColorTemperatureToRGB(rgb, kelvin) {
              if (kelvin < 1000.0) {
                kelvin = 1000.0;
              } else if (kelvin > 15000.0) {
                kelvin = 15000.0;
              }
              var kSqr = kelvin * kelvin;
              var u = (0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kSqr) / (1.0 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kSqr);
              var v = (0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kSqr) / (1.0 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kSqr);
              var d = 2.0 * u - 8.0 * v + 4.0;
              var x = 3.0 * u / d;
              var y = 2.0 * v / d;
              var z = 1.0 - x - y;
              var X = 1.0 / y * x;
              var Z = 1.0 / y * z;
              rgb.x = 3.2404542 * X + -1.5371385 + -0.4985314 * Z;
              rgb.y = -0.969266 * X + 1.8760108 + 0.0415560 * Z;
              rgb.z = 0.0556434 * X + -0.2040259 + 1.0572252 * Z;
            }
            var LightType = {
              DIRECTIONAL: 0,
              SPHERE: 1,
              SPOT: 2,
              POINT: 3,
              RANGED_DIRECTIONAL: 4,
              UNKNOWN: 5
            };
            var nt2lm = function nt2lm(size) {
              return 4 * Math.PI * Math.PI * size * size;
            };
            var Light$1 = function () {
              function Light() {
                this._baked = false;
                this._color = v3(1, 1, 1);
                this._colorTemp = 6550.0;
                this._colorTempRGB = v3(1, 1, 1);
                this._finalColor = v3(1, 1, 1);
                this._scene = null;
                this._node = null;
                this._name = null;
                this._useColorTemperature = false;
                this._type = 5;
                this._visibility = CAMERA_DEFAULT_MASK;
              }
              var _proto = Light.prototype;
              _proto.initialize = function initialize() {
                this.color = v3(1, 1, 1);
                this.colorTemperature = 6550.0;
              };
              _proto.attachToScene = function attachToScene(scene) {
                this._scene = scene;
              };
              _proto.detachFromScene = function detachFromScene() {
                this._scene = null;
              };
              _proto.destroy = function destroy() {
                this._name = null;
                this._node = null;
              };
              _proto.update = function update() {};
              _createClass(Light, [{
                key: "baked",
                get: function get() {
                  return this._baked;
                },
                set: function set(val) {
                  this._baked = val;
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(color) {
                  this._color.set(color);
                  if (this._useColorTemperature) {
                    Vec3.multiply(this._finalColor, this._color, this._colorTempRGB);
                  }
                }
              }, {
                key: "useColorTemperature",
                get: function get() {
                  return this._useColorTemperature;
                },
                set: function set(enable) {
                  this._useColorTemperature = enable;
                  if (enable) {
                    Vec3.multiply(this._finalColor, this._color, this._colorTempRGB);
                  }
                }
              }, {
                key: "colorTemperature",
                get: function get() {
                  return this._colorTemp;
                },
                set: function set(val) {
                  this._colorTemp = val;
                  ColorTemperatureToRGB(this._colorTempRGB, this._colorTemp);
                  if (this._useColorTemperature) {
                    Vec3.multiply(this._finalColor, this._color, this._colorTempRGB);
                  }
                }
              }, {
                key: "colorTemperatureRGB",
                get: function get() {
                  return this._colorTempRGB;
                }
              }, {
                key: "finalColor",
                get: function get() {
                  return this._finalColor;
                }
              }, {
                key: "visibility",
                get: function get() {
                  return this._visibility;
                },
                set: function set(vis) {
                  this._visibility = vis;
                }
              }, {
                key: "node",
                get: function get() {
                  return this._node;
                },
                set: function set(n) {
                  this._node = n;
                  if (this._node) {
                    this._node.hasChangedFlags |= 2;
                  }
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                }
              }, {
                key: "name",
                get: function get() {
                  return this._name;
                },
                set: function set(n) {
                  this._name = n;
                }
              }, {
                key: "scene",
                get: function get() {
                  return this._scene;
                }
              }]);
              return Light;
            }();

            var _forward$2 = new Vec3(0, 0, -1);
            var _v3 = new Vec3();
            var DirectionalLight$1 = function (_Light) {
              _inheritsLoose(DirectionalLight, _Light);
              function DirectionalLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._dir = new Vec3(1.0, -1, -1);
                _this._illuminanceHDR = Ambient.SUN_ILLUM;
                _this._illuminanceLDR = 1.0;
                _this._shadowEnabled = false;
                _this._shadowPcf = PCFType.HARD;
                _this._shadowBias = 0.00001;
                _this._shadowNormalBias = 0.0;
                _this._shadowSaturation = 1.0;
                _this._shadowDistance = 50;
                _this._shadowInvisibleOcclusionRange = 200;
                _this._csmLevel = CSMLevel.LEVEL_4;
                _this._csmNeedUpdate = false;
                _this._csmLayerLambda = 0.75;
                _this._csmOptimizationMode = CSMOptimizationMode.DisableRotationFix;
                _this._csmLayersTransition = false;
                _this._csmTransitionRange = 0.05;
                _this._shadowFixedArea = false;
                _this._shadowNear = 0.1;
                _this._shadowFar = 10.0;
                _this._shadowOrthoSize = 5;
                _this._type = 0;
                return _this;
              }
              var _proto = DirectionalLight.prototype;
              _proto.initialize = function initialize() {
                _Light.prototype.initialize.call(this);
                this.illuminance = Ambient.SUN_ILLUM;
                this.direction = new Vec3(1.0, -1, -1);
              };
              _proto.update = function update() {
                if (this._node && this._node.hasChangedFlags) {
                  this.direction = Vec3.transformQuat(_v3, _forward$2, this._node.worldRotation);
                }
              };
              _proto.activate = function activate() {
                var root = cclegacy.director.root;
                var pipeline = root.pipeline;
                if (this._shadowEnabled) {
                  if (this._shadowFixedArea || !pipeline.pipelineSceneData.csmSupported) {
                    pipeline.macros.CC_DIR_LIGHT_SHADOW_TYPE = 1;
                  } else if (this.csmLevel > 1 && pipeline.pipelineSceneData.csmSupported) {
                    pipeline.macros.CC_DIR_LIGHT_SHADOW_TYPE = 2;
                    pipeline.macros.CC_CASCADED_LAYERS_TRANSITION = this._csmLayersTransition;
                  } else {
                    pipeline.macros.CC_DIR_LIGHT_SHADOW_TYPE = 1;
                  }
                  pipeline.macros.CC_DIR_SHADOW_PCF_TYPE = this._shadowPcf;
                } else {
                  pipeline.macros.CC_DIR_LIGHT_SHADOW_TYPE = 0;
                }
                root.onGlobalPipelineStateChanged();
              };
              _createClass(DirectionalLight, [{
                key: "direction",
                get: function get() {
                  return this._dir;
                },
                set: function set(dir) {
                  Vec3.normalize(this._dir, dir);
                }
              }, {
                key: "illuminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._illuminanceHDR;
                  } else {
                    return this._illuminanceLDR;
                  }
                },
                set: function set(value) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this.illuminanceHDR = value;
                  } else {
                    this.illuminanceLDR = value;
                  }
                }
              }, {
                key: "illuminanceHDR",
                get: function get() {
                  return this._illuminanceHDR;
                },
                set: function set(value) {
                  this._illuminanceHDR = value;
                }
              }, {
                key: "illuminanceLDR",
                get: function get() {
                  return this._illuminanceLDR;
                },
                set: function set(value) {
                  this._illuminanceLDR = value;
                }
              }, {
                key: "shadowEnabled",
                get: function get() {
                  return this._shadowEnabled;
                },
                set: function set(val) {
                  this._shadowEnabled = val;
                  this.activate();
                }
              }, {
                key: "shadowPcf",
                get: function get() {
                  return this._shadowPcf;
                },
                set: function set(val) {
                  this._shadowPcf = val;
                  this.activate();
                }
              }, {
                key: "shadowBias",
                get: function get() {
                  return this._shadowBias;
                },
                set: function set(val) {
                  this._shadowBias = val;
                }
              }, {
                key: "shadowNormalBias",
                get: function get() {
                  return this._shadowNormalBias;
                },
                set: function set(val) {
                  this._shadowNormalBias = val;
                }
              }, {
                key: "shadowSaturation",
                get: function get() {
                  return this._shadowSaturation;
                },
                set: function set(val) {
                  this._shadowSaturation = val;
                }
              }, {
                key: "shadowDistance",
                get: function get() {
                  return this._shadowDistance;
                },
                set: function set(val) {
                  this._shadowDistance = Math.min(val, Shadows.MAX_FAR);
                }
              }, {
                key: "shadowInvisibleOcclusionRange",
                get: function get() {
                  return this._shadowInvisibleOcclusionRange;
                },
                set: function set(val) {
                  this._shadowInvisibleOcclusionRange = Math.min(val, Shadows.MAX_FAR);
                }
              }, {
                key: "csmLevel",
                get: function get() {
                  return this._csmLevel;
                },
                set: function set(val) {
                  this._csmLevel = val;
                  this.activate();
                }
              }, {
                key: "csmNeedUpdate",
                get: function get() {
                  return this._csmNeedUpdate;
                },
                set: function set(val) {
                  this._csmNeedUpdate = val;
                }
              }, {
                key: "csmLayerLambda",
                get: function get() {
                  return this._csmLayerLambda;
                },
                set: function set(val) {
                  this._csmLayerLambda = val;
                }
              }, {
                key: "csmOptimizationMode",
                get: function get() {
                  return this._csmOptimizationMode;
                },
                set: function set(val) {
                  this._csmOptimizationMode = val;
                }
              }, {
                key: "shadowFixedArea",
                get: function get() {
                  return this._shadowFixedArea;
                },
                set: function set(val) {
                  this._shadowFixedArea = val;
                  this.activate();
                }
              }, {
                key: "shadowNear",
                get: function get() {
                  return this._shadowNear;
                },
                set: function set(val) {
                  this._shadowNear = val;
                }
              }, {
                key: "shadowFar",
                get: function get() {
                  return this._shadowFar;
                },
                set: function set(val) {
                  this._shadowFar = Math.min(val, Shadows.MAX_FAR);
                }
              }, {
                key: "shadowOrthoSize",
                get: function get() {
                  return this._shadowOrthoSize;
                },
                set: function set(val) {
                  this._shadowOrthoSize = val;
                }
              }, {
                key: "csmLayersTransition",
                get: function get() {
                  return this._csmLayersTransition;
                },
                set: function set(val) {
                  this._csmLayersTransition = val;
                  this.activate();
                }
              }, {
                key: "csmTransitionRange",
                get: function get() {
                  return this._csmTransitionRange;
                },
                set: function set(val) {
                  this._csmTransitionRange = val;
                }
              }]);
              return DirectionalLight;
            }(Light$1);

            var SphereLight$1 = function (_Light) {
              _inheritsLoose(SphereLight, _Light);
              function SphereLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._needUpdate = false;
                _this._size = 0.15;
                _this._range = 1.0;
                _this._luminanceHDR = 0;
                _this._luminanceLDR = 0;
                _this._pos = new Vec3();
                _this._aabb = AABB.create();
                _this._type = 1;
                return _this;
              }
              var _proto = SphereLight.prototype;
              _proto.initialize = function initialize() {
                _Light.prototype.initialize.call(this);
                var size = 0.15;
                this.size = size;
                this.range = 1.0;
                this.luminanceHDR = 1700 / nt2lm(size);
                this.luminanceLDR = 1.0;
              };
              _proto.update = function update() {
                if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
                  this._node.getWorldPosition(this._pos);
                  var range = this._range;
                  AABB.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, range, range, range);
                  this._needUpdate = false;
                }
              };
              _createClass(SphereLight, [{
                key: "position",
                get: function get() {
                  return this._pos;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(size) {
                  this._size = size;
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(range) {
                  this._range = range;
                  this._needUpdate = true;
                }
              }, {
                key: "luminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._luminanceHDR;
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(value) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this.luminanceHDR = value;
                  } else {
                    this.luminanceLDR = value;
                  }
                }
              }, {
                key: "luminanceHDR",
                get: function get() {
                  return this._luminanceHDR;
                },
                set: function set(value) {
                  this._luminanceHDR = value;
                }
              }, {
                key: "luminanceLDR",
                set: function set(value) {
                  this._luminanceLDR = value;
                }
              }, {
                key: "aabb",
                get: function get() {
                  return this._aabb;
                }
              }]);
              return SphereLight;
            }(Light$1);

            var _forward$1 = new Vec3(0, 0, -1);
            var _qt = new Quat();
            var _matView$1 = new Mat4();
            var _matProj = new Mat4();
            var _matViewProj = new Mat4();
            var _matViewProjInv = new Mat4();
            var SpotLight$1 = function (_Light) {
              _inheritsLoose(SpotLight, _Light);
              function SpotLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._dir = new Vec3(1.0, -1, -1);
                _this._range = 5.0;
                _this._spotAngle = Math.cos(Math.PI / 6);
                _this._angleAttenuationStrength = 0;
                _this._pos = new Vec3();
                _this._aabb = AABB.create();
                _this._frustum = Frustum.create();
                _this._angle = 0;
                _this._needUpdate = false;
                _this._size = 0.15;
                _this._luminanceHDR = 0;
                _this._luminanceLDR = 0;
                _this._shadowEnabled = false;
                _this._shadowPcf = PCFType.HARD;
                _this._shadowBias = 0.00001;
                _this._shadowNormalBias = 0.0;
                _this._type = 2;
                return _this;
              }
              var _proto = SpotLight.prototype;
              _proto.initialize = function initialize() {
                _Light.prototype.initialize.call(this);
                var size = 0.15;
                this.size = size;
                this.luminanceHDR = 1700 / nt2lm(size);
                this.luminanceLDR = 1.0;
                this.range = Math.cos(Math.PI / 6);
                this._dir.set(new Vec3(1.0, -1, -1));
              };
              _proto.update = function update() {
                if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
                  this._node.getWorldPosition(this._pos);
                  Vec3.transformQuat(this._dir, _forward$1, this._node.getWorldRotation(_qt));
                  Vec3.normalize(this._dir, this._dir);
                  AABB.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range);
                  this._node.getWorldRT(_matView$1);
                  Mat4.invert(_matView$1, _matView$1);
                  Mat4.perspective(_matProj, this._angle, 1.0, 0.001, this._range);
                  Mat4.multiply(_matViewProj, _matProj, _matView$1);
                  this._frustum.update(_matViewProj, _matViewProjInv);
                  this._needUpdate = false;
                }
              };
              _createClass(SpotLight, [{
                key: "position",
                get: function get() {
                  return this._pos;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(size) {
                  this._size = size;
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(range) {
                  this._range = range;
                  this._needUpdate = true;
                }
              }, {
                key: "luminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._luminanceHDR;
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(value) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this.luminanceHDR = value;
                  } else {
                    this.luminanceLDR = value;
                  }
                }
              }, {
                key: "luminanceHDR",
                get: function get() {
                  return this._luminanceHDR;
                },
                set: function set(value) {
                  this._luminanceHDR = value;
                }
              }, {
                key: "luminanceLDR",
                get: function get() {
                  return this._luminanceLDR;
                },
                set: function set(value) {
                  this._luminanceLDR = value;
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._dir;
                }
              }, {
                key: "spotAngle",
                get: function get() {
                  return this._spotAngle;
                },
                set: function set(val) {
                  this._angle = val;
                  this._spotAngle = Math.cos(val * 0.5);
                  this._needUpdate = true;
                }
              }, {
                key: "angleAttenuationStrength",
                get: function get() {
                  return this._angleAttenuationStrength;
                },
                set: function set(val) {
                  this._angleAttenuationStrength = val;
                  this._needUpdate = true;
                }
              }, {
                key: "angle",
                get: function get() {
                  return this._angle;
                }
              }, {
                key: "aabb",
                get: function get() {
                  return this._aabb;
                }
              }, {
                key: "frustum",
                get: function get() {
                  return this._frustum;
                }
              }, {
                key: "shadowEnabled",
                get: function get() {
                  return this._shadowEnabled;
                },
                set: function set(val) {
                  this._shadowEnabled = val;
                }
              }, {
                key: "shadowPcf",
                get: function get() {
                  return this._shadowPcf;
                },
                set: function set(val) {
                  this._shadowPcf = val;
                }
              }, {
                key: "shadowBias",
                get: function get() {
                  return this._shadowBias;
                },
                set: function set(val) {
                  this._shadowBias = val;
                }
              }, {
                key: "shadowNormalBias",
                get: function get() {
                  return this._shadowNormalBias;
                },
                set: function set(val) {
                  this._shadowNormalBias = val;
                }
              }]);
              return SpotLight;
            }(Light$1);

            var PointLight$1 = function (_Light) {
              _inheritsLoose(PointLight, _Light);
              function PointLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._needUpdate = false;
                _this._range = 1.0;
                _this._luminanceHDR = 0;
                _this._luminanceLDR = 0;
                _this._pos = v3();
                _this._aabb = AABB.create();
                _this._type = 3;
                return _this;
              }
              var _proto = PointLight.prototype;
              _proto.initialize = function initialize() {
                _Light.prototype.initialize.call(this);
                this.range = 1.0;
                this.luminanceHDR = 1700 / nt2lm(1.0);
                this.luminanceLDR = 1.0;
              };
              _proto.update = function update() {
                if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
                  this._node.getWorldPosition(this._pos);
                  var range = this._range;
                  AABB.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, range, range, range);
                  this._needUpdate = false;
                }
              };
              _createClass(PointLight, [{
                key: "position",
                get: function get() {
                  return this._pos;
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(range) {
                  this._range = range;
                  this._needUpdate = true;
                }
              }, {
                key: "luminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._luminanceHDR;
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(value) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this.luminanceHDR = value;
                  } else {
                    this.luminanceLDR = value;
                  }
                }
              }, {
                key: "luminanceHDR",
                get: function get() {
                  return this._luminanceHDR;
                },
                set: function set(value) {
                  this._luminanceHDR = value;
                }
              }, {
                key: "luminanceLDR",
                set: function set(value) {
                  this._luminanceLDR = value;
                }
              }, {
                key: "aabb",
                get: function get() {
                  return this._aabb;
                }
              }]);
              return PointLight;
            }(Light$1);

            var _forward = new Vec3(0, 0, -1);
            var RangedDirectionalLight$1 = function (_Light) {
              _inheritsLoose(RangedDirectionalLight, _Light);
              function RangedDirectionalLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._dir = new Vec3(0, 0, -1);
                _this._pos = new Vec3(0, 0, 0);
                _this._scale = new Vec3(1, 1, 1);
                _this._right = new Vec3(1, 0, 0);
                _this._illuminanceHDR = Ambient.SUN_ILLUM;
                _this._illuminanceLDR = 1.0;
                _this._type = 4;
                return _this;
              }
              var _proto = RangedDirectionalLight.prototype;
              _proto.initialize = function initialize() {
                _Light.prototype.initialize.call(this);
                this.illuminance = Ambient.SUN_ILLUM;
              };
              _proto.update = function update() {
                if (this._node && this._node.hasChangedFlags) {
                  this._node.getWorldPosition(this._pos);
                  this._node.getWorldScale(this._scale);
                  Vec3.transformQuat(this._dir, _forward, this._node.worldRotation);
                  Vec3.transformQuat(this._right, Vec3.RIGHT, this._node.worldRotation);
                }
              };
              _createClass(RangedDirectionalLight, [{
                key: "direction",
                get: function get() {
                  return this._dir;
                }
              }, {
                key: "right",
                get: function get() {
                  return this._right;
                }
              }, {
                key: "position",
                get: function get() {
                  return this._pos;
                }
              }, {
                key: "scale",
                get: function get() {
                  return this._scale;
                }
              }, {
                key: "illuminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._illuminanceHDR;
                  } else {
                    return this._illuminanceLDR;
                  }
                },
                set: function set(value) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this.illuminanceHDR = value;
                  } else {
                    this.illuminanceLDR = value;
                  }
                }
              }, {
                key: "illuminanceHDR",
                get: function get() {
                  return this._illuminanceHDR;
                },
                set: function set(value) {
                  this._illuminanceHDR = value;
                }
              }, {
                key: "illuminanceLDR",
                get: function get() {
                  return this._illuminanceLDR;
                },
                set: function set(value) {
                  this._illuminanceLDR = value;
                }
              }]);
              return RangedDirectionalLight;
            }(Light$1);

            var ProbeClearFlag = {
              SKYBOX: 14,
              SOLID_COLOR: 7
            };
            var ProbeType = {
              CUBE: 0,
              PLANAR: 1
            };
            var cameraDir = [v3(0, -90, 0), v3(0, 90, 0), v3(90, 0, 0), v3(-90, 0, 0), v3(0, 0, 0), v3(0, 180, 0)];
            var tempVec3 = v3();
            var ReflectionProbe$1 = function () {
              function ReflectionProbe(id) {
                this.bakedCubeTextures = [];
                this.realtimePlanarTexture = null;
                this._resolution = 256;
                this._clearFlag = 14;
                this._backgroundColor = new Color(0, 0, 0, 255);
                this._visibility = CAMERA_DEFAULT_MASK;
                this._probeType = 0;
                this._cubemap = null;
                this._size = v3(1, 1, 1);
                this._camera = null;
                this._probeId = 0;
                this._needRefresh = false;
                this._needRender = false;
                this._node = null;
                this._cameraNode = null;
                this._boundingBox = null;
                this._cameraWorldPos = v3();
                this._cameraWorldRotation = quat();
                this._forward = v3();
                this._up = v3();
                this._previewSphere = null;
                this._previewPlane = null;
                this._probeId = id;
              }
              var _proto = ReflectionProbe.prototype;
              _proto.initialize = function initialize(node, cameraNode) {
                this._node = node;
                this._cameraNode = cameraNode;
                this.node.getWorldPosition(tempVec3);
                var size = this._size;
                this._boundingBox = AABB.create(tempVec3.x, tempVec3.y, tempVec3.z, size.x, size.y, size.z);
                this._createCamera(cameraNode);
              };
              _proto.initBakedTextures = function initBakedTextures() {
                if (this.bakedCubeTextures.length === 0) {
                  for (var i = 0; i < 6; i++) {
                    var renderTexture = this._createTargetTexture(this._resolution, this._resolution);
                    this.bakedCubeTextures.push(renderTexture);
                  }
                }
              };
              _proto.captureCubemap = function captureCubemap() {
                this.initBakedTextures();
                this._resetCameraParams();
                this._needRender = true;
              };
              _proto.renderPlanarReflection = function renderPlanarReflection(sourceCamera) {
                if (!sourceCamera) return;
                if (!this.realtimePlanarTexture) {
                  var canvasSize = cclegacy.view.getDesignResolutionSize();
                  this.realtimePlanarTexture = this._createTargetTexture(canvasSize.width, canvasSize.height);
                  cclegacy.internal.reflectionProbeManager.updatePlanarMap(this, this.realtimePlanarTexture.getGFXTexture());
                }
                this._syncCameraParams(sourceCamera);
                this._transformReflectionCamera(sourceCamera);
                this._needRender = true;
              };
              _proto.switchProbeType = function switchProbeType(type, sourceCamera) {
                if (type === 0) {
                  this._needRender = false;
                } else if (sourceCamera !== null) {
                  this.renderPlanarReflection(sourceCamera);
                }
              };
              _proto.getProbeId = function getProbeId() {
                return this._probeId;
              };
              _proto.updateProbeId = function updateProbeId(id) {
                this._probeId = id;
              };
              _proto.renderArea = function renderArea() {
                if (this._probeType === 1) {
                  return new Vec2(this.realtimePlanarTexture.width, this.realtimePlanarTexture.height);
                } else {
                  return new Vec2(this.resolution, this.resolution);
                }
              };
              _proto.isFinishedRendering = function isFinishedRendering() {
                return true;
              };
              _proto.validate = function validate() {
                return this.cubemap !== null;
              };
              _proto.destroy = function destroy() {
                if (this._camera) {
                  this._camera.destroy();
                  this._camera = null;
                }
                for (var i = 0; i < this.bakedCubeTextures.length; i++) {
                  this.bakedCubeTextures[i].destroy();
                }
                this.bakedCubeTextures = [];
                if (this.realtimePlanarTexture) {
                  this.realtimePlanarTexture.destroy();
                  this.realtimePlanarTexture = null;
                }
              };
              _proto.enable = function enable() {};
              _proto.disable = function disable() {};
              _proto.updateCameraDir = function updateCameraDir(faceIdx) {
                this.cameraNode.setRotationFromEuler(cameraDir[faceIdx]);
                this.camera.update(true);
              };
              _proto.updateBoundingBox = function updateBoundingBox() {
                if (this.node) {
                  this.node.getWorldPosition(tempVec3);
                  var size = this._size;
                  AABB.set(this._boundingBox, tempVec3.x, tempVec3.y, tempVec3.z, size.x, size.y, size.z);
                }
              };
              _proto.hasFrameBuffer = function hasFrameBuffer(framebuffer) {
                if (this.probeType === 1) {
                  var _this$realtimePlanarT;
                  if (!this.realtimePlanarTexture) return false;
                  if (((_this$realtimePlanarT = this.realtimePlanarTexture.window) == null ? undefined : _this$realtimePlanarT.framebuffer) === framebuffer) {
                    return true;
                  }
                } else {
                  if (this.bakedCubeTextures.length === 0) return false;
                  for (var i = 0; i < this.bakedCubeTextures.length; i++) {
                    var _rt$window;
                    var rt = this.bakedCubeTextures[i];
                    if (((_rt$window = rt.window) == null ? undefined : _rt$window.framebuffer) === framebuffer) {
                      return true;
                    }
                  }
                }
                return false;
              };
              _proto.isRGBE = function isRGBE() {
                return true;
              };
              _proto._syncCameraParams = function _syncCameraParams(camera) {
                this.camera.projectionType = camera.projectionType;
                this.camera.orthoHeight = camera.orthoHeight;
                this.camera.nearClip = camera.nearClip;
                this.camera.farClip = camera.farClip;
                this.camera.fov = camera.fov;
                this.camera.clearFlag = camera.clearFlag;
                this.camera.clearColor = camera.clearColor;
                this.camera.priority = camera.priority - 1;
                this.camera.resize(camera.width, camera.height);
              };
              _proto._createCamera = function _createCamera(cameraNode) {
                var root = cclegacy.director.root;
                if (!this._camera) {
                  this._camera = root.createCamera();
                  if (!this._camera) return null;
                  this._camera.initialize({
                    name: cameraNode.name,
                    node: cameraNode,
                    projection: 1,
                    window: root && root.tempWindow,
                    priority: 0,
                    cameraType: -1,
                    trackingType: 0
                  });
                }
                this._camera.setViewportInOrientedSpace(new Rect(0, 0, 1, 1));
                this._camera.fovAxis = 0;
                this._camera.fov = toRadian(90);
                this._camera.orthoHeight = 10;
                this._camera.nearClip = 1;
                this._camera.farClip = 1000;
                this._camera.clearColor = this._backgroundColor;
                this._camera.clearDepth = 1.0;
                this._camera.clearStencil = 0.0;
                this._camera.clearFlag = this._clearFlag;
                this._camera.visibility = this._visibility;
                this._camera.aperture = 19;
                this._camera.shutter = 7;
                this._camera.iso = 0;
                return this._camera;
              };
              _proto._resetCameraParams = function _resetCameraParams() {
                this.camera.projectionType = 1;
                this.camera.orthoHeight = 10;
                this.camera.nearClip = 1;
                this.camera.farClip = 1000;
                this.camera.fov = toRadian(90);
                this.camera.priority = 0;
                this.camera.resize(this.resolution, this.resolution);
                this.camera.visibility = this._visibility;
                this.camera.clearFlag = this._clearFlag;
                this.camera.clearColor = this._backgroundColor;
                this.cameraNode.worldPosition = this.node.worldPosition;
                this.cameraNode.worldRotation = this.node.worldRotation;
                this.camera.update(true);
              };
              _proto._createTargetTexture = function _createTargetTexture(width, height) {
                var rt = new RenderTexture();
                rt.reset({
                  width: width,
                  height: height
                });
                return rt;
              };
              _proto._transformReflectionCamera = function _transformReflectionCamera(sourceCamera) {
                var offset = Vec3.dot(this.node.worldPosition, this.node.up);
                this._reflect(this._cameraWorldPos, sourceCamera.node.worldPosition, this.node.up, offset);
                this.cameraNode.worldPosition = this._cameraWorldPos;
                Vec3.transformQuat(this._forward, Vec3.FORWARD, sourceCamera.node.worldRotation);
                this._reflect(this._forward, this._forward, this.node.up, 0);
                this._forward.normalize();
                this._forward.negative();
                Vec3.transformQuat(this._up, Vec3.UP, sourceCamera.node.worldRotation);
                this._reflect(this._up, this._up, this.node.up, 0);
                this._up.normalize();
                Quat.fromViewUp(this._cameraWorldRotation, this._forward, this._up);
                this.cameraNode.worldRotation = this._cameraWorldRotation;
                this.camera.update(true);
                var viewSpaceProbe = new Vec4(this.node.up.x, this.node.up.y, this.node.up.z, -Vec3.dot(this.node.up, this.node.worldPosition));
                viewSpaceProbe.transformMat4(this.camera.matView.clone().invert().transpose());
                this.camera.calculateObliqueMat(viewSpaceProbe);
              };
              _proto._reflect = function _reflect(out, point, normal, offset) {
                var n = Vec3.clone(normal);
                n.normalize();
                var dist = Vec3.dot(n, point) - offset;
                n.multiplyScalar(2.0 * dist);
                Vec3.subtract(out, point, n);
                return out;
              };
              _createClass(ReflectionProbe, [{
                key: "probeType",
                get: function get() {
                  return this._probeType;
                },
                set: function set(value) {
                  this._probeType = value;
                }
              }, {
                key: "resolution",
                get: function get() {
                  return this._resolution;
                },
                set: function set(value) {
                  if (value !== this._resolution) {
                    this.bakedCubeTextures.forEach(function (rt, idx) {
                      rt.resize(value, value);
                    });
                  }
                  this._resolution = value;
                }
              }, {
                key: "clearFlag",
                get: function get() {
                  return this._clearFlag;
                },
                set: function set(value) {
                  this._clearFlag = value;
                  this.camera.clearFlag = this._clearFlag;
                }
              }, {
                key: "backgroundColor",
                get: function get() {
                  return this._backgroundColor;
                },
                set: function set(val) {
                  this._backgroundColor = val;
                  this.camera.clearColor = this._backgroundColor;
                }
              }, {
                key: "visibility",
                get: function get() {
                  return this._visibility;
                },
                set: function set(val) {
                  this._visibility = val;
                  this._camera.visibility = this._visibility;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(value) {
                  this._size.set(value);
                  this.node.getWorldPosition(tempVec3);
                  AABB.set(this._boundingBox, tempVec3.x, tempVec3.y, tempVec3.z, value.x, value.y, value.z);
                }
              }, {
                key: "cubemap",
                get: function get() {
                  return this._cubemap;
                },
                set: function set(val) {
                  this._cubemap = val;
                }
              }, {
                key: "node",
                get: function get() {
                  return this._node;
                }
              }, {
                key: "camera",
                get: function get() {
                  return this._camera;
                }
              }, {
                key: "needRefresh",
                get: function get() {
                  return this._needRefresh;
                },
                set: function set(value) {
                  this._needRefresh = value;
                }
              }, {
                key: "needRender",
                get: function get() {
                  return this._needRender;
                },
                set: function set(value) {
                  this._needRender = value;
                }
              }, {
                key: "boundingBox",
                get: function get() {
                  return this._boundingBox;
                }
              }, {
                key: "cameraNode",
                get: function get() {
                  return this._cameraNode;
                },
                set: function set(node) {
                  this._cameraNode = node;
                }
              }, {
                key: "previewSphere",
                get: function get() {
                  return this._previewSphere;
                },
                set: function set(val) {
                  this._previewSphere = val;
                }
              }, {
                key: "previewPlane",
                get: function get() {
                  return this._previewPlane;
                },
                set: function set(val) {
                  this._previewPlane = val;
                }
              }]);
              return ReflectionProbe;
            }();

            var LODData = function () {
              function LODData() {
                this.screenUsagePercentage = 1.0;
                this._models = [];
              }
              var _proto = LODData.prototype;
              _proto.addModel = function addModel(model) {
                this._models.splice(0, 0, model);
              };
              _proto.eraseModel = function eraseModel(model) {
                var removeIndex = this._models.indexOf(model);
                if (removeIndex >= 0) {
                  this._models.splice(removeIndex, 1);
                }
              };
              _proto.clearModels = function clearModels() {
                this._models.length = 0;
              };
              _createClass(LODData, [{
                key: "models",
                get: function get() {
                  return this._models;
                }
              }]);
              return LODData;
            }();
            var LODGroup$1 = function () {
              function LODGroup() {
                this.scene = undefined;
                this.node = null;
                this.enabled = true;
                this._localBoundaryCenter = v3(0, 0, 0);
                this._objectSize = 1;
                this._lodDataArray = [];
                this._lockedLODLevelVec = [];
                this._isLockLevelChanged = false;
                this._device = deviceManager.gfxDevice;
              }
              var _proto2 = LODGroup.prototype;
              _proto2.attachToScene = function attachToScene(scene) {
                this.scene = scene;
              };
              _proto2.detachFromScene = function detachFromScene() {
                this.scene = null;
              };
              _proto2.lockLODLevels = function lockLODLevels(lockLev) {
                if (lockLev.length !== this._lockedLODLevelVec.length) {
                  this._isLockLevelChanged = true;
                } else {
                  var size = lockLev.length;
                  var index = 0;
                  for (; index < size; index++) {
                    if (lockLev[index] !== this._lockedLODLevelVec[index]) {
                      this._isLockLevelChanged = true;
                      break;
                    }
                  }
                }
                this._lockedLODLevelVec = lockLev.slice();
              };
              _proto2.isLockLevelChanged = function isLockLevelChanged() {
                return this._isLockLevelChanged;
              };
              _proto2.resetLockChangeFlag = function resetLockChangeFlag() {
                this._isLockLevelChanged = false;
              };
              _proto2.getLockedLODLevels = function getLockedLODLevels() {
                return this._lockedLODLevelVec;
              };
              _proto2.clearLODs = function clearLODs() {
                this._lodDataArray.length = 0;
              };
              _proto2.insertLOD = function insertLOD(index, lod) {
                this._lodDataArray.splice(index, 0, lod);
              };
              _proto2.updateLOD = function updateLOD(index, lod) {
                this._lodDataArray[index] = lod;
              };
              _proto2.eraseLOD = function eraseLOD(index) {
                this._lodDataArray.splice(index, 1);
              };
              _proto2.getVisibleLODLevel = function getVisibleLODLevel(camera) {
                var screenUsagePercentage = this.getScreenUsagePercentage(camera);
                var lodIndex = -1;
                for (var i = 0; i < this.lodCount; ++i) {
                  var lod = this.lodDataArray[i];
                  if (screenUsagePercentage >= lod.screenUsagePercentage) {
                    lodIndex = i;
                    break;
                  }
                }
                return lodIndex;
              };
              _proto2.getScreenUsagePercentage = function getScreenUsagePercentage(camera) {
                if (!this.node) return 0;
                var distance;
                if (camera.projectionType === 1) {
                  distance = Vec3.len(this.localBoundaryCenter.transformMat4(this.node.worldMatrix).subtract(camera.node.worldPosition));
                }
                return this.distanceToScreenUsagePercentage(camera, distance, this.getWorldSpaceSize());
              };
              _proto2.distanceToScreenUsagePercentage = function distanceToScreenUsagePercentage(camera, distance, size) {
                if (camera.projectionType === 1) {
                  assertIsTrue(typeof distance === 'number', 'distance must be present for perspective projection');
                  return size * camera.matProj.m05 / (distance * 2.0);
                } else {
                  return size * camera.matProj.m05 * 0.5;
                }
              };
              _proto2.getWorldSpaceSize = function getWorldSpaceSize() {
                var scale = this.node.scale;
                var maxScale = Math.max(Math.abs(scale.x), Math.abs(scale.y), Math.abs(scale.z));
                return maxScale * this.objectSize;
              };
              _createClass(LODGroup, [{
                key: "localBoundaryCenter",
                get: function get() {
                  return this._localBoundaryCenter.clone();
                },
                set: function set(val) {
                  this._localBoundaryCenter.set(val);
                }
              }, {
                key: "lodCount",
                get: function get() {
                  return this._lodDataArray.length;
                }
              }, {
                key: "objectSize",
                get: function get() {
                  return this._objectSize;
                },
                set: function set(val) {
                  this._objectSize = val;
                }
              }, {
                key: "lodDataArray",
                get: function get() {
                  return this._lodDataArray;
                }
              }]);
              return LODGroup;
            }();

            var index = /*#__PURE__*/Object.freeze({
                __proto__: null,
                Ambient: Ambient,
                CSMLevel: CSMLevel,
                CSMOptimizationMode: CSMOptimizationMode,
                Camera: Camera$1,
                CameraAperture: CameraAperture,
                CameraFOVAxis: CameraFOVAxis,
                CameraISO: CameraISO,
                CameraProjection: CameraProjection,
                CameraShutter: CameraShutter,
                CameraType: CameraType,
                CameraUsage: CameraUsage,
                ColorTemperatureToRGB: ColorTemperatureToRGB,
                DirectionalLight: DirectionalLight$1,
                EnvironmentLightingType: EnvironmentLightingType,
                FOG_TYPE_NONE: FOG_TYPE_NONE,
                Fog: Fog,
                FogType: FogType,
                LODData: LODData,
                LODGroup: LODGroup$1,
                Light: Light$1,
                LightType: LightType,
                Model: Model,
                ModelType: ModelType,
                Octree: Octree,
                PCFType: PCFType,
                PointLight: PointLight$1,
                PostSettings: PostSettings,
                ProbeClearFlag: ProbeClearFlag,
                ProbeType: ProbeType,
                RangedDirectionalLight: RangedDirectionalLight$1,
                ReflectionProbe: ReflectionProbe$1,
                SKYBOX_FLAG: SKYBOX_FLAG,
                ShadowSize: ShadowSize,
                ShadowType: ShadowType,
                Shadows: Shadows,
                Skin: Skin,
                SkyBoxFlagValue: SkyBoxFlagValue,
                Skybox: Skybox,
                SphereLight: SphereLight$1,
                SpotLight: SpotLight$1,
                SubModel: SubModel,
                ToneMappingType: ToneMappingType,
                TrackingType: TrackingType,
                nt2lm: nt2lm
            });

            var RenderScene = function () {
              RenderScene.registerCreateFunc = function registerCreateFunc(root) {
                root._createSceneFun = function (_root) {
                  return new RenderScene(_root);
                };
              };
              function RenderScene(root) {
                this._name = '';
                this._cameras = [];
                this._models = [];
                this._lodGroups = [];
                this._batches = [];
                this._directionalLights = [];
                this._sphereLights = [];
                this._spotLights = [];
                this._pointLights = [];
                this._rangedDirLights = [];
                this._mainLight = null;
                this._modelId = 0;
                this._lodStateCache = null;
                this._root = root;
              }
              var _proto = RenderScene.prototype;
              _proto.initialize = function initialize(info) {
                this._name = info.name;
                this._lodStateCache = new LodStateCache(this);
                return true;
              };
              _proto.update = function update(stamp) {
                var mainLight = this._mainLight;
                if (mainLight) {
                  mainLight.update();
                }
                var sphereLights = this._sphereLights;
                for (var i = 0; i < sphereLights.length; i++) {
                  var light = sphereLights[i];
                  light.update();
                }
                var spotLights = this._spotLights;
                for (var _i = 0; _i < spotLights.length; _i++) {
                  var _light = spotLights[_i];
                  _light.update();
                }
                var pointLights = this._pointLights;
                for (var _i2 = 0; _i2 < pointLights.length; _i2++) {
                  var _light2 = pointLights[_i2];
                  _light2.update();
                }
                var rangedDirLights = this._rangedDirLights;
                for (var _i3 = 0; _i3 < rangedDirLights.length; _i3++) {
                  var _light3 = rangedDirLights[_i3];
                  _light3.update();
                }
                var models = this._models;
                for (var _i4 = 0; _i4 < models.length; _i4++) {
                  var model = models[_i4];
                  if (model.enabled) {
                    model.updateTransform(stamp);
                    model.updateUBOs(stamp);
                  }
                }
                this._lodStateCache.updateLodState();
              };
              _proto.destroy = function destroy() {
                this.removeCameras();
                this.removeSphereLights();
                this.removeSpotLights();
                this.removeRangedDirLights();
                this.removeModels();
                this.removeLODGroups();
                this._lodStateCache.clearCache();
              };
              _proto.isCulledByLod = function isCulledByLod(camera, model) {
                return this._lodStateCache.isLodModelCulled(camera, model);
              };
              _proto.addCamera = function addCamera(cam) {
                cam.attachToScene(this);
                this._cameras.push(cam);
                this._lodStateCache.addCamera(cam);
              };
              _proto.removeCamera = function removeCamera(camera) {
                for (var i = 0; i < this._cameras.length; ++i) {
                  if (this._cameras[i] === camera) {
                    this._cameras.splice(i, 1);
                    camera.detachFromScene();
                    this._lodStateCache.removeCamera(camera);
                    return;
                  }
                }
              };
              _proto.removeCameras = function removeCameras() {
                var _this = this;
                this._cameras.forEach(function (camera) {
                  camera.detachFromScene();
                  _this._lodStateCache.removeCamera(camera);
                });
                this._cameras.length = 0;
              };
              _proto.setMainLight = function setMainLight(dl) {
                this._mainLight = dl;
                if (this._mainLight) this._mainLight.activate();
              };
              _proto.unsetMainLight = function unsetMainLight(dl) {
                if (this._mainLight === dl) {
                  var dlList = this._directionalLights;
                  if (dlList.length) {
                    this.setMainLight(dlList[dlList.length - 1]);
                    if (this._mainLight.node) {
                      this._mainLight.node.hasChangedFlags |= 2;
                    }
                    return;
                  }
                  this.setMainLight(null);
                }
              };
              _proto.addDirectionalLight = function addDirectionalLight(dl) {
                dl.attachToScene(this);
                this._directionalLights.push(dl);
              };
              _proto.removeDirectionalLight = function removeDirectionalLight(dl) {
                for (var i = 0; i < this._directionalLights.length; ++i) {
                  if (this._directionalLights[i] === dl) {
                    dl.detachFromScene();
                    this._directionalLights.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.addSphereLight = function addSphereLight(pl) {
                pl.attachToScene(this);
                this._sphereLights.push(pl);
              };
              _proto.removeSphereLight = function removeSphereLight(pl) {
                for (var i = 0; i < this._sphereLights.length; ++i) {
                  if (this._sphereLights[i] === pl) {
                    pl.detachFromScene();
                    this._sphereLights.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.addSpotLight = function addSpotLight(sl) {
                sl.attachToScene(this);
                this._spotLights.push(sl);
              };
              _proto.removeSpotLight = function removeSpotLight(sl) {
                for (var i = 0; i < this._spotLights.length; ++i) {
                  if (this._spotLights[i] === sl) {
                    sl.detachFromScene();
                    this._spotLights.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.removeSphereLights = function removeSphereLights() {
                for (var i = 0; i < this._sphereLights.length; ++i) {
                  this._sphereLights[i].detachFromScene();
                }
                this._sphereLights.length = 0;
              };
              _proto.removeSpotLights = function removeSpotLights() {
                for (var i = 0; i < this._spotLights.length; ++i) {
                  this._spotLights[i].detachFromScene();
                }
                this._spotLights.length = 0;
              };
              _proto.addPointLight = function addPointLight(pl) {
                pl.attachToScene(this);
                this._pointLights.push(pl);
              };
              _proto.removePointLight = function removePointLight(pl) {
                for (var i = 0; i < this._pointLights.length; ++i) {
                  if (this._pointLights[i] === pl) {
                    pl.detachFromScene();
                    this._pointLights.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.removePointLights = function removePointLights() {
                for (var i = 0; i < this._pointLights.length; ++i) {
                  this._pointLights[i].detachFromScene();
                }
                this._pointLights.length = 0;
              };
              _proto.addRangedDirLight = function addRangedDirLight(l) {
                l.attachToScene(this);
                this._rangedDirLights.push(l);
              };
              _proto.removeRangedDirLight = function removeRangedDirLight(l) {
                for (var i = 0; i < this._rangedDirLights.length; ++i) {
                  if (this._rangedDirLights[i] === l) {
                    l.detachFromScene();
                    this._rangedDirLights.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.removeRangedDirLights = function removeRangedDirLights() {
                for (var i = 0; i < this._rangedDirLights.length; ++i) {
                  this._rangedDirLights[i].detachFromScene();
                }
                this._rangedDirLights.length = 0;
              };
              _proto.addModel = function addModel(m) {
                m.attachToScene(this);
                this._models.push(m);
              };
              _proto.removeModel = function removeModel(model) {
                for (var i = 0; i < this._models.length; ++i) {
                  if (this._models[i] === model) {
                    this._lodStateCache.removeModel(model);
                    model.detachFromScene();
                    this._models.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.removeModels = function removeModels() {
                var _this2 = this;
                this._models.forEach(function (m) {
                  _this2._lodStateCache.removeModel(m);
                  m.detachFromScene();
                  m.destroy();
                });
                this._models.length = 0;
              };
              _proto.addBatch = function addBatch(batch) {
                this._batches.push(batch);
              };
              _proto.removeBatch = function removeBatch(batch) {
                for (var i = 0; i < this._batches.length; ++i) {
                  if (this._batches[i] === batch) {
                    this._batches.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.removeBatches = function removeBatches() {
                this._batches.length = 0;
              };
              _proto.addLODGroup = function addLODGroup(lodGroup) {
                this._lodGroups.push(lodGroup);
                lodGroup.attachToScene(this);
                this._lodStateCache.addLodGroup(lodGroup);
              };
              _proto.removeLODGroup = function removeLODGroup(lodGroup) {
                var index = this._lodGroups.indexOf(lodGroup);
                if (index >= 0) {
                  this._lodGroups.splice(index, 1);
                  lodGroup.detachFromScene();
                  this._lodStateCache.removeLodGroup(lodGroup);
                }
              };
              _proto.removeLODGroups = function removeLODGroups() {
                var _this3 = this;
                this._lodGroups.forEach(function (group) {
                  _this3._lodStateCache.removeLodGroup(group);
                });
                this._lodGroups.length = 0;
              };
              _proto.onGlobalPipelineStateChanged = function onGlobalPipelineStateChanged() {
                this._models.forEach(function (m) {
                  m.onGlobalPipelineStateChanged();
                });
              };
              _proto.generateModelId = function generateModelId() {
                return this._modelId++;
              };
              _createClass(RenderScene, [{
                key: "root",
                get: function get() {
                  return this._root;
                }
              }, {
                key: "name",
                get: function get() {
                  return this._name;
                }
              }, {
                key: "cameras",
                get: function get() {
                  return this._cameras;
                }
              }, {
                key: "mainLight",
                get: function get() {
                  return this._mainLight;
                }
              }, {
                key: "sphereLights",
                get: function get() {
                  return this._sphereLights;
                }
              }, {
                key: "spotLights",
                get: function get() {
                  return this._spotLights;
                }
              }, {
                key: "pointLights",
                get: function get() {
                  return this._pointLights;
                }
              }, {
                key: "rangedDirLights",
                get: function get() {
                  return this._rangedDirLights;
                }
              }, {
                key: "models",
                get: function get() {
                  return this._models;
                }
              }, {
                key: "batches",
                get: function get() {
                  return this._batches;
                }
              }, {
                key: "lodGroups",
                get: function get() {
                  return this._lodGroups;
                }
              }]);
              return RenderScene;
            }();
            var LODInfo = function LODInfo() {
              this.usedLevel = -1;
              this.lastUsedLevel = -1;
              this.transformDirty = true;
            };
            var LodStateCache = function () {
              function LodStateCache(scene) {
                this._renderScene = null;
                this._modelsInLODGroup = new Map();
                this._lodStateInCamera = new Map();
                this._newAddedLodGroupVec = [];
                this._levelModels = new Map();
                this._renderScene = scene;
              }
              var _proto2 = LodStateCache.prototype;
              _proto2.addCamera = function addCamera(camera) {
                var lodGroups = this._renderScene.lodGroups;
                for (var i = 0; i < lodGroups.length; i++) {
                  var lodGroup = lodGroups[i];
                  var layer = lodGroup.node.layer;
                  if ((camera.visibility & layer) === layer) {
                    if (!this._lodStateInCamera.has(camera)) {
                      this._lodStateInCamera.set(camera, new Map());
                    }
                    break;
                  }
                }
              };
              _proto2.removeCamera = function removeCamera(camera) {
                if (this._lodStateInCamera.has(camera)) {
                  this._lodStateInCamera["delete"](camera);
                }
              };
              _proto2.addLodGroup = function addLodGroup(lodGroup) {
                this._newAddedLodGroupVec.push(lodGroup);
                var cameras = this._renderScene.cameras;
                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (this._lodStateInCamera.has(camera)) {
                    continue;
                  }
                  var layer = lodGroup.node.layer;
                  if ((camera.visibility & layer) === layer) {
                    this._lodStateInCamera.set(camera, new Map());
                  }
                }
              };
              _proto2.removeLodGroup = function removeLodGroup(lodGroup) {
                var _this4 = this;
                for (var index = 0; index < lodGroup.lodCount; index++) {
                  var lod = lodGroup.lodDataArray[index];
                  lod.models.forEach(function (model) {
                    _this4._modelsInLODGroup["delete"](model);
                  });
                }
                for (var _iterator = _createForOfIteratorHelperLoose(this._lodStateInCamera), _step; !(_step = _iterator()).done;) {
                  var visibleCamera = _step.value;
                  visibleCamera[1]["delete"](lodGroup);
                }
                this._levelModels["delete"](lodGroup);
              };
              _proto2.removeModel = function removeModel(model) {
                if (this._modelsInLODGroup.has(model)) {
                  this._modelsInLODGroup["delete"](model);
                }
              };
              _proto2.updateLodState = function updateLodState() {
                var _this5 = this;
                this._newAddedLodGroupVec.forEach(function (addedLodGroup) {
                  var levelModels = _this5._levelModels.get(addedLodGroup);
                  if (!levelModels) {
                    levelModels = new Map();
                    _this5._levelModels.set(addedLodGroup, levelModels);
                  }
                  for (var i = 0; i < addedLodGroup.lodCount; i++) {
                    var lodModels = levelModels.get(i);
                    if (!lodModels) {
                      lodModels = [];
                    }
                    var models = addedLodGroup.lodDataArray[i].models;
                    for (var j = 0; j < models.length; j++) {
                      var model = models[j];
                      var modelInfo = _this5._modelsInLODGroup.get(model);
                      if (!modelInfo) {
                        modelInfo = new Map();
                      }
                      _this5._modelsInLODGroup.set(model, modelInfo);
                      lodModels.push(model);
                    }
                    levelModels.set(i, lodModels);
                  }
                });
                this._newAddedLodGroupVec.length = 0;
                var lodGroups = this._renderScene.lodGroups;
                var _loop = function _loop() {
                    var lodGroup = lodGroups[i];
                    if (lodGroup.enabled) {
                      var lodLevels = lodGroup.getLockedLODLevels();
                      var count = lodLevels.length;
                      if (count > 0) {
                        if (lodGroup.node.hasChangedFlags > 0) {
                          for (var _iterator2 = _createForOfIteratorHelperLoose(_this5._lodStateInCamera), _step2; !(_step2 = _iterator2()).done;) {
                            var visibleCamera = _step2.value;
                            var lodInfo = visibleCamera[1].get(lodGroup);
                            if (!lodInfo) {
                              lodInfo = new LODInfo();
                              visibleCamera[1].set(lodGroup, lodInfo);
                            }
                            lodInfo.transformDirty = true;
                          }
                        }
                        if (lodGroup.isLockLevelChanged()) {
                          lodGroup.resetLockChangeFlag();
                          var _lodModels = _this5._levelModels.get(lodGroup);
                          if (_lodModels) {
                            _lodModels.forEach(function (vecArray, index) {
                              vecArray.forEach(function (model) {
                                var modelInfo = _this5._modelsInLODGroup.get(model);
                                if (modelInfo) {
                                  modelInfo.clear();
                                }
                              });
                            });
                            lodLevels.forEach(function (visibleIndex) {
                              var vecModels = _lodModels.get(visibleIndex);
                              if (vecModels) {
                                vecModels.forEach(function (model) {
                                  var modelInfo = _this5._modelsInLODGroup.get(model);
                                  if (modelInfo && model.node && model.node.active) {
                                    for (var _iterator3 = _createForOfIteratorHelperLoose(_this5._lodStateInCamera), _step3; !(_step3 = _iterator3()).done;) {
                                      var _visibleCamera = _step3.value;
                                      modelInfo.set(_visibleCamera[0], true);
                                    }
                                  }
                                });
                              }
                            });
                          }
                        }
                        return 0;
                      }
                      var hasUpdated = false;
                      for (var _iterator4 = _createForOfIteratorHelperLoose(_this5._lodStateInCamera), _step4; !(_step4 = _iterator4()).done;) {
                        var _visibleCamera2 = _step4.value;
                        var _lodInfo = _visibleCamera2[1].get(lodGroup);
                        if (!_lodInfo) {
                          _lodInfo = new LODInfo();
                          _visibleCamera2[1].set(lodGroup, _lodInfo);
                        }
                        var cameraChangeFlags = _visibleCamera2[0].node.hasChangedFlags;
                        var lodChangeFlags = lodGroup.node.hasChangedFlags;
                        if (cameraChangeFlags > 0 || lodChangeFlags > 0 || _lodInfo.transformDirty) {
                          if (_lodInfo.transformDirty) {
                            _lodInfo.transformDirty = false;
                          }
                          var index = lodGroup.getVisibleLODLevel(_visibleCamera2[0]);
                          if (index !== _lodInfo.usedLevel) {
                            _lodInfo.lastUsedLevel = _lodInfo.usedLevel;
                            _lodInfo.usedLevel = index;
                            hasUpdated = true;
                          }
                        }
                      }
                      var lodModels = _this5._levelModels.get(lodGroup);
                      if (!lodModels) {
                        return 0;
                      }
                      if (lodGroup.isLockLevelChanged()) {
                        lodGroup.resetLockChangeFlag();
                        lodModels.forEach(function (vecArray, index) {
                          vecArray.forEach(function (model) {
                            var modelInfo = _this5._modelsInLODGroup.get(model);
                            if (modelInfo) {
                              modelInfo.clear();
                            }
                          });
                        });
                        hasUpdated = true;
                      } else if (hasUpdated) {
                        _this5._lodStateInCamera.forEach(function (lodState, camera) {
                          var lodInfo = lodState.get(lodGroup);
                          if (lodInfo && lodInfo.usedLevel !== lodInfo.lastUsedLevel) {
                            var vecModels = lodModels.get(lodInfo.lastUsedLevel);
                            if (vecModels) {
                              vecModels.forEach(function (model) {
                                var modelInfo = _this5._modelsInLODGroup.get(model);
                                if (modelInfo) {
                                  modelInfo.clear();
                                }
                              });
                            }
                          }
                        });
                      }
                      if (hasUpdated) {
                        _this5._lodStateInCamera.forEach(function (lodState, camera) {
                          var lodInfo = lodState.get(lodGroup);
                          if (lodInfo) {
                            var usedLevel = lodInfo.usedLevel;
                            var vecModels = lodModels.get(usedLevel);
                            if (vecModels) {
                              vecModels.forEach(function (model) {
                                var modelInfo = _this5._modelsInLODGroup.get(model);
                                if (modelInfo && model.node && model.node.active) {
                                  modelInfo.set(camera, true);
                                }
                              });
                            }
                          }
                        });
                      }
                    }
                  },
                  _ret;
                for (var i = 0; i < lodGroups.length; i++) {
                  _ret = _loop();
                  if (_ret === 0) continue;
                }
              };
              _proto2.isLodModelCulled = function isLodModelCulled(camera, model) {
                var modelInfo = this._modelsInLODGroup.get(model);
                if (!modelInfo) {
                  return false;
                }
                return !modelInfo.has(camera);
              };
              _proto2.clearCache = function clearCache() {
                this._levelModels.clear();
                this._modelsInLODGroup.clear();
                this._lodStateInCamera.clear();
                this._newAddedLodGroupVec.length = 0;
              };
              _proto2.isLodGroupVisibleByCamera = function isLodGroupVisibleByCamera(lodGroup, camera) {
                var layer = lodGroup.node.layer;
                return (camera.visibility & layer) === layer;
              };
              return LodStateCache;
            }();

            var _orientationMap$1;
            var orientationMap$1 = (_orientationMap$1 = {}, _orientationMap$1[Orientation.PORTRAIT] = 0, _orientationMap$1[Orientation.LANDSCAPE_RIGHT] = 1, _orientationMap$1[Orientation.PORTRAIT_UPSIDE_DOWN] = 2, _orientationMap$1[Orientation.LANDSCAPE_LEFT] = 3, _orientationMap$1);
            var _windowCount = 0;
            var RenderWindow = function () {
              var _proto = RenderWindow.prototype;
              _proto.isRenderWindowResized = function isRenderWindowResized() {
                return this._isResized;
              };
              _proto.setRenderWindowResizeHandled = function setRenderWindowResizeHandled() {
                this._isResized = false;
              };
              RenderWindow.registerCreateFunc = function registerCreateFunc(root) {
                root._createWindowFun = function (_root) {
                  return new RenderWindow();
                };
              };
              function RenderWindow(root) {
                this._title = '';
                this._width = 1;
                this._height = 1;
                this._swapchain = null;
                this._renderPass = null;
                this._colorTextures = [];
                this._depthStencilTexture = null;
                this._cameras = [];
                this._hasOnScreenAttachments = false;
                this._hasOffScreenAttachments = false;
                this._framebuffer = null;
                this._device = null;
                this._renderWindowId = _windowCount++;
                this._isResized = true;
                this._colorName = "Color" + this._renderWindowId;
                this._depthStencilName = "DepthStencil" + this._renderWindowId;
              }
              _proto.initialize = function initialize(device, info) {
                if (info.title !== undefined) {
                  this._title = info.title;
                }
                if (info.swapchain !== undefined) {
                  this._swapchain = info.swapchain;
                }
                this._width = info.width;
                this._height = info.height;
                this._device = device;
                this._renderPass = device.createRenderPass(info.renderPassInfo);
                if (info.swapchain) {
                  this._swapchain = info.swapchain;
                  this._colorTextures.push(info.swapchain.colorTexture);
                  this._depthStencilTexture = info.swapchain.depthStencilTexture;
                } else {
                  for (var i = 0; i < info.renderPassInfo.colorAttachments.length; i++) {
                    var textureInfo = new TextureInfo(1, 16 | 4 | 1, info.renderPassInfo.colorAttachments[i].format, this._width, this._height);
                    if (info.externalFlag && (info.externalFlag & 8 || info.externalFlag & 4)) {
                      textureInfo.flags |= info.externalFlag;
                      textureInfo.externalRes = info.externalResLow ? info.externalResLow : 0;
                    }
                    this._colorTextures.push(device.createTexture(textureInfo));
                  }
                  if (info.renderPassInfo.depthStencilAttachment && info.renderPassInfo.depthStencilAttachment.format !== 0) {
                    this._depthStencilTexture = device.createTexture(new TextureInfo(1, 32 | 4, info.renderPassInfo.depthStencilAttachment.format, this._width, this._height));
                    this._hasOffScreenAttachments = true;
                  }
                }
                this._framebuffer = device.createFramebuffer(new FramebufferInfo(this._renderPass, this._colorTextures, this._depthStencilTexture));
                return true;
              };
              _proto.destroy = function destroy() {
                this.clearCameras();
                if (this._framebuffer) {
                  this._framebuffer.destroy();
                  this._framebuffer = null;
                }
                if (this._depthStencilTexture) {
                  this._depthStencilTexture.destroy();
                  this._depthStencilTexture = null;
                }
                for (var i = 0; i < this._colorTextures.length; i++) {
                  var colorTexture = this._colorTextures[i];
                  if (colorTexture) {
                    colorTexture.destroy();
                  }
                }
                this._colorTextures.length = 0;
                this._device = null;
              };
              _proto.resize = function resize(width, height) {
                if (this._swapchain) {
                  this._swapchain.resize(width, height, orientationMap$1[screenAdapter.orientation]);
                  this._width = this._swapchain.width;
                  this._height = this._swapchain.height;
                } else {
                  for (var i = 0; i < this._colorTextures.length; i++) {
                    this._colorTextures[i].resize(width, height);
                  }
                  if (this._depthStencilTexture) {
                    this._depthStencilTexture.resize(width, height);
                  }
                  this._width = width;
                  this._height = height;
                }
                if (this.framebuffer) {
                  this.framebuffer.destroy();
                  this._framebuffer = this._device.createFramebuffer(new FramebufferInfo(this._renderPass, this._colorTextures, this._depthStencilTexture));
                }
                this._cameras.forEach(function (camera) {
                  camera.resize(width, height);
                });
                this._isResized = true;
              };
              _proto.extractRenderCameras = function extractRenderCameras(cameras) {
                for (var j = 0; j < this._cameras.length; j++) {
                  var camera = this._cameras[j];
                  if (camera.enabled) {
                    camera.update();
                    cameras.push(camera);
                  }
                }
              };
              _proto.attachCamera = function attachCamera(camera) {
                for (var i = 0; i < this._cameras.length; i++) {
                  if (this._cameras[i] === camera) {
                    return;
                  }
                }
                this._cameras.push(camera);
                this.sortCameras();
                this._isResized = true;
              };
              _proto.detachCamera = function detachCamera(camera) {
                for (var i = 0; i < this._cameras.length; ++i) {
                  if (this._cameras[i] === camera) {
                    this._cameras.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.clearCameras = function clearCameras() {
                this._cameras.length = 0;
              };
              _proto.sortCameras = function sortCameras() {
                this._cameras.sort(function (a, b) {
                  return a.priority - b.priority;
                });
              };
              _createClass(RenderWindow, [{
                key: "width",
                get: function get() {
                  return this._width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
              }, {
                key: "swapchain",
                get: function get() {
                  return this._swapchain;
                }
              }, {
                key: "framebuffer",
                get: function get() {
                  return this._framebuffer;
                }
              }, {
                key: "cameras",
                get: function get() {
                  return this._cameras;
                }
              }, {
                key: "renderWindowId",
                get: function get() {
                  return this._renderWindowId;
                }
              }, {
                key: "colorName",
                get: function get() {
                  return this._colorName;
                }
              }, {
                key: "depthStencilName",
                get: function get() {
                  return this._depthStencilName;
                }
              }]);
              return RenderWindow;
            }();

            var PipelineEventType = exports("PipelineEventType", {
              RENDER_FRAME_BEGIN: "render-frame-begin",
              RENDER_FRAME_END: "render-frame-end",
              RENDER_CAMERA_BEGIN: "render-camera-begin",
              RENDER_CAMERA_END: "render-camera-end",
              ATTACHMENT_SCALE_CAHNGED: "attachment-scale-changed"
            });
            var PipelineEventProcessor = exports("PipelineEventProcessor", function (_EventTarget) {
              _inheritsLoose(PipelineEventProcessor, _EventTarget);
              function PipelineEventProcessor() {
                var _this;
                _this = _EventTarget.call(this) || this;
                _this.eventTargetOn = _EventTarget.prototype.on;
                _this.eventTargetOnce = _EventTarget.prototype.once;
                return _this;
              }
              var _proto = PipelineEventProcessor.prototype;
              _proto.on = function on(type, callback, target, once) {
                return this.eventTargetOn(type, callback, target, once);
              };
              _proto.once = function once(type, callback, target) {
                return this.eventTargetOnce(type, callback, target);
              };
              return PipelineEventProcessor;
            }(EventTarget));

            var Root = exports("Root", function () {
              function Root(device) {
                var _this = this;
                this._createSceneFun = null;
                this._createWindowFun = null;
                this._windows = [];
                this._mainWindow = null;
                this._curWindow = null;
                this._tempWindow = null;
                this._usesCustomPipeline = true;
                this._pipeline = null;
                this._pipelineEvent = new PipelineEventProcessor();
                this._classicPipeline = null;
                this._customPipeline = null;
                this._batcher = null;
                this._scenes = [];
                this._modelPools = new Map();
                this._cameraPool = null;
                this._lightPools = new Map();
                this._debugView = new DebugView();
                this._fpsTime = 0;
                this._frameCount = 0;
                this._fps = 0;
                this._fixedFPS = 0;
                this._useDeferredPipeline = false;
                this._cumulativeTime = 0;
                this._frameTime = 0;
                this._cameraList = [];
                this._device = device;
                this._dataPoolMgr = cclegacy.internal.DataPoolManager && new cclegacy.internal.DataPoolManager(device);
                RenderScene.registerCreateFunc(this);
                RenderWindow.registerCreateFunc(this);
                this._cameraPool = new Pool(function () {
                  return new Camera$1(_this._device);
                }, 4, function (cam) {
                  return cam.destroy();
                });
              }
              var _proto = Root.prototype;
              _proto.initialize = function initialize(info) {
                var _this$_dataPoolMgr;
                var swapchain = deviceManager.swapchain;
                var colorAttachment = new ColorAttachment();
                colorAttachment.format = swapchain.colorTexture.format;
                var depthStencilAttachment = new DepthStencilAttachment();
                depthStencilAttachment.format = swapchain.depthStencilTexture.format;
                depthStencilAttachment.depthStoreOp = 1;
                depthStencilAttachment.stencilStoreOp = 1;
                var renderPassInfo = new RenderPassInfo([colorAttachment], depthStencilAttachment);
                this._mainWindow = this.createWindow({
                  title: 'rootMainWindow',
                  width: swapchain.width,
                  height: swapchain.height,
                  renderPassInfo: renderPassInfo,
                  swapchain: swapchain
                });
                this._curWindow = this._mainWindow;
                var customJointTextureLayouts = settings.querySettings("animation", 'customJointTextureLayouts') || [];
                (_this$_dataPoolMgr = this._dataPoolMgr) == null ? undefined : _this$_dataPoolMgr.jointTexturePool.registerCustomTextureLayouts(customJointTextureLayouts);
                this._resizeMaxJointForDS();
              };
              _proto.destroy = function destroy() {
                this.destroyScenes();
                if (this._pipeline) {
                  this._pipeline.destroy();
                  this._pipeline = null;
                  this._pipelineEvent = null;
                }
                if (this._batcher) {
                  this._batcher.destroy();
                  this._batcher = null;
                }
                this._curWindow = null;
                this._mainWindow = null;
                this.dataPoolManager.clear();
                if (cclegacy.rendering) {
                  cclegacy.rendering.destroy();
                }
              };
              _proto.resize = function resize(width, height, windowId) {
                this._windows.forEach(function (window) {
                  if (window.swapchain) {
                    window.resize(width, height);
                  }
                });
              };
              _proto.setRenderPipeline = function setRenderPipeline(useCustomPipeline) {
                var internal = cclegacy.internal,
                  director = cclegacy.director,
                  rendering = cclegacy.rendering,
                  legacy_rendering = cclegacy.legacy_rendering;
                if (rendering === undefined && legacy_rendering === undefined) {
                  errorID(1223);
                  return false;
                }
                var isCreateDefaultPipeline = false;
                if (useCustomPipeline) {
                  this._customPipeline = rendering.createCustomPipeline();
                  isCreateDefaultPipeline = true;
                  this._pipeline = this._customPipeline;
                  log("Using custom pipeline: " + macro.CUSTOM_PIPELINE_NAME);
                } else {
                  var rppl = legacy_rendering.createDefaultPipeline();
                  isCreateDefaultPipeline = true;
                  log("Using legacy pipeline");
                  this._classicPipeline = rppl;
                  this._pipeline = this._classicPipeline;
                  this._pipelineEvent = this._classicPipeline;
                  this._usesCustomPipeline = false;
                }
                var renderMode = settings.querySettings("rendering", 'renderMode');
                if (renderMode !== 3 || this._classicPipeline) {
                  if (!this._pipeline.activate(this._mainWindow.swapchain)) {
                    if (isCreateDefaultPipeline) {
                      this._pipeline.destroy();
                    }
                    this._classicPipeline = null;
                    this._customPipeline = null;
                    this._pipeline = null;
                    this._pipelineEvent = null;
                    return false;
                  }
                }
                var scene = director.getScene();
                if (scene) {
                  scene.globals.activate();
                }
                this.onGlobalPipelineStateChanged();
                if (!this._batcher && internal.Batcher2D) {
                  this._batcher = new internal.Batcher2D(this);
                  if (!this._batcher.initialize()) {
                    this.destroy();
                    return false;
                  }
                }
                return true;
              };
              _proto.onGlobalPipelineStateChanged = function onGlobalPipelineStateChanged() {
                for (var i = 0; i < this._scenes.length; i++) {
                  this._scenes[i].onGlobalPipelineStateChanged();
                }
                if (getPipelineSceneData().skybox.enabled) {
                  getPipelineSceneData().skybox.model.onGlobalPipelineStateChanged();
                }
                this._pipeline.onGlobalPipelineStateChanged();
              };
              _proto.activeWindow = function activeWindow(window) {
                this._curWindow = window;
              };
              _proto.resetCumulativeTime = function resetCumulativeTime() {
                this._cumulativeTime = 0;
              };
              _proto.frameMove = function frameMove(deltaTime) {
                this._frameTime = deltaTime;
                ++this._frameCount;
                this._cumulativeTime += deltaTime;
                this._fpsTime += deltaTime;
                if (this._fpsTime > 1.0) {
                  this._fps = this._frameCount;
                  this._frameCount = 0;
                  this._fpsTime = 0.0;
                }
                {
                  this._frameMoveBegin();
                  this._frameMoveProcess();
                  this._frameMoveEnd();
                }
              };
              _proto.createWindow = function createWindow(info) {
                var window = this._createWindowFun(this);
                window.initialize(this.device, info);
                this._windows.push(window);
                return window;
              };
              _proto.destroyWindow = function destroyWindow(window) {
                for (var i = 0; i < this._windows.length; ++i) {
                  if (this._windows[i] === window) {
                    window.destroy();
                    this._windows.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.destroyWindows = function destroyWindows() {
                this._windows.forEach(function (window) {
                  window.destroy();
                });
                this._windows.length = 0;
              };
              _proto.createScene = function createScene(info) {
                var scene = this._createSceneFun(this);
                scene.initialize(info);
                this._scenes.push(scene);
                return scene;
              };
              _proto.destroyScene = function destroyScene(scene) {
                for (var i = 0; i < this._scenes.length; ++i) {
                  if (this._scenes[i] === scene) {
                    scene.destroy();
                    this._scenes.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.destroyScenes = function destroyScenes() {
                this._scenes.forEach(function (scene) {
                  scene.destroy();
                });
                this._scenes.length = 0;
              };
              _proto.createModel = function createModel(ModelCtor) {
                var p = this._modelPools.get(ModelCtor);
                if (!p) {
                  this._modelPools.set(ModelCtor, new Pool(function () {
                    return new ModelCtor();
                  }, 10, function (obj) {
                    return obj.destroy();
                  }));
                  p = this._modelPools.get(ModelCtor);
                }
                var model = p.alloc();
                model.initialize();
                return model;
              };
              _proto.destroyModel = function destroyModel(m) {
                var p = this._modelPools.get(m.constructor);
                if (p) {
                  p.free(m);
                  if (m.scene) {
                    m.scene.removeModel(m);
                  }
                } else {
                  warnID(1300, m.constructor.name);
                }
                m.destroy();
              };
              _proto.createCamera = function createCamera() {
                return this._cameraPool.alloc();
              };
              _proto.createLight = function createLight(LightCtor) {
                var l = this._lightPools.get(LightCtor);
                if (!l) {
                  this._lightPools.set(LightCtor, new Pool(function () {
                    return new LightCtor();
                  }, 4, function (obj) {
                    return obj.destroy();
                  }));
                  l = this._lightPools.get(LightCtor);
                }
                var light = l.alloc();
                light.initialize();
                return light;
              };
              _proto.destroyLight = function destroyLight(l) {
                if (l.scene) {
                  switch (l.type) {
                    case 0:
                      l.scene.removeDirectionalLight(l);
                      break;
                    case 1:
                      l.scene.removeSphereLight(l);
                      break;
                    case 2:
                      l.scene.removeSpotLight(l);
                      break;
                    case 3:
                      l.scene.removePointLight(l);
                      break;
                    case 4:
                      l.scene.removeRangedDirLight(l);
                      break;
                  }
                }
                l.destroy();
              };
              _proto.recycleLight = function recycleLight(l) {
                var p = this._lightPools.get(l.constructor);
                if (p) {
                  p.free(l);
                  if (l.scene) {
                    switch (l.type) {
                      case 0:
                        l.scene.removeDirectionalLight(l);
                        break;
                      case 1:
                        l.scene.removeSphereLight(l);
                        break;
                      case 2:
                        l.scene.removeSpotLight(l);
                        break;
                      case 3:
                        l.scene.removePointLight(l);
                        break;
                      case 4:
                        l.scene.removeRangedDirLight(l);
                        break;
                    }
                  }
                }
              };
              _proto._doWebXRFrameMove = function _doWebXRFrameMove() {
                return;
              };
              _proto._frameMoveBegin = function _frameMoveBegin() {
                for (var i = 0; i < this._scenes.length; ++i) {
                  this._scenes[i].removeBatches();
                }
                this._cameraList.length = 0;
              };
              _proto._frameMoveProcess = function _frameMoveProcess() {
                var director = cclegacy.director;
                var windows = this._windows;
                var cameraList = this._cameraList;
                for (var i = 0; i < windows.length; i++) {
                  var window = windows[i];
                  window.extractRenderCameras(cameraList);
                }
                if (this._pipeline && cameraList.length > 0) {
                  this._device.acquire([deviceManager.swapchain]);
                  var scenes = this._scenes;
                  var stamp = director.getTotalFrames();
                  if (this._batcher) {
                    this._batcher.update();
                    this._batcher.uploadBuffers();
                  }
                  for (var _i2 = 0; _i2 < scenes.length; _i2++) {
                    scenes[_i2].update(stamp);
                  }
                }
              };
              _proto._frameMoveEnd = function _frameMoveEnd() {
                var director = cclegacy.director,
                  Director = cclegacy.Director;
                var cameraList = this._cameraList;
                if (this._pipeline && cameraList.length > 0) {
                  director.emit(Director.EVENT_BEFORE_COMMIT);
                  cameraList.sort(function (a, b) {
                    return a.priority - b.priority;
                  });
                  for (var i = 0; i < cameraList.length; ++i) {
                    var _cameraList$i$geometr;
                    (_cameraList$i$geometr = cameraList[i].geometryRenderer) == null ? undefined : _cameraList$i$geometr.update();
                  }
                  director.emit(Director.EVENT_BEFORE_RENDER);
                  this._pipeline.render(cameraList);
                  director.emit(Director.EVENT_AFTER_RENDER);
                  this._device.present();
                }
                if (this._batcher) this._batcher.reset();
              };
              _proto._resizeMaxJointForDS = function _resizeMaxJointForDS() {
                var usedUBOVectorCount = Math.max((20 + 148 + 64 + 56 + UBOWorldBound.COUNT) / 4, 100);
                var maxJoints = Math.floor((deviceManager.gfxDevice.capabilities.maxVertexUniformVectors - usedUBOVectorCount) / 3);
                maxJoints = maxJoints < 256 ? maxJoints : 256;
                localDescriptorSetLayout_ResizeMaxJoints(maxJoints);
              };
              _createClass(Root, [{
                key: "device",
                get: function get() {
                  return this._device;
                }
              }, {
                key: "mainWindow",
                get: function get() {
                  return this._mainWindow;
                }
              }, {
                key: "curWindow",
                get: function get() {
                  return this._curWindow;
                },
                set: function set(window) {
                  this._curWindow = window;
                }
              }, {
                key: "tempWindow",
                get: function get() {
                  return this._tempWindow;
                },
                set: function set(window) {
                  this._tempWindow = window;
                }
              }, {
                key: "windows",
                get: function get() {
                  return this._windows;
                }
              }, {
                key: "usesCustomPipeline",
                get: function get() {
                  return this._usesCustomPipeline;
                }
              }, {
                key: "pipeline",
                get: function get() {
                  return this._pipeline;
                }
              }, {
                key: "customPipeline",
                get: function get() {
                  return this._customPipeline;
                }
              }, {
                key: "pipelineEvent",
                get: function get() {
                  return this._pipelineEvent;
                }
              }, {
                key: "batcher2D",
                get: function get() {
                  return this._batcher;
                }
              }, {
                key: "scenes",
                get: function get() {
                  return this._scenes;
                }
              }, {
                key: "debugView",
                get: function get() {
                  return this._debugView;
                }
              }, {
                key: "cumulativeTime",
                get: function get() {
                  return this._cumulativeTime;
                }
              }, {
                key: "frameTime",
                get: function get() {
                  return this._frameTime;
                }
              }, {
                key: "frameCount",
                get: function get() {
                  return this._frameCount;
                }
              }, {
                key: "fps",
                get: function get() {
                  return this._fps;
                }
              }, {
                key: "fixedFPS",
                get: function get() {
                  return this._fixedFPS;
                },
                set: function set(fps) {
                  if (fps > 0) {
                    this._fixedFPS = fps;
                  }
                }
              }, {
                key: "dataPoolManager",
                get: function get() {
                  return this._dataPoolMgr;
                }
              }, {
                key: "useDeferredPipeline",
                get: function get() {
                  return this._useDeferredPipeline;
                }
              }, {
                key: "cameraList",
                get: function get() {
                  return this._cameraList;
                }
              }]);
              return Root;
            }());
            cclegacy.Root = Root;

            CCClass.Attr.setClassAttr(EventHandler, 'target', 'type', 'Object');
            CCClass.Attr.setClassAttr(EventHandler, 'target', 'ctor', Node$1);

            var _dec$s, _class$s;
            replaceProperty(Node$1.prototype, 'Node', [{
              name: 'childrenCount',
              newName: 'children.length',
              customGetter: function customGetter() {
                return this.children.length;
              }
            }]);
            replaceProperty(Node$1.prototype, 'Node', [{
              name: 'width',
              targetName: 'node.getComponent(UITransform)',
              customGetter: function customGetter() {
                return this._getUITransformComp().width;
              },
              customSetter: function customSetter(value) {
                this._getUITransformComp().width = value;
              }
            }, {
              name: 'height',
              targetName: 'node.getComponent(UITransform)',
              customGetter: function customGetter() {
                return this._getUITransformComp().height;
              },
              customSetter: function customSetter(value) {
                this._getUITransformComp().height = value;
              }
            }, {
              name: 'anchorX',
              targetName: 'node.getComponent(UITransform)',
              customGetter: function customGetter() {
                return this._getUITransformComp().anchorX;
              },
              customSetter: function customSetter(value) {
                this._getUITransformComp().anchorX = value;
              }
            }, {
              name: 'anchorY',
              targetName: 'node.getComponent(UITransform)',
              customGetter: function customGetter() {
                return this._getUITransformComp().anchorY;
              },
              customSetter: function customSetter(value) {
                this._getUITransformComp().anchorY = value;
              }
            }, {
              name: 'getAnchorPoint',
              targetName: 'node.getComponent(UITransform)',
              customFunction: function customFunction(out) {
                if (!out) {
                  out = new Vec2();
                }
                out.set(this._getUITransformComp().anchorPoint);
                return out;
              }
            }, {
              name: 'setAnchorPoint',
              targetName: 'node.getComponent(UITransform)',
              customFunction: function customFunction(point, y) {
                this._getUITransformComp().setAnchorPoint(point, y);
              }
            }, {
              name: 'getContentSize',
              targetName: 'node.getComponent(UITransform)',
              customFunction: function customFunction(out) {
                if (!out) {
                  out = new Size();
                }
                out.set(this._getUITransformComp().contentSize);
                return out;
              }
            }, {
              name: 'setContentSize',
              targetName: 'node.getComponent(UITransform)',
              customFunction: function customFunction(size, height) {
                if (typeof size === 'number') {
                  this._getUITransformComp().setContentSize(size, height);
                } else {
                  this._getUITransformComp().setContentSize(size);
                }
              }
            }]);
            removeProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
              name: 'aspect'
            }, {
              name: 'selfShadow'
            }, {
              name: 'linear'
            }, {
              name: 'packing'
            }, {
              name: 'autoAdapt'
            }, {
              name: 'fixedArea'
            }, {
              name: 'pcf'
            }, {
              name: 'bias'
            }, {
              name: 'normalBias'
            }, {
              name: 'near'
            }, {
              name: 'far'
            }, {
              name: 'shadowDistance'
            }, {
              name: 'invisibleOcclusionRange'
            }, {
              name: 'orthoSize'
            }, {
              name: 'saturation'
            }]);
            replaceProperty(SceneGlobals.prototype, 'SceneGlobals.prototype', [{
              name: 'distance',
              newName: 'planeHeight'
            }, {
              name: 'normal',
              newName: 'planeDirection'
            }, {
              name: 'size',
              newName: 'shadowMapSize'
            }]);
            removeProperty(Node$1.prototype, 'Node.prototype', [{
              name: 'addLayer'
            }, {
              name: 'removeLayer'
            }]);
            replaceProperty(NodeUIProperties.prototype, 'NodeUIProperties', [{
              name: 'opacityDirty',
              newName: 'colorDirty'
            }]);
            removeProperty(Layers, 'Layers', [{
              name: 'All'
            }, {
              name: 'RaycastMask'
            }, {
              name: 'check'
            }]);
            replaceProperty(Layers, 'Layers', [{
              name: 'Default',
              newName: 'DEFAULT',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Always',
              newName: 'ALWAYS',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'IgnoreRaycast',
              newName: 'IGNORE_RAYCAST',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Gizmos',
              newName: 'GIZMOS',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Editor',
              newName: 'EDITOR',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'UI',
              newName: 'UI_3D',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'UI2D',
              newName: 'UI_2D',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'SceneGizmo',
              newName: 'SCENE_GIZMO',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'makeInclusiveMask',
              newName: 'makeMaskInclude',
              target: Layers,
              targetName: 'Layers'
            }, {
              name: 'makeExclusiveMask',
              newName: 'makeMaskExclude',
              target: Layers,
              targetName: 'Layers'
            }]);
            removeProperty(Layers.Enum, 'Layers.Enum', [{
              name: 'ALWAYS'
            }]);
            removeProperty(Layers.BitMask, 'Layers.BitMask', [{
              name: 'ALWAYS'
            }]);
            var HideInHierarchy = 1024;
            var DontSave = 8;
            var PrivateNode = exports("PrivateNode", (_dec$s = ccclass$6('cc.PrivateNode'), _dec$s(_class$s = function (_Node) {
              _inheritsLoose(PrivateNode, _Node);
              function PrivateNode(name) {
                var _this;
                _this = _Node.call(this, name) || this;
                warnID(12003, _this.name);
                _this.hideFlags |= DontSave | HideInHierarchy;
                return _this;
              }
              return PrivateNode;
            }(Node$1)) || _class$s));
            replaceProperty(SystemEventType, 'SystemEventType', ['MOUSE_ENTER', 'MOUSE_LEAVE', 'TRANSFORM_CHANGED', 'SCENE_CHANGED_FOR_PERSISTS', 'SIZE_CHANGED', 'ANCHOR_CHANGED', 'COLOR_CHANGED', 'CHILD_ADDED', 'CHILD_REMOVED', 'PARENT_CHANGED', 'NODE_DESTROYED', 'LAYER_CHANGED', 'SIBLING_ORDER_CHANGED'].map(function (name) {
              return {
                name: name,
                target: Node$1.EventType,
                targetName: 'Node.EventType'
              };
            }));
            replaceProperty(Node$1.EventType, 'Node.EventType', [{
              name: 'DEVICEMOTION',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }, {
              name: 'KEY_DOWN',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }, {
              name: 'KEY_UP',
              target: SystemEvent.EventType,
              targetName: 'SystemEvent.EventType'
            }]);
            legacyCC.PrivateNode = PrivateNode;

            deprecateModuleExportedName({
              BaseNode: {
                newName: 'Node',
                since: '3.7.0',
                removed: false
              }
            });

            var fastRemoveAt = fastRemoveAt$2;
            var IsStartCalled = 65536;
            var IsOnEnableCalled$1 = 2048;
            function sortedIndex(array, comp) {
              var order = comp.constructor._executionOrder;
              var id = comp._id;
              var l = 0;
              for (var h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                var test = array[m];
                var testOrder = test.constructor._executionOrder;
                if (testOrder > order) {
                  h = m - 1;
                } else if (testOrder < order) {
                  l = m + 1;
                } else {
                  var testId = test._id;
                  if (testId > id) {
                    h = m - 1;
                  } else if (testId < id) {
                    l = m + 1;
                  } else {
                    return m;
                  }
                }
              }
              return ~l;
            }
            function stableRemoveInactive(iterator, flagToClear) {
              var array = iterator.array;
              var next = iterator.i + 1;
              while (next < array.length) {
                var comp = array[next];
                if (comp.node._activeInHierarchy) {
                  ++next;
                } else {
                  iterator.removeAt(next);
                  if (flagToClear) {
                    comp._objFlags &= ~flagToClear;
                  }
                }
              }
            }
            var LifeCycleInvoker = function () {
              function LifeCycleInvoker(invokeFunc) {
                var Iterator = MutableForwardIterator;
                this._zero = new Iterator([]);
                this._neg = new Iterator([]);
                this._pos = new Iterator([]);
                this._invoke = invokeFunc;
              }
              _createClass(LifeCycleInvoker, [{
                key: "zero",
                get: function get() {
                  return this._zero;
                }
              }, {
                key: "neg",
                get: function get() {
                  return this._neg;
                }
              }, {
                key: "pos",
                get: function get() {
                  return this._pos;
                }
              }]);
              return LifeCycleInvoker;
            }();
            LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;
            function compareOrder(a, b) {
              return a.constructor._executionOrder - b.constructor._executionOrder;
            }
            var OneOffInvoker = function (_LifeCycleInvoker) {
              _inheritsLoose(OneOffInvoker, _LifeCycleInvoker);
              function OneOffInvoker() {
                return _LifeCycleInvoker.apply(this, arguments) || this;
              }
              var _proto = OneOffInvoker.prototype;
              _proto.add = function add(comp) {
                var order = comp.constructor._executionOrder;
                (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
              };
              _proto.remove = function remove(comp) {
                var order = comp.constructor._executionOrder;
                (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
              };
              _proto.cancelInactive = function cancelInactive(flagToClear) {
                stableRemoveInactive(this._zero, flagToClear);
                stableRemoveInactive(this._neg, flagToClear);
                stableRemoveInactive(this._pos, flagToClear);
              };
              _proto.invoke = function invoke() {
                var compsNeg = this._neg;
                if (compsNeg.array.length > 0) {
                  compsNeg.array.sort(compareOrder);
                  this._invoke(compsNeg);
                  compsNeg.array.length = 0;
                }
                this._invoke(this._zero);
                this._zero.array.length = 0;
                var compsPos = this._pos;
                if (compsPos.array.length > 0) {
                  compsPos.array.sort(compareOrder);
                  this._invoke(compsPos);
                  compsPos.array.length = 0;
                }
              };
              return OneOffInvoker;
            }(LifeCycleInvoker);
            var ReusableInvoker = function (_LifeCycleInvoker2) {
              _inheritsLoose(ReusableInvoker, _LifeCycleInvoker2);
              function ReusableInvoker(invokeFunc) {
                return _LifeCycleInvoker2.call(this, invokeFunc) || this;
              }
              var _proto2 = ReusableInvoker.prototype;
              _proto2.add = function add(comp) {
                var order = comp.constructor._executionOrder;
                if (order === 0) {
                  this._zero.array.push(comp);
                } else {
                  var _array = order < 0 ? this._neg.array : this._pos.array;
                  var i = sortedIndex(_array, comp);
                  if (i < 0) {
                    _array.splice(~i, 0, comp);
                  }
                }
              };
              _proto2.remove = function remove(comp) {
                var order = comp.constructor._executionOrder;
                if (order === 0) {
                  this._zero.fastRemove(comp);
                } else {
                  var _iterator = order < 0 ? this._neg : this._pos;
                  var i = sortedIndex(_iterator.array, comp);
                  if (i >= 0) {
                    _iterator.removeAt(i);
                  }
                }
              };
              _proto2.invoke = function invoke(dt) {
                if (this._neg.array.length > 0) {
                  this._invoke(this._neg, dt);
                }
                this._invoke(this._zero, dt);
                if (this._pos.array.length > 0) {
                  this._invoke(this._pos, dt);
                }
              };
              return ReusableInvoker;
            }(LifeCycleInvoker);
            function createInvokeImplJit(code, useDt, ensureFlag) {
              var body = "" + ('var a=it.array;' + 'for(it.i=0;it.i<a.length;++it.i){' + 'var c=a[it.i];') + code + "}";
              var fastPath = useDt ? Function('it', 'dt', body) : Function('it', body);
              var singleInvoke = Function('c', 'dt', code);
              return createInvokeImpl(singleInvoke, fastPath, ensureFlag);
            }
            function createInvokeImpl(singleInvoke, fastPath, ensureFlag) {
              return function (iterator, dt) {
                try {
                  fastPath(iterator, dt);
                } catch (e) {
                  legacyCC._throw(e);
                  var _array2 = iterator.array;
                  if (ensureFlag) {
                    _array2[iterator.i]._objFlags |= ensureFlag;
                  }
                  ++iterator.i;
                  for (; iterator.i < _array2.length; ++iterator.i) {
                    try {
                      singleInvoke(_array2[iterator.i], dt);
                    } catch (e) {
                      legacyCC._throw(e);
                      if (ensureFlag) {
                        _array2[iterator.i]._objFlags |= ensureFlag;
                      }
                    }
                  }
                }
              };
            }
            var invokeStart = createInvokeImplJit("c.start();c._objFlags|=" + IsStartCalled, false, IsStartCalled) ;
            var invokeUpdate = createInvokeImplJit('c.update(dt)', true) ;
            var invokeLateUpdate = createInvokeImplJit('c.lateUpdate(dt)', true) ;
            var invokeOnEnable = function (iterator) {
              var compScheduler = legacyCC.director._compScheduler;
              var array = iterator.array;
              for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var comp = array[iterator.i];
                if (comp._enabled) {
                  comp.onEnable();
                  var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
                  if (!deactivatedDuringOnEnable) {
                    compScheduler._onEnabled(comp);
                  }
                }
              }
            };
            var ComponentScheduler = function () {
              function ComponentScheduler() {
                this._deferredComps = [];
                this.unscheduleAll();
              }
              var _proto3 = ComponentScheduler.prototype;
              _proto3.unscheduleAll = function unscheduleAll() {
                this.startInvoker = new OneOffInvoker(invokeStart);
                this.updateInvoker = new ReusableInvoker(invokeUpdate);
                this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate);
                this._updating = false;
              };
              _proto3._onEnabled = function _onEnabled(comp) {
                legacyCC.director.getScheduler().resumeTarget(comp);
                comp._objFlags |= IsOnEnableCalled$1;
                if (this._updating) {
                  this._deferredComps.push(comp);
                } else {
                  this._scheduleImmediate(comp);
                }
              };
              _proto3._onDisabled = function _onDisabled(comp) {
                legacyCC.director.getScheduler().pauseTarget(comp);
                comp._objFlags &= -2049;
                var index = this._deferredComps.indexOf(comp);
                if (index >= 0) {
                  fastRemoveAt(this._deferredComps, index);
                  return;
                }
                if (comp.internalStart && !(comp._objFlags & IsStartCalled)) {
                  this.startInvoker.remove(comp);
                }
                if (comp.internalUpdate) {
                  this.updateInvoker.remove(comp);
                }
                if (comp.internalLateUpdate) {
                  this.lateUpdateInvoker.remove(comp);
                }
              };
              _proto3.enableComp = function enableComp(comp, invoker) {
                if (!(comp._objFlags & IsOnEnableCalled$1)) {
                  if (comp.internalOnEnable) {
                    if (invoker) {
                      invoker.add(comp);
                      return;
                    } else {
                      comp.internalOnEnable();
                      var deactivatedDuringOnEnable = !comp.node.activeInHierarchy;
                      if (deactivatedDuringOnEnable) {
                        return;
                      }
                    }
                  }
                  this._onEnabled(comp);
                }
              };
              _proto3.disableComp = function disableComp(comp) {
                if (comp._objFlags & IsOnEnableCalled$1) {
                  if (comp.internalOnDisable) {
                    comp.internalOnDisable();
                  }
                  this._onDisabled(comp);
                }
              };
              _proto3.startPhase = function startPhase() {
                this._updating = true;
                this.startInvoker.invoke();
                this._startForNewComps();
              };
              _proto3.updatePhase = function updatePhase(dt) {
                this.updateInvoker.invoke(dt);
              };
              _proto3.lateUpdatePhase = function lateUpdatePhase(dt) {
                this.lateUpdateInvoker.invoke(dt);
                this._updating = false;
                this._startForNewComps();
              };
              _proto3._startForNewComps = function _startForNewComps() {
                if (this._deferredComps.length > 0) {
                  this._deferredSchedule();
                  this.startInvoker.invoke();
                }
              };
              _proto3._scheduleImmediate = function _scheduleImmediate(comp) {
                if (typeof comp.internalStart === 'function' && !(comp._objFlags & IsStartCalled)) {
                  this.startInvoker.add(comp);
                }
                if (typeof comp.internalUpdate === 'function') {
                  this.updateInvoker.add(comp);
                }
                if (typeof comp.internalLateUpdate === 'function') {
                  this.lateUpdateInvoker.add(comp);
                }
              };
              _proto3._deferredSchedule = function _deferredSchedule() {
                var comps = this._deferredComps;
                for (var i = 0, len = comps.length; i < len; i++) {
                  this._scheduleImmediate(comps[i]);
                }
                comps.length = 0;
              };
              return ComponentScheduler;
            }();

            var MAX_POOL_SIZE = 4;
            var IsPreloadStarted = 8192;
            var IsOnLoadStarted = 32768;
            var IsOnLoadCalled = 16384;
            var IsOnEnableCalled = 2048;
            var Deactivating = 256;
            var UnsortedInvoker = function (_LifeCycleInvoker) {
              _inheritsLoose(UnsortedInvoker, _LifeCycleInvoker);
              function UnsortedInvoker(invokeFunc) {
                return _LifeCycleInvoker.call(this, invokeFunc) || this;
              }
              var _proto = UnsortedInvoker.prototype;
              _proto.add = function add(comp) {
                this._zero.array.push(comp);
              };
              _proto.remove = function remove(comp) {
                this._zero.fastRemove(comp);
              };
              _proto.cancelInactive = function cancelInactive(flagToClear) {
                LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
              };
              _proto.invoke = function invoke() {
                this._invoke(this._zero);
                this._zero.array.length = 0;
              };
              return UnsortedInvoker;
            }(LifeCycleInvoker);
            var invokePreload = createInvokeImplJit('c.__preload();') ;
            var invokeOnLoad = createInvokeImplJit("c.onLoad();c._objFlags|=" + IsOnLoadCalled, false, IsOnLoadCalled) ;
            var activateTasksPool = new Pool$1(MAX_POOL_SIZE);
            activateTasksPool.get = function getActivateTask() {
              var task = this._get() || {
                preload: new UnsortedInvoker(invokePreload),
                onLoad: new OneOffInvoker(invokeOnLoad),
                onEnable: new OneOffInvoker(invokeOnEnable)
              };
              task.preload.zero.i = -1;
              var invoker = task.onLoad;
              invoker.zero.i = -1;
              invoker.neg.i = -1;
              invoker.pos.i = -1;
              invoker = task.onEnable;
              invoker.zero.i = -1;
              invoker.neg.i = -1;
              invoker.pos.i = -1;
              return task;
            };
            function _componentCorrupted(node, comp, index) {
              errorID(3817, node.name, index);
              log('Corrupted component value:', comp);
              if (comp) {
                node._removeComponent(comp);
              } else {
                removeAt(node.getWritableComponents(), index);
              }
            }
            var NodeActivator = exports("NodeActivator", function () {
              function NodeActivator() {
                this.reset();
              }
              var _proto2 = NodeActivator.prototype;
              _proto2.reset = function reset() {
                this._activatingStack = [];
              };
              _proto2.activateNode = function activateNode(node, active) {
                if (active) {
                  var task = activateTasksPool.get();
                  if (task) {
                    this._activatingStack.push(task);
                    this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);
                    task.preload.invoke();
                    task.onLoad.invoke();
                    task.onEnable.invoke();
                    this._activatingStack.pop();
                    activateTasksPool.put(task);
                  }
                } else {
                  this._deactivateNodeRecursively(node);
                  var stack = this._activatingStack;
                  for (var _iterator = _createForOfIteratorHelperLoose(stack), _step; !(_step = _iterator()).done;) {
                    var lastTask = _step.value;
                    lastTask.preload.cancelInactive(IsPreloadStarted);
                    lastTask.onLoad.cancelInactive(IsOnLoadStarted);
                    lastTask.onEnable.cancelInactive(IsOnEnableCalled);
                  }
                }
                node.emit("active-in-hierarchy-changed", node);
              };
              _proto2.activateComp = function activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (!isValid(comp, true)) {
                  return;
                }
                if (!(comp._objFlags & IsPreloadStarted)) {
                  comp._objFlags |= IsPreloadStarted;
                  if (comp.internalPreload) {
                    if (preloadInvoker) {
                      preloadInvoker.add(comp);
                    } else {
                      comp.internalPreload();
                    }
                  }
                }
                if (!(comp._objFlags & IsOnLoadStarted)) {
                  comp._objFlags |= IsOnLoadStarted;
                  if (comp.internalOnLoad) {
                    if (onLoadInvoker) {
                      onLoadInvoker.add(comp);
                    } else {
                      comp.internalOnLoad();
                      comp._objFlags |= IsOnLoadCalled;
                    }
                  } else {
                    comp._objFlags |= IsOnLoadCalled;
                  }
                }
                if (comp._enabled) {
                  {
                    assertIsTrue(comp.node, getError(3823, comp.uuid, comp.name));
                  }
                  var deactivatedOnLoading = !comp.node.activeInHierarchy;
                  if (deactivatedOnLoading) {
                    return;
                  }
                  legacyCC.director._compScheduler.enableComp(comp, onEnableInvoker);
                }
              };
              _proto2.destroyComp = function destroyComp(comp) {
                legacyCC.director._compScheduler.disableComp(comp);
                if (comp.internalOnDestroy && comp._objFlags & IsOnLoadCalled) {
                  comp.internalOnDestroy();
                }
              };
              _proto2._activateNodeRecursively = function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (node._objFlags & Deactivating) {
                  errorID(3816, node.name);
                  return;
                }
                node._setActiveInHierarchy(true);
                var originCount = node.components.length;
                for (var i = 0; i < originCount; ++i) {
                  var component = node.components[i];
                  if (component instanceof legacyCC.Component) {
                    this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker);
                  } else {
                    _componentCorrupted(node, component, i);
                    --i;
                    --originCount;
                  }
                }
                for (var _i = 0, len = node.children.length; _i < len; ++_i) {
                  var child = node.children[_i];
                  if (child.active) {
                    this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                  }
                }
                node._onPostActivated(true);
              };
              _proto2._deactivateNodeRecursively = function _deactivateNodeRecursively(node) {
                node._objFlags |= Deactivating;
                node._setActiveInHierarchy(false);
                var originCount = node.components.length;
                for (var c = 0; c < originCount; ++c) {
                  var component = node.components[c];
                  if (component._enabled) {
                    legacyCC.director._compScheduler.disableComp(component);
                    if (node.activeInHierarchy) {
                      node._objFlags &= -257;
                      return;
                    }
                  }
                }
                for (var i = 0, len = node.children.length; i < len; ++i) {
                  var child = node.children[i];
                  if (child.activeInHierarchy) {
                    this._deactivateNodeRecursively(child);
                    if (node.activeInHierarchy) {
                      node._objFlags &= -257;
                      return;
                    }
                  }
                }
                node._onPostActivated(false);
                node._objFlags &= -257;
              };
              return NodeActivator;
            }());

            var Destroyed$1 = 1;
            var PersistentMask$1 = -4192741;
            var DEFAULT = CCClass.Attr.DELIMETER + "default";
            var IDENTIFIER_RE = CCClass.IDENTIFIER_RE;
            var VAR = 'var ';
            var LOCAL_OBJ = 'o';
            var LOCAL_TEMP_OBJ = 't';
            var LOCAL_ARRAY = 'a';
            var LINE_INDEX_OF_NEW_OBJ = 0;
            var DEFAULT_MODULE_CACHE = {
              'cc.ClickEvent': false,
              'cc.PrefabInfo': false
            };
            var escapeForJS = CCClass.escapeForJS;
            var Declaration = function () {
              function Declaration(varName, expression) {
                this.varName = varName;
                this.expression = expression;
              }
              var _proto = Declaration.prototype;
              _proto.toString = function toString() {
                return VAR + this.varName + "=" + this.expression + ";";
              };
              return Declaration;
            }();
            function mergeDeclaration(statement, expression) {
              if (expression instanceof Declaration) {
                return new Declaration(expression.varName, statement + expression.expression);
              } else {
                return statement + expression;
              }
            }
            function writeAssignment(codeArray, statement, expression) {
              if (Array.isArray(expression)) {
                expression[0] = mergeDeclaration(statement, expression[0]);
                codeArray.push(expression);
              } else {
                codeArray.push(mergeDeclaration(statement, expression) + ";");
              }
            }
            var Assignments = function () {
              function Assignments(targetExpression) {
                this._exps = [];
                this._targetExp = targetExpression;
              }
              var _proto2 = Assignments.prototype;
              _proto2.setTargetExp = function setTargetExp(value) {
                this._targetExp = value;
              };
              _proto2.append = function append(key, expression) {
                this._exps.push([key, expression]);
              };
              _proto2.writeCode = function writeCode(codeArray) {
                var targetVar;
                if (this._exps.length > 1) {
                  codeArray.push(LOCAL_TEMP_OBJ + "=" + this._targetExp + ";");
                  targetVar = LOCAL_TEMP_OBJ;
                } else if (this._exps.length === 1) {
                  targetVar = this._targetExp;
                } else {
                  return;
                }
                for (var i = 0; i < this._exps.length; i++) {
                  var pair = this._exps[i];
                  writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
                }
              };
              return Assignments;
            }();
            Assignments.pool = new Pool$1(function (obj) {
              obj._exps.length = 0;
              obj._targetExp = null;
            }, 1);
            Assignments.pool.get = function get(targetExpression) {
              var cache = this._get() || new Assignments();
              cache.setTargetExp(targetExpression);
              return cache;
            };
            function getPropAccessor(key) {
              return IDENTIFIER_RE.test(key) ? "." + key : "[" + escapeForJS(key) + "]";
            }
            var Parser = function () {
              function Parser(obj, parent) {
                this.objsToClear_iN$t = [];
                this.codeArray = [];
                this.objs = [];
                this.funcs = [];
                this.globalVariables = [];
                this.globalVariableId = 0;
                this.localVariableId = 0;
                this.parent = parent;
                this.funcModuleCache = createMap();
                mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
                this.codeArray.push(VAR + LOCAL_OBJ + "," + LOCAL_TEMP_OBJ + ";", 'if(R){', LOCAL_OBJ + "=R;", '}else{', LOCAL_OBJ + "=R=new " + this.getFuncModule(obj.constructor, true) + "();", '}');
                obj._iN$t = {
                  globalVar: 'R'
                };
                this.objsToClear_iN$t.push(obj);
                this.enumerateObject(this.codeArray, obj);
                var globalVariablesDeclaration;
                if (this.globalVariables.length > 0) {
                  globalVariablesDeclaration = VAR + this.globalVariables.join(',') + ";";
                }
                var code = flattenCodeArray(['return (function(R){', globalVariablesDeclaration || [], this.codeArray, 'return o;', '})']);
                this.result = Function('O', 'F', code)(this.objs, this.funcs);
                for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) {
                  this.objsToClear_iN$t[i]._iN$t = null;
                }
                this.objsToClear_iN$t.length = 0;
              }
              var _proto3 = Parser.prototype;
              _proto3.getFuncModule = function getFuncModule(func, usedInNew) {
                var clsName = getClassName(func);
                if (clsName) {
                  var cache = this.funcModuleCache[clsName];
                  if (cache) {
                    return cache;
                  } else if (cache === undefined) {
                    var clsNameIsModule = clsName.indexOf('.') !== -1;
                    if (clsNameIsModule) {
                      try {
                        clsNameIsModule = func === Function("return " + clsName)();
                        if (clsNameIsModule) {
                          this.funcModuleCache[clsName] = clsName;
                          return clsName;
                        }
                      } catch (e) {}
                    }
                  }
                }
                var index = this.funcs.indexOf(func);
                if (index < 0) {
                  index = this.funcs.length;
                  this.funcs.push(func);
                }
                var res = "F[" + index + "]";
                if (usedInNew) {
                  res = "(" + res + ")";
                }
                this.funcModuleCache[clsName] = res;
                return res;
              };
              _proto3.getObjRef = function getObjRef(obj) {
                var index = this.objs.indexOf(obj);
                if (index < 0) {
                  index = this.objs.length;
                  this.objs.push(obj);
                }
                return "O[" + index + "]";
              };
              _proto3.setValueType = function setValueType(codeArray, defaultValue, srcValue, targetExpression) {
                var assignments = Assignments.pool.get(targetExpression);
                var fastDefinedProps = defaultValue.constructor.__props__;
                if (!fastDefinedProps) {
                  fastDefinedProps = Object.keys(defaultValue);
                }
                for (var i = 0; i < fastDefinedProps.length; i++) {
                  var propName = fastDefinedProps[i];
                  var prop = srcValue[propName];
                  if (defaultValue[propName] === prop) {
                    continue;
                  }
                  var expression = this.enumerateField(srcValue, propName, prop);
                  assignments.append(propName, expression);
                }
                assignments.writeCode(codeArray);
                Assignments.pool.put(assignments);
              };
              _proto3.enumerateCCClass = function enumerateCCClass(codeArray, obj, klass) {
                var props = klass.__values__;
                var attrs = CCClass.Attr.getClassAttrs(klass);
                for (var p = 0; p < props.length; p++) {
                  var key = props[p];
                  var val = obj[key];
                  var defaultValue = attrs[key + DEFAULT];
                  if (equalsToDefault(defaultValue, val)) {
                    continue;
                  }
                  if (typeof val === 'object' && val instanceof cclegacy.ValueType) {
                    defaultValue = CCClass.getDefault(defaultValue);
                    if (defaultValue && defaultValue.constructor === val.constructor) {
                      var targetExpression = LOCAL_OBJ + getPropAccessor(key);
                      this.setValueType(codeArray, defaultValue, val, targetExpression);
                      continue;
                    }
                  }
                  this.setObjProp(codeArray, obj, key, val);
                }
              };
              _proto3.instantiateArray = function instantiateArray(value) {
                if (value.length === 0) {
                  return '[]';
                }
                var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
                var declaration = new Declaration(arrayVar, "new Array(" + value.length + ")");
                var codeArray = [declaration];
                value._iN$t = {
                  globalVar: '',
                  source: codeArray
                };
                this.objsToClear_iN$t.push(value);
                for (var i = 0; i < value.length; ++i) {
                  var statement = arrayVar + "[" + i + "]=";
                  var expression = this.enumerateField(value, i, value[i]);
                  writeAssignment(codeArray, statement, expression);
                }
                return codeArray;
              };
              _proto3.instantiateTypedArray = function instantiateTypedArray(value) {
                var type = value.constructor.name;
                if (value.length === 0) {
                  return "new " + type;
                }
                var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
                var declaration = new Declaration(arrayVar, "new " + type + "(" + value.length + ")");
                var codeArray = [declaration];
                value._iN$t = {
                  globalVar: '',
                  source: codeArray
                };
                this.objsToClear_iN$t.push(value);
                for (var i = 0; i < value.length; ++i) {
                  if (value[i] !== 0) {
                    var statement = arrayVar + "[" + i + "]=";
                    writeAssignment(codeArray, statement, value[i]);
                  }
                }
                return codeArray;
              };
              _proto3.enumerateField = function enumerateField(obj, key, value) {
                if (typeof value === 'object' && value) {
                  var _iN$t = value._iN$t;
                  if (_iN$t) {
                    var globalVar = _iN$t.globalVar;
                    if (!globalVar) {
                      globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId;
                      this.globalVariables.push(globalVar);
                      var line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
                      _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(globalVar + "=", line);
                    }
                    return globalVar;
                  } else if (ArrayBuffer.isView(value)) {
                    return this.instantiateTypedArray(value);
                  } else if (Array.isArray(value)) {
                    return this.instantiateArray(value);
                  } else {
                    return this.instantiateObj(value);
                  }
                } else if (typeof value === 'function') {
                  return this.getFuncModule(value);
                } else if (typeof value === 'string') {
                  return escapeForJS(value);
                } else {
                  if (key === '_objFlags' && isCCObject(obj)) {
                    value &= PersistentMask$1;
                  }
                  return value;
                }
              };
              _proto3.setObjProp = function setObjProp(codeArray, obj, key, value) {
                var statement = LOCAL_OBJ + getPropAccessor(key) + "=";
                var expression = this.enumerateField(obj, key, value);
                writeAssignment(codeArray, statement, expression);
              };
              _proto3.enumerateObject = function enumerateObject(codeArray, obj) {
                var klass = obj.constructor;
                if (isCCClassOrFastDefined(klass)) {
                  this.enumerateCCClass(codeArray, obj, klass);
                } else {
                  for (var key in obj) {
                    if (!Object.prototype.hasOwnProperty.call(obj, key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__') {
                      continue;
                    }
                    var value = obj[key];
                    if (typeof value === 'object' && value && value === obj._iN$t) {
                      continue;
                    }
                    this.setObjProp(codeArray, obj, key, value);
                  }
                }
              };
              _proto3.instantiateObj = function instantiateObj(obj) {
                if (obj instanceof cclegacy.ValueType) {
                  return CCClass.getNewValueTypeCode(obj);
                }
                if (obj instanceof cclegacy.Asset) {
                  return this.getObjRef(obj);
                }
                if (obj._objFlags & Destroyed$1) {
                  return null;
                }
                var createCode;
                var ctor = obj.constructor;
                if (isCCClassOrFastDefined(ctor)) {
                  if (this.parent) {
                    if (this.parent instanceof cclegacy.Component) {
                      if (obj instanceof cclegacy.Node || obj instanceof cclegacy.Component) {
                        return this.getObjRef(obj);
                      }
                    } else if (this.parent instanceof cclegacy.Node) {
                      if (obj instanceof cclegacy.Node) {
                        if (!obj.isChildOf(this.parent)) {
                          return this.getObjRef(obj);
                        }
                      } else if (obj instanceof cclegacy.Component) {
                        var _obj$node;
                        if (!((_obj$node = obj.node) != null && _obj$node.isChildOf(this.parent))) {
                          return this.getObjRef(obj);
                        }
                      }
                    }
                  }
                  createCode = new Declaration(LOCAL_OBJ, "new " + this.getFuncModule(ctor, true) + "()");
                } else if (ctor === Object) {
                  createCode = new Declaration(LOCAL_OBJ, '{}');
                } else if (!ctor) {
                  createCode = new Declaration(LOCAL_OBJ, 'Object.create(null)');
                } else {
                  return this.getObjRef(obj);
                }
                var codeArray = [createCode];
                obj._iN$t = {
                  globalVar: '',
                  source: codeArray
                };
                this.objsToClear_iN$t.push(obj);
                this.enumerateObject(codeArray, obj);
                return ['(function(){', codeArray, 'return o;})();'];
              };
              return Parser;
            }();
            function equalsToDefault(def, value) {
              if (typeof def === 'function') {
                try {
                  def = def();
                } catch (e) {
                  return false;
                }
              }
              if (def === value) {
                return true;
              }
              if (def && value && typeof def === 'object' && typeof value === 'object' && def.constructor === value.constructor) {
                if (def instanceof cclegacy.ValueType) {
                  if (def.equals(value)) {
                    return true;
                  }
                } else if (Array.isArray(def)) {
                  return def.length === 0 && value.length === 0;
                } else if (def.constructor === Object) {
                  return isEmptyObject(def) && isEmptyObject(value);
                }
              }
              return false;
            }
            function compile(node) {
              var root = node instanceof cclegacy.Node && node;
              var parser = new Parser(node, root);
              return parser.result;
            }

            var _dec$r, _class$r, _class2$o, _initializer$n, _initializer2$k, _initializer3$f, _class3$7;
            var OptimizationPolicy = Enum({
              AUTO: 0,
              SINGLE_INSTANCE: 1,
              MULTI_INSTANCE: 2
            });
            var Prefab = exports("Prefab", (_dec$r = ccclass$6('cc.Prefab'), _dec$r(_class$r = (_class2$o = (_class3$7 = function (_Asset) {
              _inheritsLoose(Prefab, _Asset);
              function Prefab() {
                var _this;
                _this = _Asset.call(this) || this;
                _this.data = _initializer$n && _initializer$n();
                _this.optimizationPolicy = _initializer2$k && _initializer2$k();
                _this.persistent = _initializer3$f && _initializer3$f();
                _this._createFunction = null;
                _this._instantiatedTimes = 0;
                return _this;
              }
              var _proto = Prefab.prototype;
              _proto.createNode = function createNode(cb) {
                var node = legacyCC.instantiate(this);
                node.name = this.name;
                cb(null, node);
              };
              _proto.compileCreateFunction = function compileCreateFunction() {
                {
                  this._createFunction = compile(this.data);
                }
              };
              _proto._doInstantiate = function _doInstantiate(rootToRedirect) {
                if (!this.data._prefab) {
                  warnID(3700);
                }
                if (!this._createFunction) {
                  this.compileCreateFunction();
                }
                return this._createFunction(rootToRedirect);
              };
              _proto._instantiate = function _instantiate() {
                var node;
                var useJit = false;
                {
                  if (this.optimizationPolicy === OptimizationPolicy.SINGLE_INSTANCE) {
                    useJit = false;
                  } else if (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE) {
                    useJit = true;
                  } else {
                    useJit = this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold;
                  }
                }
                if (useJit) {
                  node = this._doInstantiate();
                  this.data._instantiate(node);
                } else {
                  node = this.data._instantiate();
                }
                ++this._instantiatedTimes;
                return node;
              };
              _proto.initDefault = function initDefault(uuid) {
                _Asset.prototype.initDefault.call(this, uuid);
                this.data = new Node$1();
                this.data.name = '(Missing Node)';
                var prefabInfo = new legacyCC._PrefabInfo();
                prefabInfo.asset = this;
                prefabInfo.root = this.data;
                this.data._prefab = prefabInfo;
              };
              _proto.validate = function validate() {
                return !!this.data;
              };
              _proto.onLoaded = function onLoaded() {
                var rootNode = this.data;
                expandNestedPrefabInstanceNode(rootNode);
                applyTargetOverrides(rootNode);
              };
              return Prefab;
            }(Asset), _class3$7.OptimizationPolicy = OptimizationPolicy, _class3$7.OptimizationPolicyThreshold = 3, _class3$7), (_initializer$n = applyDecoratedInitializer(_class2$o.prototype, "data", [serializable$5], function () {
              return null;
            }), _initializer2$k = applyDecoratedInitializer(_class2$o.prototype, "optimizationPolicy", [serializable$5], function () {
              return OptimizationPolicy.AUTO;
            }), _initializer3$f = applyDecoratedInitializer(_class2$o.prototype, "persistent", [serializable$5], function () {
              return false;
            })), _class2$o)) || _class$r));
            value(Prefab, '_utils', utils$1);
            legacyCC.Prefab = Prefab;
            {
              obsolete(legacyCC, 'cc._Prefab', 'Prefab');
            }

            var UIRendererManager = function () {
              function UIRendererManager() {
                this._allRenderers = [];
                this._dirtyRenderers = [];
                this._dirtyVersion = 0;
              }
              var _proto = UIRendererManager.prototype;
              _proto.addRenderer = function addRenderer(uiRenderer) {
                if (uiRenderer._internalId === -1) {
                  uiRenderer._internalId = this._allRenderers.length;
                  this._allRenderers.push(uiRenderer);
                }
              };
              _proto.removeRenderer = function removeRenderer(uiRenderer) {
                if (uiRenderer._internalId !== -1) {
                  {
                    assert(this._allRenderers[uiRenderer._internalId] === uiRenderer);
                  }
                  var id = uiRenderer._internalId;
                  this._allRenderers[this._allRenderers.length - 1]._internalId = id;
                  fastRemoveAt$2(this._allRenderers, id);
                  uiRenderer._internalId = -1;
                  if (uiRenderer._dirtyVersion === this._dirtyVersion) {
                    fastRemove(this._dirtyRenderers, uiRenderer);
                    uiRenderer._dirtyVersion = -1;
                  }
                }
              };
              _proto.markDirtyRenderer = function markDirtyRenderer(uiRenderer) {
                if (uiRenderer._dirtyVersion !== this._dirtyVersion && uiRenderer._internalId !== -1) {
                  this._dirtyRenderers.push(uiRenderer);
                  uiRenderer._dirtyVersion = this._dirtyVersion;
                }
              };
              _proto.updateAllDirtyRenderers = function updateAllDirtyRenderers() {
                var dirtyRenderers = this._dirtyRenderers;
                for (var i = 0; i < this._dirtyRenderers.length; i++) {
                  {
                    assert(dirtyRenderers[i]._internalId !== -1);
                  }
                  dirtyRenderers[i].updateRenderer();
                }
                this._dirtyRenderers.length = 0;
                this._dirtyVersion++;
              };
              return UIRendererManager;
            }();
            var uiRendererManager = new UIRendererManager();

            var ImageFmts = ['.png', '.jpg', '.bmp', '.jpeg', '.gif', '.ico', '.tiff', '.webp', '.image', '.pvr', '.pkm', '.astc'];
            var AudioFmts = ['.mp3', '.ogg', '.wav', '.m4a'];
            function GetTrue() {
              return true;
            }
            var md5Pipe = {
              transformURL: function transformURL(url) {
                var uuid = getUuidFromURL(url);
                if (!uuid) {
                  return url;
                }
                var bundle = bundles.find(function (b) {
                  return !!b.getAssetInfo(uuid);
                });
                if (!bundle) {
                  return url;
                }
                var hashValue = '';
                var info = bundle.getAssetInfo(uuid);
                if (url.startsWith(bundle.base + bundle.config.nativeBase)) {
                  hashValue = info.nativeVer || '';
                } else {
                  hashValue = info.ver || '';
                }
                if (!hashValue || url.indexOf(hashValue) !== -1) {
                  return url;
                }
                var hashPatchInFolder = false;
                if (extname(url) === '.ttf') {
                  hashPatchInFolder = true;
                }
                if (hashPatchInFolder) {
                  var dirname$1 = dirname(url);
                  var basename$1 = basename(url);
                  url = dirname$1 + "." + hashValue + "/" + basename$1;
                } else {
                  url = url.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,})/, function (match, uuid) {
                    return match + "." + hashValue;
                  });
                }
                return url;
              }
            };
            var CCLoader = exports("CCLoader", function () {
              function CCLoader() {
                this._autoReleaseSetting = Object.create(null);
                this._parseLoadResArgs = parseLoadResArgs;
              }
              var _proto = CCLoader.prototype;
              _proto.load = function load(res, progressCallback, completeCallback) {
                if (completeCallback === undefined) {
                  if (progressCallback !== undefined) {
                    completeCallback = progressCallback;
                    progressCallback = null;
                  }
                }
                var requests = Array.isArray(res) ? res : [res];
                for (var i = 0; i < requests.length; i++) {
                  var _item = requests[i];
                  if (typeof _item === 'string') {
                    requests[i] = {
                      url: _item,
                      __isNative__: true
                    };
                  } else {
                    if (_item.type) {
                      _item.ext = "." + _item.type;
                      _item.type = undefined;
                    }
                    if (_item.url) {
                      _item.__isNative__ = true;
                    }
                  }
                }
                var images = [];
                var audios = [];
                assetManager.loadAny(requests, null, function (finish, total, item) {
                  if (item.content) {
                    if (ImageFmts.includes(item.ext)) {
                      images.push(item.content);
                    } else if (AudioFmts.includes(item.ext)) {
                      audios.push(item.content);
                    }
                  }
                  if (progressCallback) {
                    progressCallback(finish, total, item);
                  }
                }, function (err, _native) {
                  var out = null;
                  if (!err) {
                    _native = Array.isArray(_native) ? _native : [_native];
                    var _loop = function _loop(_i) {
                      var item = _native[_i];
                      if (!(item instanceof Asset)) {
                        var _asset = item;
                        var _url = requests[_i].url;
                        if (images.includes(_asset)) {
                          factory.create(_url, item, '.png', {}, function (err, image) {
                            _asset = _native[_i] = image;
                          });
                        } else if (audios.includes(_asset)) {
                          factory.create(_url, item, '.mp3', {}, function (err, audio) {
                            _asset = _native[_i] = audio;
                          });
                        }
                        assets.add(_url, _asset);
                      }
                    };
                    for (var _i = 0; _i < _native.length; _i++) {
                      _loop(_i);
                    }
                    if (_native.length > 1) {
                      var map = Object.create(null);
                      _native.forEach(function (asset) {
                        map[asset._uuid] = asset;
                      });
                      out = {
                        isCompleted: GetTrue,
                        _map: map
                      };
                    } else {
                      out = _native[0];
                    }
                  }
                  if (completeCallback) {
                    completeCallback(err, out);
                  }
                });
              };
              _proto.getXMLHttpRequest = function getXMLHttpRequest() {
                return new XMLHttpRequest();
              };
              _proto.getItem = function getItem(id) {
                return assetManager.assets.has(id) ? {
                  content: assetManager.assets.get(id)
                } : null;
              };
              _proto.loadRes = function loadRes(url, type, progressCallback, completeCallback) {
                var _this$_parseLoadResAr = this._parseLoadResArgs(type, progressCallback, completeCallback),
                  _type = _this$_parseLoadResAr.type,
                  onProgress = _this$_parseLoadResAr.onProgress,
                  onComplete = _this$_parseLoadResAr.onComplete;
                var extname$1 = extname(url);
                if (extname$1 && !resources.getInfoWithPath(url, _type)) {
                  url = url.slice(0, -extname$1.length);
                }
                resources.load(url, _type, onProgress, onComplete);
              };
              _proto.loadResArray = function loadResArray(urls, type, progressCallback, completeCallback) {
                var _this$_parseLoadResAr2 = this._parseLoadResArgs(type, progressCallback, completeCallback),
                  _type = _this$_parseLoadResAr2.type,
                  onProgress = _this$_parseLoadResAr2.onProgress,
                  onComplete = _this$_parseLoadResAr2.onComplete;
                urls.forEach(function (url, i) {
                  var extname$1 = extname(url);
                  if (extname$1 && !resources.getInfoWithPath(url, _type)) {
                    urls[i] = url.slice(0, -extname$1.length);
                  }
                });
                resources.load(urls, _type, onProgress, onComplete);
              };
              _proto.loadResDir = function loadResDir(url, type, progressCallback, completeCallback) {
                var _this$_parseLoadResAr3 = this._parseLoadResArgs(type, progressCallback, completeCallback),
                  _type = _this$_parseLoadResAr3.type,
                  onProgress = _this$_parseLoadResAr3.onProgress,
                  onComplete = _this$_parseLoadResAr3.onComplete;
                resources.loadDir(url, _type, onProgress, function (err, out) {
                  var urls = [];
                  if (!err) {
                    var infos = resources.getDirWithPath(url, _type);
                    urls = infos.map(function (info) {
                      return info.path;
                    });
                  }
                  if (onComplete) {
                    onComplete(err, out, urls);
                  }
                });
              };
              _proto.getRes = function getRes(url, type) {
                return assets.has(url) ? assets.get(url) : resources.get(url, type);
              };
              _proto.getResCount = function getResCount() {
                return assets.count;
              };
              _proto.getDependsRecursively = function getDependsRecursively(owner) {
                if (!owner) {
                  return [];
                }
                var uuid = typeof owner === 'string' ? owner : owner._uuid;
                return dependUtil.getDepsRecursively(uuid).concat([uuid]);
              };
              _proto.addDownloadHandlers = function addDownloadHandlers(extMap) {
                var handler = Object.create(null);
                var _loop2 = function _loop2() {
                  var func = extMap[_type2];
                  handler["." + _type2] = function (url, options, onComplete) {
                    func({
                      url: url
                    }, onComplete);
                  };
                };
                for (var _type2 in extMap) {
                  _loop2();
                }
                downloader$1.register(handler);
              };
              _proto.addLoadHandlers = function addLoadHandlers(extMap) {
                var handler = Object.create(null);
                var _loop3 = function _loop3() {
                  var func = extMap[_type3];
                  handler["." + _type3] = function (file, options, onComplete) {
                    func({
                      content: file
                    }, onComplete);
                  };
                };
                for (var _type3 in extMap) {
                  _loop3();
                }
                parser.register(handler);
              };
              _proto.release = function release(asset) {
                if (Array.isArray(asset)) {
                  for (var i = 0; i < asset.length; i++) {
                    var key = asset[i];
                    if (typeof key === 'string') {
                      key = assets.get(key);
                    }
                    assetManager.releaseAsset(key);
                  }
                } else if (asset) {
                  if (typeof asset === 'string') {
                    asset = assets.get(asset);
                  }
                  assetManager.releaseAsset(asset);
                }
              };
              _proto.releaseAsset = function releaseAsset(asset) {
                assetManager.releaseAsset(asset);
              };
              _proto.releaseRes = function releaseRes(res, type) {
                resources.release(res, type);
              };
              _proto.releaseAll = function releaseAll() {
                assetManager.releaseAll();
                assets.clear();
              };
              _proto.removeItem = function removeItem(id) {
                return !!assets.remove(id);
              };
              _proto.setAutoRelease = function setAutoRelease(asset, autoRelease) {
                if (typeof asset === 'object') {
                  asset = asset._uuid;
                }
                this._autoReleaseSetting[asset] = !!autoRelease;
              };
              _proto.setAutoReleaseRecursively = function setAutoReleaseRecursively(asset, autoRelease) {
                if (typeof asset === 'object') {
                  asset = asset._uuid;
                }
                autoRelease = !!autoRelease;
                this._autoReleaseSetting[asset] = autoRelease;
                var depends = dependUtil.getDepsRecursively(asset);
                for (var i = 0; i < depends.length; i++) {
                  this._autoReleaseSetting[depends[i]] = autoRelease;
                }
              };
              _proto.isAutoRelease = function isAutoRelease(asset) {
                if (typeof asset === 'object') {
                  asset = asset._uuid;
                }
                return !!this._autoReleaseSetting[asset];
              };
              _createClass(CCLoader, [{
                key: "onProgress",
                set: function set(val) {
                  setDefaultProgressCallback(val);
                }
              }, {
                key: "_cache",
                get: function get() {
                  if (assets instanceof Cache) {
                    return assets.map;
                  } else {
                    var map = {};
                    assets.forEach(function (val, key) {
                      map[key] = val;
                    });
                    return map;
                  }
                }
              }, {
                key: "md5Pipe",
                get: function get() {
                  return md5Pipe;
                }
              }, {
                key: "downloader",
                get: function get() {
                  return downloader$1;
                }
              }, {
                key: "loader",
                get: function get() {
                  return assetManager.parser;
                }
              }]);
              return CCLoader;
            }());
            var loader = exports("loader", new CCLoader());
            var AssetLibrary = exports("AssetLibrary", {
              init: function init(options) {
                options.importBase = options.libraryPath;
                options.nativeBase = options.rawAssetsBase ;
                assetManager.init(options);
                if (options.rawAssets) {
                  resources.init({
                    base: '',
                    deps: [],
                    scenes: {},
                    redirect: [],
                    debug: true,
                    packs: {},
                    types: [],
                    versions: {
                      "import": [],
                      "native": []
                    },
                    name: "resources",
                    importBase: options.importBase,
                    nativeBase: options.nativeBase,
                    paths: options.rawAssets.assets,
                    uuids: Object.keys(options.rawAssets.assets),
                    extensionMap: {}
                  });
                }
              },
              loadAsset: function loadAsset(uuid, callback, options) {
                assetManager.loadAny(uuid, callback);
              }
            });
            var url = exports("url", {});
            replaceProperty(url, 'url', [{
              name: 'normalize',
              target: assetManager.utils,
              targetName: 'assetManager.utils',
              newName: 'normalize'
            }, {
              name: 'raw',
              targetName: 'Asset.prototype',
              newName: 'nativeUrl',
              customFunction: function customFunction(url) {
                if (url.startsWith('resources/')) {
                  return transform({
                    path: changeExtname(url.substring(10)),
                    bundle: "resources",
                    __isNative__: true,
                    ext: extname(url)
                  });
                }
                return '';
              }
            }]);
            removeProperty(AssetLibrary, 'AssetLibrary', [{
              name: 'getLibUrlNoExt',
              suggest: 'AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use assetManager.utils.getUrlWithUuid instead'
            }, {
              name: 'queryAssetInfo',
              suggest: 'AssetLibrary.queryAssetInfo was removed'
            }]);
            removeProperty(loader, 'loader', [{
              name: 'releaseResDir',
              suggest: 'loader.releaseResDir was removed, please use assetManager.releaseAsset instead'
            }, {
              name: 'flowInDeps',
              suggest: 'loader.flowInDeps was removed'
            }, {
              name: 'assetLoader',
              suggest: 'loader.assetLoader was removed, assetLoader and md5Pipe were merged into assetManager.transformPipeline'
            }]);
            replaceProperty(cclegacy, 'cc', [{
              name: 'loader',
              newName: 'assetManager',
              logTimes: 1,
              customGetter: function customGetter() {
                return loader;
              }
            }, {
              name: 'AssetLibrary',
              newName: 'assetManager',
              logTimes: 1,
              customGetter: function customGetter() {
                return AssetLibrary;
              }
            }, {
              name: 'Pipeline',
              target: AssetManager,
              targetName: 'AssetManager',
              newName: 'Pipeline',
              logTimes: 1
            }, {
              name: 'url',
              targetName: 'assetManager',
              newName: 'utils',
              logTimes: 1,
              customGetter: function customGetter() {
                return url;
              }
            }]);
            removeProperty(cclegacy, 'cc', [{
              name: 'LoadingItems',
              suggest: getError(1400, 'LoadingItems', 'AssetManager.Task')
            }]);
            replaceProperty(macro, 'macro', [{
              name: 'DOWNLOAD_MAX_CONCURRENT',
              target: downloader$1,
              targetName: 'assetManager.downloader',
              newName: 'maxConcurrency'
            }]);
            var _autoRelease = releaseManager._autoRelease;
            releaseManager._autoRelease = function (oldScene, newScene, persistNodes) {
              _autoRelease.call(releaseManager, oldScene, newScene, persistNodes);
              var releaseSettings = loader._autoReleaseSetting;
              var keys = Object.keys(releaseSettings);
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (releaseSettings[key] === true) {
                  var _asset2 = assets.get(key);
                  if (_asset2) {
                    releaseManager.tryRelease(_asset2);
                  }
                }
              }
            };

            var DirectorEvent = exports("DirectorEvent", {
              INIT: "director_init",
              RESET: "director_reset",
              BEFORE_SCENE_LOADING: "director_before_scene_loading",
              BEFORE_SCENE_LAUNCH: "director_before_scene_launch",
              AFTER_SCENE_LAUNCH: "director_after_scene_launch",
              BEFORE_UPDATE: "director_before_update",
              AFTER_UPDATE: "director_after_update",
              BEFORE_DRAW: "director_before_draw",
              AFTER_DRAW: "director_after_draw",
              BEFORE_COMMIT: "director_before_commit",
              BEFORE_RENDER: "director_before_render",
              AFTER_RENDER: "director_after_render",
              BEFORE_PHYSICS: "director_before_physics",
              AFTER_PHYSICS: "director_after_physics",
              BEGIN_FRAME: "director_begin_frame",
              END_FRAME: "director_end_frame"
            });
            var Director = exports("Director", function (_EventTarget) {
              _inheritsLoose(Director, _EventTarget);
              function Director() {
                var _this;
                _this = _EventTarget.call(this) || this;
                _this._compScheduler = new ComponentScheduler();
                _this._nodeActivator = new NodeActivator();
                _this._invalid = false;
                _this._paused = false;
                _this._root = null;
                _this._loadingScene = '';
                _this._scene = null;
                _this._totalFrames = 0;
                _this._scheduler = new Scheduler();
                _this._systems = [];
                _this._persistRootNodes = {};
                return _this;
              }
              var _proto = Director.prototype;
              _proto.end = function end() {
                var _this2 = this;
                this.once("director_end_frame", function () {
                  _this2.purgeDirector();
                });
              };
              _proto.pause = function pause() {
                this._paused = true;
              };
              _proto.purgeDirector = function purgeDirector() {
                this._scheduler.unscheduleAll();
                this._compScheduler.unscheduleAll();
                this._nodeActivator.reset();
                {
                  if (isValid(this._scene)) {
                    this._scene.destroy();
                  }
                  this._scene = null;
                }
                this.stopAnimation();
                assetManager.releaseAll();
              };
              _proto.reset = function reset() {
                this.purgeDirector();
                for (var id in this._persistRootNodes) {
                  this.removePersistRootNode(this._persistRootNodes[id]);
                }
                var scene = this.getScene();
                if (scene) {
                  scene.destroy();
                }
                this.emit("director_reset");
                this.startAnimation();
              };
              _proto.runSceneImmediate = function runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
                var _this3 = this;
                if (scene instanceof SceneAsset) scene = scene.scene;
                assertID(scene instanceof Scene, 1216);
                {
                  console.time('InitScene');
                }
                scene._load();
                {
                  console.timeEnd('InitScene');
                }
                {
                  console.time('AttachPersist');
                }
                var persistNodeList = Object.keys(this._persistRootNodes).map(function (x) {
                  return _this3._persistRootNodes[x];
                });
                for (var i = 0; i < persistNodeList.length; i++) {
                  var node = persistNodeList[i];
                  node.emit("scene-changed-for-persists", scene.renderScene);
                  var existNode = scene.uuid === node._originalSceneId && scene.getChildByUuid(node.uuid);
                  if (existNode) {
                    var index = existNode.siblingIndex;
                    node.hideFlags &= -9;
                    node.hideFlags |= 8 & existNode.hideFlags;
                    existNode._destroyImmediate();
                    scene.insertChild(node, index);
                  } else {
                    node.hideFlags |= 8;
                    node.parent = scene;
                  }
                }
                {
                  console.timeEnd('AttachPersist');
                }
                var oldScene = this._scene;
                {
                  console.time('Destroy');
                }
                if (isValid(oldScene)) {
                  oldScene.destroy();
                }
                {
                  {
                    console.time('AutoRelease');
                  }
                  releaseManager._autoRelease(oldScene, scene, this._persistRootNodes);
                  {
                    console.timeEnd('AutoRelease');
                  }
                }
                this._scene = null;
                CCObject._deferredDestroy();
                {
                  console.timeEnd('Destroy');
                }
                if (onBeforeLoadScene) {
                  onBeforeLoadScene();
                }
                this.emit("director_before_scene_launch", scene);
                this._scene = scene;
                {
                  console.time('Activate');
                }
                scene._activate();
                {
                  console.timeEnd('Activate');
                }
                if (this._root) {
                  this._root.resetCumulativeTime();
                }
                this.startAnimation();
                if (onLaunched) {
                  onLaunched(null, scene);
                }
                this.emit("director_after_scene_launch", scene);
              };
              _proto.runScene = function runScene(scene, onBeforeLoadScene, onLaunched) {
                var _this4 = this;
                if (scene instanceof SceneAsset) scene = scene.scene;
                assertID(Boolean(scene), 1205);
                assertID(scene instanceof Scene, 1216);
                this.once("director_end_frame", function () {
                  _this4.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
                });
              };
              _proto.loadScene = function loadScene(sceneName, onLaunched, onUnloaded) {
                var _this5 = this;
                if (this._loadingScene) {
                  warnID(1208, sceneName, this._loadingScene);
                  return false;
                }
                var bundle = assetManager.bundles.find(function (bundle) {
                  return !!bundle.getSceneInfo(sceneName);
                });
                if (bundle) {
                  this.emit("director_before_scene_loading", sceneName);
                  this._loadingScene = sceneName;
                  console.time("LoadScene " + sceneName);
                  bundle.loadScene(sceneName, function (err, scene) {
                    console.timeEnd("LoadScene " + sceneName);
                    _this5._loadingScene = '';
                    if (err) {
                      error(err);
                      if (onLaunched) {
                        onLaunched(err);
                      }
                    } else {
                      _this5.runSceneImmediate(scene, onUnloaded, onLaunched);
                    }
                  });
                  return true;
                } else {
                  errorID(1209, sceneName);
                  return false;
                }
              };
              _proto.preloadScene = function preloadScene(sceneName, onProgress, onLoaded) {
                var bundle = assetManager.bundles.find(function (bundle) {
                  return !!bundle.getSceneInfo(sceneName);
                });
                if (bundle) {
                  bundle.preloadScene(sceneName, null, onProgress, onLoaded);
                } else {
                  var _err = "Can not preload the scene \"" + sceneName + "\" because it is not in the build settings.";
                  if (onLoaded) {
                    onLoaded(new Error(_err));
                  }
                  error("preloadScene: " + _err);
                }
              };
              _proto.resume = function resume() {
                this._paused = false;
              };
              _proto.getScene = function getScene() {
                return this._scene;
              };
              _proto.getDeltaTime = function getDeltaTime() {
                return cclegacy.game.deltaTime;
              };
              _proto.getTotalTime = function getTotalTime() {
                return cclegacy.game.totalTime;
              };
              _proto.getCurrentTime = function getCurrentTime() {
                return cclegacy.game.frameStartTime;
              };
              _proto.getTotalFrames = function getTotalFrames() {
                return this._totalFrames;
              };
              _proto.isPaused = function isPaused() {
                return this._paused;
              };
              _proto.getScheduler = function getScheduler() {
                return this._scheduler;
              };
              _proto.setScheduler = function setScheduler(scheduler) {
                if (this._scheduler !== scheduler) {
                  this.unregisterSystem(this._scheduler);
                  this._scheduler = scheduler;
                  this.registerSystem(Scheduler.ID, scheduler, 200);
                }
              };
              _proto.registerSystem = function registerSystem(name, sys, priority) {
                sys.id = name;
                sys.priority = priority;
                this._systems.push(sys);
                this._systems.sort(System.sortByPriority);
              };
              _proto.unregisterSystem = function unregisterSystem(sys) {
                fastRemove(this._systems, sys);
                this._systems.sort(System.sortByPriority);
              };
              _proto.getSystem = function getSystem(name) {
                return this._systems.find(function (sys) {
                  return sys.id === name;
                });
              };
              _proto.getAnimationManager = function getAnimationManager() {
                return this.getSystem(cclegacy.AnimationManager.ID);
              };
              _proto.startAnimation = function startAnimation() {
                this._invalid = false;
              };
              _proto.stopAnimation = function stopAnimation() {
                this._invalid = true;
              };
              _proto.mainLoop = function mainLoop(now) {
                var dt;
                {
                  dt = cclegacy.game._calculateDT(false);
                }
                this.tick(dt);
              };
              _proto.tick = function tick(dt) {
                if (!this._invalid) {
                  this.emit("director_begin_frame");
                  {
                    input._frameDispatchEvents();
                  }
                  if (!this._paused) {
                    this.emit("director_before_update");
                    this._compScheduler.startPhase();
                    this._compScheduler.updatePhase(dt);
                    for (var i = 0; i < this._systems.length; ++i) {
                      this._systems[i].update(dt);
                    }
                    this._compScheduler.lateUpdatePhase(dt);
                    this.emit("director_after_update");
                    CCObject._deferredDestroy();
                    for (var _i = 0; _i < this._systems.length; ++_i) {
                      this._systems[_i].postUpdate(dt);
                    }
                  }
                  this.emit("director_before_draw");
                  uiRendererManager.updateAllDirtyRenderers();
                  this._root.frameMove(dt);
                  this.emit("director_after_draw");
                  Node$1.resetHasChangedFlags();
                  Node$1.clearNodeArray();
                  scalableContainerManager.update(dt);
                  this.emit("director_end_frame");
                  this._totalFrames++;
                }
              };
              _proto.buildRenderPipeline = function buildRenderPipeline() {
                if (!this._root) {
                  return;
                }
                var ppl = this._root.customPipeline;
                var cameras = this._root.cameraList;
                ppl.beginSetup();
                var builder = cclegacy.rendering.getCustomPipeline(macro.CUSTOM_PIPELINE_NAME);
                cclegacy.rendering.dispatchResizeEvents(cameras, builder, ppl);
                builder.setup(cameras, ppl);
                ppl.endSetup();
              };
              _proto.setupRenderPipelineBuilder = function setupRenderPipelineBuilder() {
                if (macro.CUSTOM_PIPELINE_NAME !== '' && cclegacy.rendering && this._root && this._root.usesCustomPipeline) {
                  this.on("director_before_scene_launch", cclegacy.rendering.forceResizeAllWindows, cclegacy.rendering);
                }
              };
              _proto.init = function init() {
                this._totalFrames = 0;
                this._paused = false;
                this.registerSystem(Scheduler.ID, this._scheduler, 200);
                this._root = new Root(deviceManager.gfxDevice);
                var rootInfo = {};
                this._root.initialize(rootInfo);
                this.setupRenderPipelineBuilder();
                for (var i = 0; i < this._systems.length; i++) {
                  this._systems[i].init();
                }
                this.emit("director_init");
              };
              _proto.addPersistRootNode = function addPersistRootNode(node) {
                if (!Node$1.isNode(node) || !node.uuid) {
                  warnID(3800);
                  return;
                }
                var id = node.uuid;
                if (!this._persistRootNodes[id]) {
                  var _scene = this._scene;
                  if (isValid(_scene)) {
                    if (!node.parent) {
                      node.parent = _scene;
                      node._originalSceneId = _scene.uuid;
                    } else if (!(node.parent instanceof Scene)) {
                      warnID(3801);
                      return;
                    } else if (node.parent !== _scene) {
                      warnID(3802);
                      return;
                    } else {
                      node._originalSceneId = _scene.uuid;
                    }
                  }
                  this._persistRootNodes[id] = node;
                  node._persistNode = true;
                  releaseManager._addPersistNodeRef(node);
                }
              };
              _proto.removePersistRootNode = function removePersistRootNode(node) {
                var id = node.uuid || '';
                if (node === this._persistRootNodes[id]) {
                  delete this._persistRootNodes[id];
                  node._persistNode = false;
                  node._originalSceneId = '';
                  releaseManager._removePersistNodeRef(node);
                }
              };
              _proto.isPersistRootNode = function isPersistRootNode(node) {
                return !!node._persistNode;
              };
              _createClass(Director, [{
                key: "root",
                get: function get() {
                  return this._root;
                }
              }]);
              return Director;
            }(EventTarget));
            Director.EVENT_INIT = "director_init";
            Director.EVENT_RESET = "director_reset";
            Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading";
            Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
            Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch";
            Director.EVENT_BEFORE_UPDATE = "director_before_update";
            Director.EVENT_AFTER_UPDATE = "director_after_update";
            Director.EVENT_BEFORE_DRAW = "director_before_draw";
            Director.EVENT_AFTER_DRAW = "director_after_draw";
            Director.EVENT_BEFORE_COMMIT = "director_before_commit";
            Director.EVENT_BEFORE_RENDER = "director_before_render";
            Director.EVENT_AFTER_RENDER = "director_after_render";
            Director.EVENT_BEFORE_PHYSICS = "director_before_physics";
            Director.EVENT_AFTER_PHYSICS = "director_after_physics";
            Director.EVENT_BEGIN_FRAME = "director_begin_frame";
            Director.EVENT_END_FRAME = "director_end_frame";
            Director.instance = undefined;
            cclegacy.Director = Director;
            cclegacy.DirectorEvent = DirectorEvent;
            var director = exports("director", Director.instance = cclegacy.director = new Director());

            function findCanvas() {
              var frame = document.querySelector('#GameDiv');
              var container = document.querySelector('#Cocos3dGameContainer');
              var canvas = document.querySelector('#GameCanvas');
              return {
                frame: frame,
                container: container,
                canvas: canvas
              };
            }
            function loadJsFile(path) {
              return new Promise(function (resolve, reject) {
                var err;
                function windowErrorListener(evt) {
                  if (evt.filename === path) {
                    err = evt.error;
                  }
                }
                window.addEventListener('error', windowErrorListener);
                var script = document.createElement('script');
                script.charset = 'utf-8';
                script.async = true;
                script.crossOrigin = 'anonymous';
                script.addEventListener('error', function () {
                  window.removeEventListener('error', windowErrorListener);
                  reject(Error("Error loading " + path));
                });
                script.addEventListener('load', function () {
                  window.removeEventListener('error', windowErrorListener);
                  document.head.removeChild(script);
                  if (err) {
                    reject(err);
                  } else {
                    resolve();
                  }
                });
                script.src = path.replace('#', '%23');
                document.head.appendChild(script);
              });
            }

            var Pacer = function () {
              function Pacer() {
                var _this = this;
                this._stHandle = 0;
                this._onTick = null;
                this._targetFrameRate = 60;
                this._frameTime = 0;
                this._startTime = 0;
                this._isPlaying = false;
                this._frameCount = 0;
                this._callback = null;
                this._rAF = undefined;
                this._cAF = undefined;
                this._handleRAF = function (stamp) {
                  var currTime = performance.now();
                  var elapseTime = currTime - _this._startTime;
                  var elapseFrame = Math.floor(elapseTime / _this._frameTime);
                  if (elapseFrame < 0) {
                    _this._startTime = currTime;
                    _this._frameCount = 0;
                  }
                  if (elapseFrame < _this._frameCount) {
                    _this._stHandle = _this._rAF.call(window, _this._handleRAF);
                  } else {
                    _this._frameCount = elapseFrame + 1;
                    if (_this._callback) {
                      _this._callback();
                    }
                  }
                };
                this._frameTime = 1000 / this._targetFrameRate;
                this._rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
                this._cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.ocancelAnimationFrame;
              }
              var _proto = Pacer.prototype;
              _proto.start = function start() {
                var _this2 = this;
                if (this._isPlaying) return;
                var recordStartTime = this._rAF === undefined || USE_XR;
                var updateCallback = function updateCallback() {
                  if (recordStartTime) _this2._startTime = performance.now();
                  if (_this2._isPlaying) {
                    _this2._stHandle = _this2._stTime(updateCallback);
                  }
                  if (_this2._onTick) {
                    _this2._onTick();
                  }
                };
                this._startTime = performance.now();
                this._stHandle = this._stTime(updateCallback);
                this._isPlaying = true;
                this._frameCount = 0;
              };
              _proto.stop = function stop() {
                if (!this._isPlaying) return;
                this._ctTime(this._stHandle);
                this._stHandle = 0;
                this._isPlaying = false;
                this._frameCount = 0;
              };
              _proto._stTime = function _stTime(callback) {
                if (this._rAF === undefined || USE_XR) {
                  var currTime = performance.now();
                  var elapseTime = Math.max(0, currTime - this._startTime);
                  var timeToCall = Math.max(0, this._frameTime - elapseTime);
                  return setTimeout(callback, timeToCall);
                }
                this._callback = callback;
                return this._rAF.call(window, this._handleRAF);
              };
              _proto._ctTime = function _ctTime(id) {
                if (this._cAF === undefined || USE_XR) {
                  clearTimeout(id);
                } else if (id) {
                  this._cAF.call(window, id);
                }
              };
              _createClass(Pacer, [{
                key: "targetFrameRate",
                get: function get() {
                  return this._targetFrameRate;
                },
                set: function set(val) {
                  if (this._targetFrameRate !== val) {
                    assertIsTrue(val > 0);
                    this._targetFrameRate = val;
                    this._frameTime = 1000 / this._targetFrameRate;
                    if (this._isPlaying) {
                      this.stop();
                      this.start();
                    }
                  }
                }
              }, {
                key: "onTick",
                get: function get() {
                  return this._onTick;
                },
                set: function set(val) {
                  this._onTick = val;
                }
              }]);
              return Pacer;
            }();

            var PipelineInputAssemblerData = exports("PipelineInputAssemblerData", function PipelineInputAssemblerData() {
              this.quadIB = null;
              this.quadVB = null;
              this.quadIA = null;
            });

            var _mat4Trans = new Mat4();
            var _matShadowTrans = new Mat4();
            var _matShadowView = new Mat4();
            var _matShadowProj = new Mat4();
            var _matShadowViewProj = new Mat4();
            var _matShadowViewProjArbitaryPos = new Mat4();
            var _matShadowViewProjArbitaryPosInv = new Mat4();
            var _focus = new Vec3(0, 0, 0);
            var _projPos = new Vec3();
            var _texelSize = new Vec2();
            var _projSnap = new Vec3();
            var _snap = new Vec3();
            var _maxVec3 = new Vec3(10000000, 10000000, 10000000);
            var _minVec3 = new Vec3(-1e7, -1e7, -1e7);
            var _shadowPos = new Vec3();
            var _maxLayerPosz = 0.0;
            var _maxLayerFarPlane = 0.0;
            var ShadowLayerVolume = function () {
              function ShadowLayerVolume(level) {
                this._shadowObjects = [];
                this._shadowCameraFar = 0;
                this._matShadowView = new Mat4();
                this._matShadowProj = new Mat4();
                this._matShadowViewProj = new Mat4();
                this._validFrustum = new Frustum();
                this._splitFrustum = new Frustum();
                this._lightViewFrustum = new Frustum();
                this._castLightViewBoundingBox = new AABB();
                this._level = level;
                this._validFrustum.accurate = true;
                this._splitFrustum.accurate = true;
                this._lightViewFrustum.accurate = true;
              }
              var _proto = ShadowLayerVolume.prototype;
              _proto.copyToValidFrustum = function copyToValidFrustum(validFrustum) {
                Frustum.copy(this._validFrustum, validFrustum);
              };
              _proto.calculateValidFrustumOrtho = function calculateValidFrustumOrtho(width, height, near, far, transform) {
                Frustum.createOrtho(this._validFrustum, width, height, near, far, transform);
              };
              _proto.calculateSplitFrustum = function calculateSplitFrustum(camera, m, start, end) {
                this._splitFrustum.split(start, end, camera.aspect, camera.fov, m);
              };
              _proto.destroy = function destroy() {
                this._shadowObjects.length = 0;
              };
              _proto.createMatrix = function createMatrix(dirLight, shadowMapWidth, onlyForCulling) {
                var device = cclegacy.director.root.device;
                var invisibleOcclusionRange = dirLight.shadowInvisibleOcclusionRange;
                Frustum.copy(this._lightViewFrustum, this._splitFrustum);
                Mat4.fromRT(_matShadowTrans, dirLight.node.rotation, _focus);
                Mat4.invert(_matShadowView, _matShadowTrans);
                var shadowViewArbitaryPos = _matShadowView.clone();
                this._lightViewFrustum.transform(_matShadowView);
                AABB.fromPoints(this._castLightViewBoundingBox, _maxVec3, _minVec3);
                this._castLightViewBoundingBox.mergeFrustum(this._lightViewFrustum);
                var orthoSizeWidth;
                var orthoSizeHeight;
                if (dirLight.csmOptimizationMode === CSMOptimizationMode.DisableRotationFix) {
                  orthoSizeWidth = this._castLightViewBoundingBox.halfExtents.x * 2.0;
                  orthoSizeHeight = this._castLightViewBoundingBox.halfExtents.y * 2.0;
                } else {
                  orthoSizeWidth = orthoSizeHeight = Vec3.distance(this._lightViewFrustum.vertices[0], this._lightViewFrustum.vertices[6]);
                }
                var csmLevel = cclegacy.director.root.pipeline.pipelineSceneData.csmSupported ? dirLight.csmLevel : 1;
                if (csmLevel > 1 && dirLight.csmOptimizationMode === CSMOptimizationMode.RemoveDuplicates) {
                  if (this._level >= csmLevel - 1) {
                    _maxLayerFarPlane = this._castLightViewBoundingBox.halfExtents.z;
                    _maxLayerPosz = this._castLightViewBoundingBox.center.z;
                  } else {
                    var alignFarPlaneDist = Math.abs(this._castLightViewBoundingBox.center.z - _maxLayerPosz) + _maxLayerFarPlane;
                    this._castLightViewBoundingBox.halfExtents.z = Math.max(this._castLightViewBoundingBox.center.z, alignFarPlaneDist);
                  }
                }
                var r = this._castLightViewBoundingBox.halfExtents.z;
                this._shadowCameraFar = r * 2 + invisibleOcclusionRange;
                var center = this._castLightViewBoundingBox.center;
                _shadowPos.set(center.x, center.y, center.z + r + invisibleOcclusionRange);
                Vec3.transformMat4(_shadowPos, _shadowPos, _matShadowTrans);
                Mat4.fromRT(_matShadowTrans, dirLight.node.rotation, _shadowPos);
                Mat4.invert(_matShadowView, _matShadowTrans);
                if (!onlyForCulling) {
                  var halfOrthoSizeWidth = orthoSizeWidth * 0.5;
                  var halfOrthoSizeHeight = orthoSizeHeight * 0.5;
                  Mat4.ortho(_matShadowProj, -halfOrthoSizeWidth, halfOrthoSizeWidth, -halfOrthoSizeHeight, halfOrthoSizeHeight, 0.1, this._shadowCameraFar, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY);
                  Mat4.multiply(_matShadowViewProjArbitaryPos, _matShadowProj, shadowViewArbitaryPos);
                  Vec3.transformMat4(_projPos, _shadowPos, _matShadowViewProjArbitaryPos);
                  var invActualSize = 2.0 / shadowMapWidth;
                  _texelSize.set(invActualSize, invActualSize);
                  var modX = _projPos.x % _texelSize.x;
                  var modY = _projPos.y % _texelSize.y;
                  _projSnap.set(_projPos.x - modX, _projPos.y - modY, _projPos.z);
                  Mat4.invert(_matShadowViewProjArbitaryPosInv, _matShadowViewProjArbitaryPos);
                  Vec3.transformMat4(_snap, _projSnap, _matShadowViewProjArbitaryPosInv);
                  Mat4.fromRT(_matShadowTrans, dirLight.node.rotation, _snap);
                  Mat4.invert(_matShadowView, _matShadowTrans);
                  Mat4.multiply(_matShadowViewProj, _matShadowProj, _matShadowView);
                  Mat4.copy(this._matShadowView, _matShadowView);
                  Mat4.copy(this._matShadowProj, _matShadowProj);
                  Mat4.copy(this._matShadowViewProj, _matShadowViewProj);
                }
                Frustum.createOrtho(this._validFrustum, orthoSizeWidth, orthoSizeHeight, 0.1, this._shadowCameraFar, _matShadowTrans);
              };
              _createClass(ShadowLayerVolume, [{
                key: "level",
                get: function get() {
                  return this._level;
                }
              }, {
                key: "shadowObjects",
                get: function get() {
                  return this._shadowObjects;
                }
              }, {
                key: "shadowCameraFar",
                get: function get() {
                  return this._shadowCameraFar;
                },
                set: function set(val) {
                  this._shadowCameraFar = val;
                }
              }, {
                key: "matShadowView",
                get: function get() {
                  return this._matShadowView;
                },
                set: function set(val) {
                  this._matShadowView = val;
                }
              }, {
                key: "matShadowProj",
                get: function get() {
                  return this._matShadowProj;
                },
                set: function set(val) {
                  this._matShadowProj = val;
                }
              }, {
                key: "matShadowViewProj",
                get: function get() {
                  return this._matShadowViewProj;
                },
                set: function set(val) {
                  this._matShadowViewProj = val;
                }
              }, {
                key: "validFrustum",
                get: function get() {
                  return this._validFrustum;
                }
              }, {
                key: "splitFrustum",
                get: function get() {
                  return this._splitFrustum;
                }
              }, {
                key: "lightViewFrustum",
                get: function get() {
                  return this._lightViewFrustum;
                }
              }, {
                key: "castLightViewBoundingBox",
                get: function get() {
                  return this._castLightViewBoundingBox;
                }
              }]);
              return ShadowLayerVolume;
            }();
            var CSMShadowLayer = function (_ShadowLayerVolume) {
              _inheritsLoose(CSMShadowLayer, _ShadowLayerVolume);
              function CSMShadowLayer(level) {
                var _this;
                _this = _ShadowLayerVolume.call(this, level) || this;
                _this._splitCameraNear = 0;
                _this._splitCameraFar = 0;
                _this._csmAtlas = new Vec4();
                _this._calculateAtlas(level);
                return _this;
              }
              var _proto2 = CSMShadowLayer.prototype;
              _proto2.destroy = function destroy() {
                _ShadowLayerVolume.prototype.destroy.call(this);
              };
              _proto2._calculateAtlas = function _calculateAtlas(level) {
                var clipSpaceSignY = cclegacy.director.root.device.capabilities.clipSpaceSignY;
                var x = level % 2 - 0.5;
                var y = (0.5 - Math.floor(level / 2)) * clipSpaceSignY;
                this._csmAtlas.set(0.5, 0.5, x, y);
              };
              _createClass(CSMShadowLayer, [{
                key: "splitCameraNear",
                get: function get() {
                  return this._splitCameraNear;
                },
                set: function set(val) {
                  this._splitCameraNear = val;
                }
              }, {
                key: "splitCameraFar",
                get: function get() {
                  return this._splitCameraFar;
                },
                set: function set(val) {
                  this._splitCameraFar = val;
                }
              }, {
                key: "csmAtlas",
                get: function get() {
                  return this._csmAtlas;
                },
                set: function set(val) {
                  this._csmAtlas = val;
                }
              }]);
              return CSMShadowLayer;
            }(ShadowLayerVolume);
            var CSMLayers = function () {
              function CSMLayers() {
                this._castShadowObjects = [];
                this._layerObjects = new CachedArray(64);
                this._layers = [];
                this._levelCount = 0;
                this._specialLayer = new ShadowLayerVolume(1);
                this._shadowDistance = 0;
                for (var i = 0; i < CSMLevel.LEVEL_4; i++) {
                  this._layers[i] = new CSMShadowLayer(i);
                }
              }
              var _proto3 = CSMLayers.prototype;
              _proto3.update = function update(sceneData, camera) {
                var scene = camera.scene;
                var dirLight = scene.mainLight;
                if (dirLight === null) {
                  return;
                }
                var shadowInfo = sceneData.shadows;
                var levelCount = cclegacy.director.root.pipeline.pipelineSceneData.csmSupported ? dirLight.csmLevel : 1;
                var shadowDistance = dirLight.shadowDistance;
                if (!shadowInfo.enabled || !dirLight.shadowEnabled) {
                  return;
                }
                if (dirLight.shadowFixedArea) {
                  this._updateFixedArea(dirLight);
                } else {
                  if (dirLight.csmNeedUpdate || this._levelCount !== levelCount || this._shadowDistance !== shadowDistance) {
                    this._splitFrustumLevels(dirLight);
                    this._levelCount = levelCount;
                    this._shadowDistance = shadowDistance;
                  }
                  this._calculateCSM(camera, dirLight, shadowInfo);
                }
              };
              _proto3.destroy = function destroy() {
                this._castShadowObjects.length = 0;
                for (var i = 0; i < this._layers.length; i++) {
                  this._layers[i].destroy();
                }
                this._layers.length = 0;
              };
              _proto3._updateFixedArea = function _updateFixedArea(dirLight) {
                var device = cclegacy.director.root.device;
                var x = dirLight.shadowOrthoSize;
                var y = dirLight.shadowOrthoSize;
                var near = dirLight.shadowNear;
                var far = dirLight.shadowFar;
                Mat4.fromRT(_matShadowTrans, dirLight.node.worldRotation, dirLight.node.worldPosition);
                Mat4.invert(_matShadowView, _matShadowTrans);
                Mat4.ortho(_matShadowProj, -x, x, -y, y, near, far, device.capabilities.clipSpaceMinZ, device.capabilities.clipSpaceSignY);
                Mat4.multiply(_matShadowViewProj, _matShadowProj, _matShadowView);
                this._specialLayer.matShadowView = _matShadowView;
                this._specialLayer.matShadowProj = _matShadowProj;
                this._specialLayer.matShadowViewProj = _matShadowViewProj;
                this._specialLayer.calculateValidFrustumOrtho(x * 2.0, y * 2.0, near, far, _matShadowTrans);
              };
              _proto3._splitFrustumLevels = function _splitFrustumLevels(dirLight) {
                var nd = 0.1;
                var fd = dirLight.shadowDistance;
                var ratio = fd / nd;
                var level = cclegacy.director.root.pipeline.pipelineSceneData.csmSupported ? dirLight.csmLevel : 1;
                var lambda = dirLight.csmLayerLambda;
                this._layers[0].splitCameraNear = nd;
                for (var i = 1; i < level; i++) {
                  var si = i / level;
                  var preNear = lambda * (nd * Math.pow(ratio, si)) + (1 - lambda) * (nd + (fd - nd) * si);
                  var nextFar = preNear * 1.005;
                  this._layers[i].splitCameraNear = preNear;
                  this._layers[i - 1].splitCameraFar = nextFar;
                }
                this._layers[level - 1].splitCameraFar = fd;
                dirLight.csmNeedUpdate = false;
              };
              _proto3._calculateCSM = function _calculateCSM(camera, dirLight, shadowInfo) {
                var level = cclegacy.director.root.pipeline.pipelineSceneData.csmSupported ? dirLight.csmLevel : 1;
                var shadowMapWidth = level > 1 ? shadowInfo.size.x * 0.5 : shadowInfo.size.x;
                if (shadowMapWidth < 0.0) {
                  return;
                }
                this._getCameraWorldMatrix(_mat4Trans, camera);
                for (var i = level - 1; i >= 0; i--) {
                  var csmLayer = this._layers[i];
                  var near = csmLayer.splitCameraNear;
                  var far = csmLayer.splitCameraFar;
                  csmLayer.calculateSplitFrustum(camera, _mat4Trans, near, far);
                  csmLayer.createMatrix(dirLight, shadowMapWidth, false);
                }
                if (level === CSMLevel.LEVEL_1) {
                  this._specialLayer.shadowCameraFar = this._layers[0].shadowCameraFar;
                  Mat4.copy(this._specialLayer.matShadowView, this._layers[0].matShadowView);
                  Mat4.copy(this._specialLayer.matShadowProj, this._layers[0].matShadowProj);
                  Mat4.copy(this._specialLayer.matShadowViewProj, this._layers[0].matShadowViewProj);
                  this._specialLayer.copyToValidFrustum(this._layers[0].validFrustum);
                } else {
                  this._specialLayer.calculateSplitFrustum(camera, _mat4Trans, 0.1, dirLight.shadowDistance);
                  this._specialLayer.createMatrix(dirLight, shadowMapWidth, true);
                }
              };
              _proto3._getCameraWorldMatrix = function _getCameraWorldMatrix(out, camera) {
                if (!camera.node) {
                  return;
                }
                var cameraNode = camera.node;
                var position = cameraNode.worldPosition;
                var rotation = cameraNode.worldRotation;
                Mat4.fromRT(out, rotation, position);
              };
              _createClass(CSMLayers, [{
                key: "castShadowObjects",
                get: function get() {
                  return this._castShadowObjects;
                }
              }, {
                key: "layerObjects",
                get: function get() {
                  return this._layerObjects;
                }
              }, {
                key: "layers",
                get: function get() {
                  return this._layers;
                }
              }, {
                key: "specialLayer",
                get: function get() {
                  return this._specialLayer;
                }
              }]);
              return CSMLayers;
            }();

            var GEOMETRY_RENDERER_TECHNIQUE_COUNT = 6;
            var PipelineSceneData = exports("PipelineSceneData", function () {
              function PipelineSceneData() {
                this.fog = new Fog();
                this.ambient = new Ambient();
                this.skybox = new Skybox();
                this.shadows = new Shadows();
                this.csmLayers = new CSMLayers();
                this.octree = new Octree();
                this.skin = new Skin();
                this.postSettings = new PostSettings();
                this.lightProbes = cclegacy.internal.LightProbes ? new cclegacy.internal.LightProbes() : null;
                this.validPunctualLights = [];
                this.renderObjects = [];
                this.shadowFrameBufferMap = new Map();
                this._geometryRendererMaterials = [];
                this._geometryRendererPasses = [];
                this._geometryRendererShaders = [];
                this._occlusionQueryVertexBuffer = null;
                this._occlusionQueryIndicesBuffer = null;
                this._occlusionQueryInputAssembler = null;
                this._occlusionQueryMaterial = null;
                this._occlusionQueryShader = null;
                this._isHDR = true;
                this._shadingScale = 1.0;
                this._csmSupported = true;
                this._standardSkinMeshRenderer = null;
                this._standardSkinModel = null;
                this._skinMaterialModel = null;
                this._shadingScale = 1.0;
              }
              var _proto = PipelineSceneData.prototype;
              _proto.activate = function activate(device) {
                this._device = device;
                this.initGeometryRendererMaterials();
                this.initOcclusionQuery();
                return true;
              };
              _proto.initGeometryRendererMaterials = function initGeometryRendererMaterials() {
                var offset = 0;
                var geometryRendererMaterials = this._geometryRendererMaterials;
                for (var tech = 0; tech < GEOMETRY_RENDERER_TECHNIQUE_COUNT; tech++) {
                  geometryRendererMaterials[tech] = new Material();
                  geometryRendererMaterials[tech]._uuid = "geometry-renderer-material-" + tech;
                  geometryRendererMaterials[tech].initialize({
                    effectName: 'internal/builtin-geometry-renderer',
                    technique: tech
                  });
                  var passes = geometryRendererMaterials[tech].passes;
                  for (var pass = 0; pass < passes.length; ++pass) {
                    this._geometryRendererPasses[offset] = passes[pass];
                    this._geometryRendererShaders[offset] = passes[pass].getShaderVariant();
                    offset++;
                  }
                }
              };
              _proto.initOcclusionQuery = function initOcclusionQuery() {
                if (!this._occlusionQueryInputAssembler) {
                  this._occlusionQueryInputAssembler = this._createOcclusionQueryIA();
                }
                if (!this._occlusionQueryMaterial) {
                  var mat = new Material();
                  mat._uuid = 'default-occlusion-query-material';
                  mat.initialize({
                    effectName: 'internal/builtin-occlusion-query'
                  });
                  this._occlusionQueryMaterial = mat;
                  if (mat.passes.length > 0) {
                    this._occlusionQueryShader = mat.passes[0].getShaderVariant();
                  }
                }
              };
              _proto.getOcclusionQueryPass = function getOcclusionQueryPass() {
                if (this._occlusionQueryMaterial && this._occlusionQueryMaterial.passes.length > 0) {
                  return this._occlusionQueryMaterial.passes[0];
                }
                return null;
              };
              _proto.updatePipelineSceneData = function updatePipelineSceneData() {};
              _proto.destroy = function destroy() {
                var _this$_occlusionQuery, _this$_occlusionQuery2, _this$_occlusionQuery3;
                this.shadows.destroy();
                this.csmLayers.destroy();
                this.validPunctualLights.length = 0;
                (_this$_occlusionQuery = this._occlusionQueryInputAssembler) == null ? undefined : _this$_occlusionQuery.destroy();
                this._occlusionQueryInputAssembler = null;
                (_this$_occlusionQuery2 = this._occlusionQueryVertexBuffer) == null ? undefined : _this$_occlusionQuery2.destroy();
                this._occlusionQueryVertexBuffer = null;
                (_this$_occlusionQuery3 = this._occlusionQueryIndicesBuffer) == null ? undefined : _this$_occlusionQuery3.destroy();
                this._occlusionQueryIndicesBuffer = null;
                this._standardSkinMeshRenderer = null;
                this._standardSkinModel = null;
                this._skinMaterialModel = null;
              };
              _proto._createOcclusionQueryIA = function _createOcclusionQueryIA() {
                var device = this._device;
                var vertices = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1]);
                var vbStride = 4 * 3;
                var vbSize = vbStride * 8;
                this._occlusionQueryVertexBuffer = device.createBuffer(new BufferInfo(8 | 2, 1, vbSize, vbStride));
                this._occlusionQueryVertexBuffer.update(vertices);
                var indices = new Uint16Array([0, 2, 1, 1, 2, 3, 4, 5, 6, 5, 7, 6, 1, 3, 7, 1, 7, 5, 0, 4, 6, 0, 6, 2, 0, 1, 5, 0, 5, 4, 2, 6, 7, 2, 7, 3]);
                var ibStride = 2;
                var ibSize = ibStride * 36;
                this._occlusionQueryIndicesBuffer = device.createBuffer(new BufferInfo(4 | 2, 1, ibSize, ibStride));
                this._occlusionQueryIndicesBuffer.update(indices);
                var attributes = [new Attribute('a_position', 32)];
                var info = new InputAssemblerInfo(attributes, [this._occlusionQueryVertexBuffer], this._occlusionQueryIndicesBuffer);
                var inputAssembler = device.createInputAssembler(info);
                return inputAssembler;
              };
              _createClass(PipelineSceneData, [{
                key: "isHDR",
                get: function get() {
                  return this._isHDR;
                },
                set: function set(val) {
                  this._isHDR = val;
                }
              }, {
                key: "shadingScale",
                get: function get() {
                  return this._shadingScale;
                },
                set: function set(val) {
                  this._shadingScale = val;
                }
              }, {
                key: "csmSupported",
                get: function get() {
                  return this._csmSupported;
                },
                set: function set(val) {
                  this._csmSupported = val;
                }
              }, {
                key: "standardSkinModel",
                get: function get() {
                  return this._standardSkinModel;
                },
                set: function set(val) {
                  this._standardSkinModel = val;
                }
              }, {
                key: "standardSkinMeshRenderer",
                get: function get() {
                  return this._standardSkinMeshRenderer;
                },
                set: function set(val) {
                  if (this._standardSkinMeshRenderer && this._standardSkinMeshRenderer !== val) {
                    this._standardSkinMeshRenderer.clearGlobalStandardSkinObjectFlag();
                  }
                  this._standardSkinMeshRenderer = val;
                  this.standardSkinModel = val ? val.model : null;
                }
              }, {
                key: "skinMaterialModel",
                get: function get() {
                  return this._skinMaterialModel;
                },
                set: function set(val) {
                  this._skinMaterialModel = val;
                }
              }, {
                key: "geometryRendererPasses",
                get: function get() {
                  return this._geometryRendererPasses;
                }
              }, {
                key: "geometryRendererShaders",
                get: function get() {
                  return this._geometryRendererShaders;
                }
              }]);
              return PipelineSceneData;
            }());

            var _orientationMap;
            var localWinSize = size();
            var orientationMap = (_orientationMap = {}, _orientationMap[macro.ORIENTATION_AUTO] = Orientation.AUTO, _orientationMap[macro.ORIENTATION_LANDSCAPE] = Orientation.LANDSCAPE, _orientationMap[macro.ORIENTATION_PORTRAIT] = Orientation.PORTRAIT, _orientationMap);
            var View = function (_Eventify) {
              _inheritsLoose(View, _Eventify);
              function View() {
                var _this;
                _this = _Eventify.call(this) || this;
                _this._designResolutionSize = size(0, 0);
                _this._scaleX = 1;
                _this._scaleY = 1;
                _this._viewportRect = rect();
                _this._visibleRect = rect();
                _this._autoFullScreen = false;
                _this._retinaEnabled = false;
                _this._resizeCallback = null;
                var _strategyer = ContainerStrategy;
                var _strategy = ContentStrategy;
                _this._rpExactFit = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
                _this._rpShowAll = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL);
                _this._rpNoBorder = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
                _this._rpFixedHeight = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
                _this._rpFixedWidth = new ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
                _this._resolutionPolicy = _this._rpShowAll;
                return _this;
              }
              var _proto = View.prototype;
              _proto.init = function init() {
                var windowSize = screen$1.windowSize;
                var w = windowSize.width;
                var h = windowSize.height;
                this._designResolutionSize.width = w;
                this._designResolutionSize.height = h;
                this._viewportRect.width = w;
                this._viewportRect.height = h;
                this._visibleRect.width = w;
                this._visibleRect.height = h;
                localWinSize.width = this._visibleRect.width;
                localWinSize.height = this._visibleRect.height;
                {
                  visibleRect.init(this._visibleRect);
                }
                {
                  this.resizeWithBrowserSize(true);
                  var designResolution = settings.querySettings("screen", 'designResolution');
                  if (designResolution) {
                    this.setDesignResolutionSize(Number(designResolution.width), Number(designResolution.height), designResolution.policy || ResolutionPolicy.FIXED_HEIGHT);
                  }
                }
                screen$1.on('window-resize', this._updateAdaptResult, this);
                screen$1.on('fullscreen-change', this._updateAdaptResult, this);
              };
              _proto.resizeWithBrowserSize = function resizeWithBrowserSize(enabled) {
                screenAdapter.handleResizeEvent = enabled;
              };
              _proto.setResizeCallback = function setResizeCallback(callback) {
                if (typeof callback === 'function' || callback == null) {
                  this._resizeCallback = callback;
                }
              };
              _proto.setOrientation = function setOrientation(orientation) {
                screenAdapter.orientation = orientationMap[orientation];
              };
              _proto.adjustViewportMeta = function adjustViewportMeta(enabled) {};
              _proto.enableRetina = function enableRetina(enabled) {
                this._retinaEnabled = !!enabled;
              };
              _proto.isRetinaEnabled = function isRetinaEnabled() {
                return this._retinaEnabled;
              };
              _proto.enableAutoFullScreen = function enableAutoFullScreen(enabled) {
                if (enabled === this._autoFullScreen) {
                  return;
                }
                this._autoFullScreen = enabled;
                if (enabled) {
                  screen$1.requestFullScreen()["catch"](function (e) {});
                }
              };
              _proto.isAutoFullScreenEnabled = function isAutoFullScreenEnabled() {
                return this._autoFullScreen;
              };
              _proto.setCanvasSize = function setCanvasSize(width, height) {
                screenAdapter.resolutionScale = 1;
                var dpr = screenAdapter.devicePixelRatio;
                var windowSize = new Size(width * dpr, height * dpr);
                screen$1.windowSize = windowSize;
              };
              _proto.getCanvasSize = function getCanvasSize() {
                return screen$1.windowSize;
              };
              _proto.getFrameSize = function getFrameSize() {
                var dpr = screenAdapter.devicePixelRatio;
                var sizeInCssPixels = screen$1.windowSize;
                sizeInCssPixels.width /= dpr;
                sizeInCssPixels.height /= dpr;
                return sizeInCssPixels;
              };
              _proto.setFrameSize = function setFrameSize(width, height) {
                var dpr = screenAdapter.devicePixelRatio;
                screen$1.windowSize = new Size(width * dpr, height * dpr);
              };
              _proto.getVisibleSize = function getVisibleSize() {
                return new Size(this._visibleRect.width, this._visibleRect.height);
              };
              _proto.getVisibleSizeInPixel = function getVisibleSizeInPixel() {
                return new Size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
              };
              _proto.getVisibleOrigin = function getVisibleOrigin() {
                return new Vec2(this._visibleRect.x, this._visibleRect.y);
              };
              _proto.getVisibleOriginInPixel = function getVisibleOriginInPixel() {
                return new Vec2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
              };
              _proto.getResolutionPolicy = function getResolutionPolicy() {
                return this._resolutionPolicy;
              };
              _proto._updateResolutionPolicy = function _updateResolutionPolicy(resolutionPolicy) {
                if (resolutionPolicy instanceof ResolutionPolicy) {
                  this._resolutionPolicy = resolutionPolicy;
                } else {
                  var _locPolicy = ResolutionPolicy;
                  if (resolutionPolicy === _locPolicy.EXACT_FIT) {
                    this._resolutionPolicy = this._rpExactFit;
                  }
                  if (resolutionPolicy === _locPolicy.SHOW_ALL) {
                    this._resolutionPolicy = this._rpShowAll;
                  }
                  if (resolutionPolicy === _locPolicy.NO_BORDER) {
                    this._resolutionPolicy = this._rpNoBorder;
                  }
                  if (resolutionPolicy === _locPolicy.FIXED_HEIGHT) {
                    this._resolutionPolicy = this._rpFixedHeight;
                  }
                  if (resolutionPolicy === _locPolicy.FIXED_WIDTH) {
                    this._resolutionPolicy = this._rpFixedWidth;
                  }
                }
              };
              _proto.setResolutionPolicy = function setResolutionPolicy(resolutionPolicy) {
                this._updateResolutionPolicy(resolutionPolicy);
                var designedResolution = view.getDesignResolutionSize();
                view.setDesignResolutionSize(designedResolution.width, designedResolution.height, resolutionPolicy);
              };
              _proto.setDesignResolutionSize = function setDesignResolutionSize(width, height, resolutionPolicy) {
                if (!(width > 0 && height > 0)) {
                  errorID(2200);
                  return;
                }
                this._updateResolutionPolicy(resolutionPolicy);
                var policy = this._resolutionPolicy;
                if (policy) {
                  policy.preApply(this);
                }
                this._designResolutionSize.width = width;
                this._designResolutionSize.height = height;
                var result = policy.apply(this, this._designResolutionSize);
                if (result.scale && result.scale.length === 2) {
                  this._scaleX = result.scale[0];
                  this._scaleY = result.scale[1];
                }
                if (result.viewport) {
                  var vp = this._viewportRect;
                  var vb = this._visibleRect;
                  var rv = result.viewport;
                  vp.x = rv.x;
                  vp.y = rv.y;
                  vp.width = rv.width;
                  vp.height = rv.height;
                  vb.x = 0;
                  vb.y = 0;
                  vb.width = rv.width / this._scaleX;
                  vb.height = rv.height / this._scaleY;
                }
                policy.postApply(this);
                localWinSize.width = this._visibleRect.width;
                localWinSize.height = this._visibleRect.height;
                {
                  visibleRect.init(this._visibleRect);
                }
                this.emit('design-resolution-changed');
              };
              _proto.getDesignResolutionSize = function getDesignResolutionSize() {
                return new Size(this._designResolutionSize.width, this._designResolutionSize.height);
              };
              _proto.setRealPixelResolution = function setRealPixelResolution(width, height, resolutionPolicy) {
                {
                  document.documentElement.style.width = width + "px";
                  document.body.style.width = width + "px";
                  document.body.style.left = '0px';
                  document.body.style.top = '0px';
                }
                this.setDesignResolutionSize(width, height, resolutionPolicy);
              };
              _proto.getViewportRect = function getViewportRect() {
                return this._viewportRect;
              };
              _proto.getScaleX = function getScaleX() {
                return this._scaleX;
              };
              _proto.getScaleY = function getScaleY() {
                return this._scaleY;
              };
              _proto.getDevicePixelRatio = function getDevicePixelRatio() {
                return screenAdapter.devicePixelRatio;
              };
              _proto.convertToLocationInView = function convertToLocationInView(tx, ty, relatedPos, out) {
                if (out === undefined) {
                  out = new Vec2();
                }
                var x = screenAdapter.devicePixelRatio * (tx - relatedPos.left);
                var y = screenAdapter.devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
                if (screenAdapter.isFrameRotated) {
                  out.x = screen$1.windowSize.width - y;
                  out.y = x;
                } else {
                  out.x = x;
                  out.y = y;
                }
                return out;
              };
              _proto._convertToUISpace = function _convertToUISpace(point) {
                var viewport = this._viewportRect;
                point.x = (point.x - viewport.x) / this._scaleX;
                point.y = (point.y - viewport.y) / this._scaleY;
              };
              _proto._updateAdaptResult = function _updateAdaptResult(width, height, windowId) {
                cclegacy.director.root.resize(width, height, windowId === undefined || windowId === 0 ? 1 : windowId);
                var designResolutionSize = this._designResolutionSize;
                var w = designResolutionSize.width;
                var h = designResolutionSize.height;
                if (width > 0 && height > 0) {
                  this.setDesignResolutionSize(w, h, this._resolutionPolicy);
                } else {
                  assert(false, '_updateAdaptResult Invalid size.');
                }
                this.emit('canvas-resize');
                if (this._resizeCallback) this._resizeCallback();
              };
              return View;
            }(Eventify(System));
            View.instance = undefined;
            var ContainerStrategy = function () {
              function ContainerStrategy() {
                this.name = 'ContainerStrategy';
              }
              var _proto2 = ContainerStrategy.prototype;
              _proto2.preApply = function preApply(_view) {};
              _proto2.apply = function apply(_view, designedResolution) {};
              _proto2.postApply = function postApply(_view) {};
              _proto2._setupCanvas = function _setupCanvas() {
                var locCanvas = cclegacy.game.canvas;
                if (locCanvas) {
                  var windowSize = screen$1.windowSize;
                  if (locCanvas.width !== windowSize.width) {
                    locCanvas.width = windowSize.width;
                  }
                  if (locCanvas.height !== windowSize.height) {
                    locCanvas.height = windowSize.height;
                  }
                }
              };
              return ContainerStrategy;
            }();
            ContainerStrategy.EQUAL_TO_FRAME = undefined;
            ContainerStrategy.PROPORTION_TO_FRAME = undefined;
            var ContentStrategy = function () {
              function ContentStrategy() {
                this.name = 'ContentStrategy';
                this._result = {
                  scale: [1, 1],
                  viewport: null
                };
                this._strategy = ResolutionPolicy.UNKNOWN;
              }
              var _proto3 = ContentStrategy.prototype;
              _proto3.preApply = function preApply(_view) {};
              _proto3.apply = function apply(_view, designedResolution) {
                return {
                  scale: [1, 1]
                };
              };
              _proto3.postApply = function postApply(_view) {};
              _proto3._buildResult = function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
                if (Math.abs(containerW - contentW) < 2) {
                  contentW = containerW;
                }
                if (Math.abs(containerH - contentH) < 2) {
                  contentH = containerH;
                }
                var viewport = new Rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
                var result = this._result;
                result.scale = [scaleX, scaleY];
                result.viewport = viewport;
                return result;
              };
              _createClass(ContentStrategy, [{
                key: "strategy",
                get: function get() {
                  return this._strategy;
                }
              }]);
              return ContentStrategy;
            }();
            var EqualToFrame = function (_ContainerStrategy) {
              _inheritsLoose(EqualToFrame, _ContainerStrategy);
              function EqualToFrame() {
                var _this2;
                _this2 = _ContainerStrategy.call(this) || this;
                _this2.name = 'EqualToFrame';
                return _this2;
              }
              var _proto4 = EqualToFrame.prototype;
              _proto4.apply = function apply(_view, designedResolution) {
                screenAdapter.isProportionalToFrame = false;
                this._setupCanvas();
              };
              return EqualToFrame;
            }(ContainerStrategy);
            var ProportionalToFrame = function (_ContainerStrategy2) {
              _inheritsLoose(ProportionalToFrame, _ContainerStrategy2);
              function ProportionalToFrame() {
                var _this3;
                _this3 = _ContainerStrategy2.call(this) || this;
                _this3.name = 'ProportionalToFrame';
                return _this3;
              }
              var _proto5 = ProportionalToFrame.prototype;
              _proto5.apply = function apply(_view, designedResolution) {
                screenAdapter.isProportionalToFrame = true;
                this._setupCanvas();
              };
              return ProportionalToFrame;
            }(ContainerStrategy);
            ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
            ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
            var ExactFit = function (_ContentStrategy) {
              _inheritsLoose(ExactFit, _ContentStrategy);
              function ExactFit() {
                var _this4;
                _this4 = _ContentStrategy.call(this) || this;
                _this4.name = 'ExactFit';
                _this4._strategy = ResolutionPolicy.EXACT_FIT;
                return _this4;
              }
              var _proto6 = ExactFit.prototype;
              _proto6.apply = function apply(_view, designedResolution) {
                var windowSize = screen$1.windowSize;
                var containerW = windowSize.width;
                var containerH = windowSize.height;
                var scaleX = containerW / designedResolution.width;
                var scaleY = containerH / designedResolution.height;
                return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
              };
              return ExactFit;
            }(ContentStrategy);
            var ShowAll = function (_ContentStrategy2) {
              _inheritsLoose(ShowAll, _ContentStrategy2);
              function ShowAll() {
                var _this5;
                _this5 = _ContentStrategy2.call(this) || this;
                _this5.name = 'ShowAll';
                _this5._strategy = ResolutionPolicy.SHOW_ALL;
                return _this5;
              }
              var _proto7 = ShowAll.prototype;
              _proto7.apply = function apply(_view, designedResolution) {
                var windowSize = screen$1.windowSize;
                var containerW = windowSize.width;
                var containerH = windowSize.height;
                var designW = designedResolution.width;
                var designH = designedResolution.height;
                var scaleX = containerW / designW;
                var scaleY = containerH / designH;
                var scale = 0;
                var contentW;
                var contentH;
                if (scaleX < scaleY) {
                  scale = scaleX;
                  contentW = containerW;
                  contentH = designH * scale;
                } else {
                  scale = scaleY;
                  contentW = designW * scale;
                  contentH = containerH;
                }
                return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
              };
              return ShowAll;
            }(ContentStrategy);
            var NoBorder = function (_ContentStrategy3) {
              _inheritsLoose(NoBorder, _ContentStrategy3);
              function NoBorder() {
                var _this6;
                _this6 = _ContentStrategy3.call(this) || this;
                _this6.name = 'NoBorder';
                _this6._strategy = ResolutionPolicy.NO_BORDER;
                return _this6;
              }
              var _proto8 = NoBorder.prototype;
              _proto8.apply = function apply(_view, designedResolution) {
                var windowSize = screen$1.windowSize;
                var containerW = windowSize.width;
                var containerH = windowSize.height;
                var designW = designedResolution.width;
                var designH = designedResolution.height;
                var scaleX = containerW / designW;
                var scaleY = containerH / designH;
                var scale;
                var contentW;
                var contentH;
                if (scaleX < scaleY) {
                  scale = scaleY;
                  contentW = designW * scale;
                  contentH = containerH;
                } else {
                  scale = scaleX;
                  contentW = containerW;
                  contentH = designH * scale;
                }
                return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
              };
              return NoBorder;
            }(ContentStrategy);
            var FixedHeight = function (_ContentStrategy4) {
              _inheritsLoose(FixedHeight, _ContentStrategy4);
              function FixedHeight() {
                var _this7;
                _this7 = _ContentStrategy4.call(this) || this;
                _this7.name = 'FixedHeight';
                _this7._strategy = ResolutionPolicy.FIXED_HEIGHT;
                return _this7;
              }
              var _proto9 = FixedHeight.prototype;
              _proto9.apply = function apply(_view, designedResolution) {
                var windowSize = screen$1.windowSize;
                var containerW = windowSize.width;
                var containerH = windowSize.height;
                var designH = designedResolution.height;
                var scale = containerH / designH;
                var contentW = containerW;
                var contentH = containerH;
                return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
              };
              return FixedHeight;
            }(ContentStrategy);
            var FixedWidth = function (_ContentStrategy5) {
              _inheritsLoose(FixedWidth, _ContentStrategy5);
              function FixedWidth() {
                var _this8;
                _this8 = _ContentStrategy5.call(this) || this;
                _this8.name = 'FixedWidth';
                _this8._strategy = ResolutionPolicy.FIXED_WIDTH;
                return _this8;
              }
              var _proto10 = FixedWidth.prototype;
              _proto10.apply = function apply(_view, designedResolution) {
                var windowSize = screen$1.windowSize;
                var containerW = windowSize.width;
                var containerH = windowSize.height;
                var designW = designedResolution.width;
                var scale = containerW / designW;
                var contentW = containerW;
                var contentH = containerH;
                return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
              };
              return FixedWidth;
            }(ContentStrategy);
            var ResolutionPolicy = function () {
              function ResolutionPolicy(containerStg, contentStg) {
                this.name = 'ResolutionPolicy';
                this._containerStrategy = containerStg;
                this._contentStrategy = contentStg;
              }
              var _proto11 = ResolutionPolicy.prototype;
              _proto11.preApply = function preApply(_view) {
                this._contentStrategy.preApply(_view);
              };
              _proto11.apply = function apply(_view, designedResolution) {
                this._containerStrategy.apply(_view, designedResolution);
                return this._contentStrategy.apply(_view, designedResolution);
              };
              _proto11.postApply = function postApply(_view) {
                this._contentStrategy.postApply(_view);
              };
              _proto11.setContainerStrategy = function setContainerStrategy(containerStg) {
                this._containerStrategy = containerStg;
              };
              _proto11.setContentStrategy = function setContentStrategy(contentStg) {
                this._contentStrategy = contentStg;
              };
              _proto11.getContentStrategy = function getContentStrategy() {
                return this._contentStrategy;
              };
              _createClass(ResolutionPolicy, [{
                key: "canvasSize",
                get: function get() {
                  return screen$1.windowSize;
                }
              }]);
              return ResolutionPolicy;
            }();
            ResolutionPolicy.EXACT_FIT = 0;
            ResolutionPolicy.NO_BORDER = 1;
            ResolutionPolicy.SHOW_ALL = 2;
            ResolutionPolicy.FIXED_HEIGHT = 3;
            ResolutionPolicy.FIXED_WIDTH = 4;
            ResolutionPolicy.UNKNOWN = 5;
            ResolutionPolicy.ContainerStrategy = ContainerStrategy;
            ResolutionPolicy.ContentStrategy = ContentStrategy;
            cclegacy.ResolutionPolicy = ResolutionPolicy;
            ContentStrategy.EXACT_FIT = new ExactFit();
            ContentStrategy.SHOW_ALL = new ShowAll();
            ContentStrategy.NO_BORDER = new NoBorder();
            ContentStrategy.FIXED_HEIGHT = new FixedHeight();
            ContentStrategy.FIXED_WIDTH = new FixedWidth();
            var view = View.instance = cclegacy.view = new View();
            director.registerSystem('view', view, 0);
            cclegacy.winSize = localWinSize;

            var v2_0 = new Vec2();
            function setMaterialProperty(mat, key, value, passIdx) {
              mat.setProperty(key, value, passIdx);
            }
            var SplashScreen = function () {
              var _proto = SplashScreen.prototype;
              _proto.init = function init() {
                var _policy,
                  _settings$querySettin,
                  _settings$querySettin2,
                  _settings$querySettin3,
                  _settings$querySettin4,
                  _settings$querySettin5,
                  _settings$querySettin6,
                  _this = this;
                var policy = ResolutionPolicy.SHOW_ALL;
                {
                  var designResolution = settings.querySettings("screen", 'designResolution');
                  if (designResolution !== null) {
                    policy = designResolution.policy;
                  }
                }
                this.settings = {
                  policy: (_policy = policy) !== null && _policy !== undefined ? _policy : ResolutionPolicy.SHOW_ALL,
                  displayRatio: (_settings$querySettin = settings.querySettings("splashScreen", 'displayRatio')) !== null && _settings$querySettin !== undefined ? _settings$querySettin : 0.4,
                  totalTime: (_settings$querySettin2 = settings.querySettings("splashScreen", 'totalTime')) !== null && _settings$querySettin2 !== undefined ? _settings$querySettin2 : 3000,
                  watermarkLocation: (_settings$querySettin3 = settings.querySettings("splashScreen", 'watermarkLocation')) !== null && _settings$querySettin3 !== undefined ? _settings$querySettin3 : 'default',
                  autoFit: (_settings$querySettin4 = settings.querySettings("splashScreen", 'autoFit')) !== null && _settings$querySettin4 !== undefined ? _settings$querySettin4 : true,
                  logo: (_settings$querySettin5 = settings.querySettings("splashScreen", 'logo')) !== null && _settings$querySettin5 !== undefined ? _settings$querySettin5 : undefined,
                  background: (_settings$querySettin6 = settings.querySettings("splashScreen", 'background')) !== null && _settings$querySettin6 !== undefined ? _settings$querySettin6 : undefined
                };
                this._curTime = 0;
                if (this.settings.totalTime <= 0 || this.settings.logo === undefined || this.settings.background === undefined) {
                  this.settings.totalTime = 0;
                } else {
                  this.device = cclegacy.director.root.device;
                  this.swapchain = cclegacy.director.root.mainWindow.swapchain;
                  this.preInit();
                  this.initLayout();
                  if (this.settings.logo.type === 'default') {
                    this.initWaterMark();
                  }
                  var bgPromise = Promise.resolve();
                  var logoPromise = Promise.resolve();
                  if (this.settings.background.type === 'custom') {
                    bgPromise = new Promise(function (resolve, reject) {
                      _this.bgImage = new ccwindow.Image();
                      _this.bgImage.onload = function () {
                        _this.initBG();
                        resolve();
                      };
                      _this.bgImage.onerror = function () {
                        reject();
                      };
                      _this.bgImage.src = _this.settings.background.base64;
                    });
                  }
                  if (this.settings.logo.type !== 'none') {
                    logoPromise = new Promise(function (resolve, reject) {
                      _this.logoImage = new ccwindow.Image();
                      _this.logoImage.onload = function () {
                        _this.initLogo();
                        resolve();
                      };
                      _this.logoImage.onerror = function () {
                        reject();
                      };
                      _this.logoImage.src = _this.settings.logo.base64;
                    });
                  }
                  return Promise.all([bgPromise, logoPromise]);
                }
                return Promise.resolve([]);
              };
              _proto.preInit = function preInit() {
                var _this$settings$backgr;
                var clearColor = (_this$settings$backgr = this.settings.background) == null ? undefined : _this$settings$backgr.color;
                this.clearColors = clearColor ? [new Color$1(clearColor.x, clearColor.y, clearColor.z, clearColor.w)] : [new Color$1(0, 0, 0, 1)];
                var device = this.device,
                  swapchain = this.swapchain;
                var capabilities = device.capabilities;
                this.renderArea = new Rect$1(0, 0, swapchain.width, swapchain.height);
                this.cmdBuff = device.commandBuffer;
                var verts = new Float32Array([0.5, 0.5, 1, 0, -0.5, 0.5, 0, 0, 0.5, -0.5, 1, 1, -0.5, -0.5, 0, 1]);
                var vbStride = 4 * 4;
                var vbSize = vbStride * 4;
                this.vertexBuffers = device.createBuffer(new BufferInfo(8 | 2, 1, vbSize, vbStride));
                this.vertexBuffers.update(verts);
                var indices = new Uint16Array([0, 1, 2, 1, 3, 2]);
                var ibStride = 2;
                var ibSize = ibStride * 6;
                this.indicesBuffers = device.createBuffer(new BufferInfo(4 | 2, 1, ibSize, ibStride));
                this.indicesBuffers.update(indices);
                var attributes = [new Attribute('a_position', 21), new Attribute('a_texCoord', 21)];
                var IAInfo = new InputAssemblerInfo(attributes, [this.vertexBuffers], this.indicesBuffers);
                this.quadAssmebler = device.createInputAssembler(IAInfo);
                this.projection = new Mat4();
                Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, capabilities.clipSpaceMinZ, capabilities.clipSpaceSignY, swapchain.surfaceTransform);
                this.isMobile = sys.isMobile;
              };
              _proto.initLayout = function initLayout() {
                if (this.isMobile) {
                  this.bgWidth = 812;
                  this.bgHeight = 375;
                  this.logoWidthTemp = 70;
                  this.logoHeightTemp = 100;
                  this.textSize = 12;
                  this.textHeight = this.textSize + this.textExpandSize;
                  this.textXTrans = 1 / 2;
                  this.textYExtraTrans = 16;
                } else {
                  this.bgWidth = 1920;
                  this.bgHeight = 1080;
                  this.logoWidthTemp = 140;
                  this.logoHeightTemp = 200;
                  this.textSize = 24;
                  this.textHeight = this.textSize + this.textExpandSize;
                  this.textXTrans = 1 / 2;
                  this.textYExtraTrans = 32;
                }
                this.logoXTrans = 1 / 2;
                this.logoYTrans = 1 / 6 + 2.5 / 6;
                this.initScale();
              };
              _proto.initScale = function initScale() {
                var dw = this.swapchain.width;
                var dh = this.swapchain.height;
                var desiredWidth = this.isMobile ? 375 : 1080;
                var desiredHeight = this.isMobile ? 812 : 1920;
                if (dw > dh) {
                  var temp = desiredHeight;
                  desiredHeight = desiredWidth;
                  desiredWidth = temp;
                }
                if (dw / dh > 16 / 9) {
                  this.scaleSize = dh / desiredHeight;
                } else {
                  this.scaleSize = dw / desiredWidth;
                }
              };
              _proto.update = function update(deltaTime) {
                var settings = this.settings;
                var device = this.device,
                  swapchain = this.swapchain;
                var capabilities = device.capabilities;
                Mat4.ortho(this.projection, -1, 1, -1, 1, -1, 1, capabilities.clipSpaceMinZ, capabilities.clipSpaceSignY, swapchain.surfaceTransform);
                var dw = swapchain.width;
                var dh = swapchain.height;
                this.initScale();
                this._curTime += deltaTime * 1000;
                var percent = clamp01(this._curTime / settings.totalTime);
                var u_p = cubicOut(percent);
                var scaleX = 1;
                var scaleY = 1;
                var bgImage = this.bgImage;
                if (settings.background.type === 'custom') {
                  if (settings.policy === ResolutionPolicy.FIXED_WIDTH) {
                    scaleX = dw;
                    scaleY = dw / bgImage.width * bgImage.height;
                  } else if (settings.policy === ResolutionPolicy.FIXED_HEIGHT) {
                    scaleX = dh / bgImage.height * bgImage.width;
                    scaleY = dh;
                  } else if (settings.policy === ResolutionPolicy.SHOW_ALL) {
                    if (bgImage.width / this.bgHeight > dw / dh) {
                      scaleX = dw;
                      scaleY = dw / bgImage.width * bgImage.height;
                    } else {
                      scaleX = dh / bgImage.height * bgImage.width;
                      scaleY = dh;
                    }
                  } else if (settings.policy === ResolutionPolicy.NO_BORDER) {
                    if (bgImage.width / bgImage.height > dw / dh) {
                      scaleX = dh / bgImage.height * bgImage.width;
                      scaleY = dh;
                    } else {
                      scaleX = dw;
                      scaleY = dw / bgImage.width * bgImage.height;
                    }
                  } else {
                    scaleX = dw;
                    scaleY = dh;
                  }
                  var bgMat = this.bgMat;
                  setMaterialProperty(bgMat, 'resolution', v2_0.set(dw, dh), 0);
                  setMaterialProperty(bgMat, 'scale', v2_0.set(scaleX, scaleY), 0);
                  setMaterialProperty(bgMat, 'translate', v2_0.set(dw * 0.5, dh * 0.5), 0);
                  setMaterialProperty(bgMat, 'percent', 1.0);
                  setMaterialProperty(bgMat, 'u_projection', this.projection);
                  bgMat.passes[0].update();
                }
                var logoYTrans = dh * this.logoYTrans;
                if (this.settings.logo.type !== 'none') {
                  scaleY = dh * 0.185 * settings.displayRatio;
                  scaleX = this.logoWidth * (dh * 0.185 / this.logoHeight) * settings.displayRatio;
                  var logoMat = this.logoMat;
                  setMaterialProperty(logoMat, 'resolution', v2_0.set(dw, dh), 0);
                  setMaterialProperty(logoMat, 'scale', v2_0.set(scaleX, scaleY), 0);
                  setMaterialProperty(logoMat, 'translate', v2_0.set(dw * this.logoXTrans, logoYTrans), 0);
                  setMaterialProperty(logoMat, 'percent', u_p);
                  setMaterialProperty(logoMat, 'u_projection', this.projection);
                  logoMat.passes[0].update();
                }
                if (this.settings.logo.type === 'default' && this.watermarkMat) {
                  var watermarkTW = this.watermarkTexture.width;
                  var watermarkTH = this.watermarkTexture.height;
                  scaleX = watermarkTW;
                  scaleY = watermarkTH;
                  var textYTrans = logoYTrans - (this.logoHeight * 0.5 * settings.displayRatio + this.textYExtraTrans) * this.scaleSize - watermarkTH * 0.5;
                  var watermarkMat = this.watermarkMat;
                  setMaterialProperty(watermarkMat, 'resolution', v2_0.set(dw, dh), 0);
                  setMaterialProperty(watermarkMat, 'scale', v2_0.set(scaleX, scaleY), 0);
                  setMaterialProperty(watermarkMat, 'translate', v2_0.set(dw * this.textXTrans, textYTrans), 0);
                  setMaterialProperty(watermarkMat, 'percent', u_p);
                  setMaterialProperty(watermarkMat, 'u_projection', this.projection);
                  watermarkMat.passes[0].update();
                }
                this.frame();
              };
              _proto.initBG = function initBG() {
                var device = this.device;
                this.bgMat = new Material();
                this.bgMat.initialize({
                  effectName: 'util/splash-screen'
                });
                var samplerInfo = new SamplerInfo();
                samplerInfo.addressU = 2;
                samplerInfo.addressV = 2;
                samplerInfo.addressW = 2;
                this.sampler = device.getSampler(samplerInfo);
                this.bgTexture = device.createTexture(new TextureInfo(1, 4 | 2, 35, this.bgImage.width, this.bgImage.height));
                var pass = this.bgMat.passes[0];
                var binding = pass.getBinding('mainTexture');
                pass.bindTexture(binding, this.bgTexture);
                this.shader = pass.getShaderVariant();
                var descriptorSet = pass.descriptorSet;
                descriptorSet.bindSampler(binding, this.sampler);
                descriptorSet.update();
                var region = new BufferTextureCopy();
                var regionTexExtent = region.texExtent;
                regionTexExtent.width = this.bgImage.width;
                regionTexExtent.height = this.bgImage.height;
                regionTexExtent.depth = 1;
                device.copyTexImagesToTexture([this.bgImage], this.bgTexture, [region]);
              };
              _proto.initLogo = function initLogo() {
                var device = this.device;
                this.logoMat = new Material();
                this.logoMat.initialize({
                  effectName: 'util/splash-screen'
                });
                var samplerInfo = new SamplerInfo();
                samplerInfo.addressU = 2;
                samplerInfo.addressV = 2;
                samplerInfo.addressW = 2;
                this.sampler = device.getSampler(samplerInfo);
                this.logoTexture = device.createTexture(new TextureInfo(1, 4 | 2, 35, this.logoImage.width, this.logoImage.height));
                var pass = this.logoMat.passes[0];
                var binding = pass.getBinding('mainTexture');
                pass.bindTexture(binding, this.logoTexture);
                this.shader = pass.getShaderVariant();
                var descriptorSet = pass.descriptorSet;
                descriptorSet.bindSampler(binding, this.sampler);
                descriptorSet.update();
                var region = new BufferTextureCopy();
                var regionTexExtent = region.texExtent;
                regionTexExtent.width = this.logoImage.width;
                regionTexExtent.height = this.logoImage.height;
                regionTexExtent.depth = 1;
                device.copyTexImagesToTexture([this.logoImage], this.logoTexture, [region]);
                var logoRatio = this.logoImage.width / this.logoImage.height;
                if (logoRatio < 1) {
                  this.logoWidth = this.logoWidthTemp;
                  this.logoHeight = this.logoWidthTemp / logoRatio;
                } else {
                  this.logoWidth = this.logoHeightTemp * logoRatio;
                  this.logoHeight = this.logoHeightTemp;
                }
              };
              _proto.initWaterMark = function initWaterMark() {
                var watermarkImg = ccwindow.document.createElement('canvas');
                watermarkImg.height = this.textHeight * this.scaleSize;
                watermarkImg.style.width = "" + watermarkImg.width;
                watermarkImg.style.height = "" + watermarkImg.height;
                var text = 'Created with Cocos';
                var ctx = watermarkImg.getContext('2d');
                ctx.font = this.textSize * this.scaleSize + "px Arial";
                ctx.textBaseline = 'top';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#707070';
                var textLength = ctx.measureText(text).width + 10;
                watermarkImg.width = textLength;
                ctx.font = this.textSize * this.scaleSize + "px Arial";
                ctx.textBaseline = 'top';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#707070';
                ctx.fillText(text, watermarkImg.width / 2, 0);
                var region = new BufferTextureCopy();
                var regionTexExtent = region.texExtent;
                regionTexExtent.width = watermarkImg.width;
                regionTexExtent.height = watermarkImg.height;
                regionTexExtent.depth = 1;
                this.watermarkTexture = this.device.createTexture(new TextureInfo(1, 4 | 2, 35, watermarkImg.width, watermarkImg.height));
                this.device.copyTexImagesToTexture([watermarkImg], this.watermarkTexture, [region]);
                this.watermarkMat = new Material();
                this.watermarkMat.initialize({
                  effectName: 'util/splash-screen'
                });
                var pass = this.watermarkMat.passes[0];
                var binding = pass.getBinding('mainTexture');
                pass.bindTexture(binding, this.watermarkTexture);
                pass.descriptorSet.update();
              };
              _proto.frame = function frame() {
                var device = this.device,
                  swapchain = this.swapchain;
                  this.projection;
                  var bgMat = this.bgMat,
                  logoMat = this.logoMat,
                  watermarkMat = this.watermarkMat,
                  settings = this.settings,
                  quadAssmebler = this.quadAssmebler;
                device.capabilities;
                if (!sys.isXR || xr.entry.isRenderAllowable()) {
                  var renderSize = sys.isXR ? 2 : 1;
                  for (var xrEye = 0; xrEye < renderSize; xrEye++) {
                    device.enableAutoBarrier(true);
                    device.acquire([swapchain]);
                    var cmdBuff = this.cmdBuff;
                    var framebuffer = cclegacy.director.root.mainWindow.framebuffer;
                    var renderArea = this.renderArea;
                    renderArea.width = swapchain.width;
                    renderArea.height = swapchain.height;
                    cmdBuff.begin();
                    cmdBuff.beginRenderPass(framebuffer.renderPass, framebuffer, renderArea, this.clearColors, 1.0, 0);
                    cclegacy.director.root.pipeline;
                    if (settings.background.type === 'custom') {
                      var bgPass = bgMat.passes[0];
                      var bgPso = PipelineStateManager.getOrCreatePipelineState(device, bgPass, this.shader, framebuffer.renderPass, quadAssmebler);
                      cmdBuff.bindPipelineState(bgPso);
                      cmdBuff.bindDescriptorSet(1, bgPass.descriptorSet);
                      cmdBuff.bindInputAssembler(quadAssmebler);
                      cmdBuff.draw(quadAssmebler);
                    }
                    if (settings.logo.type !== 'none') {
                      var logoPass = logoMat.passes[0];
                      var logoPso = PipelineStateManager.getOrCreatePipelineState(device, logoPass, this.shader, framebuffer.renderPass, quadAssmebler);
                      cmdBuff.bindPipelineState(logoPso);
                      cmdBuff.bindDescriptorSet(1, logoPass.descriptorSet);
                      cmdBuff.bindInputAssembler(quadAssmebler);
                      cmdBuff.draw(quadAssmebler);
                    }
                    if (settings.logo.type === 'default' && watermarkMat) {
                      var wartermarkPass = this.watermarkMat.passes[0];
                      var watermarkPso = PipelineStateManager.getOrCreatePipelineState(device, wartermarkPass, this.shader, framebuffer.renderPass, quadAssmebler);
                      cmdBuff.bindPipelineState(watermarkPso);
                      cmdBuff.bindDescriptorSet(1, wartermarkPass.descriptorSet);
                      cmdBuff.bindInputAssembler(quadAssmebler);
                      cmdBuff.draw(quadAssmebler);
                    }
                    cmdBuff.endRenderPass();
                    cmdBuff.end();
                    device.flushCommands([cmdBuff]);
                    device.queue.submit([cmdBuff]);
                    device.present();
                    device.enableAutoBarrier(!legacyCC.rendering);
                  }
                }
              };
              _proto.destroy = function destroy() {
                this.device = null;
                this.swapchain = null;
                this.clearColors = null;
                if (this.bgImage) {
                  if (this.bgImage.destroy) this.bgImage.destroy();
                  this.bgImage = null;
                }
                if (this.bgMat) {
                  this.bgMat.destroy();
                  this.bgMat = null;
                }
                if (this.bgTexture) {
                  this.bgTexture.destroy();
                  this.bgTexture = null;
                }
                if (this.logoImage) {
                  if (this.logoImage.destroy) this.logoImage.destroy();
                  this.logoImage = null;
                }
                if (this.logoMat) {
                  this.logoMat.destroy();
                  this.logoMat = null;
                }
                if (this.logoTexture) {
                  this.logoTexture.destroy();
                  this.logoTexture = null;
                }
                this.renderArea = null;
                this.cmdBuff = null;
                this.shader = null;
                if (this.quadAssmebler) {
                  this.quadAssmebler.destroy();
                  this.quadAssmebler = null;
                }
                if (this.vertexBuffers) {
                  this.vertexBuffers.destroy();
                  this.vertexBuffers = null;
                }
                if (this.indicesBuffers) {
                  this.indicesBuffers.destroy();
                  this.indicesBuffers = null;
                }
                this.sampler = null;
                if (this.watermarkMat) {
                  this.watermarkMat.destroy();
                  this.watermarkMat = null;
                }
                if (this.watermarkTexture) {
                  this.watermarkTexture.destroy();
                  this.watermarkTexture = null;
                }
                this.settings = null;
              };
              SplashScreen.createInstance = function createInstance() {
                SplashScreen._ins = new SplashScreen();
                return SplashScreen._ins;
              };
              SplashScreen.releaseInstance = function releaseInstance() {
                if (SplashScreen._ins) {
                  SplashScreen._ins.destroy();
                  SplashScreen._ins = null;
                }
              };
              function SplashScreen() {
                this.settings = undefined;
                this._curTime = 0;
                this.device = undefined;
                this.swapchain = undefined;
                this.shader = undefined;
                this.sampler = undefined;
                this.cmdBuff = undefined;
                this.quadAssmebler = undefined;
                this.vertexBuffers = undefined;
                this.indicesBuffers = undefined;
                this.renderArea = undefined;
                this.clearColors = undefined;
                this.projection = undefined;
                this.isMobile = false;
                this.bgMat = undefined;
                this.bgImage = undefined;
                this.bgTexture = undefined;
                this.logoMat = undefined;
                this.logoImage = undefined;
                this.logoTexture = undefined;
                this.watermarkMat = undefined;
                this.watermarkTexture = undefined;
                this.bgWidth = 1920;
                this.bgHeight = 1080;
                this.logoWidthTemp = 140;
                this.logoHeightTemp = 200;
                this.logoWidth = 0;
                this.logoHeight = 0;
                this.logoXTrans = 1 / 2;
                this.logoYTrans = 1 / 6 + 2.5 / 6;
                this.textSize = 24;
                this.textHeight = 24;
                this.textXTrans = 1 / 2;
                this.textYExtraTrans = 32;
                this.textExpandSize = 4;
                this.scaleSize = 1;
              }
              _createClass(SplashScreen, [{
                key: "isFinished",
                get: function get() {
                  return this._curTime >= this.settings.totalTime;
                }
              }, {
                key: "curTime",
                get: function get() {
                  return this._curTime;
                },
                set: function set(val) {
                  this._curTime = val;
                }
              }], [{
                key: "instance",
                get: function get() {
                  return SplashScreen._ins;
                }
              }]);
              return SplashScreen;
            }();
            SplashScreen._ins = null;
            cclegacy.internal.SplashScreen = SplashScreen;

            var EffectSettings = function () {
              function EffectSettings() {
                this._data = null;
              }
              var _proto = EffectSettings.prototype;
              _proto.init = function init(path) {
                var _this = this;
                if (path === undefined) {
                  path = '';
                }
                if (!legacyCC.rendering || !legacyCC.rendering.enableEffectImport || !path) {
                  return Promise.resolve();
                }
                return new Promise(function (resolve, reject) {
                  {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', path);
                    xhr.responseType = 'arraybuffer';
                    xhr.onload = function () {
                      _this._data = xhr.response;
                      resolve();
                    };
                    xhr.onerror = function () {
                      reject(new Error('request effect settings failed!'));
                    };
                    xhr.send(null);
                  }
                });
              };
              _createClass(EffectSettings, [{
                key: "data",
                get: function get() {
                  return this._data;
                }
              }]);
              return EffectSettings;
            }();
            var effectSettings = new EffectSettings();
            legacyCC.effectSettings = effectSettings;

            var querySettings = settings.querySettings.bind(settings);
            var Game = exports("Game", function (_EventTarget) {
              _inheritsLoose(Game, _EventTarget);
              function Game() {
                var _this;
                _this = _EventTarget.call(this) || this;
                _this.frame = null;
                _this.container = null;
                _this.canvas = null;
                _this.renderType = -1;
                _this.eventTargetOn = _EventTarget.prototype.on;
                _this.eventTargetOnce = _EventTarget.prototype.once;
                _this.config = {};
                _this.onStart = null;
                _this.frameTime = 1000 / 60;
                _this._isCloning = false;
                _this._inited = false;
                _this._engineInited = false;
                _this._rendererInitialized = false;
                _this._paused = true;
                _this._pausedByEngine = false;
                _this._frameRate = 60;
                _this._pacer = null;
                _this._initTime = 0;
                _this._startTime = 0;
                _this._deltaTime = 0.0;
                _this._useFixedDeltaTime = false;
                _this._shouldLoadLaunchScene = true;
                _this.onPreBaseInitDelegate = new AsyncDelegate();
                _this.onPostBaseInitDelegate = new AsyncDelegate();
                _this.onPreInfrastructureInitDelegate = new AsyncDelegate();
                _this.onPostInfrastructureInitDelegate = new AsyncDelegate();
                _this.onPreSubsystemInitDelegate = new AsyncDelegate();
                _this.onPostSubsystemInitDelegate = new AsyncDelegate();
                _this.onPreProjectInitDelegate = new AsyncDelegate();
                _this.onPostProjectInitDelegate = new AsyncDelegate();
                return _this;
              }
              var _proto = Game.prototype;
              _proto.setFrameRate = function setFrameRate(frameRate) {
                this.frameRate = frameRate;
              };
              _proto.getFrameRate = function getFrameRate() {
                return this.frameRate;
              };
              _proto.step = function step() {
                director.tick(this._calculateDT(true));
              };
              _proto.pauseByEngine = function pauseByEngine() {
                if (this._paused) {
                  return;
                }
                this._pausedByEngine = true;
                this.pause();
              };
              _proto.resumeByEngine = function resumeByEngine() {
                if (this._pausedByEngine) {
                  this.resume();
                  this._pausedByEngine = false;
                }
              };
              _proto.pause = function pause() {
                var _this$_pacer;
                if (this._paused) {
                  return;
                }
                this._paused = true;
                (_this$_pacer = this._pacer) == null ? undefined : _this$_pacer.stop();
                this.emit(Game.EVENT_PAUSE);
              };
              _proto.resume = function resume() {
                var _this$_pacer2;
                if (!this._paused) {
                  return;
                }
                input._clearEvents();
                this._paused = false;
                (_this$_pacer2 = this._pacer) == null ? undefined : _this$_pacer2.start();
                this.emit(Game.EVENT_RESUME);
              };
              _proto.isPaused = function isPaused() {
                return this._paused;
              };
              _proto.restart = function restart() {
                var _this2 = this;
                var endFramePromise = new Promise(function (resolve) {
                  director.once("director_end_frame", function () {
                    return resolve();
                  });
                });
                return endFramePromise.then(function () {
                  director.reset();
                  cclegacy.Object._deferredDestroy();
                  _this2.pause();
                  _this2.resume();
                  _this2._shouldLoadLaunchScene = true;
                }).then(function () {
                  {
                    return SplashScreen.createInstance().init();
                  }
                }).then(function () {
                  _this2._safeEmit(Game.EVENT_RESTART);
                });
              };
              _proto.end = function end() {
                systemInfo.close();
              };
              _proto.on = function on(type, callback, target, once) {
                if (this.canRegisterEvent(type)) {
                  callback.call(target);
                }
                return this.eventTargetOn(type, callback, target, once);
              };
              _proto.once = function once(type, callback, target) {
                if (this.canRegisterEvent(type)) {
                  return callback.call(target);
                }
                return this.eventTargetOnce(type, callback, target);
              };
              _proto.canRegisterEvent = function canRegisterEvent(type) {
                return this._engineInited && type === Game.EVENT_ENGINE_INITED || this._inited && type === Game.EVENT_GAME_INITED || this._rendererInitialized && type === Game.EVENT_RENDERER_INITED;
              };
              _proto.init = function init(config) {
                var _this3 = this;
                this._compatibleWithOldParams(config);
                return Promise.resolve().then(function () {
                  _this3.emit(Game.EVENT_PRE_BASE_INIT);
                  return _this3.onPreBaseInitDelegate.dispatch();
                }).then(function () {
                  {
                    console.time('Init Base');
                  }
                  var debugMode = config.debugMode || 0;
                  _resetDebugSetting(debugMode);
                }).then(function () {
                  return sys.init();
                }).then(function () {
                  _this3._initEvents();
                }).then(function () {
                  return settings.init(config.settingsPath, config.overrideSettings);
                }).then(function () {
                  {
                    console.timeEnd('Init Base');
                  }
                  _this3.emit(Game.EVENT_POST_BASE_INIT);
                  return _this3.onPostBaseInitDelegate.dispatch();
                }).then(function () {
                  _this3.emit(Game.EVENT_PRE_INFRASTRUCTURE_INIT);
                  return _this3.onPreInfrastructureInitDelegate.dispatch();
                }).then(function () {
                  {
                    console.time('Init Infrastructure');
                  }
                  macro.init();
                  _this3._initXR();
                  var adapter = findCanvas();
                  {
                    _this3.canvas = adapter.canvas;
                    _this3.frame = adapter.frame;
                    _this3.container = adapter.container;
                  }
                  screen$1.init();
                  garbageCollectionManager.init();
                  return deviceManager.init(_this3.canvas, bindingMappingInfo);
                }).then(function () {
                  var usesCustomPipeline = querySettings("rendering", 'customPipeline');
                  if (usesCustomPipeline) {
                    if (!cclegacy.rendering) {
                      errorID(12109);
                      return;
                    }
                    if (!macro.CUSTOM_PIPELINE_NAME) {
                      macro.CUSTOM_PIPELINE_NAME = 'Builtin';
                    }
                  } else {
                    cclegacy.rendering = undefined;
                  }
                  assetManager.init();
                  builtinResMgr.init();
                  Layers.init();
                  _this3.initPacer();
                  {
                    console.timeEnd('Init Infrastructure');
                  }
                }).then(function () {
                  _this3.emit(Game.EVENT_POST_INFRASTRUCTURE_INIT);
                  return _this3.onPostInfrastructureInitDelegate.dispatch();
                }).then(function () {
                  _this3.emit(Game.EVENT_PRE_SUBSYSTEM_INIT);
                  return _this3.onPreSubsystemInitDelegate.dispatch();
                }).then(function () {
                  return effectSettings.init(querySettings("rendering", 'effectSettingsPath'));
                }).then(function () {
                  if (!cclegacy.rendering || !cclegacy.rendering.enableEffectImport) {
                    return;
                  }
                  var renderMode = querySettings("rendering", 'renderMode');
                  if (renderMode === 3) {
                    cclegacy.rendering.init(deviceManager.gfxDevice, null);
                    return;
                  }
                  var data = effectSettings.data;
                  if (data === null) {
                    errorID(1102);
                    return;
                  }
                  cclegacy.rendering.init(deviceManager.gfxDevice, data);
                }).then(function () {
                  var scriptPackages = querySettings("scripting", 'scriptPackages');
                  if (scriptPackages) {
                    return Promise.all(scriptPackages.map(function (pack) {
                      return module.import(pack);
                    }));
                  }
                  return Promise.resolve([]);
                }).then(function () {
                  {
                    console.time('Init SubSystem');
                  }
                  director.init();
                  return builtinResMgr.loadBuiltinAssets();
                }).then(function () {
                  {
                    console.timeEnd('Init SubSystem');
                  }
                  _this3.emit(Game.EVENT_POST_SUBSYSTEM_INIT);
                  return _this3.onPostSubsystemInitDelegate.dispatch();
                }).then(function () {
                  log("Cocos Creator v" + engineVersion);
                  _this3.emit(Game.EVENT_ENGINE_INITED);
                  _this3._engineInited = true;
                }).then(function () {
                  _this3.emit(Game.EVENT_PRE_PROJECT_INIT);
                  return _this3.onPreProjectInitDelegate.dispatch();
                }).then(function () {
                  {
                    console.time('Init Project');
                  }
                  var jsList = querySettings("plugins", 'jsList');
                  var promise = Promise.resolve();
                  if (jsList) {
                    jsList.forEach(function (jsListFile) {
                      promise = promise.then(function () {
                        return loadJsFile(('src') + "/" + jsListFile);
                      });
                    });
                  }
                  return promise;
                }).then(function () {
                  return _this3._loadProjectBundles();
                }).then(function () {
                  return _this3._loadCCEScripts();
                }).then(function () {
                  return _this3._setupRenderPipeline();
                }).then(function () {
                  return _this3._loadPreloadAssets();
                }).then(function () {
                  builtinResMgr.compileBuiltinMaterial();
                  return SplashScreen.createInstance().init();
                }).then(function () {
                  {
                    console.timeEnd('Init Project');
                  }
                  _this3.emit(Game.EVENT_POST_PROJECT_INIT);
                  return _this3.onPostProjectInitDelegate.dispatch();
                }).then(function () {
                  _this3._inited = true;
                  _this3._safeEmit(Game.EVENT_GAME_INITED);
                });
              };
              _proto._initXR = function _initXR() {
                return;
              };
              _proto._compatibleWithOldParams = function _compatibleWithOldParams(config) {
                var overrideSettings = config.overrideSettings = config.overrideSettings || {};
                if ('showFPS' in config) {
                  overrideSettings.profiling = overrideSettings.profiling || {};
                  overrideSettings.profiling.showFPS = config.showFPS;
                }
                if ('frameRate' in config) {
                  overrideSettings.screen = overrideSettings.screen || {};
                  overrideSettings.screen.frameRate = config.frameRate;
                }
                if ('renderMode' in config) {
                  overrideSettings.rendering = overrideSettings.rendering || {};
                  overrideSettings.rendering.renderMode = config.renderMode;
                }
                if ('renderPipeline' in config) {
                  overrideSettings.rendering = overrideSettings.rendering || {};
                  overrideSettings.rendering.renderPipeline = config.renderPipeline;
                }
                if ('assetOptions' in config) {
                  overrideSettings.assets = overrideSettings.assets || {};
                  Object.assign(overrideSettings.assets, config.assetOptions);
                }
                if ('customJointTextureLayouts' in config) {
                  overrideSettings.animation = overrideSettings.animation || {};
                  overrideSettings.animation.customJointTextureLayouts = config.customJointTextureLayouts;
                }
                if ('physics' in config) {
                  overrideSettings.physics = overrideSettings.physics || {};
                  Object.assign(overrideSettings.physics, config.physics);
                }
                if ('orientation' in config) {
                  overrideSettings.screen = overrideSettings.screen || {};
                  overrideSettings.screen.orientation = config.orientation;
                }
                if ('exactFitScreen' in config) {
                  overrideSettings.screen = overrideSettings.screen || {};
                  overrideSettings.screen.exactFitScreen = config.exactFitScreen;
                }
              };
              _proto._loadPreloadAssets = function _loadPreloadAssets() {
                var preloadAssets = querySettings("assets", 'preloadAssets');
                if (!preloadAssets) return Promise.resolve([]);
                return Promise.all(preloadAssets.map(function (uuid) {
                  return new Promise(function (resolve, reject) {
                    assetManager.loadAny(uuid, function (err) {
                      if (err) {
                        reject(err);
                        return;
                      }
                      resolve();
                    });
                  });
                }));
              };
              _proto._loadCCEScripts = function _loadCCEScripts() {
                return new Promise(function (resolve, reject) {
                  {
                    resolve();
                  }
                });
              };
              _proto._loadProjectBundles = function _loadProjectBundles() {
                var preloadBundles = querySettings("assets", 'preloadBundles');
                if (!preloadBundles) return Promise.resolve([]);
                return Promise.all(preloadBundles.map(function (_ref) {
                  var bundle = _ref.bundle,
                    version = _ref.version;
                  return new Promise(function (resolve, reject) {
                    var opts = {};
                    if (version) opts.version = version;
                    assetManager.loadBundle(bundle, opts, function (err) {
                      if (err) {
                        reject(err);
                        return;
                      }
                      resolve();
                    });
                  });
                }));
              };
              _proto.run = function run(onStart) {
                if (onStart) {
                  this.onStart = onStart;
                }
                if (!this._inited || EDITOR_NOT_IN_PREVIEW) {
                  return;
                }
                this.resume();
              };
              _proto._calculateDT = function _calculateDT(useFixedDeltaTime) {
                this._useFixedDeltaTime = useFixedDeltaTime;
                if (useFixedDeltaTime) {
                  this._startTime = performance.now();
                  return this.frameTime / 1000;
                }
                var now = performance.now();
                this._deltaTime = now > this._startTime ? (now - this._startTime) / 1000 : 0;
                if (this._deltaTime > Game.DEBUG_DT_THRESHOLD) {
                  this._deltaTime = this.frameTime / 1000;
                }
                this._startTime = now;
                return this._deltaTime;
              };
              _proto._updateCallback = function _updateCallback() {
                var _this4 = this;
                if (!this._inited) return;
                if (SplashScreen.instance && !SplashScreen.instance.isFinished) {
                  SplashScreen.instance.update(this._calculateDT(false));
                } else if (this._shouldLoadLaunchScene) {
                  {
                    SplashScreen.releaseInstance();
                  }
                  this._shouldLoadLaunchScene = false;
                  var launchScene = querySettings("launch", 'launchScene');
                  if (launchScene) {
                    director.loadScene(launchScene, function () {
                      logID(1103, launchScene);
                      _this4._initTime = performance.now();
                      director.startAnimation();
                      _this4.onStart == null ? undefined : _this4.onStart();
                    });
                  } else {
                    var _this$onStart;
                    this._initTime = performance.now();
                    director.startAnimation();
                    (_this$onStart = this.onStart) == null ? undefined : _this$onStart.call(this);
                  }
                } else {
                  director.tick(this._calculateDT(false));
                }
              };
              _proto.initPacer = function initPacer() {
                var _querySettings4;
                var frameRate = (_querySettings4 = querySettings("screen", 'frameRate')) !== null && _querySettings4 !== undefined ? _querySettings4 : 60;
                assert(typeof frameRate === 'number');
                this._pacer = new Pacer();
                this._pacer.onTick = this._updateCallback.bind(this);
                this.frameRate = frameRate;
              };
              _proto._initEvents = function _initEvents() {
                systemInfo.on('show', this._onShow, this);
                systemInfo.on('hide', this._onHide, this);
                systemInfo.on('close', this._onClose, this);
              };
              _proto._onHide = function _onHide() {
                this.emit(Game.EVENT_HIDE);
                this.pauseByEngine();
              };
              _proto._onShow = function _onShow() {
                this.emit(Game.EVENT_SHOW);
                this.resumeByEngine();
              };
              _proto._onClose = function _onClose() {
                this.emit(Game.EVENT_CLOSE);
                systemInfo.exit();
              };
              _proto.addPersistRootNode = function addPersistRootNode(node) {
                director.addPersistRootNode(node);
              };
              _proto.removePersistRootNode = function removePersistRootNode(node) {
                director.removePersistRootNode(node);
              };
              _proto.isPersistRootNode = function isPersistRootNode(node) {
                return director.isPersistRootNode(node);
              };
              _proto._setupRenderPipeline = function _setupRenderPipeline() {
                var usesCustomPipeline = querySettings("rendering", 'customPipeline');
                return this._setRenderPipeline(!!usesCustomPipeline);
              };
              _proto._setRenderPipeline = function _setRenderPipeline(customPipeline) {
                if (!director.root.setRenderPipeline(customPipeline)) {
                  errorID(1222);
                  return;
                }
                this._rendererInitialized = true;
                this._safeEmit(Game.EVENT_RENDERER_INITED);
              };
              _proto._safeEmit = function _safeEmit(event) {
                {
                  this.emit(event);
                }
              };
              _createClass(Game, [{
                key: "inited",
                get: function get() {
                  return this._inited;
                }
              }, {
                key: "frameRate",
                get: function get() {
                  return this._frameRate;
                },
                set: function set(frameRate) {
                  if (typeof frameRate !== 'number') {
                    frameRate = parseInt(frameRate, 10);
                    if (Number.isNaN(frameRate)) {
                      frameRate = 60;
                    }
                  }
                  this._frameRate = frameRate;
                  this.frameTime = 1000 / frameRate;
                  if (this._pacer) this._pacer.targetFrameRate = this._frameRate;
                }
              }, {
                key: "deltaTime",
                get: function get() {
                  return this._useFixedDeltaTime ? this.frameTime / 1000 : this._deltaTime;
                }
              }, {
                key: "totalTime",
                get: function get() {
                  return performance.now() - this._initTime;
                }
              }, {
                key: "frameStartTime",
                get: function get() {
                  return this._startTime;
                }
              }]);
              return Game;
            }(EventTarget));
            Game.EVENT_HIDE = 'game_on_hide';
            Game.EVENT_SHOW = 'game_on_show';
            Game.EVENT_LOW_MEMORY = 'game_on_low_memory';
            Game.EVENT_GAME_INITED = 'game_inited';
            Game.EVENT_ENGINE_INITED = 'engine_inited';
            Game.EVENT_RENDERER_INITED = 'renderer_inited';
            Game.EVENT_PRE_BASE_INIT = 'pre_base_init';
            Game.EVENT_POST_BASE_INIT = 'post_base_init';
            Game.EVENT_PRE_INFRASTRUCTURE_INIT = 'pre_infrastructure_init';
            Game.EVENT_POST_INFRASTRUCTURE_INIT = 'post_infrastructure_init';
            Game.EVENT_PRE_SUBSYSTEM_INIT = 'pre_subsystem_init';
            Game.EVENT_POST_SUBSYSTEM_INIT = 'post_subsystem_init';
            Game.EVENT_PRE_PROJECT_INIT = 'pre_project_init';
            Game.EVENT_POST_PROJECT_INIT = 'post_project_init';
            Game.EVENT_RESTART = 'game_on_restart';
            Game.EVENT_PAUSE = 'game_on_pause';
            Game.EVENT_RESUME = 'game_on_resume';
            Game.EVENT_CLOSE = 'game_on_close';
            Game.RENDER_TYPE_CANVAS = 0;
            Game.RENDER_TYPE_WEBGL = 1;
            Game.RENDER_TYPE_OPENGL = 2;
            Game.RENDER_TYPE_HEADLESS = 3;
            Game.DEBUG_DT_THRESHOLD = 1;
            cclegacy.Game = Game;
            var game = exports("game", cclegacy.game = new Game());

            markAsWarning(Director.prototype, 'director', [{
              name: 'calculateDeltaTime'
            }, {
              name: 'getDeltaTime',
              suggest: 'Use game.deltaTime instead'
            }, {
              name: 'getTotalTime',
              suggest: 'Use game.totalTime instead'
            }, {
              name: 'getCurrentTime',
              suggest: 'Use game.frameStartTime instead'
            }]);
            removeProperty(Director.prototype, 'director', [{
              name: 'setAnimationInterval',
              suggest: 'please use game.frameRate instead'
            }, {
              name: 'getAnimationInterval',
              suggest: 'please use game.frameRate instead'
            }, {
              name: 'getRunningScene',
              suggest: 'please use getScene instead'
            }, {
              name: 'setDepthTest',
              suggest: 'please use camera API instead'
            }, {
              name: 'setClearColor',
              suggest: 'please use camera API instead'
            }, {
              name: 'getWinSize',
              suggest: 'please use view.getVisibleSize instead'
            }, {
              name: 'getWinSizeInPixels'
            }, {
              name: 'purgeCachedData',
              suggest: 'please use assetManager.releaseAll instead'
            }, {
              name: 'convertToGL'
            }, {
              name: 'convertToUI'
            }]);
            replaceProperty(director, 'director', [{
              name: '_getSceneUuid',
              targetName: 'assetManager.main',
              newName: 'getSceneInfo',
              customFunction: function customFunction(sceneName) {
                if (assetManager.main) {
                  var _assetManager$main$ge;
                  return (_assetManager$main$ge = assetManager.main.getSceneInfo(sceneName)) == null ? undefined : _assetManager$main$ge.uuid;
                }
                return '';
              }
            }]);
            markAsWarning(game, 'game', [{
              name: 'collisionMatrix'
            }, {
              name: 'groupList'
            }]);
            replaceProperty(game, 'game', [{
              name: '_sceneInfos',
              targetName: 'assetManager.main',
              newName: 'getSceneInfo',
              customGetter: function customGetter() {
                var scenes = [];
                if (assetManager.main) {
                  assetManager.main.config.scenes.forEach(function (val) {
                    scenes.push(val);
                  });
                }
                return scenes;
              }
            }]);

            var MeshoptDecoder = {};

            var ns = {};
            (function () {

              function m(a) {
                throw a;
              }
              var q = undefined,
                aa = this;
              function s(a, c) {
                var d = a.split("."),
                  b = aa;
                !(d[0] in b) && b.execScript && b.execScript("var " + d[0]);
                for (var e; d.length && (e = d.shift());) !d.length && c !== q ? b[e] = c : b = b[e] ? b[e] : b[e] = {};
              }
              var u = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array && "undefined" !== typeof DataView;
              function x(a) {
                var c = a.length,
                  d = 0,
                  b = Number.POSITIVE_INFINITY,
                  e,
                  g,
                  f,
                  l,
                  h,
                  k,
                  n,
                  p,
                  t,
                  y;
                for (p = 0; p < c; ++p) a[p] > d && (d = a[p]), a[p] < b && (b = a[p]);
                e = 1 << d;
                g = new (u ? Uint32Array : Array)(e);
                f = 1;
                l = 0;
                for (h = 2; f <= d;) {
                  for (p = 0; p < c; ++p) if (a[p] === f) {
                    k = 0;
                    n = l;
                    for (t = 0; t < f; ++t) k = k << 1 | n & 1, n >>= 1;
                    y = f << 16 | p;
                    for (t = k; t < e; t += h) g[t] = y;
                    ++l;
                  }
                  ++f;
                  l <<= 1;
                  h <<= 1;
                }
                return [g, d, b];
              }
              function ba(a, c) {
                this.g = [];
                this.h = 32768;
                this.d = this.f = this.a = this.j = 0;
                this.input = u ? new Uint8Array(a) : a;
                this.k = false;
                this.e = z;
                this.o = false;
                if (c || !(c = {})) c.index && (this.a = c.index), c.bufferSize && (this.h = c.bufferSize), c.bufferType && (this.e = c.bufferType), c.resize && (this.o = c.resize);
                switch (this.e) {
                  case A:
                    this.b = 32768;
                    this.c = new (u ? Uint8Array : Array)(32768 + this.h + 258);
                    break;
                  case z:
                    this.b = 0;
                    this.c = new (u ? Uint8Array : Array)(this.h);
                    break;
                  default:
                    m(Error("invalid inflate mode"));
                }
              }
              var A = 0,
                z = 1,
                ca = {
                  q: A,
                  p: z
                };
              ba.prototype.i = function () {
                for (; !this.k;) {
                  var a = B(this, 3);
                  a & 1 && (this.k = true);
                  a >>>= 1;
                  switch (a) {
                    case 0:
                      var c = this.input,
                        d = this.a,
                        b = this.c,
                        e = this.b,
                        g = c.length,
                        f = q,
                        l = q,
                        h = b.length,
                        k = q;
                      this.d = this.f = 0;
                      d + 1 >= g && m(Error("invalid uncompressed block header: LEN"));
                      f = c[d++] | c[d++] << 8;
                      d + 1 >= g && m(Error("invalid uncompressed block header: NLEN"));
                      l = c[d++] | c[d++] << 8;
                      f === ~l && m(Error("invalid uncompressed block header: length verify"));
                      d + f > c.length && m(Error("input buffer is broken"));
                      switch (this.e) {
                        case A:
                          for (; e + f > b.length;) {
                            k = h - e;
                            f -= k;
                            if (u) b.set(c.subarray(d, d + k), e), e += k, d += k;else for (; k--;) b[e++] = c[d++];
                            this.b = e;
                            b = D(this);
                            e = this.b;
                          }
                          break;
                        case z:
                          for (; e + f > b.length;) b = E(this, {
                            m: 2
                          });
                          break;
                        default:
                          m(Error("invalid inflate mode"));
                      }
                      if (u) b.set(c.subarray(d, d + f), e), e += f, d += f;else for (; f--;) b[e++] = c[d++];
                      this.a = d;
                      this.b = e;
                      this.c = b;
                      break;
                    case 1:
                      switch (this.e) {
                        case z:
                          da(this, ea, fa);
                          break;
                        case A:
                          ga(this, ea, fa);
                          break;
                        default:
                          m(Error("invalid inflate mode"));
                      }
                      break;
                    case 2:
                      for (var n = B(this, 5) + 257, p = B(this, 5) + 1, t = B(this, 4) + 4, y = new (u ? Uint8Array : Array)(H.length), ja = q, T = q, U = q, v = q, V = q, J = q, C = q, r = q, ka = q, r = 0; r < t; ++r) y[H[r]] = B(this, 3);
                      if (!u) {
                        r = t;
                        for (t = y.length; r < t; ++r) y[H[r]] = 0;
                      }
                      ja = x(y);
                      v = new (u ? Uint8Array : Array)(n + p);
                      r = 0;
                      for (ka = n + p; r < ka;) switch (V = I(this, ja), V) {
                        case 16:
                          for (C = 3 + B(this, 2); C--;) v[r++] = J;
                          break;
                        case 17:
                          for (C = 3 + B(this, 3); C--;) v[r++] = 0;
                          J = 0;
                          break;
                        case 18:
                          for (C = 11 + B(this, 7); C--;) v[r++] = 0;
                          J = 0;
                          break;
                        default:
                          J = v[r++] = V;
                      }
                      T = u ? x(v.subarray(0, n)) : x(v.slice(0, n));
                      U = u ? x(v.subarray(n)) : x(v.slice(n));
                      switch (this.e) {
                        case z:
                          da(this, T, U);
                          break;
                        case A:
                          ga(this, T, U);
                          break;
                        default:
                          m(Error("invalid inflate mode"));
                      }
                      break;
                    default:
                      m(Error("unknown BTYPE: " + a));
                  }
                }
                switch (this.e) {
                  case A:
                    var W;
                    var la = 0,
                      za = this.c,
                      X = this.g,
                      Y,
                      Z = new (u ? Uint8Array : Array)(this.j + (this.b - 32768)),
                      w,
                      K,
                      L,
                      ma;
                    if (0 === X.length) W = u ? this.c.subarray(32768, this.b) : this.c.slice(32768, this.b);else {
                      w = 0;
                      for (K = X.length; w < K; ++w) {
                        Y = X[w];
                        L = 0;
                        for (ma = Y.length; L < ma; ++L) Z[la++] = Y[L];
                      }
                      w = 32768;
                      for (K = this.b; w < K; ++w) Z[la++] = za[w];
                      this.g = [];
                      W = this.buffer = Z;
                    }
                    return W;
                  case z:
                    var F,
                      G = this.b;
                    u ? this.o ? (F = new Uint8Array(G), F.set(this.c.subarray(0, G))) : F = this.c.subarray(0, G) : (this.c.length > G && (this.c.length = G), F = this.c);
                    return this.buffer = F;
                  default:
                    m(Error("invalid inflate mode"));
                }
              };
              var ha = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                H = u ? new Uint16Array(ha) : ha,
                ia = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],
                na = u ? new Uint16Array(ia) : ia,
                oa = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],
                M = u ? new Uint8Array(oa) : oa,
                pa = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
                qa = u ? new Uint16Array(pa) : pa,
                ra = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                N = u ? new Uint8Array(ra) : ra,
                O = new (u ? Uint8Array : Array)(288),
                P,
                sa;
              P = 0;
              for (sa = O.length; P < sa; ++P) O[P] = 143 >= P ? 8 : 255 >= P ? 9 : 279 >= P ? 7 : 8;
              var ea = x(O),
                ta = new (u ? Uint8Array : Array)(30),
                Q,
                ua;
              Q = 0;
              for (ua = ta.length; Q < ua; ++Q) ta[Q] = 5;
              var fa = x(ta);
              function B(a, c) {
                var d = a.f,
                  b = a.d,
                  e = a.input,
                  g = a.a,
                  f;
                g + (c - b + 7 >> 3) >= e.length && m(Error("input buffer is broken"));
                for (; b < c;) d |= e[g++] << b, b += 8;
                f = d & (1 << c) - 1;
                a.f = d >>> c;
                a.d = b - c;
                a.a = g;
                return f;
              }
              function I(a, c) {
                for (var d = a.f, b = a.d, e = a.input, g = a.a, f = e.length, l = c[0], h = c[1], k, n; b < h && !(g >= f);) d |= e[g++] << b, b += 8;
                k = l[d & (1 << h) - 1];
                n = k >>> 16;
                n > b && m(Error("invalid code length: " + n));
                a.f = d >> n;
                a.d = b - n;
                a.a = g;
                return k & 65535;
              }
              function ga(a, c, d) {
                var b = a.c,
                  e = a.b;
                a.l = c;
                for (var g = b.length - 258, f, l, h, k; 256 !== (f = I(a, c));) if (256 > f) e >= g && (a.b = e, b = D(a), e = a.b), b[e++] = f;else {
                  l = f - 257;
                  k = na[l];
                  0 < M[l] && (k += B(a, M[l]));
                  f = I(a, d);
                  h = qa[f];
                  0 < N[f] && (h += B(a, N[f]));
                  e >= g && (a.b = e, b = D(a), e = a.b);
                  for (; k--;) b[e] = b[e++ - h];
                }
                for (; 8 <= a.d;) a.d -= 8, a.a--;
                a.b = e;
              }
              function da(a, c, d) {
                var b = a.c,
                  e = a.b;
                a.l = c;
                for (var g = b.length, f, l, h, k; 256 !== (f = I(a, c));) if (256 > f) e >= g && (b = E(a), g = b.length), b[e++] = f;else {
                  l = f - 257;
                  k = na[l];
                  0 < M[l] && (k += B(a, M[l]));
                  f = I(a, d);
                  h = qa[f];
                  0 < N[f] && (h += B(a, N[f]));
                  e + k > g && (b = E(a), g = b.length);
                  for (; k--;) b[e] = b[e++ - h];
                }
                for (; 8 <= a.d;) a.d -= 8, a.a--;
                a.b = e;
              }
              function D(a) {
                var c = new (u ? Uint8Array : Array)(a.b - 32768),
                  d = a.b - 32768,
                  b,
                  e,
                  g = a.c;
                if (u) c.set(g.subarray(32768, c.length));else {
                  b = 0;
                  for (e = c.length; b < e; ++b) c[b] = g[b + 32768];
                }
                a.g.push(c);
                a.j += c.length;
                if (u) g.set(g.subarray(d, d + 32768));else for (b = 0; 32768 > b; ++b) g[b] = g[d + b];
                a.b = 32768;
                return g;
              }
              function E(a, c) {
                var d,
                  b = a.input.length / a.a + 1 | 0,
                  e,
                  g,
                  f,
                  l = a.input,
                  h = a.c;
                c && ("number" === typeof c.m && (b = c.m), "number" === typeof c.r && (b += c.r));
                2 > b ? (e = (l.length - a.a) / a.l[2], f = 258 * (e / 2) | 0, g = f < h.length ? h.length + f : h.length << 1) : g = h.length * b;
                u ? (d = new Uint8Array(g), d.set(h)) : d = h;
                a.c = d;
                return a.c;
              }
              function va(a, c) {
                var d, b;
                this.input = a;
                this.a = 0;
                if (c || !(c = {})) c.index && (this.a = c.index), c.verify && (this.s = c.verify);
                d = a[this.a++];
                b = a[this.a++];
                switch (d & 15) {
                  case wa:
                    this.method = wa;
                    break;
                  default:
                    m(Error("unsupported compression method"));
                }
                0 !== ((d << 8) + b) % 31 && m(Error("invalid fcheck flag:" + ((d << 8) + b) % 31));
                b & 32 && m(Error("fdict flag is not supported"));
                this.n = new ba(a, {
                  index: this.a,
                  bufferSize: c.bufferSize,
                  bufferType: c.bufferType,
                  resize: c.resize
                });
              }
              va.prototype.i = function () {
                var a = this.input,
                  c,
                  d;
                c = this.n.i();
                this.a = this.n.a;
                if (this.s) {
                  d = (a[this.a++] << 24 | a[this.a++] << 16 | a[this.a++] << 8 | a[this.a++]) >>> 0;
                  var b = c;
                  if ("string" === typeof b) {
                    var e = b.split(""),
                      g,
                      f;
                    g = 0;
                    for (f = e.length; g < f; g++) e[g] = (e[g].charCodeAt(0) & 255) >>> 0;
                    b = e;
                  }
                  for (var l = 1, h = 0, k = b.length, n, p = 0; 0 < k;) {
                    n = 1024 < k ? 1024 : k;
                    k -= n;
                    do l += b[p++], h += l; while (--n);
                    l %= 65521;
                    h %= 65521;
                  }
                  d !== (h << 16 | l) >>> 0 && m(Error("invalid adler-32 checksum"));
                }
                return c;
              };
              var wa = 8;
              s("Zlib.Inflate", va);
              s("Zlib.Inflate.prototype.decompress", va.prototype.i);
              var xa = {
                  ADAPTIVE: ca.p,
                  BLOCK: ca.q
                },
                R,
                S,
                $,
                ya;
              if (Object.keys) R = Object.keys(xa);else for (S in R = [], $ = 0, xa) R[$++] = S;
              $ = 0;
              for (ya = R.length; $ < ya; ++$) S = R[$], s("Zlib.Inflate.BufferType." + S, xa[S]);
            }).call(ns);
            var _p = ns.Zlib;
            _p.Inflate = _p["Inflate"];
            _p.Inflate.BufferType = _p.Inflate["BufferType"];
            _p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];

            var _dec$q, _class$q, _class2$n, _initializer$m, _initializer2$j, _initializer3$e;
            var vec3Add = Vec3.add;
            var vec3MultiplyScalar = Vec3.multiplyScalar;
            var vec3Subtract = Vec3.subtract;
            var aabbTransform = AABB.transform;
            var aabbFromPoints = AABB.fromPoints;
            var vec3Max = Vec3.max;
            var vec3Min = Vec3.min;
            var vec3TransformQuat = Vec3.transformQuat;
            var vec3TransformMat4$1 = Vec3.transformMat4;
            function getIndexStrideCtor(stride) {
              switch (stride) {
                case 1:
                  return Uint8Array;
                case 2:
                  return Uint16Array;
                case 4:
                  return Uint32Array;
                default:
                  return Uint8Array;
              }
            }
            var v3_1$3 = new Vec3();
            var v3_2$1 = new Vec3();
            var globalEmptyMeshBuffer = new Uint8Array();
            var Mesh = exports("Mesh", (_dec$q = ccclass$6('cc.Mesh'), _dec$q(_class$q = (_class2$n = function (_Asset) {
              _inheritsLoose(Mesh, _Asset);
              function Mesh(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this.morphRendering = null;
                _this._struct = _initializer$m && _initializer$m();
                _this._hash = _initializer2$j && _initializer2$j();
                _this._data = globalEmptyMeshBuffer;
                _this._initialized = false;
                _this._allowDataAccess = _initializer3$e && _initializer3$e();
                _this._isMeshDataUploaded = false;
                _this._renderingSubMeshes = null;
                _this._boneSpaceBounds = new Map();
                _this._jointBufferIndices = null;
                return _this;
              }
              var _proto = Mesh.prototype;
              _proto.onLoaded = function onLoaded() {
                this.initialize();
              };
              _proto.initialize = function initialize() {
                if (this._initialized) {
                  return;
                }
                this._initialized = true;
                var info = {
                  struct: this.struct,
                  data: this.data
                };
                if (info.struct.compressed) {
                  info = inflateMesh(info);
                }
                if (this.struct.encoded) {
                  info = decodeMesh(info);
                }
                if (this.struct.quantized && !(deviceManager.gfxDevice.getFormatFeatures(29) & 16)) {
                  info = dequantizeMesh(info);
                }
                this._struct = info.struct;
                this._data = info.data;
                if (this._struct.dynamic) {
                  var device = deviceManager.gfxDevice;
                  var vertexBuffers = [];
                  var subMeshes = [];
                  for (var i = 0; i < this._struct.vertexBundles.length; i++) {
                    var _vertexBundle = this._struct.vertexBundles[i];
                    var vertexBuffer = device.createBuffer(new BufferInfo(8 | 2, 1, _vertexBundle.view.length, _vertexBundle.view.stride));
                    vertexBuffers.push(vertexBuffer);
                  }
                  for (var _i = 0; _i < this._struct.primitives.length; _i++) {
                    var primitive = this._struct.primitives[_i];
                    var indexView = primitive.indexView;
                    var indexBuffer = null;
                    if (indexView) {
                      indexBuffer = device.createBuffer(new BufferInfo(4 | 2, 1, indexView.length, indexView.stride));
                    }
                    var subVBs = [];
                    for (var k = 0; k < primitive.vertexBundelIndices.length; k++) {
                      var idx = primitive.vertexBundelIndices[k];
                      subVBs.push(vertexBuffers[idx]);
                    }
                    var allAttributes = [];
                    for (var _k = 0; _k < primitive.vertexBundelIndices.length; _k++) {
                      var _idx = primitive.vertexBundelIndices[_k];
                      var attributes = this._struct.vertexBundles[_idx].attributes;
                      for (var j = 0; j < attributes.length; j++) {
                        var attr = attributes[j];
                        var attribute = new Attribute();
                        attribute.copy(attr);
                        allAttributes.push(attribute);
                      }
                    }
                    var subMesh = new RenderingSubMesh(subVBs, allAttributes, primitive.primitiveMode, indexBuffer);
                    subMesh.drawInfo = new DrawInfo();
                    subMesh.mesh = this;
                    subMesh.subMeshIdx = _i;
                    subMeshes.push(subMesh);
                  }
                  this._renderingSubMeshes = subMeshes;
                } else {
                  var buffer = this._data.buffer;
                  var gfxDevice = deviceManager.gfxDevice;
                  var _vertexBuffers = this._createVertexBuffers(gfxDevice, buffer);
                  var indexBuffers = [];
                  var _subMeshes = [];
                  for (var _i2 = 0; _i2 < this._struct.primitives.length; _i2++) {
                    var prim = this._struct.primitives[_i2];
                    if (prim.vertexBundelIndices.length === 0) {
                      continue;
                    }
                    var _indexBuffer = null;
                    var ib = undefined;
                    if (prim.indexView) {
                      var idxView = prim.indexView;
                      var dstStride = idxView.stride;
                      var dstSize = idxView.length;
                      if (dstStride === 4 && !gfxDevice.hasFeature(0)) {
                        var vertexCount = this._struct.vertexBundles[prim.vertexBundelIndices[0]].view.count;
                        if (vertexCount >= 65536) {
                          warnID(10001, vertexCount, 65536);
                          continue;
                        } else {
                          dstStride >>= 1;
                          dstSize >>= 1;
                        }
                      }
                      _indexBuffer = gfxDevice.createBuffer(new BufferInfo(4, 1, dstSize, dstStride));
                      indexBuffers.push(_indexBuffer);
                      ib = new (getIndexStrideCtor(idxView.stride))(buffer, idxView.offset, idxView.count);
                      if (idxView.stride !== dstStride) {
                        ib = getIndexStrideCtor(dstStride).from(ib);
                      }
                      _indexBuffer.update(ib);
                    }
                    var vbReference = prim.vertexBundelIndices.map(function (idx) {
                      return _vertexBuffers[idx];
                    });
                    var gfxAttributes = [];
                    if (prim.vertexBundelIndices.length > 0) {
                      var _idx2 = prim.vertexBundelIndices[0];
                      var _vertexBundle2 = this._struct.vertexBundles[_idx2];
                      var attrs = _vertexBundle2.attributes;
                      for (var _j = 0; _j < attrs.length; ++_j) {
                        var _attr = attrs[_j];
                        gfxAttributes[_j] = new Attribute(_attr.name, _attr.format, _attr.isNormalized, _attr.stream, _attr.isInstanced, _attr.location);
                      }
                    }
                    var _subMesh = new RenderingSubMesh(vbReference, gfxAttributes, prim.primitiveMode, _indexBuffer);
                    _subMesh.mesh = this;
                    _subMesh.subMeshIdx = _i2;
                    _subMeshes.push(_subMesh);
                  }
                  this._renderingSubMeshes = _subMeshes;
                  if (this._struct.morph) {
                    this.morphRendering = createMorphRendering(this, gfxDevice);
                  }
                  this._isMeshDataUploaded = true;
                  if (!this._allowDataAccess && true) {
                    this.releaseData();
                  }
                }
              };
              _proto.updateSubMesh = function updateSubMesh(primitiveIndex, dynamicGeometry) {
                if (!this._struct.dynamic) {
                  warnID(14200);
                  return;
                }
                if (primitiveIndex >= this._struct.primitives.length) {
                  warnID(14201);
                  return;
                }
                var buffers = [];
                if (dynamicGeometry.positions.length > 0) {
                  buffers.push(dynamicGeometry.positions);
                }
                if (dynamicGeometry.normals && dynamicGeometry.normals.length > 0) {
                  buffers.push(dynamicGeometry.normals);
                }
                if (dynamicGeometry.uvs && dynamicGeometry.uvs.length > 0) {
                  buffers.push(dynamicGeometry.uvs);
                }
                if (dynamicGeometry.tangents && dynamicGeometry.tangents.length > 0) {
                  buffers.push(dynamicGeometry.tangents);
                }
                if (dynamicGeometry.colors && dynamicGeometry.colors.length > 0) {
                  buffers.push(dynamicGeometry.colors);
                }
                if (dynamicGeometry.customAttributes) {
                  for (var k = 0; k < dynamicGeometry.customAttributes.length; k++) {
                    buffers.push(dynamicGeometry.customAttributes[k].values);
                  }
                }
                var dynamic = this._struct.dynamic;
                var info = dynamic.info;
                var primitive = this._struct.primitives[primitiveIndex];
                var subMesh = this._renderingSubMeshes[primitiveIndex];
                var drawInfo = subMesh.drawInfo;
                for (var index = 0; index < buffers.length; index++) {
                  var vertices = buffers[index];
                  var bundle = this._struct.vertexBundles[primitive.vertexBundelIndices[index]];
                  var stride = bundle.view.stride;
                  var vertexCount = vertices.byteLength / stride;
                  var updateSize = vertices.byteLength;
                  var dstBuffer = new Uint8Array(this._data.buffer, bundle.view.offset, updateSize);
                  var srcBuffer = new Uint8Array(vertices.buffer, vertices.byteOffset, updateSize);
                  var vertexBuffer = subMesh.vertexBuffers[index];
                  assertIsTrue(vertexCount <= info.maxSubMeshVertices, 'Too many vertices.');
                  if (updateSize > 0) {
                    dstBuffer.set(srcBuffer);
                    vertexBuffer.update(srcBuffer, updateSize);
                  }
                  bundle.view.count = vertexCount;
                  drawInfo.vertexCount = vertexCount;
                }
                if (primitive.indexView) {
                  var indexView = primitive.indexView;
                  var _stride = indexView.stride;
                  var indexCount = _stride === 2 ? dynamicGeometry.indices16.length : dynamicGeometry.indices32.length;
                  var _updateSize = indexCount * _stride;
                  var _dstBuffer = new Uint8Array(this._data.buffer, indexView.offset, _updateSize);
                  var _srcBuffer = _stride === 2 ? new Uint8Array(dynamicGeometry.indices16.buffer, dynamicGeometry.indices16.byteOffset, _updateSize) : new Uint8Array(dynamicGeometry.indices32.buffer, dynamicGeometry.indices32.byteOffset, _updateSize);
                  var indexBuffer = subMesh.indexBuffer;
                  assertIsTrue(indexCount <= info.maxSubMeshIndices, 'Too many indices.');
                  if (_updateSize > 0) {
                    _dstBuffer.set(_srcBuffer);
                    indexBuffer.update(_srcBuffer, _updateSize);
                  }
                  indexView.count = indexCount;
                  drawInfo.indexCount = indexCount;
                }
                if (dynamicGeometry.minPos && dynamicGeometry.maxPos) {
                  var minPos = v3(dynamicGeometry.minPos.x, dynamicGeometry.minPos.y, dynamicGeometry.minPos.z);
                  var maxPos = v3(dynamicGeometry.maxPos.x, dynamicGeometry.maxPos.y, dynamicGeometry.maxPos.z);
                  if (!dynamic.bounds[primitiveIndex]) {
                    dynamic.bounds[primitiveIndex] = new AABB();
                  }
                  aabbFromPoints(dynamic.bounds[primitiveIndex], minPos, maxPos);
                  var subMin = v3();
                  var subMax = v3();
                  dynamic.bounds.forEach(function (bound) {
                    if (bound) {
                      bound.getBoundary(subMin, subMax);
                      vec3Min(minPos, subMin, minPos);
                      vec3Max(maxPos, subMax, maxPos);
                    }
                  });
                  this._struct.minPosition = v3(minPos.x, minPos.y, minPos.z);
                  this._struct.maxPosition = v3(maxPos.x, maxPos.y, maxPos.z);
                }
                subMesh.invalidateGeometricInfo();
              };
              _proto.destroy = function destroy() {
                this.destroyRenderingMesh();
                return _Asset.prototype.destroy.call(this);
              };
              _proto.destroyRenderingMesh = function destroyRenderingMesh() {
                if (this._renderingSubMeshes) {
                  for (var i = 0; i < this._renderingSubMeshes.length; i++) {
                    this._renderingSubMeshes[i].destroy();
                  }
                  this._renderingSubMeshes = null;
                  this._initialized = false;
                  this._isMeshDataUploaded = false;
                }
              };
              _proto.assign = function assign(struct, data) {
                this.reset({
                  struct: struct,
                  data: data
                });
              };
              _proto.reset = function reset(info) {
                this.destroyRenderingMesh();
                this._struct = info.struct;
                this._data = info.data;
                this._hash = 0;
              };
              _proto.getBoneSpaceBounds = function getBoneSpaceBounds(skeleton) {
                if (this._boneSpaceBounds.has(skeleton.hash)) {
                  return this._boneSpaceBounds.get(skeleton.hash);
                }
                var bounds = [];
                this._boneSpaceBounds.set(skeleton.hash, bounds);
                var valid = [];
                var bindposes = skeleton.bindposes;
                for (var i = 0; i < bindposes.length; i++) {
                  bounds.push(new AABB(Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity));
                  valid.push(false);
                }
                var primitives = this._struct.primitives;
                for (var p = 0; p < primitives.length; p++) {
                  var joints = this.readAttribute(p, "a_joints");
                  var weights = this.readAttribute(p, "a_weights");
                  var positions = this.readAttribute(p, "a_position");
                  if (!joints || !weights || !positions) {
                    continue;
                  }
                  var vertCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3);
                  for (var _i3 = 0; _i3 < vertCount; _i3++) {
                    Vec3.set(v3_1$3, positions[3 * _i3 + 0], positions[3 * _i3 + 1], positions[3 * _i3 + 2]);
                    for (var j = 0; j < 4; ++j) {
                      var idx = 4 * _i3 + j;
                      var joint = joints[idx];
                      if (weights[idx] === 0 || joint >= bindposes.length) {
                        continue;
                      }
                      vec3TransformMat4$1(v3_2$1, v3_1$3, bindposes[joint]);
                      valid[joint] = true;
                      var b = bounds[joint];
                      vec3Min(b.center, b.center, v3_2$1);
                      vec3Max(b.halfExtents, b.halfExtents, v3_2$1);
                    }
                  }
                }
                for (var _i4 = 0; _i4 < bindposes.length; _i4++) {
                  var _b = bounds[_i4];
                  if (!valid[_i4]) {
                    bounds[_i4] = null;
                  } else {
                    aabbFromPoints(_b, _b.center, _b.halfExtents);
                  }
                }
                return bounds;
              };
              _proto.merge = function merge(mesh, worldMatrix, validate) {
                if (validate) {
                  if (!this.validateMergingMesh(mesh)) {
                    return false;
                  }
                }
                var vec3_temp = new Vec3();
                var rotate = worldMatrix && new Quat();
                var boundingBox = worldMatrix && new AABB();
                if (rotate) {
                  worldMatrix.getRotation(rotate);
                }
                if (!this._initialized) {
                  var struct = JSON.parse(JSON.stringify(mesh._struct));
                  var data = mesh._data.slice();
                  if (worldMatrix) {
                    if (struct.maxPosition && struct.minPosition) {
                      vec3Add(boundingBox.center, struct.maxPosition, struct.minPosition);
                      vec3MultiplyScalar(boundingBox.center, boundingBox.center, 0.5);
                      vec3Subtract(boundingBox.halfExtents, struct.maxPosition, struct.minPosition);
                      vec3MultiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
                      aabbTransform(boundingBox, boundingBox, worldMatrix);
                      vec3Add(struct.maxPosition, boundingBox.center, boundingBox.halfExtents);
                      vec3Subtract(struct.minPosition, boundingBox.center, boundingBox.halfExtents);
                    }
                    for (var i = 0; i < struct.vertexBundles.length; i++) {
                      var vtxBdl = struct.vertexBundles[i];
                      for (var j = 0; j < vtxBdl.attributes.length; j++) {
                        if (vtxBdl.attributes[j].name === "a_position" || vtxBdl.attributes[j].name === "a_normal") {
                          var format = vtxBdl.attributes[j].format;
                          var inputView = new DataView(data.buffer, vtxBdl.view.offset + getOffset(vtxBdl.attributes, j));
                          var reader = getReader(inputView, format);
                          var writer = getWriter(inputView, format);
                          if (!reader || !writer) {
                            continue;
                          }
                          var vertexCount = vtxBdl.view.count;
                          var vertexStride = vtxBdl.view.stride;
                          var attrComponentByteLength = getComponentByteLength(format);
                          for (var vtxIdx = 0; vtxIdx < vertexCount; vtxIdx++) {
                            var xOffset = vtxIdx * vertexStride;
                            var yOffset = xOffset + attrComponentByteLength;
                            var zOffset = yOffset + attrComponentByteLength;
                            vec3_temp.set(reader(xOffset), reader(yOffset), reader(zOffset));
                            switch (vtxBdl.attributes[j].name) {
                              case "a_position":
                                vec3_temp.transformMat4(worldMatrix);
                                break;
                              case "a_normal":
                                vec3TransformQuat(vec3_temp, vec3_temp, rotate);
                                break;
                            }
                            writer(xOffset, vec3_temp.x);
                            writer(yOffset, vec3_temp.y);
                            writer(zOffset, vec3_temp.z);
                          }
                        }
                      }
                    }
                  }
                  this.reset({
                    struct: struct,
                    data: data
                  });
                  this.initialize();
                  return true;
                }
                var bufferBlob = new BufferBlob();
                var vertCount = 0;
                var vertStride = 0;
                var srcOffset = 0;
                var dstOffset = 0;
                var vb;
                var vbView;
                var srcVBView;
                var dstVBView;
                var srcAttrOffset = 0;
                var srcVBOffset = 0;
                var dstVBOffset = 0;
                var attrSize = 0;
                var dstAttrView;
                var hasAttr = false;
                var vertexBundles = new Array(this._struct.vertexBundles.length);
                for (var _i5 = 0; _i5 < this._struct.vertexBundles.length; ++_i5) {
                  var bundle = this._struct.vertexBundles[_i5];
                  var dstBundle = mesh._struct.vertexBundles[_i5];
                  srcOffset = bundle.view.offset;
                  dstOffset = dstBundle.view.offset;
                  vertStride = bundle.view.stride;
                  vertCount = bundle.view.count + dstBundle.view.count;
                  vb = new ArrayBuffer(vertCount * vertStride);
                  vbView = new Uint8Array(vb);
                  srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length);
                  srcOffset += srcVBView.length;
                  dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length);
                  dstOffset += dstVBView.length;
                  vbView.set(srcVBView);
                  srcAttrOffset = 0;
                  for (var _iterator = _createForOfIteratorHelperLoose(bundle.attributes), _step; !(_step = _iterator()).done;) {
                    var attr = _step.value;
                    dstVBOffset = 0;
                    hasAttr = false;
                    for (var _iterator2 = _createForOfIteratorHelperLoose(dstBundle.attributes), _step2; !(_step2 = _iterator2()).done;) {
                      var dstAttr = _step2.value;
                      if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                        hasAttr = true;
                        break;
                      }
                      dstVBOffset += FormatInfos[dstAttr.format].size;
                    }
                    if (hasAttr) {
                      attrSize = FormatInfos[attr.format].size;
                      srcVBOffset = bundle.view.length + srcAttrOffset;
                      for (var v = 0; v < dstBundle.view.count; ++v) {
                        dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize);
                        vbView.set(dstAttrView, srcVBOffset);
                        if ((attr.name === "a_position" || attr.name === "a_normal") && worldMatrix) {
                          var f32_temp = new Float32Array(vbView.buffer, srcVBOffset, 3);
                          vec3_temp.set(f32_temp[0], f32_temp[1], f32_temp[2]);
                          switch (attr.name) {
                            case "a_position":
                              vec3_temp.transformMat4(worldMatrix);
                              break;
                            case "a_normal":
                              vec3TransformQuat(vec3_temp, vec3_temp, rotate);
                              break;
                          }
                          f32_temp[0] = vec3_temp.x;
                          f32_temp[1] = vec3_temp.y;
                          f32_temp[2] = vec3_temp.z;
                        }
                        srcVBOffset += bundle.view.stride;
                        dstVBOffset += dstBundle.view.stride;
                      }
                    }
                    srcAttrOffset += FormatInfos[attr.format].size;
                  }
                  vertexBundles[_i5] = {
                    attributes: bundle.attributes,
                    view: {
                      offset: bufferBlob.getLength(),
                      length: vb.byteLength,
                      count: vertCount,
                      stride: vertStride
                    }
                  };
                  bufferBlob.addBuffer(vb);
                }
                var idxCount = 0;
                var idxStride = 2;
                var ibView;
                var srcIBView;
                var dstIBView;
                var primitives = new Array(this._struct.primitives.length);
                for (var _i6 = 0; _i6 < this._struct.primitives.length; ++_i6) {
                  var prim = this._struct.primitives[_i6];
                  var dstPrim = mesh._struct.primitives[_i6];
                  primitives[_i6] = {
                    primitiveMode: prim.primitiveMode,
                    vertexBundelIndices: prim.vertexBundelIndices
                  };
                  var vertBatchCount = 0;
                  for (var _iterator3 = _createForOfIteratorHelperLoose(prim.vertexBundelIndices), _step3; !(_step3 = _iterator3()).done;) {
                    var bundleIdx = _step3.value;
                    vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
                  }
                  if (prim.indexView && dstPrim.indexView) {
                    idxCount = prim.indexView.count;
                    idxCount += dstPrim.indexView.count;
                    srcOffset = prim.indexView.offset;
                    dstOffset = dstPrim.indexView.offset;
                    if (idxCount < 256) {
                      idxStride = 1;
                    } else if (idxCount < 65536) {
                      idxStride = 2;
                    } else {
                      idxStride = 4;
                    }
                    var ib = new ArrayBuffer(idxCount * idxStride);
                    if (idxStride === 2) {
                      ibView = new Uint16Array(ib);
                    } else if (idxStride === 1) {
                      ibView = new Uint8Array(ib);
                    } else {
                      ibView = new Uint32Array(ib);
                    }
                    if (prim.indexView.stride === 2) {
                      srcIBView = new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count);
                    } else if (prim.indexView.stride === 1) {
                      srcIBView = new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count);
                    } else {
                      srcIBView = new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count);
                    }
                    if (idxStride === prim.indexView.stride) {
                      ibView.set(srcIBView);
                    } else {
                      for (var n = 0; n < prim.indexView.count; ++n) {
                        ibView[n] = srcIBView[n];
                      }
                    }
                    srcOffset += prim.indexView.length;
                    if (dstPrim.indexView.stride === 2) {
                      dstIBView = new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    } else if (dstPrim.indexView.stride === 1) {
                      dstIBView = new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    } else {
                      dstIBView = new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    }
                    for (var _n = 0; _n < dstPrim.indexView.count; ++_n) {
                      ibView[prim.indexView.count + _n] = vertBatchCount + dstIBView[_n];
                    }
                    dstOffset += dstPrim.indexView.length;
                    primitives[_i6].indexView = {
                      offset: bufferBlob.getLength(),
                      length: ib.byteLength,
                      count: idxCount,
                      stride: idxStride
                    };
                    bufferBlob.setNextAlignment(idxStride);
                    bufferBlob.addBuffer(ib);
                  }
                }
                var meshStruct = {
                  vertexBundles: vertexBundles,
                  primitives: primitives,
                  minPosition: this._struct.minPosition,
                  maxPosition: this._struct.maxPosition
                };
                if (meshStruct.minPosition && mesh._struct.minPosition && meshStruct.maxPosition && mesh._struct.maxPosition) {
                  if (worldMatrix) {
                    vec3Add(boundingBox.center, mesh._struct.maxPosition, mesh._struct.minPosition);
                    vec3MultiplyScalar(boundingBox.center, boundingBox.center, 0.5);
                    vec3Subtract(boundingBox.halfExtents, mesh._struct.maxPosition, mesh._struct.minPosition);
                    vec3MultiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
                    aabbTransform(boundingBox, boundingBox, worldMatrix);
                    vec3Add(vec3_temp, boundingBox.center, boundingBox.halfExtents);
                    vec3Max(meshStruct.maxPosition, meshStruct.maxPosition, vec3_temp);
                    vec3Subtract(vec3_temp, boundingBox.center, boundingBox.halfExtents);
                    vec3Min(meshStruct.minPosition, meshStruct.minPosition, vec3_temp);
                  } else {
                    vec3Min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition);
                    vec3Max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition);
                  }
                }
                this.reset({
                  struct: meshStruct,
                  data: new Uint8Array(bufferBlob.getCombined())
                });
                this.initialize();
                return true;
              };
              _proto.validateMergingMesh = function validateMergingMesh(mesh) {
                if (this._struct.dynamic || mesh._struct.dynamic) {
                  return false;
                }
                if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) {
                  return false;
                }
                for (var i = 0; i < this._struct.vertexBundles.length; ++i) {
                  var bundle = this._struct.vertexBundles[i];
                  var dstBundle = mesh._struct.vertexBundles[i];
                  if (bundle.attributes.length !== dstBundle.attributes.length) {
                    return false;
                  }
                  for (var j = 0; j < bundle.attributes.length; ++j) {
                    if (bundle.attributes[j].format !== dstBundle.attributes[j].format) {
                      return false;
                    }
                  }
                }
                if (this._struct.primitives.length !== mesh._struct.primitives.length) {
                  return false;
                }
                for (var _i7 = 0; _i7 < this._struct.primitives.length; ++_i7) {
                  var prim = this._struct.primitives[_i7];
                  var dstPrim = mesh._struct.primitives[_i7];
                  if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) {
                    return false;
                  }
                  for (var _j2 = 0; _j2 < prim.vertexBundelIndices.length; ++_j2) {
                    if (prim.vertexBundelIndices[_j2] !== dstPrim.vertexBundelIndices[_j2]) {
                      return false;
                    }
                  }
                  if (prim.primitiveMode !== dstPrim.primitiveMode) {
                    return false;
                  }
                  if (prim.indexView) {
                    if (dstPrim.indexView === undefined) {
                      return false;
                    }
                  } else if (dstPrim.indexView) {
                    return false;
                  }
                }
                return true;
              };
              _proto.readAttribute = function readAttribute(primitiveIndex, attributeName) {
                var _this2 = this;
                var result = null;
                this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
                  var vertexCount = vertexBundle.view.count;
                  var format = vertexBundle.attributes[iAttribute].format;
                  var StorageConstructor = getTypedArrayConstructor(FormatInfos[format]);
                  if (vertexCount === 0) {
                    return;
                  }
                  var inputView = new DataView(_this2._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
                  var formatInfo = FormatInfos[format];
                  var reader = getReader(inputView, format);
                  if (!StorageConstructor || !reader) {
                    return;
                  }
                  var componentCount = formatInfo.count;
                  var storage = new StorageConstructor(vertexCount * componentCount);
                  var inputStride = vertexBundle.view.stride;
                  for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
                    for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                      storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
                    }
                  }
                  result = storage;
                });
                return result;
              };
              _proto.copyAttribute = function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
                var _this3 = this;
                var written = false;
                this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
                  var vertexCount = vertexBundle.view.count;
                  if (vertexCount === 0) {
                    written = true;
                    return;
                  }
                  var format = vertexBundle.attributes[iAttribute].format;
                  var inputView = new DataView(_this3._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
                  var outputView = new DataView(buffer, offset);
                  var formatInfo = FormatInfos[format];
                  var reader = getReader(inputView, format);
                  var writer = getWriter(outputView, format);
                  if (!reader || !writer) {
                    return;
                  }
                  var componentCount = formatInfo.count;
                  var inputStride = vertexBundle.view.stride;
                  var inputComponentByteLength = getComponentByteLength(format);
                  var outputStride = stride;
                  var outputComponentByteLength = inputComponentByteLength;
                  for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
                    for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                      var inputOffset = inputStride * iVertex + inputComponentByteLength * iComponent;
                      var outputOffset = outputStride * iVertex + outputComponentByteLength * iComponent;
                      writer(outputOffset, reader(inputOffset));
                    }
                  }
                  written = true;
                });
                return written;
              };
              _proto.readIndices = function readIndices(primitiveIndex) {
                if (primitiveIndex >= this._struct.primitives.length) {
                  return null;
                }
                var primitive = this._struct.primitives[primitiveIndex];
                if (!primitive.indexView) {
                  return null;
                }
                var stride = primitive.indexView.stride;
                var Ctor = stride === 1 ? Uint8Array : stride === 2 ? Uint16Array : Uint32Array;
                return new Ctor(this._data.buffer, primitive.indexView.offset, primitive.indexView.count);
              };
              _proto.copyIndices = function copyIndices(primitiveIndex, outputArray) {
                if (primitiveIndex >= this._struct.primitives.length) {
                  return false;
                }
                var primitive = this._struct.primitives[primitiveIndex];
                if (!primitive.indexView) {
                  return false;
                }
                var indexCount = primitive.indexView.count;
                var indexFormat = primitive.indexView.stride === 1 ? 6 : primitive.indexView.stride === 2 ? 9 : 12;
                var reader = getReader(new DataView(this._data.buffer), indexFormat);
                for (var i = 0; i < indexCount; ++i) {
                  outputArray[i] = reader(primitive.indexView.offset + FormatInfos[indexFormat].size * i);
                }
                return true;
              };
              _proto.readAttributeFormat = function readAttributeFormat(primitiveIndex, attributeName) {
                var result = null;
                this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
                  var format = vertexBundle.attributes[iAttribute].format;
                  result = FormatInfos[format];
                });
                return result;
              };
              _proto._accessAttribute = function _accessAttribute(primitiveIndex, attributeName, accessor) {
                if (primitiveIndex >= this._struct.primitives.length) {
                  return;
                }
                var vertexBundelIndices = this._struct.primitives[primitiveIndex].vertexBundelIndices;
                for (var i = 0; i < vertexBundelIndices.length; i++) {
                  var vertexBundleIndex = vertexBundelIndices[i];
                  var _vertexBundle3 = this._struct.vertexBundles[vertexBundleIndex];
                  var _iAttribute = _vertexBundle3.attributes.findIndex(function (a) {
                    return a.name === attributeName;
                  });
                  if (_iAttribute < 0) {
                    continue;
                  }
                  accessor(_vertexBundle3, _iAttribute);
                  break;
                }
              };
              _proto._createVertexBuffers = function _createVertexBuffers(gfxDevice, data) {
                return this._struct.vertexBundles.map(function (vertexBundle) {
                  var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(8, 1, vertexBundle.view.length, vertexBundle.view.stride));
                  var view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);
                  vertexBuffer.update(view);
                  return vertexBuffer;
                });
              };
              _proto.initDefault = function initDefault(uuid) {
                _Asset.prototype.initDefault.call(this, uuid);
                this.reset({
                  struct: {
                    vertexBundles: [],
                    primitives: []
                  },
                  data: globalEmptyMeshBuffer
                });
              };
              _proto.releaseData = function releaseData() {
                this._data = globalEmptyMeshBuffer;
              };
              _createClass(Mesh, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._data.buffer;
                },
                set: function set(value) {
                  this._data = new Uint8Array(value);
                }
              }, {
                key: "subMeshCount",
                get: function get() {
                  var renderingMesh = this.renderingSubMeshes;
                  return renderingMesh ? renderingMesh.length : 0;
                }
              }, {
                key: "minPosition",
                get: function get() {
                  return this.struct.minPosition;
                }
              }, {
                key: "maxPosition",
                get: function get() {
                  return this.struct.maxPosition;
                }
              }, {
                key: "struct",
                get: function get() {
                  return this._struct;
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }, {
                key: "hash",
                get: function get() {
                  if (!this._hash) {
                    this._hash = murmurhash2_32_gc(this._data, 666);
                  }
                  return this._hash;
                }
              }, {
                key: "jointBufferIndices",
                get: function get() {
                  if (this._jointBufferIndices) {
                    return this._jointBufferIndices;
                  }
                  return this._jointBufferIndices = this._struct.primitives.map(function (p) {
                    return p.jointMapIndex || 0;
                  });
                }
              }, {
                key: "renderingSubMeshes",
                get: function get() {
                  this.initialize();
                  return this._renderingSubMeshes;
                }
              }, {
                key: "allowDataAccess",
                get: function get() {
                  return this._allowDataAccess;
                },
                set: function set(allowDataAccess) {
                  this._allowDataAccess = allowDataAccess;
                  if (this._isMeshDataUploaded && !this._allowDataAccess && true) {
                    this.releaseData();
                  }
                }
              }]);
              return Mesh;
            }(Asset), (_initializer$m = applyDecoratedInitializer(_class2$n.prototype, "_struct", [serializable$5], function () {
              return {
                vertexBundles: [],
                primitives: []
              };
            }), _initializer2$j = applyDecoratedInitializer(_class2$n.prototype, "_hash", [serializable$5], function () {
              return 0;
            }), _initializer3$e = applyDecoratedInitializer(_class2$n.prototype, "_allowDataAccess", [serializable$5], function () {
              return true;
            })), _class2$n)) || _class$q));
            cclegacy.Mesh = Mesh;
            function getOffset(attributes, attributeIndex) {
              var result = 0;
              for (var i = 0; i < attributeIndex; ++i) {
                var attribute = attributes[i];
                result += FormatInfos[attribute.format].size;
              }
              return result;
            }
            var isLittleEndian = sys.isLittleEndian;
            function getComponentByteLength(format) {
              var info = FormatInfos[format];
              return info.size / info.count;
            }
            function getReader(dataView, format) {
              var info = FormatInfos[format];
              var stride = info.size / info.count;
              switch (info.type) {
                case 1:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getUint8(offset);
                        };
                      case 2:
                        return function (offset) {
                          return dataView.getUint16(offset, isLittleEndian);
                        };
                      case 4:
                        return function (offset) {
                          return dataView.getUint32(offset, isLittleEndian);
                        };
                    }
                    break;
                  }
                case 2:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getInt8(offset);
                        };
                      case 2:
                        return function (offset) {
                          return dataView.getInt16(offset, isLittleEndian);
                        };
                      case 4:
                        return function (offset) {
                          return dataView.getInt32(offset, isLittleEndian);
                        };
                    }
                    break;
                  }
                case 4:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getInt8(offset);
                        };
                      case 2:
                        return function (offset) {
                          return dataView.getInt16(offset, isLittleEndian);
                        };
                      case 4:
                        return function (offset) {
                          return dataView.getInt32(offset, isLittleEndian);
                        };
                    }
                    break;
                  }
                case 3:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getUint8(offset);
                        };
                      case 2:
                        return function (offset) {
                          return dataView.getUint16(offset, isLittleEndian);
                        };
                      case 4:
                        return function (offset) {
                          return dataView.getUint32(offset, isLittleEndian);
                        };
                    }
                    break;
                  }
                case 6:
                  {
                    switch (stride) {
                      case 2:
                        return function (offset) {
                          return dataView.getUint16(offset, isLittleEndian);
                        };
                      case 4:
                        return function (offset) {
                          return dataView.getFloat32(offset, isLittleEndian);
                        };
                    }
                    break;
                  }
              }
              return null;
            }
            function getWriter(dataView, format) {
              var info = FormatInfos[format];
              var stride = info.size / info.count;
              switch (info.type) {
                case 1:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setUint8(offset, value);
                        };
                      case 2:
                        return function (offset, value) {
                          return dataView.setUint16(offset, value, isLittleEndian);
                        };
                      case 4:
                        return function (offset, value) {
                          return dataView.setUint32(offset, value, isLittleEndian);
                        };
                    }
                    break;
                  }
                case 2:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setInt8(offset, value);
                        };
                      case 2:
                        return function (offset, value) {
                          return dataView.setInt16(offset, value, isLittleEndian);
                        };
                      case 4:
                        return function (offset, value) {
                          return dataView.setInt32(offset, value, isLittleEndian);
                        };
                    }
                    break;
                  }
                case 4:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setInt8(offset, value);
                        };
                      case 2:
                        return function (offset, value) {
                          return dataView.setInt16(offset, value, isLittleEndian);
                        };
                      case 4:
                        return function (offset, value) {
                          return dataView.setInt32(offset, value, isLittleEndian);
                        };
                    }
                    break;
                  }
                case 3:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setUint8(offset, value);
                        };
                      case 2:
                        return function (offset, value) {
                          return dataView.setUint16(offset, value, isLittleEndian);
                        };
                      case 4:
                        return function (offset, value) {
                          return dataView.setUint32(offset, value, isLittleEndian);
                        };
                    }
                    break;
                  }
                case 6:
                  {
                    switch (stride) {
                      case 2:
                        return function (offset, value) {
                          return dataView.setUint16(offset, value, isLittleEndian);
                        };
                      case 4:
                        return function (offset, value) {
                          return dataView.setFloat32(offset, value, isLittleEndian);
                        };
                    }
                    break;
                  }
              }
              return null;
            }
            function decodeMesh(mesh) {
              if (!mesh.struct.encoded) {
                return mesh;
              }
              var res_checker = function res_checker(res) {
                if (res < 0) {
                  errorID(14204, res);
                }
              };
              var struct = JSON.parse(JSON.stringify(mesh.struct));
              var bufferBlob = new BufferBlob();
              bufferBlob.setNextAlignment(0);
              for (var _iterator4 = _createForOfIteratorHelperLoose(struct.vertexBundles), _step4; !(_step4 = _iterator4()).done;) {
                var bundle = _step4.value;
                var view = bundle.view;
                var bound = view.count * view.stride;
                var buffer = new Uint8Array(bound);
                var vertex = new Uint8Array(mesh.data.buffer, view.offset, view.length);
                var res = MeshoptDecoder.decodeVertexBuffer(buffer, view.count, view.stride, vertex);
                res_checker(res);
                bufferBlob.setNextAlignment(view.stride);
                var newView = {
                  offset: bufferBlob.getLength(),
                  length: buffer.byteLength,
                  count: view.count,
                  stride: view.stride
                };
                bundle.view = newView;
                bufferBlob.addBuffer(buffer);
              }
              for (var _iterator5 = _createForOfIteratorHelperLoose(struct.primitives), _step5; !(_step5 = _iterator5()).done;) {
                var primitive = _step5.value;
                if (primitive.indexView === undefined) {
                  continue;
                }
                var _view = primitive.indexView;
                var _bound = _view.count * _view.stride;
                var _buffer = new Uint8Array(_bound);
                var index = new Uint8Array(mesh.data.buffer, _view.offset, _view.length);
                var _res = MeshoptDecoder.decodeIndexBuffer(_buffer, _view.count, _view.stride, index);
                res_checker(_res);
                bufferBlob.setNextAlignment(_view.stride);
                var _newView = {
                  offset: bufferBlob.getLength(),
                  length: _buffer.byteLength,
                  count: _view.count,
                  stride: _view.stride
                };
                primitive.indexView = _newView;
                bufferBlob.addBuffer(_buffer);
              }
              var data = new Uint8Array(bufferBlob.getCombined());
              return {
                struct: struct,
                data: data
              };
            }
            function inflateMesh(mesh) {
              var inflator = new _p.Inflate(mesh.data);
              var decompressed = inflator.decompress();
              mesh.data = decompressed;
              mesh.struct.compressed = false;
              return mesh;
            }
            function dequantizeMesh(mesh) {
              var struct = JSON.parse(JSON.stringify(mesh.struct));
              var bufferBlob = new BufferBlob();
              bufferBlob.setNextAlignment(0);
              function transformVertex(reader, writer, count, components, componentSize, readerStride, writerStride) {
                for (var i = 0; i < count; i++) {
                  for (var j = 0; j < components; j++) {
                    var inputOffset = readerStride * i + componentSize * j;
                    var outputOffset = writerStride * i + componentSize * j;
                    writer(outputOffset, reader(inputOffset));
                  }
                }
              }
              function dequantizeHalf(reader, writer, count, components, readerStride, writerStride) {
                for (var i = 0; i < count; i++) {
                  for (var j = 0; j < components; j++) {
                    var inputOffset = readerStride * i + 2 * j;
                    var outputOffset = writerStride * i + 4 * j;
                    var _value = halfToFloat(reader(inputOffset));
                    writer(outputOffset, _value);
                  }
                }
              }
              for (var i = 0; i < struct.vertexBundles.length; ++i) {
                var bundle = struct.vertexBundles[i];
                var view = bundle.view;
                var attributes = bundle.attributes;
                var oldAttributes = mesh.struct.vertexBundles[i].attributes;
                var strides = [];
                var dequantizes = [];
                var readers = [];
                for (var j = 0; j < attributes.length; ++j) {
                  var attr = attributes[j];
                  var inputView = new DataView(mesh.data.buffer, view.offset + getOffset(oldAttributes, j));
                  var reader = getReader(inputView, attr.format);
                  var dequantize = true;
                  switch (attr.format) {
                    case 8:
                      attr.format = 11;
                      break;
                    case 18:
                      attr.format = 21;
                      break;
                    case 29:
                      attr.format = 32;
                      break;
                    case 41:
                      attr.format = 44;
                      break;
                    default:
                      dequantize = false;
                      break;
                  }
                  strides.push(FormatInfos[attr.format].size);
                  dequantizes.push(dequantize);
                  readers.push(reader);
                }
                var netStride = strides.reduce(function (acc, cur) {
                  return acc + cur;
                }, 0);
                var newBuffer = new Uint8Array(netStride * view.count);
                for (var _j3 = 0; _j3 < attributes.length; ++_j3) {
                  var attribute = attributes[_j3];
                  var _reader = readers[_j3];
                  var outputView = new DataView(newBuffer.buffer, getOffset(attributes, _j3));
                  var writer = getWriter(outputView, attribute.format);
                  var _dequantize = dequantizes[_j3];
                  var formatInfo = FormatInfos[attribute.format];
                  if (_dequantize) {
                    dequantizeHalf(_reader, writer, view.count, formatInfo.count, view.stride, netStride);
                  } else {
                    transformVertex(_reader, writer, view.count, formatInfo.count, formatInfo.size / formatInfo.count, view.stride, netStride);
                  }
                }
                bufferBlob.setNextAlignment(netStride);
                var newView = {
                  offset: bufferBlob.getLength(),
                  length: newBuffer.byteLength,
                  count: view.count,
                  stride: netStride
                };
                bundle.view = newView;
                bufferBlob.addBuffer(newBuffer);
              }
              for (var _iterator6 = _createForOfIteratorHelperLoose(struct.primitives), _step6; !(_step6 = _iterator6()).done;) {
                var primitive = _step6.value;
                if (primitive.indexView === undefined) {
                  continue;
                }
                var _view2 = primitive.indexView;
                var buffer = new Uint8Array(mesh.data.buffer, _view2.offset, _view2.length);
                bufferBlob.setNextAlignment(_view2.stride);
                var _newView2 = {
                  offset: bufferBlob.getLength(),
                  length: buffer.byteLength,
                  count: _view2.count,
                  stride: _view2.stride
                };
                primitive.indexView = _newView2;
                bufferBlob.addBuffer(buffer);
              }
              var data = new Uint8Array(bufferBlob.getCombined());
              struct.quantized = false;
              return {
                struct: struct,
                data: data
              };
            }

            var _defAttrs = [new Attribute("a_position", 32), new Attribute("a_normal", 32), new Attribute("a_texCoord", 21), new Attribute("a_tangent", 44), new Attribute("a_color", 44)];
            var v3_1$2 = new Vec3();
            function _createMesh(geometry, out, options) {
              options = options || {};
              var attributes = [];
              var stride = 0;
              var channels = [];
              var vertCount = 0;
              var attr;
              var positions = geometry.positions.slice();
              if (positions.length > 0) {
                attr = null;
                if (geometry.attributes) {
                  attr = geometry.attributes.find(function (att) {
                    return att.name === "a_position";
                  }) || null;
                }
                if (!attr) {
                  attr = _defAttrs[0];
                }
                attributes.push(attr);
                var info = FormatInfos[attr.format];
                vertCount = Math.max(vertCount, Math.floor(positions.length / info.count));
                channels.push({
                  offset: stride,
                  data: positions,
                  attribute: attr
                });
                stride += info.size;
              }
              if (geometry.normals && geometry.normals.length > 0) {
                attr = null;
                if (geometry.attributes) {
                  attr = geometry.attributes.find(function (att) {
                    return att.name === "a_normal";
                  }) || null;
                }
                if (!attr) {
                  attr = _defAttrs[1];
                }
                var _info = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count));
                channels.push({
                  offset: stride,
                  data: geometry.normals,
                  attribute: attr
                });
                stride += _info.size;
              }
              if (geometry.uvs && geometry.uvs.length > 0) {
                attr = null;
                if (geometry.attributes) {
                  attr = geometry.attributes.find(function (att) {
                    return att.name === "a_texCoord";
                  }) || null;
                }
                if (!attr) {
                  attr = _defAttrs[2];
                }
                var _info2 = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count));
                channels.push({
                  offset: stride,
                  data: geometry.uvs,
                  attribute: attr
                });
                stride += _info2.size;
              }
              if (geometry.tangents && geometry.tangents.length > 0) {
                attr = null;
                if (geometry.attributes) {
                  attr = geometry.attributes.find(function (att) {
                    return att.name === "a_tangent";
                  }) || null;
                }
                if (!attr) {
                  attr = _defAttrs[3];
                }
                var _info3 = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.tangents.length / _info3.count));
                channels.push({
                  offset: stride,
                  data: geometry.tangents,
                  attribute: attr
                });
                stride += _info3.size;
              }
              if (geometry.colors && geometry.colors.length > 0) {
                attr = null;
                if (geometry.attributes) {
                  attr = geometry.attributes.find(function (att) {
                    return att.name === "a_color";
                  }) || null;
                }
                if (!attr) {
                  attr = _defAttrs[4];
                }
                var _info4 = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info4.count));
                channels.push({
                  offset: stride,
                  data: geometry.colors,
                  attribute: attr
                });
                stride += _info4.size;
              }
              if (geometry.customAttributes) {
                for (var k = 0; k < geometry.customAttributes.length; k++) {
                  var ca = geometry.customAttributes[k];
                  var _info5 = FormatInfos[ca.attr.format];
                  attributes.push(ca.attr);
                  vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info5.count));
                  channels.push({
                    offset: stride,
                    data: ca.values,
                    attribute: ca.attr
                  });
                  stride += _info5.size;
                }
              }
              var bufferBlob = new BufferBlob();
              var vertexBuffer = new ArrayBuffer(vertCount * stride);
              var vertexBufferView = new DataView(vertexBuffer);
              channels.forEach(function (channel) {
                writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
              });
              bufferBlob.setNextAlignment(0);
              var vertexBundle = {
                attributes: attributes,
                view: {
                  offset: bufferBlob.getLength(),
                  length: vertexBuffer.byteLength,
                  count: vertCount,
                  stride: stride
                }
              };
              bufferBlob.addBuffer(vertexBuffer);
              var indexBuffer = null;
              var idxCount = 0;
              var idxStride = 2;
              if (geometry.indices) {
                var indices = geometry.indices;
                idxCount = indices.length;
                indexBuffer = new ArrayBuffer(idxStride * idxCount);
                var indexBufferView = new DataView(indexBuffer);
                writeBuffer(indexBufferView, indices, 9);
              }
              var primitive = {
                primitiveMode: geometry.primitiveMode || 7,
                vertexBundelIndices: [0]
              };
              if (indexBuffer) {
                bufferBlob.setNextAlignment(idxStride);
                primitive.indexView = {
                  offset: bufferBlob.getLength(),
                  length: indexBuffer.byteLength,
                  count: idxCount,
                  stride: idxStride
                };
                bufferBlob.addBuffer(indexBuffer);
              }
              var minPosition = geometry.minPos;
              if (!minPosition && options.calculateBounds) {
                minPosition = Vec3.set(new Vec3(), Infinity, Infinity, Infinity);
                for (var iVertex = 0; iVertex < vertCount; ++iVertex) {
                  Vec3.set(v3_1$2, positions[iVertex * 3 + 0], positions[iVertex * 3 + 1], positions[iVertex * 3 + 2]);
                  Vec3.min(minPosition, minPosition, v3_1$2);
                }
              }
              var maxPosition = geometry.maxPos;
              if (!maxPosition && options.calculateBounds) {
                maxPosition = Vec3.set(new Vec3(), -Infinity, -Infinity, -Infinity);
                for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) {
                  Vec3.set(v3_1$2, positions[_iVertex * 3 + 0], positions[_iVertex * 3 + 1], positions[_iVertex * 3 + 2]);
                  Vec3.max(maxPosition, maxPosition, v3_1$2);
                }
              }
              var meshStruct = {
                vertexBundles: [vertexBundle],
                primitives: [primitive]
              };
              if (minPosition) {
                meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z);
              }
              if (maxPosition) {
                meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z);
              }
              if (!out) {
                out = new Mesh();
              }
              out.reset({
                struct: meshStruct,
                data: new Uint8Array(bufferBlob.getCombined())
              });
              return out;
            }
            function getPadding(length, align) {
              if (align > 0) {
                var remainder = length % align;
                if (remainder !== 0) {
                  var padding = align - remainder;
                  return padding;
                }
              }
              return 0;
            }
            function _createDynamicMesh(primitiveIndex, geometry, out, options) {
              options = options || {
                maxSubMeshes: 1,
                maxSubMeshVertices: 1024,
                maxSubMeshIndices: 1024
              };
              var attributes = [];
              var stream = 0;
              if (geometry.positions.length > 0) {
                attributes.push(new Attribute("a_position", 32, false, stream++, false, 0));
              }
              if (geometry.normals && geometry.normals.length > 0) {
                attributes.push(new Attribute("a_normal", 32, false, stream++, false, 0));
              }
              if (geometry.uvs && geometry.uvs.length > 0) {
                attributes.push(new Attribute("a_texCoord", 21, false, stream++, false, 0));
              }
              if (geometry.tangents && geometry.tangents.length > 0) {
                attributes.push(new Attribute("a_tangent", 44, false, stream++, false, 0));
              }
              if (geometry.colors && geometry.colors.length > 0) {
                attributes.push(new Attribute("a_color", 44, false, stream++, false, 0));
              }
              if (geometry.customAttributes) {
                for (var k = 0; k < geometry.customAttributes.length; k++) {
                  var ca = geometry.customAttributes[k];
                  var attr = new Attribute();
                  attr.copy(ca.attr);
                  attr.stream = stream++;
                  attributes.push(attr);
                }
              }
              var vertexBundles = [];
              var primitives = [];
              var dataSize = 0;
              for (var i = 0; i < options.maxSubMeshes; i++) {
                var primitive = {
                  vertexBundelIndices: [],
                  primitiveMode: geometry.primitiveMode || 7
                };
                for (var _iterator = _createForOfIteratorHelperLoose(attributes), _step; !(_step = _iterator()).done;) {
                  var _attr = _step.value;
                  var formatInfo = FormatInfos[_attr.format];
                  var vertexBufferSize = options.maxSubMeshVertices * formatInfo.size;
                  var vertexView = {
                    offset: dataSize,
                    length: vertexBufferSize,
                    count: 0,
                    stride: formatInfo.size
                  };
                  var vertexBundle = {
                    view: vertexView,
                    attributes: [_attr]
                  };
                  var vertexBundleIndex = vertexBundles.length;
                  primitive.vertexBundelIndices.push(vertexBundleIndex);
                  vertexBundles.push(vertexBundle);
                  dataSize += vertexBufferSize;
                }
                var stride = 0;
                if (geometry.indices16 && geometry.indices16.length > 0) {
                  stride = 2;
                } else if (geometry.indices32 && geometry.indices32.length > 0) {
                  stride = 4;
                }
                if (stride > 0) {
                  dataSize += getPadding(dataSize, stride);
                  var indexBufferSize = options.maxSubMeshIndices * stride;
                  var indexView = {
                    offset: dataSize,
                    length: indexBufferSize,
                    count: 0,
                    stride: stride
                  };
                  primitive.indexView = indexView;
                  dataSize += indexBufferSize;
                }
                primitives.push(primitive);
              }
              var dynamicInfo = {
                maxSubMeshes: options.maxSubMeshes,
                maxSubMeshVertices: options.maxSubMeshVertices,
                maxSubMeshIndices: options.maxSubMeshIndices
              };
              var dynamicStruct = {
                info: dynamicInfo,
                bounds: []
              };
              dynamicStruct.bounds.length = options.maxSubMeshes;
              var meshStruct = {
                vertexBundles: vertexBundles,
                primitives: primitives,
                dynamic: dynamicStruct
              };
              var createInfo = {
                struct: meshStruct,
                data: new Uint8Array(dataSize)
              };
              if (!out) {
                out = new Mesh();
              }
              out.reset(createInfo);
              out.initialize();
              out.updateSubMesh(primitiveIndex, geometry);
              return out;
            }
            var MeshUtils = function () {
              function MeshUtils() {}
              MeshUtils.createMesh = function createMesh(geometry, out, options) {
                return _createMesh(geometry, out, options);
              };
              MeshUtils.createDynamicMesh = function createDynamicMesh(primitiveIndex, geometry, out, options) {
                return _createDynamicMesh(primitiveIndex, geometry, out, options);
              };
              MeshUtils.decodeMesh = function decodeMesh$1(mesh) {
                return decodeMesh(mesh);
              };
              MeshUtils.inflateMesh = function inflateMesh$1(mesh) {
                return inflateMesh(mesh);
              };
              return MeshUtils;
            }();

            var utils = /*#__PURE__*/Object.freeze({
                __proto__: null,
                MeshUtils: MeshUtils,
                createMesh: _createMesh,
                find: find,
                mapBuffer: mapBuffer,
                readBuffer: readBuffer,
                readMesh: readMesh,
                toPPM: toPPM,
                writeBuffer: writeBuffer
            });
            exports("utils", utils);

            function createIA(device, data) {
              if (!data.positions) {
                errorID(16306);
                return null;
              }
              var verts = [];
              var vcount = data.positions.length / 3;
              for (var i = 0; i < vcount; ++i) {
                verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);
                if (data.normals) {
                  verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
                }
                if (data.uvs) {
                  verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
                }
                if (data.colors) {
                  verts.push(data.colors[3 * i], data.colors[3 * i + 1], data.colors[3 * i + 2]);
                }
              }
              var vfmt = [];
              vfmt.push(new Attribute("a_position", 32));
              if (data.normals) {
                vfmt.push(new Attribute("a_normal", 32));
              }
              if (data.uvs) {
                vfmt.push(new Attribute("a_texCoord", 21));
              }
              if (data.colors) {
                vfmt.push(new Attribute("a_color", 32));
              }
              var vb = device.createBuffer(new BufferInfo(8 | 2, 1, verts.length * 4, verts.length * 4 / vcount));
              vb.update(new Float32Array(verts));
              var ib = null;
              if (data.indices) {
                ib = device.createBuffer(new BufferInfo(4 | 2, 1, data.indices.length * 2, 2));
                ib.update(new Uint16Array(data.indices));
              }
              return device.createInputAssembler(new InputAssemblerInfo(vfmt, [vb], ib));
            }

            var RenderQueue$2 = {
              OPAQUE: 0,
              TRANSPARENT: 1,
              OVERLAY: 2
            };
            var PassStage = {
              DEFAULT: 1,
              FORWARD: 2,
              SHADOWCAST: 4
            };

            function nearestPOT(num) {
              --num;
              num |= num >> 16;
              num |= num >> 8;
              num |= num >> 4;
              num |= num >> 2;
              num |= num >> 1;
              ++num;
              return num;
            }
            function roundUp(n, alignment) {
              return Math.ceil(n / alignment) * alignment;
            }
            var TextureBufferPool = function () {
              function TextureBufferPool(device) {
                this._format = 0;
                this._formatSize = 0;
                this._chunks = [];
                this._chunkCount = 0;
                this._handles = [];
                this._region0 = new BufferTextureCopy();
                this._region1 = new BufferTextureCopy();
                this._region2 = new BufferTextureCopy();
                this._roundUpFn = null;
                this._bufferViewCtor = Uint8Array;
                this._channels = 4;
                this._alignment = 1;
                this._device = device;
              }
              var _proto = TextureBufferPool.prototype;
              _proto.initialize = function initialize(info) {
                var formatInfo = FormatInfos[info.format];
                this._format = info.format;
                this._formatSize = formatInfo.size;
                this._channels = formatInfo.count;
                this._bufferViewCtor = getTypedArrayConstructor(formatInfo);
                this._roundUpFn = info.roundUpFn || null;
                this._alignment = info.alignment || 1;
                if (info.inOrderFree) {
                  this.alloc = this._McDonaldAlloc;
                }
              };
              _proto.destroy = function destroy() {
                for (var i = 0; i < this._chunkCount; ++i) {
                  var chunk = this._chunks[i];
                  chunk.texture.destroy();
                }
                this._chunks.length = 0;
                this._handles.length = 0;
              };
              _proto.alloc = function alloc(size, chunkIdx) {
                size = roundUp(size, this._alignment);
                var index = -1;
                var start = -1;
                if (chunkIdx !== undefined) {
                  index = chunkIdx;
                  start = this._findAvailableSpace(size, index);
                }
                if (start < 0) {
                  for (var i = 0; i < this._chunkCount; ++i) {
                    index = i;
                    start = this._findAvailableSpace(size, index);
                    if (start >= 0) {
                      break;
                    }
                  }
                }
                if (start >= 0) {
                  var chunk = this._chunks[index];
                  chunk.start += size;
                  var handle = {
                    chunkIdx: index,
                    start: start,
                    end: start + size,
                    texture: chunk.texture
                  };
                  this._handles.push(handle);
                  return handle;
                }
                var targetSize = Math.sqrt(size / this._formatSize);
                var texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));
                var newChunk = this._chunks[this.createChunk(texLength)];
                newChunk.start += size;
                var texHandle = {
                  chunkIdx: this._chunkCount - 1,
                  start: 0,
                  end: size,
                  texture: newChunk.texture
                };
                this._handles.push(texHandle);
                return texHandle;
              };
              _proto.free = function free(handle) {
                for (var i = 0; i < this._handles.length; ++i) {
                  if (this._handles[i] === handle) {
                    this._chunks[handle.chunkIdx].end = handle.end;
                    this._handles.splice(i, 1);
                    return;
                  }
                }
              };
              _proto.createChunk = function createChunk(length) {
                var texSize = length * length * this._formatSize;
                debug("TextureBufferPool: Allocate chunk " + this._chunkCount + ", size: " + texSize + ", format: " + this._format);
                var texture = this._device.createTexture(new TextureInfo(1, 4 | 2, this._format, length, length));
                var chunk = {
                  texture: texture,
                  size: texSize,
                  start: 0,
                  end: texSize
                };
                this._chunks[this._chunkCount] = chunk;
                return this._chunkCount++;
              };
              _proto.update = function update(handle, buffer) {
                var buffers = [];
                var regions = [];
                var start = handle.start / this._formatSize;
                var remainSize = buffer.byteLength / this._formatSize;
                var offsetX = start % handle.texture.width;
                var offsetY = Math.floor(start / handle.texture.width);
                var copySize = Math.min(handle.texture.width - offsetX, remainSize);
                var begin = 0;
                if (offsetX > 0) {
                  this._region0.texOffset.x = offsetX;
                  this._region0.texOffset.y = offsetY;
                  this._region0.texExtent.width = copySize;
                  this._region0.texExtent.height = 1;
                  buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
                  regions.push(this._region0);
                  offsetX = 0;
                  offsetY += 1;
                  remainSize -= copySize;
                  begin += copySize;
                }
                if (remainSize > 0) {
                  this._region1.texOffset.x = offsetX;
                  this._region1.texOffset.y = offsetY;
                  if (remainSize > handle.texture.width) {
                    this._region1.texExtent.width = handle.texture.width;
                    this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width);
                    copySize = this._region1.texExtent.width * this._region1.texExtent.height;
                  } else {
                    copySize = remainSize;
                    this._region1.texExtent.width = copySize;
                    this._region1.texExtent.height = 1;
                  }
                  buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
                  regions.push(this._region1);
                  offsetX = 0;
                  offsetY += this._region1.texExtent.height;
                  remainSize -= copySize;
                  begin += copySize;
                }
                if (remainSize > 0) {
                  this._region2.texOffset.x = offsetX;
                  this._region2.texOffset.y = offsetY;
                  this._region2.texExtent.width = remainSize;
                  this._region2.texExtent.height = 1;
                  buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels));
                  regions.push(this._region2);
                }
                this._device.copyBuffersToTexture(buffers, handle.texture, regions);
              };
              _proto._findAvailableSpace = function _findAvailableSpace(size, chunkIdx) {
                var chunk = this._chunks[chunkIdx];
                var isFound = false;
                var start = chunk.start;
                if (start + size <= chunk.size) {
                  isFound = true;
                } else {
                  start = 0;
                  var handles = this._handles.filter(function (h) {
                    return h.chunkIdx === chunkIdx;
                  }).sort(function (a, b) {
                    return a.start - b.start;
                  });
                  for (var i = 0; i < handles.length; i++) {
                    var handle = handles[i];
                    if (start + size <= handle.start) {
                      isFound = true;
                      break;
                    }
                    start = handle.end;
                  }
                  if (!isFound && start + size <= chunk.size) {
                    isFound = true;
                  }
                }
                return isFound ? start : -1;
              };
              _proto._McDonaldAlloc = function _McDonaldAlloc(size) {
                size = roundUp(size, this._alignment);
                for (var i = 0; i < this._chunkCount; ++i) {
                  var chunk = this._chunks[i];
                  var isFound = false;
                  var start = chunk.start;
                  if (start + size <= chunk.end) {
                    isFound = true;
                  } else if (start > chunk.end) {
                    if (start + size <= chunk.size) {
                      isFound = true;
                    } else if (size <= chunk.end) {
                      chunk.start = start = 0;
                      isFound = true;
                    }
                  } else if (start === chunk.end) {
                    chunk.start = start = 0;
                    chunk.end = chunk.size;
                    if (size <= chunk.end) {
                      isFound = true;
                    }
                  }
                  if (isFound) {
                    chunk.start += size;
                    var handle = {
                      chunkIdx: i,
                      start: start,
                      end: start + size,
                      texture: chunk.texture
                    };
                    this._handles.push(handle);
                    return handle;
                  }
                }
                var targetSize = Math.sqrt(size / this._formatSize);
                var texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));
                var newChunk = this._chunks[this.createChunk(texLength)];
                newChunk.start += size;
                var texHandle = {
                  chunkIdx: this._chunkCount,
                  start: 0,
                  end: size,
                  texture: newChunk.texture
                };
                this._handles.push(texHandle);
                return texHandle;
              };
              return TextureBufferPool;
            }();

            removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
              name: 'raycastUI2DNode'
            }, {
              name: 'raycastUINode'
            }]);
            removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
              name: 'raycastAll',
              suggest: 'using intersect.rayModel in geometry'
            }, {
              name: 'raycastAllModels',
              suggest: 'using intersect.rayModel in geometry'
            }, {
              name: 'raycastSingleModel',
              suggest: 'using intersect.rayModel in geometry'
            }, {
              name: 'raycastAllCanvas',
              suggest: 'using intersect.rayAABB in geometry'
            }, {
              name: 'rayResultCanvas'
            }, {
              name: 'rayResultModels'
            }, {
              name: 'rayResultAll'
            }, {
              name: 'rayResultSingleModel'
            }]);
            removeProperty(Model.prototype, 'Model.prototype', [{
              name: 'isInstancingEnabled'
            }, {
              name: 'instancedAttributes'
            }]);
            var CameraVisFlags = {};
            removeProperty(CameraVisFlags, 'CameraVisFlags', [{
              name: 'GENERAL'
            }]);
            replaceProperty(CameraVisFlags, 'CameraVisFlags', [{
              name: 'PROFILER',
              newName: 'PROFILER',
              target: Layers.BitMask,
              targetName: 'PROFILER'
            }, {
              name: 'GIZMOS',
              newName: 'GIZMOS',
              target: Layers.BitMask,
              targetName: 'GIZMOS'
            }, {
              name: 'EDITOR',
              newName: 'EDITOR',
              target: Layers.BitMask,
              targetName: 'EDITOR'
            }, {
              name: 'UI',
              newName: 'UI',
              target: Layers.BitMask,
              targetName: 'UI_3D'
            }, {
              name: 'UI2D',
              newName: 'UI2D',
              target: Layers.BitMask,
              targetName: 'UI_2D'
            }]);
            legacyCC.CameraVisFlags = CameraVisFlags;
            var VisibilityFlags = {};
            removeProperty(VisibilityFlags, 'VisibilityFlags', [{
              name: 'GENERAL'
            }]);
            replaceProperty(VisibilityFlags, 'VisibilityFlags', [{
              name: 'ALWALS',
              newName: 'ALWALS',
              target: Layers.Enum,
              targetName: 'ALWALS'
            }, {
              name: 'PROFILER',
              newName: 'PROFILER',
              target: Layers.Enum,
              targetName: 'PROFILER'
            }, {
              name: 'GIZMOS',
              newName: 'GIZMOS',
              target: Layers.Enum,
              targetName: 'GIZMOS'
            }, {
              name: 'EDITOR',
              newName: 'EDITOR',
              target: Layers.Enum,
              targetName: 'EDITOR'
            }, {
              name: 'UI',
              newName: 'UI',
              target: Layers.Enum,
              targetName: 'UI_3D'
            }, {
              name: 'UI2D',
              newName: 'UI2D',
              target: Layers.Enum,
              targetName: 'UI_2D'
            }]);
            legacyCC.VisibilityFlags = VisibilityFlags;
            replaceProperty(Pass.prototype, 'Pass.prototype', [{
              name: 'getBindingTypeFromHandle',
              newName: 'getDescriptorTypeFromHandle'
            }]);
            removeProperty(Camera$1.prototype, 'Camera.prototype', [{
              name: 'getSplitFrustum'
            }, {
              name: 'setMatView'
            }, {
              name: 'setMatViewInv'
            }, {
              name: 'setMatProjInv'
            }, {
              name: 'setMatViewProjInv'
            }, {
              name: 'setMatProj'
            }, {
              name: 'setMatViewProj'
            }, {
              name: 'getMatViewInv'
            }]);
            removeProperty(Shadows.prototype, 'Shadows.prototype', [{
              name: 'aspect'
            }, {
              name: 'selfShadow'
            }, {
              name: 'linear'
            }, {
              name: 'packing'
            }, {
              name: 'autoAdapt'
            }, {
              name: 'fixedArea'
            }, {
              name: 'pcf'
            }, {
              name: 'bias'
            }, {
              name: 'normalBias'
            }, {
              name: 'near'
            }, {
              name: 'far'
            }, {
              name: 'shadowDistance'
            }, {
              name: 'invisibleOcclusionRange'
            }, {
              name: 'orthoSize'
            }, {
              name: 'saturation'
            }]);
            removeProperty(SpotLight$1.prototype, 'SpotLight.prototype', [{
              name: 'aspect'
            }]);
            replaceProperty(SubModel.prototype, 'SubModel.prototype', [{
              name: 'subMeshData',
              newName: 'subMesh'
            }]);
            removeProperty(SubModel.prototype, 'SubModel.prototype', [{
              name: 'getSubModel',
              suggest: 'Use `subModels[i]` instead'
            }, {
              name: 'subModelNum',
              suggest: 'Use `subModels.length` instead'
            }]);

            var renderer = /*#__PURE__*/Object.freeze({
                __proto__: null,
                BatchingSchemes: BatchingSchemes,
                CameraVisFlags: CameraVisFlags,
                MaterialInstance: MaterialInstance,
                Pass: Pass,
                PassInstance: PassInstance,
                PassStage: PassStage,
                RenderQueue: RenderQueue$2,
                RenderScene: RenderScene,
                RenderWindow: RenderWindow,
                TextureBufferPool: TextureBufferPool,
                VisibilityFlags: VisibilityFlags,
                createIA: createIA,
                customizeType: customizeType,
                genHandle: genHandle,
                getBindingFromHandle: getBindingFromHandle,
                getCountFromHandle: getCountFromHandle,
                getDefaultFromType: getDefaultFromType,
                getDeviceShaderVersion: getDeviceShaderVersion,
                getOffsetFromHandle: getOffsetFromHandle,
                getStringFromType: getStringFromType,
                getTypeFromHandle: getTypeFromHandle,
                nearestPOT: nearestPOT,
                overrideMacros: overrideMacros,
                programLib: programLib$1,
                scene: index,
                type2reader: type2reader,
                type2validator: type2validator,
                type2writer: type2writer
            });
            exports("renderer", renderer);

            var MorphModel = function (_Model) {
              _inheritsLoose(MorphModel, _Model);
              function MorphModel() {
                var _this;
                _this = _Model.call(this) || this;
                _this._morphRenderingInstance = null;
                _this._usedMaterials = new Set();
                return _this;
              }
              var _proto = MorphModel.prototype;
              _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
                var superMacroPatches = _Model.prototype.getMacroPatches.call(this, subModelIndex);
                if (this._morphRenderingInstance) {
                  var morphInstanceMacroPatches = this._morphRenderingInstance.requiredPatches(subModelIndex);
                  if (morphInstanceMacroPatches) {
                    return morphInstanceMacroPatches.concat(superMacroPatches !== null && superMacroPatches !== undefined ? superMacroPatches : []);
                  }
                }
                return superMacroPatches;
              };
              _proto.initSubModel = function initSubModel(subModelIndex, subMeshData, material) {
                return _Model.prototype.initSubModel.call(this, subModelIndex, subMeshData, this._launderMaterial(material));
              };
              _proto.destroy = function destroy() {
                _Model.prototype.destroy.call(this);
                this._morphRenderingInstance = null;
              };
              _proto.setSubModelMaterial = function setSubModelMaterial(subModelIndex, material) {
                return _Model.prototype.setSubModelMaterial.call(this, subModelIndex, this._launderMaterial(material));
              };
              _proto.setMorphRendering = function setMorphRendering(morphRendering) {
                this._morphRenderingInstance = morphRendering;
              };
              _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                _Model.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);
                if (this._morphRenderingInstance) {
                  this._morphRenderingInstance.adaptPipelineState(submodelIdx, descriptorSet);
                }
              };
              _proto._launderMaterial = function _launderMaterial(material) {
                return material;
              };
              return MorphModel;
            }(Model);

            var _dec$p, _dec2$l, _dec3$j, _class$p, _class2$m, _initializer$l;
            var _matInsInfo = {
              parent: null,
              owner: null,
              subModelIdx: 0
            };
            var ccclass$4 = ccclass$6,
              disallowMultiple = disallowMultiple$1,
              type$4 = type$5;
            var Renderer = exports("Renderer", (_dec$p = ccclass$4('cc.Renderer'), _dec2$l = type$4(Material), _dec3$j = type$4([Material]), _dec$p(_class$p = disallowMultiple(_class$p = (_class2$m = function (_Component) {
              _inheritsLoose(Renderer, _Component);
              function Renderer() {
                var _this;
                _this = _Component.call(this) || this;
                _this._materials = _initializer$l && _initializer$l();
                _this._materialInstances = [];
                return _this;
              }
              var _proto = Renderer.prototype;
              _proto.getMaterial = function getMaterial(idx) {
                return this.getSharedMaterial(idx);
              };
              _proto.setMaterial = function setMaterial(material, index) {
                this.setSharedMaterial(material, index);
              };
              _proto.getSharedMaterial = function getSharedMaterial(idx) {
                if (idx < 0 || idx >= this._materials.length) {
                  return null;
                }
                return this._materials[idx];
              };
              _proto.setSharedMaterial = function setSharedMaterial(material, index, forceUpdate) {
                if (forceUpdate === undefined) {
                  forceUpdate = false;
                }
                if (material && material instanceof MaterialInstance) {
                  errorID(12012);
                }
                if (!forceUpdate && this._materials[index] === material) return;
                this._materials[index] = material;
                var inst = this._materialInstances[index];
                if (inst) {
                  inst.destroy();
                  this._materialInstances[index] = null;
                }
                this._onMaterialModified(index, this._materials[index]);
              };
              _proto.getMaterialInstance = function getMaterialInstance(idx) {
                var mat = this._materials[idx];
                if (!mat) {
                  return null;
                }
                if (!this._materialInstances[idx]) {
                  _matInsInfo.parent = this._materials[idx];
                  _matInsInfo.owner = this;
                  _matInsInfo.subModelIdx = idx;
                  var instantiated = new MaterialInstance(_matInsInfo);
                  _matInsInfo.parent = null;
                  _matInsInfo.owner = null;
                  _matInsInfo.subModelIdx = 0;
                  this.setMaterialInstance(instantiated, idx);
                }
                return this._materialInstances[idx];
              };
              _proto.setMaterialInstance = function setMaterialInstance(matInst, index) {
                if (typeof matInst === 'number') {
                  warnID(12007);
                  var temp = matInst;
                  matInst = index;
                  index = temp;
                }
                var curInst = this._materialInstances[index];
                if (matInst && matInst.parent) {
                  if (matInst !== curInst) {
                    this._materialInstances[index] = matInst;
                    this._onMaterialModified(index, matInst);
                  }
                  return;
                }
                if (matInst !== this._materials[index] || curInst) {
                  this.setSharedMaterial(matInst, index);
                }
              };
              _proto.getRenderMaterial = function getRenderMaterial(index) {
                return this._materialInstances[index] || this._materials[index];
              };
              _proto._onMaterialModified = function _onMaterialModified(index, material) {};
              _proto._onRebuildPSO = function _onRebuildPSO(index, material) {};
              _proto._clearMaterials = function _clearMaterials() {};
              _createClass(Renderer, [{
                key: "sharedMaterial",
                get: function get() {
                  return this.getSharedMaterial(0);
                }
              }, {
                key: "sharedMaterials",
                get: function get() {
                  return this._materials;
                },
                set: function set(val) {
                  for (var i = 0; i < val.length; i++) {
                    if (val[i] !== this._materials[i]) {
                      this.setSharedMaterial(val[i], i);
                    }
                  }
                  if (val.length < this._materials.length) {
                    for (var _i = val.length; _i < this._materials.length; _i++) {
                      this.setSharedMaterial(null, _i);
                    }
                    this._materials.splice(val.length);
                  }
                }
              }, {
                key: "material",
                get: function get() {
                  return this.getMaterialInstance(0);
                },
                set: function set(val) {
                  if (this._materials.length === 1 && !this._materialInstances[0] && this._materials[0] === val) {
                    return;
                  }
                  this.setMaterialInstance(val, 0);
                }
              }, {
                key: "materials",
                get: function get() {
                  for (var i = 0; i < this._materials.length; i++) {
                    this._materialInstances[i] = this.getMaterialInstance(i);
                  }
                  return this._materialInstances;
                },
                set: function set(val) {
                  var newLength = val.length;
                  var oldLength = this._materials.length;
                  for (var i = newLength; i < oldLength; i++) {
                    this.setMaterialInstance(null, i);
                  }
                  this._materials.length = newLength;
                  this._materialInstances.length = newLength;
                  for (var _i2 = 0; _i2 < newLength; _i2++) {
                    if (this._materialInstances[_i2] != val[_i2]) {
                      this.setMaterialInstance(val[_i2], _i2);
                    }
                  }
                }
              }]);
              return Renderer;
            }(Component), (_applyDecoratedDescriptor(_class2$m.prototype, "sharedMaterials", [_dec2$l], Object.getOwnPropertyDescriptor(_class2$m.prototype, "sharedMaterials"), _class2$m.prototype), _initializer$l = applyDecoratedInitializer(_class2$m.prototype, "_materials", [_dec3$j], function () {
              return [];
            })), _class2$m)) || _class$p) || _class$p));

            var _dec$o, _class$o, _class2$l, _initializer$k;
            getPhaseID$1('specular-pass');
            var ModelRenderer = (_dec$o = ccclass$6('cc.ModelRenderer'), _dec$o(_class$o = (_class2$l = function (_Renderer) {
              _inheritsLoose(ModelRenderer, _Renderer);
              function ModelRenderer() {
                var _this;
                _this = _Renderer.call(this) || this;
                _this._visFlags = _initializer$k && _initializer$k();
                _this._models = [];
                _this._priority = 0;
                return _this;
              }
              var _proto = ModelRenderer.prototype;
              _proto._collectModels = function _collectModels() {
                return this._models;
              };
              _proto.onEnable = function onEnable() {
                this._updatePriority();
              };
              _proto._attachToScene = function _attachToScene() {};
              _proto._detachFromScene = function _detachFromScene() {};
              _proto._onVisibilityChange = function _onVisibilityChange(val) {};
              _proto._updatePriority = function _updatePriority() {
                if (this._models.length > 0) {
                  for (var i = 0; i < this._models.length; i++) {
                    this._models[i].priority = this._priority;
                  }
                }
              };
              _createClass(ModelRenderer, [{
                key: "visibility",
                get: function get() {
                  return this._visFlags;
                },
                set: function set(val) {
                  this._visFlags = val;
                  this._onVisibilityChange(val);
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(val) {
                  if (val === this._priority) return;
                  this._priority = val;
                  this._updatePriority();
                }
              }]);
              return ModelRenderer;
            }(Renderer), (_initializer$k = applyDecoratedInitializer(_class2$l.prototype, "_visFlags", [serializable$5], function () {
              return Layers.Enum.NONE;
            })), _class2$l)) || _class$o); exports({ ModelRenderer: ModelRenderer, RenderableComponent: ModelRenderer });

            var ReflectionProbeType = exports("ReflectionProbeType", {
              NONE: 0,
              BAKED_CUBEMAP: 1,
              PLANAR_REFLECTION: 2,
              BLEND_PROBES: 3,
              BLEND_PROBES_AND_SKYBOX: 4
            });

            var _dec$n, _dec2$k, _dec3$i, _dec4$c, _dec5$9, _dec6$9, _dec7$7, _class$n, _class2$k, _initializer$j, _initializer2$i, _initializer3$d, _initializer4$b, _initializer5$a, _initializer6$7, _initializer7$6, _initializer8$6, _initializer9$5, _initializer10$4, _class3$6, _dec8$6, _dec9$5, _dec10$4, _dec11$2, _dec12$2, _dec13$1, _dec14$1, _dec15$1, _class4$3, _class5$3, _initializer11$3, _initializer12$2, _initializer13$2, _initializer14$2, _initializer15$2, _initializer16$2, _initializer17$2, _initializer18$2, _initializer19$2, _initializer20$1, _initializer21$1, _class6$1;
            var ccclass$3 = ccclass$6,
              executionOrder = executionOrder$1,
              type$3 = type$5,
              formerlySerializedAs$2 = formerlySerializedAs$3,
              serializable$3 = serializable$5;
            var _phaseID = getPhaseID$1('specular-pass');
            function getSkinPassIndex(subModel) {
              var passes = subModel.passes;
              var r = cclegacy.rendering;
              if (isEnableEffect()) _phaseID = r.getPhaseID(r.getPassID('specular-pass'), 'default');
              for (var k = 0; k < passes.length; k++) {
                if ((!r || !r.enableEffectImport) && passes[k].phase === _phaseID || isEnableEffect() && passes[k].phaseID === _phaseID) {
                  return k;
                }
              }
              return -1;
            }
            var ModelShadowCastingMode = Enum({
              OFF: 0,
              ON: 1
            });
            var ModelShadowReceivingMode = Enum({
              OFF: 0,
              ON: 1
            });
            var ModelBakeSettings = (_dec$n = ccclass$3('cc.ModelBakeSettings'), _dec2$k = formerlySerializedAs$2('_recieveShadow'), _dec3$i = type$3(CCInteger), _dec4$c = type$3(CCBoolean), _dec5$9 = type$3(CCBoolean), _dec6$9 = type$3(Enum(ReflectionProbeType)), _dec7$7 = type$3(CCBoolean), _dec$n(_class$n = (_class2$k = (_class3$6 = function (_EventTarget) {
              _inheritsLoose(ModelBakeSettings, _EventTarget);
              function ModelBakeSettings() {
                var _this;
                _this = _EventTarget.call(this) || this;
                _this.texture = _initializer$j && _initializer$j();
                _this.uvParam = _initializer2$i && _initializer2$i();
                _this._bakeable = _initializer3$d && _initializer3$d();
                _this._castShadow = _initializer4$b && _initializer4$b();
                _this._receiveShadow = _initializer5$a && _initializer5$a();
                _this._lightmapSize = _initializer6$7 && _initializer6$7();
                _this._useLightProbe = _initializer7$6 && _initializer7$6();
                _this._bakeToLightProbe = _initializer8$6 && _initializer8$6();
                _this._reflectionProbeType = _initializer9$5 && _initializer9$5();
                _this._bakeToReflectionProbe = _initializer10$4 && _initializer10$4();
                _this.probeCubemap = null;
                _this.probeBlendCubemap = null;
                _this.probePlanarmap = null;
                return _this;
              }
              _createClass(ModelBakeSettings, [{
                key: "bakeable",
                get: function get() {
                  return this._bakeable;
                },
                set: function set(val) {
                  this._bakeable = val;
                }
              }, {
                key: "castShadow",
                get: function get() {
                  return this._castShadow;
                },
                set: function set(val) {
                  this._castShadow = val;
                }
              }, {
                key: "receiveShadow",
                get: function get() {
                  return this._receiveShadow;
                },
                set: function set(val) {
                  this._receiveShadow = val;
                }
              }, {
                key: "lightmapSize",
                get: function get() {
                  return this._lightmapSize;
                },
                set: function set(val) {
                  this._lightmapSize = val;
                }
              }, {
                key: "useLightProbe",
                get: function get() {
                  return this._useLightProbe;
                },
                set: function set(val) {
                  this._useLightProbe = val;
                  this.emit("use_light_probe_changed");
                }
              }, {
                key: "bakeToLightProbe",
                get: function get() {
                  return this._bakeToLightProbe;
                },
                set: function set(val) {
                  this._bakeToLightProbe = val;
                }
              }, {
                key: "reflectionProbe",
                get: function get() {
                  return this._reflectionProbeType;
                },
                set: function set(val) {
                  this._reflectionProbeType = val;
                  this.emit("reflection_probe_changed");
                }
              }, {
                key: "bakeToReflectionProbe",
                get: function get() {
                  return this._bakeToReflectionProbe;
                },
                set: function set(val) {
                  this._bakeToReflectionProbe = val;
                  this.emit("bake_to_reflection_probe_changed");
                }
              }]);
              return ModelBakeSettings;
            }(EventTarget), _class3$6.USE_LIGHT_PROBE_CHANGED = "use_light_probe_changed", _class3$6.REFLECTION_PROBE_CHANGED = "reflection_probe_changed", _class3$6.BAKE_TO_REFLECTION_PROBE_CHANGED = "bake_to_reflection_probe_changed", _class3$6), (_initializer$j = applyDecoratedInitializer(_class2$k.prototype, "texture", [serializable$3], function () {
              return null;
            }), _initializer2$i = applyDecoratedInitializer(_class2$k.prototype, "uvParam", [serializable$3], function () {
              return new Vec4();
            }), _initializer3$d = applyDecoratedInitializer(_class2$k.prototype, "_bakeable", [serializable$3], function () {
              return false;
            }), _initializer4$b = applyDecoratedInitializer(_class2$k.prototype, "_castShadow", [serializable$3], function () {
              return false;
            }), _initializer5$a = applyDecoratedInitializer(_class2$k.prototype, "_receiveShadow", [_dec2$k], function () {
              return false;
            }), _initializer6$7 = applyDecoratedInitializer(_class2$k.prototype, "_lightmapSize", [serializable$3], function () {
              return 64;
            }), _initializer7$6 = applyDecoratedInitializer(_class2$k.prototype, "_useLightProbe", [serializable$3], function () {
              return false;
            }), _initializer8$6 = applyDecoratedInitializer(_class2$k.prototype, "_bakeToLightProbe", [serializable$3], function () {
              return true;
            }), _initializer9$5 = applyDecoratedInitializer(_class2$k.prototype, "_reflectionProbeType", [serializable$3], function () {
              return 0;
            }), _initializer10$4 = applyDecoratedInitializer(_class2$k.prototype, "_bakeToReflectionProbe", [serializable$3], function () {
              return true;
            }), _applyDecoratedDescriptor(_class2$k.prototype, "lightmapSize", [_dec3$i], Object.getOwnPropertyDescriptor(_class2$k.prototype, "lightmapSize"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "useLightProbe", [_dec4$c], Object.getOwnPropertyDescriptor(_class2$k.prototype, "useLightProbe"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "bakeToLightProbe", [_dec5$9], Object.getOwnPropertyDescriptor(_class2$k.prototype, "bakeToLightProbe"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "reflectionProbe", [_dec6$9], Object.getOwnPropertyDescriptor(_class2$k.prototype, "reflectionProbe"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "bakeToReflectionProbe", [_dec7$7], Object.getOwnPropertyDescriptor(_class2$k.prototype, "bakeToReflectionProbe"), _class2$k.prototype)), _class2$k)) || _class$n);
            var MeshRenderer = (_dec8$6 = ccclass$3('cc.MeshRenderer'), _dec9$5 = executionOrder(100), _dec10$4 = type$3(CCFloat), _dec11$2 = type$3(CCFloat), _dec12$2 = type$3(ModelShadowCastingMode), _dec13$1 = type$3(ModelShadowReceivingMode), _dec14$1 = type$3(Mesh), _dec15$1 = type$3(CCBoolean), _dec8$6(_class4$3 = _dec9$5(_class4$3 = (_class5$3 = (_class6$1 = function (_ModelRenderer) {
              _inheritsLoose(MeshRenderer, _ModelRenderer);
              var _proto = MeshRenderer.prototype;
              _proto.onUpdateReceiveDirLight = function onUpdateReceiveDirLight(visibility, forceClose) {
                if (forceClose === undefined) {
                  forceClose = false;
                }
                if (!this._model) {
                  return;
                }
                if (forceClose) {
                  this._model.receiveDirLight = false;
                  return;
                }
                if (this.node && (visibility & this.node.layer) === this.node.layer || visibility & this._model.visFlags) {
                  this._model.receiveDirLight = true;
                } else {
                  this._model.receiveDirLight = false;
                }
              };
              _proto.clearGlobalStandardSkinObjectFlag = function clearGlobalStandardSkinObjectFlag() {
                this._enabledGlobalStandardSkinObject = false;
              };
              function MeshRenderer() {
                var _this2;
                _this2 = _ModelRenderer.call(this) || this;
                _this2.bakeSettings = _initializer11$3 && _initializer11$3();
                _this2._mesh = _initializer12$2 && _initializer12$2();
                _this2._shadowCastingMode = _initializer13$2 && _initializer13$2();
                _this2._shadowReceivingMode = _initializer14$2 && _initializer14$2();
                _this2._shadowBias = _initializer15$2 && _initializer15$2();
                _this2._shadowNormalBias = _initializer16$2 && _initializer16$2();
                _this2._reflectionProbeId = _initializer17$2 && _initializer17$2();
                _this2._reflectionProbeBlendId = _initializer18$2 && _initializer18$2();
                _this2._reflectionProbeBlendWeight = _initializer19$2 && _initializer19$2();
                _this2._enabledGlobalStandardSkinObject = _initializer20$1 && _initializer20$1();
                _this2._reflectionProbeDataMap = null;
                _this2._subMeshShapesWeights = [];
                _this2._modelType = Model;
                _this2._model = null;
                _this2._morphInstance = null;
                _this2._enableMorph = _initializer21$1 && _initializer21$1();
                var highQualityMode = settings.querySettings("rendering", 'highQualityMode');
                if (highQualityMode) {
                  _this2._shadowCastingMode = ModelShadowCastingMode.ON;
                  _this2.bakeSettings.castShadow = true;
                  _this2.bakeSettings.receiveShadow = true;
                }
                return _this2;
              }
              _proto.onLoad = function onLoad() {
                if (this._mesh) {
                  this._mesh.initialize();
                }
                if (!this._validateShapeWeights()) {
                  this._initSubMeshShapesWeights();
                }
                this._watchMorphInMesh();
                this._updateModels();
                this._updateCastShadow();
                this._updateReceiveShadow();
                this._updateShadowBias();
                this._updateShadowNormalBias();
                this._updateUseLightProbe();
                this._updateBakeToReflectionProbe();
                this._updateUseReflectionProbe();
                this._updateReceiveDirLight();
                this._updateStandardSkin();
              };
              _proto.onRestore = function onRestore() {
                this._updateModels();
                if (this.enabledInHierarchy) {
                  this._attachToScene();
                }
                this._updateCastShadow();
                this._updateReceiveShadow();
                this._updateShadowBias();
                this._updateShadowNormalBias();
                this._updateUseLightProbe();
                this._updateBakeToReflectionProbe();
                this._updateUseReflectionProbe();
                this._updateReceiveDirLight();
                this._updateStandardSkin();
              };
              _proto.onEnable = function onEnable() {
                _ModelRenderer.prototype.onEnable.call(this);
                this.node.on("mobility-changed", this.onMobilityChanged, this);
                this.node.on("light-probe-baking-changed", this.onLightProbeBakingChanged, this);
                this.bakeSettings.on("use_light_probe_changed", this.onUseLightProbeChanged, this);
                this.bakeSettings.on("reflection_probe_changed", this.onReflectionProbeChanged, this);
                this.bakeSettings.on("bake_to_reflection_probe_changed", this.onBakeToReflectionProbeChanged, this);
                if (!this._model) {
                  this._updateModels();
                }
                this._model.onGlobalPipelineStateChanged();
                this._updateCastShadow();
                this._updateReceiveShadow();
                this._updateShadowBias();
                this._updateShadowNormalBias();
                this._updateBakeToReflectionProbe();
                this._updateUseReflectionProbe();
                this._onUpdateLocalShadowBiasAndProbeId();
                this._updateUseLightProbe();
                this._updateReceiveDirLight();
                this._onUpdateReflectionProbeDataMap();
                this._onUpdateLocalReflectionProbeData();
                this._updateStandardSkin();
                this._attachToScene();
              };
              _proto.onDisable = function onDisable() {
                if (this._model) {
                  this._detachFromScene();
                }
                this.node.off("mobility-changed", this.onMobilityChanged, this);
                this.node.off("light-probe-baking-changed", this.onLightProbeBakingChanged, this);
                this.bakeSettings.off("use_light_probe_changed", this.onUseLightProbeChanged, this);
                this.bakeSettings.off("reflection_probe_changed", this.onReflectionProbeChanged, this);
                this.bakeSettings.off("bake_to_reflection_probe_changed", this.onBakeToReflectionProbeChanged, this);
              };
              _proto.onDestroy = function onDestroy() {
                if (this._model) {
                  cclegacy.director.root.destroyModel(this._model);
                  this._model = null;
                  this._models.length = 0;
                }
                if (this._morphInstance) {
                  this._morphInstance.destroy();
                }
              };
              _proto.onGeometryChanged = function onGeometryChanged() {
                if (this._model && this._mesh) {
                  var meshStruct = this._mesh.struct;
                  this._model.createBoundingShape(meshStruct.minPosition, meshStruct.maxPosition);
                  this._model.updateWorldBound();
                  this._model.onGeometryChanged();
                }
              };
              _proto.getWeight = function getWeight(subMeshIndex, shapeIndex) {
                var subMeshShapesWeights = this._subMeshShapesWeights;
                assertIsTrue(subMeshIndex < subMeshShapesWeights.length);
                var shapeWeights = this._subMeshShapesWeights[subMeshIndex];
                assertIsTrue(shapeIndex < shapeWeights.length);
                return shapeWeights[shapeIndex];
              };
              _proto.setWeights = function setWeights(weights, subMeshIndex) {
                var subMeshShapesWeights = this._subMeshShapesWeights;
                if (subMeshIndex >= subMeshShapesWeights.length) {
                  return;
                }
                var shapeWeights = subMeshShapesWeights[subMeshIndex];
                if (shapeWeights.length !== weights.length) {
                  return;
                }
                subMeshShapesWeights[subMeshIndex] = weights.slice(0);
                this._uploadSubMeshShapesWeights(subMeshIndex);
              };
              _proto.setWeight = function setWeight(weight, subMeshIndex, shapeIndex) {
                var subMeshShapesWeights = this._subMeshShapesWeights;
                if (subMeshIndex >= subMeshShapesWeights.length) {
                  return;
                }
                var shapeWeights = subMeshShapesWeights[subMeshIndex];
                if (shapeIndex >= shapeWeights.length) {
                  return;
                }
                shapeWeights[shapeIndex] = weight;
                this._uploadSubMeshShapesWeights(subMeshIndex);
              };
              _proto.setInstancedAttribute = function setInstancedAttribute(name, value) {
                if (!this.model) {
                  return;
                }
                {
                  var subModels = this.model.subModels;
                  for (var i = 0; i < subModels.length; i++) {
                    var subModel = subModels[i];
                    var _subModel$instancedAt = subModel.instancedAttributeBlock,
                      attributes = _subModel$instancedAt.attributes,
                      views = _subModel$instancedAt.views;
                    for (var _i = 0; _i < attributes.length; _i++) {
                      if (attributes[_i].name === name) {
                        views[_i].set(value);
                        break;
                      }
                    }
                  }
                }
              };
              _proto._updateLightmap = function _updateLightmap(lightmap, uOff, vOff, scale, lum) {
                this.bakeSettings.texture = lightmap;
                this.bakeSettings.uvParam.x = uOff;
                this.bakeSettings.uvParam.y = vOff;
                this.bakeSettings.uvParam.z = scale;
                this.bakeSettings.uvParam.w = lum;
                this._onUpdateLightingmap();
                this._updateReceiveDirLight();
              };
              _proto.updateProbeCubemap = function updateProbeCubemap(cubeMap) {
                if (this.bakeSettings.probeCubemap && this.bakeSettings.probeCubemap === cubeMap) {
                  return;
                }
                this.bakeSettings.probeCubemap = cubeMap;
                if (this.model !== null) {
                  this.model.updateReflectionProbeCubemap(this.bakeSettings.probeCubemap);
                }
              };
              _proto.updateProbeBlendCubemap = function updateProbeBlendCubemap(cubeMap) {
                if (this.bakeSettings.probeBlendCubemap && this.bakeSettings.probeBlendCubemap === cubeMap) {
                  return;
                }
                this.bakeSettings.probeBlendCubemap = cubeMap;
                if (this.model !== null) {
                  this.model.updateReflectionProbeBlendCubemap(this.bakeSettings.probeBlendCubemap);
                }
              };
              _proto.updateProbePlanarMap = function updateProbePlanarMap(planarMap) {
                if (this.bakeSettings.probePlanarmap === planarMap) {
                  return;
                }
                this.bakeSettings.probePlanarmap = planarMap;
                if (this.model !== null) {
                  this.model.updateReflectionProbePlanarMap(this.bakeSettings.probePlanarmap);
                }
              };
              _proto.updateReflectionProbeDataMap = function updateReflectionProbeDataMap(dataMap) {
                this._reflectionProbeDataMap = dataMap;
                if (this.model !== null) {
                  this.model.updateReflectionProbeDataMap(dataMap);
                }
              };
              _proto.updateReflectionProbeId = function updateReflectionProbeId(probeId) {
                this._reflectionProbeId = probeId;
                if (this.model) {
                  this.model.reflectionProbeId = probeId;
                }
                this._onUpdateLocalShadowBiasAndProbeId();
              };
              _proto.updateReflectionProbeBlendId = function updateReflectionProbeBlendId(blendProbeId) {
                this._reflectionProbeBlendId = blendProbeId;
                if (this.model) {
                  this.model.reflectionProbeBlendId = blendProbeId;
                }
                this._onUpdateLocalShadowBiasAndProbeId();
              };
              _proto.updateReflectionProbeBlendWeight = function updateReflectionProbeBlendWeight(weight) {
                this._reflectionProbeBlendWeight = weight;
                if (this.model) {
                  this.model.reflectionProbeBlendWeight = weight;
                }
                this._onUpdateLocalReflectionProbeData();
              };
              _proto._updateReflectionProbeTexture = function _updateReflectionProbeTexture() {
                if (!this.model) return;
                var bakeSettings = this.bakeSettings;
                var reflectionProbe = bakeSettings.reflectionProbe;
                var probeBlendCubemap = bakeSettings.probeBlendCubemap;
                var probePlanarMap = bakeSettings.probePlanarmap;
                var probeCubeMap = bakeSettings.probeCubemap;
                if (reflectionProbe === 1) {
                  this.model.updateReflectionProbeCubemap(probeCubeMap);
                  this.model.updateReflectionProbePlanarMap(null);
                  this.model.updateReflectionProbeBlendCubemap(null);
                } else if (reflectionProbe === 3 || reflectionProbe === 4) {
                  this.model.updateReflectionProbeCubemap(probeCubeMap);
                  this.model.updateReflectionProbeBlendCubemap(probeBlendCubemap);
                  this.model.updateReflectionProbePlanarMap(null);
                } else if (reflectionProbe === 2) {
                  this.model.updateReflectionProbePlanarMap(probePlanarMap);
                  this.model.updateReflectionProbeCubemap(null);
                  this.model.updateReflectionProbeBlendCubemap(null);
                } else {
                  this.model.updateReflectionProbeCubemap(null);
                  this.model.updateReflectionProbePlanarMap(null);
                  this.model.updateReflectionProbeBlendCubemap(null);
                }
              };
              _proto._updateModels = function _updateModels() {
                if (!this.enabledInHierarchy) {
                  return;
                }
                var model = this._model;
                if (model) {
                  model.destroy();
                  model.initialize();
                  model.node = model.transform = this.node;
                } else {
                  this._createModel();
                }
                if (this._model) {
                  if (this._mesh) {
                    var meshStruct = this._mesh.struct;
                    this._model.createBoundingShape(meshStruct.minPosition, meshStruct.maxPosition);
                    this._model.updateWorldBound();
                  }
                  this._model.initLightingmap(this.bakeSettings.texture, this.bakeSettings.uvParam);
                  this._updateUseLightProbe();
                  this._updateUseReflectionProbeType();
                  this._updateModelParams();
                  this._onUpdateLightingmap();
                  this._onUpdateLocalShadowBiasAndProbeId();
                  this._updateUseReflectionProbe();
                  this._updateReceiveDirLight();
                  this._onUpdateReflectionProbeDataMap();
                  this._onUpdateLocalReflectionProbeData();
                }
              };
              _proto._updateReceiveDirLight = function _updateReceiveDirLight() {
                if (!this._model) {
                  return;
                }
                var scene = this.node.scene;
                if (!scene || !scene.renderScene) {
                  return;
                }
                var mainLight = scene.renderScene.mainLight;
                if (!mainLight) {
                  return;
                }
                var visibility = mainLight.visibility;
                if (!mainLight.node) {
                  return;
                }
                if (mainLight.node.mobility === MobilityMode.Static) {
                  var sceneGlobals = this.node.scene.globals;
                  var lightProbeInfoData = sceneGlobals.lightProbeInfo.data;
                  var forceClose = false;
                  if (this.bakeSettings.texture && !sceneGlobals.disableLightmap) {
                    forceClose = true;
                  }
                  if (lightProbeInfoData && lightProbeInfoData.hasCoefficients() && this._model.useLightProbe) {
                    forceClose = true;
                  }
                  this.onUpdateReceiveDirLight(visibility, forceClose);
                } else {
                  this.onUpdateReceiveDirLight(visibility);
                }
              };
              _proto._createModel = function _createModel() {
                var preferMorphOverPlain = !!this._morphInstance;
                var modelType = preferMorphOverPlain && this._modelType === Model ? MorphModel : this._modelType;
                var model = this._model = cclegacy.director.root.createModel(modelType);
                model.visFlags = this.visibility;
                model.node = model.transform = this.node;
                this._models.length = 0;
                this._models.push(model);
                if (this._morphInstance && model instanceof MorphModel) {
                  model.setMorphRendering(this._morphInstance);
                }
              };
              _proto._attachToScene = function _attachToScene() {
                if (!this.node.scene || !this._model) {
                  return;
                }
                var renderScene = this._getRenderScene();
                if (this._model.scene !== null) {
                  this._detachFromScene();
                }
                renderScene.addModel(this._model);
              };
              _proto._detachFromScene = function _detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              };
              _proto._updateModelParams = function _updateModelParams() {
                if (!this._mesh || !this._model) {
                  return;
                }
                this.node.hasChangedFlags |= 1;
                this._model.transform.hasChangedFlags |= 1;
                this._model.isDynamicBatching = this._isBatchingEnabled();
                var meshCount = this._mesh ? this._mesh.renderingSubMeshes.length : 0;
                var renderingMesh = this._mesh.renderingSubMeshes;
                if (renderingMesh) {
                  for (var i = 0; i < meshCount; ++i) {
                    var material = this.getRenderMaterial(i);
                    if (material && !material.isValid) {
                      material = null;
                    }
                    var subMeshData = renderingMesh[i];
                    if (subMeshData) {
                      this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                    }
                  }
                }
                this._model.enabled = true;
              };
              _proto._onUpdateLightingmap = function _onUpdateLightingmap() {
                if (this.model !== null) {
                  this.model.updateLightingmap(this.bakeSettings.texture, this.bakeSettings.uvParam);
                }
                this.setInstancedAttribute('a_lightingMapUVParam', [this.bakeSettings.uvParam.x, this.bakeSettings.uvParam.y, this.bakeSettings.uvParam.z, this.bakeSettings.uvParam.w]);
              };
              _proto._onUpdateLocalShadowBiasAndProbeId = function _onUpdateLocalShadowBiasAndProbeId() {
                if (this.model !== null) {
                  this.model.updateLocalShadowBias();
                  this.model.updateReflectionProbeId();
                }
                this.setInstancedAttribute('a_localShadowBiasAndProbeId', [this._shadowBias, this._shadowNormalBias, this._reflectionProbeId, this._reflectionProbeBlendId]);
              };
              _proto._onUpdateLocalReflectionProbeData = function _onUpdateLocalReflectionProbeData() {
                if (this.bakeSettings.reflectionProbe === 1 || this.bakeSettings.reflectionProbe === 3 || this.bakeSettings.reflectionProbe === 4) {
                  if (this.model !== null) {
                    this.model.updateReflectionProbeId();
                  }
                  this.setInstancedAttribute('a_reflectionProbeData', [this._reflectionProbeBlendWeight, 0.0, 0.0, 0.0]);
                }
              };
              _proto._onUpdateReflectionProbeDataMap = function _onUpdateReflectionProbeDataMap() {
                if (this.model !== null) {
                  this.model.updateReflectionProbeDataMap(this._reflectionProbeDataMap);
                }
              };
              _proto._onMaterialModified = function _onMaterialModified(idx, material) {
                if (!this._model || !this._model.inited) {
                  return;
                }
                this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
                this._updateStandardSkin();
              };
              _proto._onRebuildPSO = function _onRebuildPSO(idx, material) {
                if (!this._model || !this._model.inited) {
                  return;
                }
                this._model.isDynamicBatching = this._isBatchingEnabled();
                this._model.setSubModelMaterial(idx, material);
                this._onUpdateLightingmap();
                this._onUpdateLocalShadowBiasAndProbeId();
                this._updateReflectionProbeTexture();
                this._onUpdateReflectionProbeDataMap();
                this._onUpdateLocalReflectionProbeData();
              };
              _proto._onMeshChanged = function _onMeshChanged(old) {};
              _proto._clearMaterials = function _clearMaterials() {
                if (!this._model) {
                  return;
                }
                var subModels = this._model.subModels;
                for (var i = 0; i < subModels.length; ++i) {
                  this._onMaterialModified(i, null);
                }
              };
              _proto._getBuiltinMaterial = function _getBuiltinMaterial() {
                return builtinResMgr.get('missing-material');
              };
              _proto._onVisibilityChange = function _onVisibilityChange(val) {
                if (!this._model) {
                  return;
                }
                this._model.visFlags = val;
              };
              _proto._updateShadowBias = function _updateShadowBias() {
                if (!this._model) {
                  return;
                }
                this._model.shadowBias = this._shadowBias;
              };
              _proto._updateShadowNormalBias = function _updateShadowNormalBias() {
                if (!this._model) {
                  return;
                }
                this._model.shadowNormalBias = this._shadowNormalBias;
              };
              _proto._updateCastShadow = function _updateCastShadow() {
                if (!this._model) {
                  return;
                }
                if (this._shadowCastingMode === ModelShadowCastingMode.OFF) {
                  this._model.castShadow = false;
                } else {
                  assertIsTrue(this._shadowCastingMode === ModelShadowCastingMode.ON, "ShadowCastingMode " + this._shadowCastingMode + " is not supported.");
                  this._model.castShadow = true;
                }
              };
              _proto._updateReceiveShadow = function _updateReceiveShadow() {
                if (!this._model) {
                  return;
                }
                if (this._shadowReceivingMode === ModelShadowReceivingMode.OFF) {
                  this._model.receiveShadow = false;
                } else {
                  this._model.receiveShadow = true;
                }
              };
              _proto.onMobilityChanged = function onMobilityChanged() {
                this._updateUseLightProbe();
                this._updateReceiveDirLight();
              };
              _proto.onLightProbeBakingChanged = function onLightProbeBakingChanged() {
                this._updateReceiveDirLight();
              };
              _proto.onUseLightProbeChanged = function onUseLightProbeChanged() {
                this._updateUseLightProbe();
              };
              _proto.onReflectionProbeChanged = function onReflectionProbeChanged() {
                this._updateUseReflectionProbe();
                this._onUpdateLocalShadowBiasAndProbeId();
                var reflectionProbeManager = cclegacy.internal.reflectionProbeManager;
                var model = this._model;
                if (this.bakeSettings.reflectionProbe === 1 || this.bakeSettings.reflectionProbe === 3 || this.bakeSettings.reflectionProbe === 4) {
                  reflectionProbeManager.selectReflectionProbe(model);
                  if (!reflectionProbeManager.getUsedReflectionProbe(model, false)) {
                    warnID(16302);
                  }
                } else if (this.bakeSettings.reflectionProbe === 2) {
                  reflectionProbeManager.selectPlanarReflectionProbe(model);
                  if (!reflectionProbeManager.getUsedReflectionProbe(model, true)) {
                    warnID(16302);
                  }
                }
              };
              _proto.onBakeToReflectionProbeChanged = function onBakeToReflectionProbeChanged() {
                this._updateBakeToReflectionProbe();
              };
              _proto._updateUseLightProbe = function _updateUseLightProbe() {
                if (!this._model) {
                  return;
                }
                var node = this.node;
                if (this._mesh && node && node.mobility === MobilityMode.Movable && this.bakeSettings.useLightProbe) {
                  this._model.useLightProbe = true;
                } else {
                  this._model.useLightProbe = false;
                }
              };
              _proto._isBatchingEnabled = function _isBatchingEnabled() {
                for (var i = 0; i < this._materials.length; ++i) {
                  var mat = this._materials[i];
                  if (!mat) {
                    continue;
                  }
                  for (var p = 0; p < mat.passes.length; ++p) {
                    var pass = mat.passes[p];
                    if (pass.batchingScheme) {
                      return true;
                    }
                  }
                }
                return false;
              };
              _proto._updateUseReflectionProbe = function _updateUseReflectionProbe() {
                if (!this._model) return;
                this._model.reflectionProbeType = this.bakeSettings.reflectionProbe;
                this._updateReflectionProbeTexture();
              };
              _proto._updateUseReflectionProbeType = function _updateUseReflectionProbeType() {
                if (!this._model) return;
                this._model.reflectionProbeType = this.bakeSettings.reflectionProbe;
              };
              _proto._updateBakeToReflectionProbe = function _updateBakeToReflectionProbe() {
                if (!this._model) {
                  return;
                }
                this._model.bakeToReflectionProbe = this.bakeSettings.bakeToReflectionProbe;
              };
              _proto._watchMorphInMesh = function _watchMorphInMesh() {
                if (this._morphInstance) {
                  this._morphInstance.destroy();
                  this._morphInstance = null;
                }
                if (!this._enableMorph) {
                  return;
                }
                if (!this._mesh || !this._mesh.struct.morph || !this._mesh.morphRendering) {
                  return;
                }
                this._morphInstance = this._mesh.morphRendering.createInstance();
                var nSubMeshes = this._mesh.struct.primitives.length;
                for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  this._uploadSubMeshShapesWeights(iSubMesh);
                }
                if (this._model && this._model instanceof MorphModel) {
                  this._model.setMorphRendering(this._morphInstance);
                }
              };
              _proto._initSubMeshShapesWeights = function _initSubMeshShapesWeights() {
                var mesh = this._mesh;
                this._subMeshShapesWeights.length = 0;
                if (!mesh) {
                  return;
                }
                var morph = mesh.struct.morph;
                if (!morph) {
                  return;
                }
                var commonWeights = morph.weights;
                this._subMeshShapesWeights = morph.subMeshMorphs.map(function (subMeshMorph) {
                  if (!subMeshMorph) {
                    return [];
                  } else if (subMeshMorph.weights) {
                    return subMeshMorph.weights.slice(0);
                  } else if (commonWeights) {
                    assertIsTrue(commonWeights.length === subMeshMorph.targets.length);
                    return commonWeights.slice(0);
                  } else {
                    return new Array(subMeshMorph.targets.length).fill(0.0);
                  }
                });
              };
              _proto._validateShapeWeights = function _validateShapeWeights() {
                var mesh = this._mesh,
                  subMeshShapesWeights = this._subMeshShapesWeights;
                if (!mesh || !mesh.struct.morph) {
                  return subMeshShapesWeights.length === 0;
                }
                var morph = mesh.struct.morph;
                if (morph.subMeshMorphs.length !== subMeshShapesWeights.length) {
                  return false;
                }
                return subMeshShapesWeights.every(function (_ref, subMeshIndex) {
                  var _morph$subMeshMorphs$, _morph$subMeshMorphs$2;
                  var shapeCount = _ref.length;
                  return ((_morph$subMeshMorphs$ = (_morph$subMeshMorphs$2 = morph.subMeshMorphs[subMeshIndex]) == null ? undefined : _morph$subMeshMorphs$2.targets.length) !== null && _morph$subMeshMorphs$ !== undefined ? _morph$subMeshMorphs$ : 0) === shapeCount;
                });
              };
              _proto._uploadSubMeshShapesWeights = function _uploadSubMeshShapesWeights(subMeshIndex) {
                var _this$_morphInstance;
                (_this$_morphInstance = this._morphInstance) == null ? undefined : _this$_morphInstance.setWeights(subMeshIndex, this._subMeshShapesWeights[subMeshIndex]);
              };
              _proto._updateStandardSkin = function _updateStandardSkin() {
                var pipelineSceneData = getPipelineSceneData();
                if (this._enabledGlobalStandardSkinObject) {
                  pipelineSceneData.standardSkinMeshRenderer = this;
                  pipelineSceneData.standardSkinModel = this.model;
                }
                if (!pipelineSceneData.skinMaterialModel && this._model) {
                  var subModels = this._model.subModels;
                  for (var j = 0; j < subModels.length; j++) {
                    var subModel = subModels[j];
                    var skinPassIdx = getSkinPassIndex(subModel);
                    if (skinPassIdx < 0) {
                      continue;
                    }
                    pipelineSceneData.skinMaterialModel = this._model;
                    return;
                  }
                }
              };
              _createClass(MeshRenderer, [{
                key: "shadowBias",
                get: function get() {
                  return this._shadowBias;
                },
                set: function set(val) {
                  this._shadowBias = val;
                  this._updateShadowBias();
                  this._onUpdateLocalShadowBiasAndProbeId();
                }
              }, {
                key: "shadowNormalBias",
                get: function get() {
                  return this._shadowNormalBias;
                },
                set: function set(val) {
                  this._shadowNormalBias = val;
                  this._updateShadowNormalBias();
                  this._onUpdateLocalShadowBiasAndProbeId();
                }
              }, {
                key: "shadowCastingMode",
                get: function get() {
                  return this._shadowCastingMode;
                },
                set: function set(val) {
                  this._shadowCastingMode = val;
                  this._updateCastShadow();
                }
              }, {
                key: "shadowCastingModeForInspector",
                get: function get() {
                  return this.shadowCastingMode === ModelShadowCastingMode.ON;
                },
                set: function set(val) {
                  this.shadowCastingMode = val === true ? ModelShadowCastingMode.ON : ModelShadowCastingMode.OFF;
                }
              }, {
                key: "receiveShadow",
                get: function get() {
                  return this._shadowReceivingMode;
                },
                set: function set(val) {
                  this._shadowReceivingMode = val;
                  this._updateReceiveShadow();
                }
              }, {
                key: "receiveShadowForInspector",
                get: function get() {
                  return this._shadowReceivingMode === ModelShadowReceivingMode.ON;
                },
                set: function set(val) {
                  this._shadowReceivingMode = val === true ? ModelShadowReceivingMode.ON : ModelShadowReceivingMode.OFF;
                  this._updateReceiveShadow();
                }
              }, {
                key: "mesh",
                get: function get() {
                  return this._mesh;
                },
                set: function set(val) {
                  var old = this._mesh;
                  var mesh = this._mesh = val;
                  mesh == null ? undefined : mesh.initialize();
                  this._initSubMeshShapesWeights();
                  this._watchMorphInMesh();
                  this._onMeshChanged(old);
                  this._updateModels();
                  if (this.enabledInHierarchy) {
                    this._attachToScene();
                  }
                  this._updateCastShadow();
                  this._updateReceiveShadow();
                  this._updateUseLightProbe();
                  this._updateUseReflectionProbe();
                  this._updateReceiveDirLight();
                }
              }, {
                key: "model",
                get: function get() {
                  return this._model;
                }
              }, {
                key: "enableMorph",
                get: function get() {
                  return this._enableMorph;
                },
                set: function set(value) {
                  this._enableMorph = value;
                }
              }, {
                key: "isGlobalStandardSkinObject",
                get: function get() {
                  return this._enabledGlobalStandardSkinObject;
                },
                set: function set(val) {
                  getPipelineSceneData().standardSkinMeshRenderer = val ? this : null;
                  this._enabledGlobalStandardSkinObject = val;
                }
              }]);
              return MeshRenderer;
            }(ModelRenderer), _class6$1.ShadowCastingMode = ModelShadowCastingMode, _class6$1.ShadowReceivingMode = ModelShadowReceivingMode, _class6$1), (_initializer11$3 = applyDecoratedInitializer(_class5$3.prototype, "bakeSettings", [serializable$3], function () {
              return new ModelBakeSettings();
            }), _initializer12$2 = applyDecoratedInitializer(_class5$3.prototype, "_mesh", [serializable$3], function () {
              return null;
            }), _initializer13$2 = applyDecoratedInitializer(_class5$3.prototype, "_shadowCastingMode", [serializable$3], function () {
              return ModelShadowCastingMode.OFF;
            }), _initializer14$2 = applyDecoratedInitializer(_class5$3.prototype, "_shadowReceivingMode", [serializable$3], function () {
              return ModelShadowReceivingMode.ON;
            }), _initializer15$2 = applyDecoratedInitializer(_class5$3.prototype, "_shadowBias", [serializable$3], function () {
              return 0;
            }), _initializer16$2 = applyDecoratedInitializer(_class5$3.prototype, "_shadowNormalBias", [serializable$3], function () {
              return 0;
            }), _initializer17$2 = applyDecoratedInitializer(_class5$3.prototype, "_reflectionProbeId", [serializable$3], function () {
              return -1;
            }), _initializer18$2 = applyDecoratedInitializer(_class5$3.prototype, "_reflectionProbeBlendId", [serializable$3], function () {
              return -1;
            }), _initializer19$2 = applyDecoratedInitializer(_class5$3.prototype, "_reflectionProbeBlendWeight", [serializable$3], function () {
              return 0;
            }), _initializer20$1 = applyDecoratedInitializer(_class5$3.prototype, "_enabledGlobalStandardSkinObject", [serializable$3], function () {
              return false;
            }), _applyDecoratedDescriptor(_class5$3.prototype, "shadowBias", [_dec10$4], Object.getOwnPropertyDescriptor(_class5$3.prototype, "shadowBias"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "shadowNormalBias", [_dec11$2], Object.getOwnPropertyDescriptor(_class5$3.prototype, "shadowNormalBias"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "shadowCastingMode", [_dec12$2], Object.getOwnPropertyDescriptor(_class5$3.prototype, "shadowCastingMode"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "receiveShadow", [_dec13$1], Object.getOwnPropertyDescriptor(_class5$3.prototype, "receiveShadow"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "mesh", [_dec14$1], Object.getOwnPropertyDescriptor(_class5$3.prototype, "mesh"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "isGlobalStandardSkinObject", [_dec15$1], Object.getOwnPropertyDescriptor(_class5$3.prototype, "isGlobalStandardSkinObject"), _class5$3.prototype), _initializer21$1 = applyDecoratedInitializer(_class5$3.prototype, "_enableMorph", [serializable$3], function () {
              return true;
            })), _class5$3)) || _class4$3) || _class4$3); exports({ MeshRenderer: MeshRenderer, ModelComponent: MeshRenderer });

            function checkMaterialisSame(comp1, comp2) {
              var matNum = comp1.sharedMaterials.length;
              if (matNum !== comp2.sharedMaterials.length) {
                return false;
              }
              for (var i = 0; i < matNum; i++) {
                if (comp1.getRenderMaterial(i) !== comp2.getRenderMaterial(i)) {
                  return false;
                }
              }
              return true;
            }
            var BatchingUtility = exports("BatchingUtility", function () {
              function BatchingUtility() {}
              BatchingUtility.batchStaticModel = function batchStaticModel(staticModelRoot, batchedRoot) {
                var models = staticModelRoot.getComponentsInChildren(MeshRenderer);
                if (models.length < 2) {
                  console.error('the number of static models to batch is less than 2,it needn\'t batch.');
                  return false;
                }
                for (var i = 1; i < models.length; i++) {
                  if (!models[0].mesh.validateMergingMesh(models[i].mesh)) {
                    console.error("the meshes of " + models[0].node.name + " and " + models[i].node.name + " can't be merged");
                    return false;
                  }
                  if (!checkMaterialisSame(models[0], models[i])) {
                    console.error("the materials of " + models[0].node.name + " and " + models[i].node.name + " can't be merged");
                    return false;
                  }
                }
                var batchedMesh = new Mesh();
                var worldMat = new Mat4();
                var rootWorldMatInv = new Mat4();
                staticModelRoot.getWorldMatrix(rootWorldMatInv);
                Mat4.invert(rootWorldMatInv, rootWorldMatInv);
                for (var _i = 0; _i < models.length; _i++) {
                  var comp = models[_i];
                  comp.node.getWorldMatrix(worldMat);
                  Mat4.multiply(worldMat, rootWorldMatInv, worldMat);
                  batchedMesh.merge(models[_i].mesh, worldMat);
                  comp.enabled = false;
                }
                var batchedModel = batchedRoot.addComponent(MeshRenderer);
                batchedModel.mesh = batchedMesh;
                batchedModel.sharedMaterials = models[0].sharedMaterials;
                return true;
              };
              BatchingUtility.unbatchStaticModel = function unbatchStaticModel(staticModelRoot, batchedRoot) {
                var models = staticModelRoot.getComponentsInChildren(MeshRenderer);
                for (var i = 0; i < models.length; i++) {
                  var comp = models[i];
                  comp.enabled = true;
                }
                var batchedModel = batchedRoot.getComponent(MeshRenderer);
                if (batchedModel) {
                  if (batchedModel.mesh) {
                    batchedModel.mesh.destroyRenderingMesh();
                  }
                  batchedModel.destroy();
                }
                return true;
              };
              return BatchingUtility;
            }());

            replaceProperty(Mesh.prototype, 'Mesh.prototype', [{
              name: 'renderingMesh',
              newName: 'renderingSubMeshes'
            }]);
            removeProperty(Mesh.prototype, 'Mesh.prototype', [{
              name: 'hasFlatBuffers'
            }, {
              name: 'destroyFlatBuffers'
            }]);

            var _dec$m, _dec2$j, _dec3$h, _class$m, _class2$j, _initializer$i, _initializer2$h, _initializer3$c;
            var Skeleton = exports("Skeleton", (_dec$m = ccclass$6('cc.Skeleton'), _dec2$j = type$5([CCString]), _dec3$h = type$5([Mat4]), _dec$m(_class$m = (_class2$j = function (_Asset) {
              _inheritsLoose(Skeleton, _Asset);
              function Skeleton(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this._joints = _initializer$i && _initializer$i();
                _this._bindposes = _initializer2$h && _initializer2$h();
                _this._hash = _initializer3$c && _initializer3$c();
                _this._invBindposes = null;
                return _this;
              }
              var _proto = Skeleton.prototype;
              _proto.destroy = function destroy() {
                var _cclegacy$director$ro, _cclegacy$director$ro2;
                (_cclegacy$director$ro = cclegacy.director.root) == null ? undefined : (_cclegacy$director$ro2 = _cclegacy$director$ro.dataPoolManager) == null ? undefined : _cclegacy$director$ro2.releaseSkeleton(this);
                return _Asset.prototype.destroy.call(this);
              };
              _proto.validate = function validate() {
                return this.joints.length > 0 && this.bindposes.length > 0;
              };
              _createClass(Skeleton, [{
                key: "joints",
                get: function get() {
                  return this._joints;
                },
                set: function set(value) {
                  this._joints = value;
                }
              }, {
                key: "bindposes",
                get: function get() {
                  return this._bindposes;
                },
                set: function set(value) {
                  this._bindposes = value;
                }
              }, {
                key: "inverseBindposes",
                get: function get() {
                  if (!this._invBindposes) {
                    this._invBindposes = [];
                    for (var i = 0; i < this._bindposes.length; i++) {
                      var inv = new Mat4();
                      Mat4.invert(inv, this._bindposes[i]);
                      this._invBindposes.push(inv);
                    }
                  }
                  return this._invBindposes;
                }
              }, {
                key: "hash",
                get: function get() {
                  if (!this._hash) {
                    var str = '';
                    for (var i = 0; i < this._bindposes.length; i++) {
                      var ibm = this._bindposes[i];
                      str += ibm.m00.toPrecision(2) + " " + ibm.m01.toPrecision(2) + " " + ibm.m02.toPrecision(2) + " " + ibm.m03.toPrecision(2) + " " + ibm.m04.toPrecision(2) + " " + ibm.m05.toPrecision(2) + " " + ibm.m06.toPrecision(2) + " " + ibm.m07.toPrecision(2) + " " + ibm.m08.toPrecision(2) + " " + ibm.m09.toPrecision(2) + " " + ibm.m10.toPrecision(2) + " " + ibm.m11.toPrecision(2) + " " + ibm.m12.toPrecision(2) + " " + ibm.m13.toPrecision(2) + " " + ibm.m14.toPrecision(2) + " " + ibm.m15.toPrecision(2) + "\n";
                    }
                    this._hash = murmurhash2_32_gc(str, 666);
                  }
                  return this._hash;
                }
              }]);
              return Skeleton;
            }(Asset), (_initializer$i = applyDecoratedInitializer(_class2$j.prototype, "_joints", [_dec2$j], function () {
              return [];
            }), _initializer2$h = applyDecoratedInitializer(_class2$j.prototype, "_bindposes", [_dec3$h], function () {
              return [];
            }), _initializer3$c = applyDecoratedInitializer(_class2$j.prototype, "_hash", [serializable$5], function () {
              return 0;
            })), _class2$j)) || _class$m));
            cclegacy.Skeleton = Skeleton;

            removeProperty(MeshRenderer.prototype, 'MeshRenderer.prototype', [{
              name: 'enableDynamicBatching'
            }, {
              name: 'recieveShadows'
            }]);
            cclegacy.ModelComponent = MeshRenderer;
            setClassAlias(MeshRenderer, 'cc.ModelComponent');

            var _dec$l, _class$l, _class2$i, _initializer$h, _initializer2$g, _initializer3$b, _dec2$i, _dec3$g, _dec4$b, _class4$2, _class5$2, _initializer4$a, _initializer5$9, _initializer6$6, _initializer7$5, _initializer8$5, _class6;
            var _color_tmp = new Vec3();
            var PhotometricTerm = Enum({
              LUMINOUS_FLUX: 0,
              LUMINANCE: 1
            });
            var StaticLightSettings = (_dec$l = ccclass$6('cc.StaticLightSettings'), _dec$l(_class$l = (_class2$i = function () {
              function StaticLightSettings() {
                this._baked = _initializer$h && _initializer$h();
                this._editorOnly = _initializer2$g && _initializer2$g();
                this._castShadow = _initializer3$b && _initializer3$b();
              }
              _createClass(StaticLightSettings, [{
                key: "editorOnly",
                get: function get() {
                  return this._editorOnly;
                },
                set: function set(val) {
                  this._editorOnly = val;
                }
              }, {
                key: "baked",
                get: function get() {
                  return this._baked;
                },
                set: function set(val) {
                  this._baked = val;
                }
              }, {
                key: "castShadow",
                get: function get() {
                  return this._castShadow;
                },
                set: function set(val) {
                  this._castShadow = val;
                }
              }]);
              return StaticLightSettings;
            }(), (_initializer$h = applyDecoratedInitializer(_class2$i.prototype, "_baked", [serializable$5], function () {
              return false;
            }), _initializer2$g = applyDecoratedInitializer(_class2$i.prototype, "_editorOnly", [serializable$5], function () {
              return false;
            }), _initializer3$b = applyDecoratedInitializer(_class2$i.prototype, "_castShadow", [serializable$5], function () {
              return false;
            })), _class2$i)) || _class$l);
            var Light = (_dec2$i = ccclass$6('cc.Light'), _dec3$g = type$5(StaticLightSettings), _dec4$b = type$5(Layers.BitMask), _dec2$i(_class4$2 = (_class5$2 = (_class6 = function (_Component) {
              _inheritsLoose(Light, _Component);
              function Light() {
                var _this;
                _this = _Component.call(this) || this;
                _this._color = _initializer4$a && _initializer4$a();
                _this._useColorTemperature = _initializer5$9 && _initializer5$9();
                _this._colorTemperature = _initializer6$6 && _initializer6$6();
                _this._staticSettings = _initializer7$5 && _initializer7$5();
                _this._visibility = _initializer8$5 && _initializer8$5();
                _this._type = 5;
                _this._lightType = undefined;
                _this._light = null;
                _this._lightType = Light$1;
                return _this;
              }
              var _proto = Light.prototype;
              _proto.onLoad = function onLoad() {
                this._createLight();
              };
              _proto.onEnable = function onEnable() {
                this._attachToScene();
              };
              _proto.onDisable = function onDisable() {
                this._detachFromScene();
              };
              _proto.onDestroy = function onDestroy() {
                this._destroyLight();
              };
              _proto._createLight = function _createLight() {
                if (!this._light) {
                  this._light = cclegacy.director.root.createLight(this._lightType);
                }
                this.color = this._color;
                this.useColorTemperature = this._useColorTemperature;
                this.colorTemperature = this._colorTemperature;
                this._light.node = this.node;
                this._light.baked = this.baked;
                this._light.visibility = this.visibility;
              };
              _proto._destroyLight = function _destroyLight() {
                if (this._light) {
                  cclegacy.director.root.recycleLight(this._light);
                  this._light = null;
                }
              };
              _proto._attachToScene = function _attachToScene() {
                this._detachFromScene();
                if (this._light && !this._light.scene && this.node.scene) {
                  var renderScene = this._getRenderScene();
                  switch (this._type) {
                    case 0:
                      renderScene.addDirectionalLight(this._light);
                      renderScene.setMainLight(this._light);
                      break;
                    case 1:
                      renderScene.addSphereLight(this._light);
                      break;
                    case 2:
                      renderScene.addSpotLight(this._light);
                      break;
                    case 3:
                      renderScene.addPointLight(this._light);
                      break;
                    case 4:
                      renderScene.addRangedDirLight(this._light);
                      break;
                  }
                }
              };
              _proto._detachFromScene = function _detachFromScene() {
                if (this._light && this._light.scene) {
                  var renderScene = this._light.scene;
                  switch (this._type) {
                    case 0:
                      renderScene.removeDirectionalLight(this._light);
                      renderScene.unsetMainLight(this._light);
                      break;
                    case 1:
                      renderScene.removeSphereLight(this._light);
                      break;
                    case 2:
                      renderScene.removeSpotLight(this._light);
                      break;
                    case 3:
                      renderScene.removePointLight(this._light);
                      break;
                    case 4:
                      renderScene.removeRangedDirLight(this._light);
                      break;
                  }
                }
              };
              _proto._onUpdateReceiveDirLight = function _onUpdateReceiveDirLight() {};
              _createClass(Light, [{
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(val) {
                  this._color = val.clone();
                  if (this._light) {
                    _color_tmp.x = val.r / 255.0;
                    _color_tmp.y = val.g / 255.0;
                    _color_tmp.z = val.b / 255.0;
                    this._light.color = _color_tmp;
                  }
                }
              }, {
                key: "useColorTemperature",
                get: function get() {
                  return this._useColorTemperature;
                },
                set: function set(enable) {
                  this._useColorTemperature = enable;
                  if (this._light) {
                    this._light.useColorTemperature = enable;
                  }
                }
              }, {
                key: "colorTemperature",
                get: function get() {
                  return this._colorTemperature;
                },
                set: function set(val) {
                  this._colorTemperature = val;
                  if (this._light) {
                    this._light.colorTemperature = val;
                  }
                }
              }, {
                key: "staticSettings",
                get: function get() {
                  return this._staticSettings;
                },
                set: function set(val) {
                  this._staticSettings = val;
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                }
              }, {
                key: "baked",
                get: function get() {
                  return this.staticSettings.baked;
                },
                set: function set(val) {
                  this.staticSettings.baked = val;
                  if (this._light !== null) {
                    this._light.baked = val;
                  }
                }
              }, {
                key: "visibility",
                get: function get() {
                  return this._visibility;
                },
                set: function set(vis) {
                  this._visibility = vis;
                  if (this._light) {
                    this._light.visibility = vis;
                  }
                  this._onUpdateReceiveDirLight();
                }
              }]);
              return Light;
            }(Component), _class6.Type = LightType, _class6.PhotometricTerm = PhotometricTerm, _class6), (_initializer4$a = applyDecoratedInitializer(_class5$2.prototype, "_color", [serializable$5], function () {
              return Color.WHITE.clone();
            }), _initializer5$9 = applyDecoratedInitializer(_class5$2.prototype, "_useColorTemperature", [serializable$5], function () {
              return false;
            }), _initializer6$6 = applyDecoratedInitializer(_class5$2.prototype, "_colorTemperature", [serializable$5], function () {
              return 6550;
            }), _initializer7$5 = applyDecoratedInitializer(_class5$2.prototype, "_staticSettings", [serializable$5], function () {
              return new StaticLightSettings();
            }), _initializer8$5 = applyDecoratedInitializer(_class5$2.prototype, "_visibility", [serializable$5], function () {
              return CAMERA_DEFAULT_MASK;
            }), _applyDecoratedDescriptor(_class5$2.prototype, "staticSettings", [_dec3$g], Object.getOwnPropertyDescriptor(_class5$2.prototype, "staticSettings"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "visibility", [_dec4$b], Object.getOwnPropertyDescriptor(_class5$2.prototype, "visibility"), _class5$2.prototype)), _class5$2)) || _class4$2); exports({ Light: Light, LightComponent: Light });

            var _dec$k, _dec2$h, _dec3$f, _dec4$a, _dec5$8, _dec6$8, _dec7$6, _dec8$5, _dec9$4, _dec10$3, _dec11$1, _dec12$1, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _class$k, _class2$h, _initializer$g, _initializer2$f, _initializer3$a, _initializer4$9, _initializer5$8, _initializer6$5, _initializer7$4, _initializer8$4, _initializer9$4, _initializer10$3, _initializer11$2, _initializer12$1, _initializer13$1, _initializer14$1, _initializer15$1, _initializer16$1, _initializer17$1, _initializer18$1, _initializer19$1;
            var ccclass$2 = ccclass$6,
              property$1 = property$3,
              serializable$2 = serializable$5,
              formerlySerializedAs$1 = formerlySerializedAs$3,
              type$2 = type$5;
            var DirectionalLight = (_dec$k = ccclass$2('cc.DirectionalLight'), _dec2$h = formerlySerializedAs$1('_illuminance'), _dec3$f = type$2(CCInteger), _dec4$a = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 1
              }
            }), _dec5$8 = type$2(CCBoolean), _dec6$8 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 5
              }
            }), _dec7$6 = type$2(PCFType), _dec8$5 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 6
              }
            }), _dec9$4 = type$2(CCFloat), _dec10$3 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 7
              }
            }), _dec11$1 = type$2(CCFloat), _dec12$1 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 8
              }
            }), _dec13 = type$2(CCFloat), _dec14 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 9
              }
            }), _dec15 = type$2(CCFloat), _dec16 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 22
              }
            }), _dec17 = type$2(CCFloat), _dec18 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 10
              }
            }), _dec19 = type$2(CSMLevel), _dec20 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 11
              }
            }), _dec21 = type$2(CCBoolean), _dec22 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 12
              }
            }), _dec23 = type$2(CCFloat), _dec24 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 13
              }
            }), _dec25 = type$2(CSMOptimizationMode), _dec26 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 14
              }
            }), _dec27 = type$2(CCBoolean), _dec28 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 15
              }
            }), _dec29 = type$2(CCFloat), _dec30 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 16
              }
            }), _dec31 = type$2(CCFloat), _dec32 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 17
              }
            }), _dec33 = type$2(CCFloat), _dec34 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 19
              }
            }), _dec35 = type$2(CCBoolean), _dec36 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 20
              }
            }), _dec37 = type$2(CCBoolean), _dec38 = property$1({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 21
              }
            }), _dec39 = type$2(CCFloat), _dec$k(_class$k = (_class2$h = function (_Light) {
              _inheritsLoose(DirectionalLight, _Light);
              function DirectionalLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._illuminanceHDR = _initializer$g && _initializer$g();
                _this._illuminanceLDR = _initializer2$f && _initializer2$f();
                _this._shadowEnabled = _initializer3$a && _initializer3$a();
                _this._shadowPcf = _initializer4$9 && _initializer4$9();
                _this._shadowBias = _initializer5$8 && _initializer5$8();
                _this._shadowNormalBias = _initializer6$5 && _initializer6$5();
                _this._shadowSaturation = _initializer7$4 && _initializer7$4();
                _this._shadowDistance = _initializer8$4 && _initializer8$4();
                _this._shadowInvisibleOcclusionRange = _initializer9$4 && _initializer9$4();
                _this._csmLevel = _initializer10$3 && _initializer10$3();
                _this._csmLayerLambda = _initializer11$2 && _initializer11$2();
                _this._csmOptimizationMode = _initializer12$1 && _initializer12$1();
                _this._csmAdvancedOptions = _initializer13$1 && _initializer13$1();
                _this._csmLayersTransition = _initializer14$1 && _initializer14$1();
                _this._csmTransitionRange = _initializer15$1 && _initializer15$1();
                _this._shadowFixedArea = _initializer16$1 && _initializer16$1();
                _this._shadowNear = _initializer17$1 && _initializer17$1();
                _this._shadowFar = _initializer18$1 && _initializer18$1();
                _this._shadowOrthoSize = _initializer19$1 && _initializer19$1();
                _this._lightType = DirectionalLight$1;
                var highQualityMode = settings.querySettings("rendering", 'highQualityMode');
                if (highQualityMode) {
                  _this._shadowPcf = PCFType.SOFT_2X;
                  _this._shadowDistance = 50;
                  _this.enableCSM = true;
                  _this.staticSettings.castShadow = true;
                }
                return _this;
              }
              var _proto = DirectionalLight.prototype;
              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);
                this._type = 0;
                if (this._light) {
                  var dirLight = this._light;
                  dirLight.illuminanceHDR = this._illuminanceHDR;
                  dirLight.illuminanceLDR = this._illuminanceLDR;
                  dirLight.shadowEnabled = this._shadowEnabled;
                  dirLight.shadowPcf = this._shadowPcf;
                  dirLight.shadowBias = this._shadowBias;
                  dirLight.shadowNormalBias = this._shadowNormalBias;
                  dirLight.shadowSaturation = this._shadowSaturation;
                  dirLight.shadowDistance = this._shadowDistance;
                  dirLight.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange;
                  dirLight.shadowFixedArea = this._shadowFixedArea;
                  dirLight.shadowNear = this._shadowNear;
                  dirLight.shadowFar = this._shadowFar;
                  dirLight.shadowOrthoSize = this._shadowOrthoSize;
                  dirLight.csmLevel = this._csmLevel;
                  dirLight.csmLayerLambda = this._csmLayerLambda;
                  dirLight.csmOptimizationMode = this._csmOptimizationMode;
                  dirLight.csmLayersTransition = this._csmLayersTransition;
                  dirLight.csmTransitionRange = this._csmTransitionRange;
                }
              };
              _proto._onUpdateReceiveDirLight = function _onUpdateReceiveDirLight() {
                if (!this._light) {
                  return;
                }
                _Light.prototype._onUpdateReceiveDirLight.call(this);
                var scene = this.node.scene;
                if (!scene || !scene.renderScene) {
                  return;
                }
                if (scene.renderScene.mainLight !== this._light) {
                  return;
                }
                var models = scene.renderScene.models;
                for (var i = 0; i < models.length; i++) {
                  var model = models[i];
                  if (!model.node) continue;
                  var meshRender = model.node.getComponent(MeshRenderer);
                  if (!meshRender) continue;
                  meshRender.onUpdateReceiveDirLight(this._visibility);
                }
              };
              _createClass(DirectionalLight, [{
                key: "illuminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._illuminanceHDR;
                  } else {
                    return this._illuminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._illuminanceHDR = val;
                    this._light && (this._light.illuminanceHDR = this._illuminanceHDR);
                  } else {
                    this._illuminanceLDR = val;
                    this._light && (this._light.illuminanceLDR = this._illuminanceLDR);
                  }
                }
              }, {
                key: "shadowEnabled",
                get: function get() {
                  return this._shadowEnabled;
                },
                set: function set(val) {
                  this._shadowEnabled = val;
                  if (this._light) {
                    this._light.shadowEnabled = this._shadowEnabled;
                  }
                }
              }, {
                key: "shadowPcf",
                get: function get() {
                  return this._shadowPcf;
                },
                set: function set(val) {
                  this._shadowPcf = val;
                  if (this._light) {
                    this._light.shadowPcf = this._shadowPcf;
                  }
                }
              }, {
                key: "shadowBias",
                get: function get() {
                  return this._shadowBias;
                },
                set: function set(val) {
                  this._shadowBias = val;
                  if (this._light) {
                    this._light.shadowBias = this._shadowBias;
                  }
                }
              }, {
                key: "shadowNormalBias",
                get: function get() {
                  return this._shadowNormalBias;
                },
                set: function set(val) {
                  this._shadowNormalBias = val;
                  if (this._light) {
                    this._light.shadowNormalBias = this._shadowNormalBias;
                  }
                }
              }, {
                key: "shadowSaturation",
                get: function get() {
                  return this._shadowSaturation;
                },
                set: function set(val) {
                  this._shadowSaturation = clamp(val, 0.0, 1.0);
                  if (this._light) {
                    this._light.shadowSaturation = this._shadowSaturation;
                  }
                }
              }, {
                key: "shadowDistance",
                get: function get() {
                  return this._shadowDistance;
                },
                set: function set(val) {
                  this._shadowDistance = Math.min(val, Shadows.MAX_FAR);
                  if (this._shadowDistance / 0.1 < 10.0) {
                    warnID(15003, this._shadowDistance);
                  }
                  if (this._light) {
                    this._light.shadowDistance = this._shadowDistance;
                    this._light.csmNeedUpdate = true;
                  }
                }
              }, {
                key: "shadowInvisibleOcclusionRange",
                get: function get() {
                  return this._shadowInvisibleOcclusionRange;
                },
                set: function set(val) {
                  this._shadowInvisibleOcclusionRange = Math.min(val, Shadows.MAX_FAR);
                  if (this._light) {
                    this._light.shadowInvisibleOcclusionRange = this._shadowInvisibleOcclusionRange;
                  }
                }
              }, {
                key: "csmLevel",
                get: function get() {
                  return this._csmLevel;
                },
                set: function set(val) {
                  this._csmLevel = val;
                  if (this._light) {
                    this._light.csmLevel = this._csmLevel;
                    this._light.csmNeedUpdate = true;
                  }
                }
              }, {
                key: "enableCSM",
                get: function get() {
                  return this._csmLevel > CSMLevel.LEVEL_1;
                },
                set: function set(val) {
                  this._csmLevel = val ? CSMLevel.LEVEL_4 : CSMLevel.LEVEL_1;
                  if (this._light) {
                    this._light.csmLevel = this._csmLevel;
                    this._light.csmNeedUpdate = true;
                  }
                }
              }, {
                key: "csmLayerLambda",
                get: function get() {
                  return this._csmLayerLambda;
                },
                set: function set(val) {
                  this._csmLayerLambda = val;
                  if (this._light) {
                    this._light.csmLayerLambda = this._csmLayerLambda;
                    this._light.csmNeedUpdate = true;
                  }
                }
              }, {
                key: "csmOptimizationMode",
                get: function get() {
                  return this._csmOptimizationMode;
                },
                set: function set(val) {
                  this._csmOptimizationMode = val;
                  if (this._light) {
                    this._light.csmOptimizationMode = this._csmOptimizationMode;
                  }
                }
              }, {
                key: "shadowFixedArea",
                get: function get() {
                  return this._shadowFixedArea;
                },
                set: function set(val) {
                  this._shadowFixedArea = val;
                  if (this._light) {
                    this._light.shadowFixedArea = this._shadowFixedArea;
                  }
                }
              }, {
                key: "shadowNear",
                get: function get() {
                  return this._shadowNear;
                },
                set: function set(val) {
                  this._shadowNear = val;
                  if (this._light) {
                    this._light.shadowNear = this._shadowNear;
                  }
                }
              }, {
                key: "shadowFar",
                get: function get() {
                  return this._shadowFar;
                },
                set: function set(val) {
                  this._shadowFar = Math.min(val, Shadows.MAX_FAR);
                  if (this._light) {
                    this._light.shadowFar = this._shadowFar;
                  }
                }
              }, {
                key: "shadowOrthoSize",
                get: function get() {
                  return this._shadowOrthoSize;
                },
                set: function set(val) {
                  this._shadowOrthoSize = val;
                  if (this._light) {
                    this._light.shadowOrthoSize = this._shadowOrthoSize;
                  }
                }
              }, {
                key: "csmAdvancedOptions",
                get: function get() {
                  return this._csmAdvancedOptions;
                },
                set: function set(val) {
                  this._csmAdvancedOptions = val;
                }
              }, {
                key: "csmLayersTransition",
                get: function get() {
                  return this._csmLayersTransition;
                },
                set: function set(val) {
                  this._csmLayersTransition = val;
                  if (this._light) {
                    this._light.csmLayersTransition = val;
                  }
                }
              }, {
                key: "csmTransitionRange",
                get: function get() {
                  return this._csmTransitionRange;
                },
                set: function set(val) {
                  this._csmTransitionRange = val;
                  if (this._light) {
                    this._light.csmTransitionRange = val;
                  }
                }
              }]);
              return DirectionalLight;
            }(Light), (_initializer$g = applyDecoratedInitializer(_class2$h.prototype, "_illuminanceHDR", [property$1, _dec2$h], function () {
              return 65000;
            }), _initializer2$f = applyDecoratedInitializer(_class2$h.prototype, "_illuminanceLDR", [serializable$2], function () {
              return 65000 * Camera$1.standardExposureValue;
            }), _initializer3$a = applyDecoratedInitializer(_class2$h.prototype, "_shadowEnabled", [serializable$2], function () {
              return false;
            }), _initializer4$9 = applyDecoratedInitializer(_class2$h.prototype, "_shadowPcf", [serializable$2], function () {
              return PCFType.HARD;
            }), _initializer5$8 = applyDecoratedInitializer(_class2$h.prototype, "_shadowBias", [serializable$2], function () {
              return 0.00001;
            }), _initializer6$5 = applyDecoratedInitializer(_class2$h.prototype, "_shadowNormalBias", [serializable$2], function () {
              return 0.0;
            }), _initializer7$4 = applyDecoratedInitializer(_class2$h.prototype, "_shadowSaturation", [serializable$2], function () {
              return 1.0;
            }), _initializer8$4 = applyDecoratedInitializer(_class2$h.prototype, "_shadowDistance", [serializable$2], function () {
              return 50;
            }), _initializer9$4 = applyDecoratedInitializer(_class2$h.prototype, "_shadowInvisibleOcclusionRange", [serializable$2], function () {
              return 200;
            }), _initializer10$3 = applyDecoratedInitializer(_class2$h.prototype, "_csmLevel", [serializable$2], function () {
              return CSMLevel.LEVEL_4;
            }), _initializer11$2 = applyDecoratedInitializer(_class2$h.prototype, "_csmLayerLambda", [serializable$2], function () {
              return 0.75;
            }), _initializer12$1 = applyDecoratedInitializer(_class2$h.prototype, "_csmOptimizationMode", [serializable$2], function () {
              return CSMOptimizationMode.RemoveDuplicates;
            }), _initializer13$1 = applyDecoratedInitializer(_class2$h.prototype, "_csmAdvancedOptions", [serializable$2], function () {
              return false;
            }), _initializer14$1 = applyDecoratedInitializer(_class2$h.prototype, "_csmLayersTransition", [serializable$2], function () {
              return false;
            }), _initializer15$1 = applyDecoratedInitializer(_class2$h.prototype, "_csmTransitionRange", [serializable$2], function () {
              return 0.05;
            }), _initializer16$1 = applyDecoratedInitializer(_class2$h.prototype, "_shadowFixedArea", [serializable$2], function () {
              return false;
            }), _initializer17$1 = applyDecoratedInitializer(_class2$h.prototype, "_shadowNear", [serializable$2], function () {
              return 0.1;
            }), _initializer18$1 = applyDecoratedInitializer(_class2$h.prototype, "_shadowFar", [serializable$2], function () {
              return 10.0;
            }), _initializer19$1 = applyDecoratedInitializer(_class2$h.prototype, "_shadowOrthoSize", [serializable$2], function () {
              return 5;
            }), _applyDecoratedDescriptor(_class2$h.prototype, "illuminance", [_dec3$f], Object.getOwnPropertyDescriptor(_class2$h.prototype, "illuminance"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowEnabled", [_dec4$a, _dec5$8], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowEnabled"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowPcf", [_dec6$8, _dec7$6], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowPcf"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowBias", [_dec8$5, _dec9$4], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowBias"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowNormalBias", [_dec10$3, _dec11$1], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowNormalBias"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowSaturation", [_dec12$1, _dec13], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowSaturation"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowDistance", [_dec14, _dec15], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowDistance"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowInvisibleOcclusionRange", [_dec16, _dec17], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowInvisibleOcclusionRange"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "csmLevel", [_dec18, _dec19], Object.getOwnPropertyDescriptor(_class2$h.prototype, "csmLevel"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "enableCSM", [_dec20, _dec21], Object.getOwnPropertyDescriptor(_class2$h.prototype, "enableCSM"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "csmLayerLambda", [_dec22, _dec23], Object.getOwnPropertyDescriptor(_class2$h.prototype, "csmLayerLambda"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "csmOptimizationMode", [_dec24, _dec25], Object.getOwnPropertyDescriptor(_class2$h.prototype, "csmOptimizationMode"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowFixedArea", [_dec26, _dec27], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowFixedArea"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowNear", [_dec28, _dec29], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowNear"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowFar", [_dec30, _dec31], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowFar"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "shadowOrthoSize", [_dec32, _dec33], Object.getOwnPropertyDescriptor(_class2$h.prototype, "shadowOrthoSize"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "csmAdvancedOptions", [_dec34, _dec35], Object.getOwnPropertyDescriptor(_class2$h.prototype, "csmAdvancedOptions"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "csmLayersTransition", [_dec36, _dec37], Object.getOwnPropertyDescriptor(_class2$h.prototype, "csmLayersTransition"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "csmTransitionRange", [_dec38, _dec39], Object.getOwnPropertyDescriptor(_class2$h.prototype, "csmTransitionRange"), _class2$h.prototype)), _class2$h)) || _class$k); exports({ DirectionalLight: DirectionalLight, DirectionalLightComponent: DirectionalLight });

            var _dec$j, _dec2$g, _dec3$e, _dec4$9, _dec5$7, _dec6$7, _dec7$5, _class$j, _class2$g, _initializer$f, _initializer2$e, _initializer3$9, _initializer4$8, _initializer5$7;
            var SphereLight = (_dec$j = ccclass$6('cc.SphereLight'), _dec2$g = formerlySerializedAs$3('_luminance'), _dec3$e = type$5(CCInteger), _dec4$9 = type$5(CCInteger), _dec5$7 = type$5(PhotometricTerm), _dec6$7 = type$5(CCFloat), _dec7$5 = type$5(CCFloat), _dec$j(_class$j = (_class2$g = function (_Light) {
              _inheritsLoose(SphereLight, _Light);
              function SphereLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._size = _initializer$f && _initializer$f();
                _this._luminanceHDR = _initializer2$e && _initializer2$e();
                _this._luminanceLDR = _initializer3$9 && _initializer3$9();
                _this._term = _initializer4$8 && _initializer4$8();
                _this._range = _initializer5$7 && _initializer5$7();
                _this._lightType = SphereLight$1;
                return _this;
              }
              var _proto = SphereLight.prototype;
              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);
                this._type = 1;
                this.size = this._size;
                this.range = this._range;
                if (this._light) {
                  this._light.luminanceHDR = this._luminanceHDR;
                  this._light.luminanceLDR = this._luminanceLDR;
                }
              };
              _createClass(SphereLight, [{
                key: "luminousFlux",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._luminanceHDR * nt2lm(this._size);
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  var result = 0;
                  if (isHDR) {
                    this._luminanceHDR = val / nt2lm(this._size);
                    result = this._luminanceHDR;
                  } else {
                    this._luminanceLDR = val;
                    result = this._luminanceLDR;
                  }
                  this._light && (this._light.luminance = result);
                }
              }, {
                key: "luminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._luminanceHDR;
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._luminanceHDR = val;
                    this._light && (this._light.luminanceHDR = this._luminanceHDR);
                  } else {
                    this._luminanceLDR = val;
                    this._light && (this._light.luminanceLDR = this._luminanceLDR);
                  }
                }
              }, {
                key: "term",
                get: function get() {
                  return this._term;
                },
                set: function set(val) {
                  this._term = val;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(val) {
                  this._size = val;
                  if (this._light) {
                    this._light.size = val;
                  }
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(val) {
                  this._range = val;
                  if (this._light) {
                    this._light.range = val;
                  }
                }
              }]);
              return SphereLight;
            }(Light), (_initializer$f = applyDecoratedInitializer(_class2$g.prototype, "_size", [serializable$5], function () {
              return 0.15;
            }), _initializer2$e = applyDecoratedInitializer(_class2$g.prototype, "_luminanceHDR", [serializable$5, _dec2$g], function () {
              return 1700 / nt2lm(0.15);
            }), _initializer3$9 = applyDecoratedInitializer(_class2$g.prototype, "_luminanceLDR", [serializable$5], function () {
              return 1700 / nt2lm(0.15) * Camera$1.standardExposureValue * Camera$1.standardLightMeterScale;
            }), _initializer4$8 = applyDecoratedInitializer(_class2$g.prototype, "_term", [serializable$5], function () {
              return PhotometricTerm.LUMINOUS_FLUX;
            }), _initializer5$7 = applyDecoratedInitializer(_class2$g.prototype, "_range", [serializable$5], function () {
              return 1;
            }), _applyDecoratedDescriptor(_class2$g.prototype, "luminousFlux", [_dec3$e], Object.getOwnPropertyDescriptor(_class2$g.prototype, "luminousFlux"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "luminance", [_dec4$9], Object.getOwnPropertyDescriptor(_class2$g.prototype, "luminance"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "term", [_dec5$7], Object.getOwnPropertyDescriptor(_class2$g.prototype, "term"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "size", [_dec6$7], Object.getOwnPropertyDescriptor(_class2$g.prototype, "size"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "range", [_dec7$5], Object.getOwnPropertyDescriptor(_class2$g.prototype, "range"), _class2$g.prototype)), _class2$g)) || _class$j); exports({ SphereLight: SphereLight, SphereLightComponent: SphereLight });

            var _dec$i, _dec2$f, _dec3$d, _dec4$8, _dec5$6, _dec6$6, _dec7$4, _dec8$4, _dec9$3, _dec10$2, _dec11, _dec12, _class$i, _class2$f, _initializer$e, _initializer2$d, _initializer3$8, _initializer4$7, _initializer5$6, _initializer6$4, _initializer7$3, _initializer8$3, _initializer9$3, _initializer10$2, _initializer11$1;
            var ccclass$1 = ccclass$6,
              type$1 = type$5,
              serializable$1 = serializable$5,
              formerlySerializedAs = formerlySerializedAs$3,
              property = property$3;
            var SpotLight = (_dec$i = ccclass$1('cc.SpotLight'), _dec2$f = formerlySerializedAs('_luminance'), _dec3$d = type$1(PhotometricTerm), _dec4$8 = type$1(CCFloat), _dec5$6 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 1
              }
            }), _dec6$6 = type$1(CCBoolean), _dec7$4 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 2
              }
            }), _dec8$4 = type$1(PCFType), _dec9$3 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 3
              }
            }), _dec10$2 = type$1(CCFloat), _dec11 = property({
              group: {
                name: 'DynamicShadowSettings',
                displayOrder: 4
              }
            }), _dec12 = type$1(CCFloat), _dec$i(_class$i = (_class2$f = function (_Light) {
              _inheritsLoose(SpotLight, _Light);
              function SpotLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._size = _initializer$e && _initializer$e();
                _this._luminanceHDR = _initializer2$d && _initializer2$d();
                _this._luminanceLDR = _initializer3$8 && _initializer3$8();
                _this._term = _initializer4$7 && _initializer4$7();
                _this._range = _initializer5$6 && _initializer5$6();
                _this._spotAngle = _initializer6$4 && _initializer6$4();
                _this._angleAttenuationStrength = _initializer7$3 && _initializer7$3();
                _this._shadowEnabled = _initializer8$3 && _initializer8$3();
                _this._shadowPcf = _initializer9$3 && _initializer9$3();
                _this._shadowBias = _initializer10$2 && _initializer10$2();
                _this._shadowNormalBias = _initializer11$1 && _initializer11$1();
                _this._lightType = SpotLight$1;
                return _this;
              }
              var _proto = SpotLight.prototype;
              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);
                this._type = 2;
                this.size = this._size;
                this.range = this._range;
                this.spotAngle = this._spotAngle;
                this.angleAttenuationStrength = this._angleAttenuationStrength;
                if (this._light) {
                  var spotLight = this._light;
                  spotLight.luminanceHDR = this._luminanceHDR;
                  spotLight.luminanceLDR = this._luminanceLDR;
                  spotLight.shadowEnabled = this._shadowEnabled;
                  spotLight.shadowPcf = this._shadowPcf;
                  spotLight.shadowBias = this._shadowBias;
                  spotLight.shadowNormalBias = this._shadowNormalBias;
                }
              };
              _createClass(SpotLight, [{
                key: "luminousFlux",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._luminanceHDR * nt2lm(this._size);
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  var result = 0;
                  if (isHDR) {
                    this._luminanceHDR = val / nt2lm(this._size);
                    result = this._luminanceHDR;
                  } else {
                    this._luminanceLDR = val;
                    result = this._luminanceLDR;
                  }
                  this._light && (this._light.luminance = result);
                }
              }, {
                key: "luminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._luminanceHDR;
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._luminanceHDR = val;
                    this._light && (this._light.luminanceHDR = this._luminanceHDR);
                  } else {
                    this._luminanceLDR = val;
                    this._light && (this._light.luminanceLDR = this._luminanceLDR);
                  }
                }
              }, {
                key: "term",
                get: function get() {
                  return this._term;
                },
                set: function set(val) {
                  this._term = val;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(val) {
                  this._size = val;
                  if (this._light) {
                    this._light.size = val;
                  }
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(val) {
                  this._range = val;
                  if (this._light) {
                    this._light.range = val;
                  }
                }
              }, {
                key: "spotAngle",
                get: function get() {
                  return this._spotAngle;
                },
                set: function set(val) {
                  this._spotAngle = val;
                  if (this._light) {
                    this._light.spotAngle = toRadian(val);
                  }
                }
              }, {
                key: "angleAttenuationStrength",
                get: function get() {
                  return this._angleAttenuationStrength;
                },
                set: function set(val) {
                  this._angleAttenuationStrength = val;
                  if (this._light) {
                    this._light.angleAttenuationStrength = val;
                  }
                }
              }, {
                key: "shadowEnabled",
                get: function get() {
                  return this._shadowEnabled;
                },
                set: function set(val) {
                  this._shadowEnabled = val;
                  if (this._light) {
                    this._light.shadowEnabled = val;
                  }
                }
              }, {
                key: "shadowPcf",
                get: function get() {
                  return this._shadowPcf;
                },
                set: function set(val) {
                  this._shadowPcf = val;
                  if (this._light) {
                    this._light.shadowPcf = val;
                  }
                }
              }, {
                key: "shadowBias",
                get: function get() {
                  return this._shadowBias;
                },
                set: function set(val) {
                  this._shadowBias = val;
                  if (this._light) {
                    this._light.shadowBias = val;
                  }
                }
              }, {
                key: "shadowNormalBias",
                get: function get() {
                  return this._shadowNormalBias;
                },
                set: function set(val) {
                  this._shadowNormalBias = val;
                  if (this._light) {
                    this._light.shadowNormalBias = val;
                  }
                }
              }]);
              return SpotLight;
            }(Light), (_initializer$e = applyDecoratedInitializer(_class2$f.prototype, "_size", [serializable$1], function () {
              return 0.15;
            }), _initializer2$d = applyDecoratedInitializer(_class2$f.prototype, "_luminanceHDR", [serializable$1, _dec2$f], function () {
              return 1700 / nt2lm(0.15);
            }), _initializer3$8 = applyDecoratedInitializer(_class2$f.prototype, "_luminanceLDR", [serializable$1], function () {
              return 1700 / nt2lm(0.15) * Camera$1.standardExposureValue * Camera$1.standardLightMeterScale;
            }), _initializer4$7 = applyDecoratedInitializer(_class2$f.prototype, "_term", [serializable$1], function () {
              return PhotometricTerm.LUMINOUS_FLUX;
            }), _initializer5$6 = applyDecoratedInitializer(_class2$f.prototype, "_range", [serializable$1], function () {
              return 1;
            }), _initializer6$4 = applyDecoratedInitializer(_class2$f.prototype, "_spotAngle", [serializable$1], function () {
              return 60;
            }), _initializer7$3 = applyDecoratedInitializer(_class2$f.prototype, "_angleAttenuationStrength", [serializable$1], function () {
              return 0;
            }), _initializer8$3 = applyDecoratedInitializer(_class2$f.prototype, "_shadowEnabled", [serializable$1], function () {
              return false;
            }), _initializer9$3 = applyDecoratedInitializer(_class2$f.prototype, "_shadowPcf", [serializable$1], function () {
              return PCFType.HARD;
            }), _initializer10$2 = applyDecoratedInitializer(_class2$f.prototype, "_shadowBias", [serializable$1], function () {
              return 0.00001;
            }), _initializer11$1 = applyDecoratedInitializer(_class2$f.prototype, "_shadowNormalBias", [serializable$1], function () {
              return 0.0;
            }), _applyDecoratedDescriptor(_class2$f.prototype, "term", [_dec3$d], Object.getOwnPropertyDescriptor(_class2$f.prototype, "term"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "size", [_dec4$8], Object.getOwnPropertyDescriptor(_class2$f.prototype, "size"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "shadowEnabled", [_dec5$6, _dec6$6], Object.getOwnPropertyDescriptor(_class2$f.prototype, "shadowEnabled"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "shadowPcf", [_dec7$4, _dec8$4], Object.getOwnPropertyDescriptor(_class2$f.prototype, "shadowPcf"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "shadowBias", [_dec9$3, _dec10$2], Object.getOwnPropertyDescriptor(_class2$f.prototype, "shadowBias"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "shadowNormalBias", [_dec11, _dec12], Object.getOwnPropertyDescriptor(_class2$f.prototype, "shadowNormalBias"), _class2$f.prototype)), _class2$f)) || _class$i); exports({ SpotLight: SpotLight, SpotLightComponent: SpotLight });

            var _dec$h, _dec2$e, _dec3$c, _dec4$7, _dec5$5, _dec6$5, _class$h, _class2$e, _initializer$d, _initializer2$c, _initializer3$7, _initializer4$6;
            var PointLight = exports("PointLight", (_dec$h = ccclass$6('cc.PointLight'), _dec2$e = formerlySerializedAs$3('_luminance'), _dec3$c = type$5(CCInteger), _dec4$7 = type$5(CCInteger), _dec5$5 = type$5(PhotometricTerm), _dec6$5 = type$5(CCFloat), _dec$h(_class$h = (_class2$e = function (_Light) {
              _inheritsLoose(PointLight, _Light);
              function PointLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._luminanceHDR = _initializer$d && _initializer$d();
                _this._luminanceLDR = _initializer2$c && _initializer2$c();
                _this._term = _initializer3$7 && _initializer3$7();
                _this._range = _initializer4$6 && _initializer4$6();
                _this._lightType = PointLight$1;
                return _this;
              }
              var _proto = PointLight.prototype;
              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);
                this._type = 3;
                this.range = this._range;
                if (this._light) {
                  this._light.luminanceHDR = this._luminanceHDR;
                  this._light.luminanceLDR = this._luminanceLDR;
                }
              };
              _createClass(PointLight, [{
                key: "luminousFlux",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._luminanceHDR * nt2lm(1.0);
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  var result = 0;
                  if (isHDR) {
                    this._luminanceHDR = val / nt2lm(1.0);
                    result = this._luminanceHDR;
                  } else {
                    this._luminanceLDR = val;
                    result = this._luminanceLDR;
                  }
                  this._light && (this._light.luminance = result);
                }
              }, {
                key: "luminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._luminanceHDR;
                  } else {
                    return this._luminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._luminanceHDR = val;
                    this._light && (this._light.luminanceHDR = this._luminanceHDR);
                  } else {
                    this._luminanceLDR = val;
                    this._light && (this._light.luminanceLDR = this._luminanceLDR);
                  }
                }
              }, {
                key: "term",
                get: function get() {
                  return this._term;
                },
                set: function set(val) {
                  this._term = val;
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(val) {
                  this._range = val;
                  if (this._light) {
                    this._light.range = val;
                  }
                }
              }]);
              return PointLight;
            }(Light), (_initializer$d = applyDecoratedInitializer(_class2$e.prototype, "_luminanceHDR", [serializable$5, _dec2$e], function () {
              return 1700 / nt2lm(0.15);
            }), _initializer2$c = applyDecoratedInitializer(_class2$e.prototype, "_luminanceLDR", [serializable$5], function () {
              return 1700 / nt2lm(0.15) * Camera$1.standardExposureValue * Camera$1.standardLightMeterScale;
            }), _initializer3$7 = applyDecoratedInitializer(_class2$e.prototype, "_term", [serializable$5], function () {
              return PhotometricTerm.LUMINOUS_FLUX;
            }), _initializer4$6 = applyDecoratedInitializer(_class2$e.prototype, "_range", [serializable$5], function () {
              return 1;
            }), _applyDecoratedDescriptor(_class2$e.prototype, "luminousFlux", [_dec3$c], Object.getOwnPropertyDescriptor(_class2$e.prototype, "luminousFlux"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "luminance", [_dec4$7], Object.getOwnPropertyDescriptor(_class2$e.prototype, "luminance"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "term", [_dec5$5], Object.getOwnPropertyDescriptor(_class2$e.prototype, "term"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "range", [_dec6$5], Object.getOwnPropertyDescriptor(_class2$e.prototype, "range"), _class2$e.prototype)), _class2$e)) || _class$h));

            var _dec$g, _dec2$d, _dec3$b, _class$g, _class2$d, _initializer$c, _initializer2$b;
            var RangedDirectionalLight = exports("RangedDirectionalLight", (_dec$g = ccclass$6('cc.RangedDirectionalLight'), _dec2$d = formerlySerializedAs$3('_illuminance'), _dec3$b = type$5(CCInteger), _dec$g(_class$g = (_class2$d = function (_Light) {
              _inheritsLoose(RangedDirectionalLight, _Light);
              function RangedDirectionalLight() {
                var _this;
                _this = _Light.call(this) || this;
                _this._illuminanceHDR = _initializer$c && _initializer$c();
                _this._illuminanceLDR = _initializer2$b && _initializer2$b();
                _this._lightType = RangedDirectionalLight$1;
                return _this;
              }
              var _proto = RangedDirectionalLight.prototype;
              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);
                this._type = 4;
                if (this._light) {
                  this._light.illuminanceHDR = this._illuminanceHDR;
                  this._light.illuminanceLDR = this._illuminanceLDR;
                }
              };
              _createClass(RangedDirectionalLight, [{
                key: "illuminance",
                get: function get() {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    return this._illuminanceHDR;
                  } else {
                    return this._illuminanceLDR;
                  }
                },
                set: function set(val) {
                  var isHDR = getPipelineSceneData().isHDR;
                  if (isHDR) {
                    this._illuminanceHDR = val;
                    this._light && (this._light.illuminanceHDR = this._illuminanceHDR);
                  } else {
                    this._illuminanceLDR = val;
                    this._light && (this._light.illuminanceLDR = this._illuminanceLDR);
                  }
                }
              }]);
              return RangedDirectionalLight;
            }(Light), (_initializer$c = applyDecoratedInitializer(_class2$d.prototype, "_illuminanceHDR", [property$3, _dec2$d], function () {
              return 65000;
            }), _initializer2$b = applyDecoratedInitializer(_class2$d.prototype, "_illuminanceLDR", [serializable$5], function () {
              return 65000 * Camera$1.standardExposureValue;
            }), _applyDecoratedDescriptor(_class2$d.prototype, "illuminance", [_dec3$b], Object.getOwnPropertyDescriptor(_class2$d.prototype, "illuminance"), _class2$d.prototype)), _class2$d)) || _class$g));

            cclegacy.LightComponent = Light;
            setClassAlias(Light, 'cc.LightComponent');
            cclegacy.DirectionalLightComponent = DirectionalLight;
            setClassAlias(DirectionalLight, 'cc.DirectionalLightComponent');
            cclegacy.SphereLightComponent = SphereLight;
            setClassAlias(SphereLight, 'cc.SphereLightComponent');
            cclegacy.SpotLightComponent = SpotLight;
            setClassAlias(SpotLight, 'cc.SpotLightComponent');
            replaceProperty(SpotLight.prototype, 'SpotLight.prototype', [{
              name: 'luminousPower',
              newName: 'luminousFlux',
              customGetter: function customGetter() {
                return this.luminousFlux;
              },
              customSetter: function customSetter(value) {
                this.luminousFlux = value;
              }
            }]);
            replaceProperty(SphereLight.prototype, 'SphereLight.prototype', [{
              name: 'luminousPower',
              newName: 'luminousFlux',
              customGetter: function customGetter() {
                return this.luminousFlux;
              },
              customSetter: function customSetter(value) {
                this.luminousFlux = value;
              }
            }]);
            replaceProperty(Light.PhotometricTerm, 'Light.PhotometricTerm', [{
              name: 'LUMINOUS_POWER',
              newName: 'LUMINOUS_FLUX'
            }]);

            var BAKE_SKELETON_CURVE_SYMBOL = Symbol('BakeNodeCurves');

            var SkelAnimDataHub = function () {
              function SkelAnimDataHub() {}
              SkelAnimDataHub.getOrExtract = function getOrExtract(clip) {
                var data = SkelAnimDataHub.pool.get(clip);
                if (!data || data.samples !== clip.sample) {
                  if (data) {
                    cclegacy.director.root.dataPoolManager.releaseAnimationClip(clip);
                  }
                  var frames = Math.ceil(clip.sample * clip.duration) + 1;
                  var step = clip.sample;
                  data = clip[BAKE_SKELETON_CURVE_SYMBOL](0, step, frames);
                  SkelAnimDataHub.pool.set(clip, data);
                }
                return data;
              };
              SkelAnimDataHub.destroy = function destroy(clip) {
                SkelAnimDataHub.pool["delete"](clip);
              };
              return SkelAnimDataHub;
            }();
            SkelAnimDataHub.pool = new Map();

            var m4_1$2 = new Mat4();
            function getWorldTransformUntilRoot(target, root, outMatrix) {
              Mat4.identity(outMatrix);
              while (target !== root) {
                Mat4.fromRTS(m4_1$2, target.rotation, target.position, target.scale);
                Mat4.multiply(outMatrix, m4_1$2, outMatrix);
                target = target.parent;
              }
              return outMatrix;
            }

            var jointTextureSamplerInfo = new SamplerInfo(1, 1, 0, 2, 2, 2);

            var uploadJointData = uploadJointDataLBS;
            var MINIMUM_JOINT_TEXTURE_SIZE = 480;
            function selectJointsMediumFormat(device) {
              if (device.getFormatFeatures(44) & 2) {
                return 44;
              }
              return 35;
            }
            function uploadJointDataLBS(out, base, mat, firstBone) {
              out[base + 0] = mat.m00;
              out[base + 1] = mat.m01;
              out[base + 2] = mat.m02;
              out[base + 3] = mat.m12;
              out[base + 4] = mat.m04;
              out[base + 5] = mat.m05;
              out[base + 6] = mat.m06;
              out[base + 7] = mat.m13;
              out[base + 8] = mat.m08;
              out[base + 9] = mat.m09;
              out[base + 10] = mat.m10;
              out[base + 11] = mat.m14;
            }
            new Quat();
            new Quat();
            new Vec3();
            new Quat();
            new Vec3();
            function roundUpTextureSize(targetLength, formatSize) {
              var formatScale = 4 / Math.sqrt(formatSize);
              return Math.ceil(Math.max(MINIMUM_JOINT_TEXTURE_SIZE * formatScale, targetLength) / 12) * 12;
            }
            var v3_3 = new Vec3();
            var v3_4 = new Vec3();
            var v3_min$1 = new Vec3();
            var v3_max$1 = new Vec3();
            var m4_1$1 = new Mat4();
            var m4_2 = new Mat4();
            var ab_1$1 = new AABB();
            var Inf = Number.MAX_SAFE_INTEGER;
            (function () {
              function JointTexturePool(device) {
                this._device = undefined;
                this._pool = undefined;
                this._textureBuffers = new Map();
                this._formatSize = undefined;
                this._pixelsPerJoint = undefined;
                this._customPool = undefined;
                this._chunkIdxMap = new Map();
                this._device = device;
                var format = selectJointsMediumFormat(this._device);
                this._formatSize = FormatInfos[format].size;
                this._pixelsPerJoint = 48 / this._formatSize;
                this._pool = new TextureBufferPool(device);
                this._pool.initialize({
                  format: format,
                  roundUpFn: roundUpTextureSize
                });
                this._customPool = new TextureBufferPool(device);
                this._customPool.initialize({
                  format: format,
                  roundUpFn: roundUpTextureSize
                });
              }
              var _proto = JointTexturePool.prototype;
              _proto.clear = function clear() {
                this._pool.destroy();
                this._textureBuffers.clear();
              };
              _proto.registerCustomTextureLayouts = function registerCustomTextureLayouts(layouts) {
                for (var i = 0; i < layouts.length; i++) {
                  var layout = layouts[i];
                  var textureLength = layout.textureLength;
                  if (!(this._device.getFormatFeatures(44) & 2)) {
                    textureLength *= 2;
                  }
                  var chunkIdx = this._customPool.createChunk(textureLength);
                  for (var j = 0; j < layout.contents.length; j++) {
                    var content = layout.contents[j];
                    var skeleton = content.skeleton;
                    this._chunkIdxMap.set(skeleton, chunkIdx);
                    for (var k = 0; k < content.clips.length; k++) {
                      var clip = content.clips[k];
                      this._chunkIdxMap.set(skeleton ^ clip, chunkIdx);
                    }
                  }
                }
              };
              _proto.getDefaultPoseTexture = function getDefaultPoseTexture(skeleton, mesh, skinningRoot) {
                var hash = skeleton.hash ^ 0;
                var texture = this._textureBuffers.get(hash) || null;
                if (texture && texture.bounds.has(mesh.hash)) {
                  texture.refCount++;
                  return texture;
                }
                var joints = skeleton.joints,
                  bindposes = skeleton.bindposes;
                var textureBuffer = null;
                var buildTexture = false;
                var jointCount = joints.length;
                if (!texture) {
                  var bufSize = jointCount * 12;
                  var customChunkIdx = this._chunkIdxMap.get(hash);
                  var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * 4, customChunkIdx) : this._pool.alloc(bufSize * 4);
                  if (!handle) {
                    return texture;
                  }
                  texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map(),
                    skeletonHash: skeleton.hash,
                    clipHash: 0,
                    readyToBeDeleted: false,
                    handle: handle
                  };
                  textureBuffer = new Float32Array(bufSize);
                  buildTexture = true;
                } else {
                  texture.refCount++;
                }
                Vec3.set(v3_min$1, Inf, Inf, Inf);
                Vec3.set(v3_max$1, -Inf, -Inf, -Inf);
                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                for (var j = 0, offset = 0; j < jointCount; j++, offset += 12) {
                  var node = skinningRoot.getChildByPath(joints[j]);
                  var mat = node ? getWorldTransformUntilRoot(node, skinningRoot, m4_1$1) : skeleton.inverseBindposes[j];
                  var bound = boneSpaceBounds[j];
                  if (bound) {
                    AABB.transform(ab_1$1, bound, mat);
                    ab_1$1.getBoundary(v3_3, v3_4);
                    Vec3.min(v3_min$1, v3_min$1, v3_3);
                    Vec3.max(v3_max$1, v3_max$1, v3_4);
                  }
                  if (buildTexture) {
                    if (node) {
                      Mat4.multiply(mat, mat, bindposes[j]);
                    }
                    uploadJointData(textureBuffer, offset, node ? mat : Mat4.IDENTITY);
                  }
                }
                var bounds = [new AABB()];
                texture.bounds.set(mesh.hash, bounds);
                AABB.fromPoints(bounds[0], v3_min$1, v3_max$1);
                if (buildTexture) {
                  this._pool.update(texture.handle, textureBuffer.buffer);
                  this._textureBuffers.set(hash, texture);
                }
                return texture;
              };
              _proto.getSequencePoseTexture = function getSequencePoseTexture(skeleton, clip, mesh, skinningRoot) {
                var hash = skeleton.hash ^ clip.hash;
                var texture = this._textureBuffers.get(hash) || null;
                if (texture && texture.bounds.has(mesh.hash)) {
                  texture.refCount++;
                  return texture;
                }
                var joints = skeleton.joints,
                  bindposes = skeleton.bindposes;
                var clipData = SkelAnimDataHub.getOrExtract(clip);
                var frames = clipData.frames;
                var textureBuffer = null;
                var buildTexture = false;
                var jointCount = joints.length;
                if (!texture) {
                  var bufSize = jointCount * 12 * frames;
                  var customChunkIdx = this._chunkIdxMap.get(hash);
                  var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * 4, customChunkIdx) : this._pool.alloc(bufSize * 4);
                  if (!handle) {
                    return null;
                  }
                  var animInfos = this._createAnimInfos(skeleton, clip, skinningRoot);
                  texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map(),
                    skeletonHash: skeleton.hash,
                    clipHash: clip.hash,
                    readyToBeDeleted: false,
                    handle: handle,
                    animInfos: animInfos
                  };
                  textureBuffer = new Float32Array(bufSize);
                  buildTexture = true;
                } else {
                  texture.refCount++;
                }
                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                var bounds = [];
                texture.bounds.set(mesh.hash, bounds);
                for (var f = 0; f < frames; f++) {
                  bounds.push(new AABB(Inf, Inf, Inf, -Inf, -Inf, -Inf));
                }
                for (var _f = 0, offset = 0; _f < frames; _f++) {
                  var bound = bounds[_f];
                  for (var j = 0; j < jointCount; j++, offset += 12) {
                    var _j = texture.animInfos[j],
                      curveData = _j.curveData,
                      downstream = _j.downstream,
                      bindposeIdx = _j.bindposeIdx,
                      bindposeCorrection = _j.bindposeCorrection;
                    var mat = undefined;
                    var transformValid = true;
                    if (curveData && downstream) {
                      mat = Mat4.multiply(m4_1$1, curveData[_f], downstream);
                    } else if (curveData) {
                      mat = curveData[_f];
                    } else if (downstream) {
                      mat = downstream;
                    } else {
                      mat = skeleton.inverseBindposes[bindposeIdx];
                      transformValid = false;
                    }
                    var boneSpaceBound = boneSpaceBounds[j];
                    if (boneSpaceBound) {
                      var transform = bindposeCorrection ? Mat4.multiply(m4_2, mat, bindposeCorrection) : mat;
                      AABB.transform(ab_1$1, boneSpaceBound, transform);
                      ab_1$1.getBoundary(v3_3, v3_4);
                      Vec3.min(bound.center, bound.center, v3_3);
                      Vec3.max(bound.halfExtents, bound.halfExtents, v3_4);
                    }
                    if (buildTexture) {
                      if (transformValid) {
                        Mat4.multiply(m4_1$1, mat, bindposes[bindposeIdx]);
                      }
                      uploadJointData(textureBuffer, offset, transformValid ? m4_1$1 : Mat4.IDENTITY);
                    }
                  }
                  AABB.fromPoints(bound, bound.center, bound.halfExtents);
                }
                if (buildTexture) {
                  this._pool.update(texture.handle, textureBuffer.buffer);
                  this._textureBuffers.set(hash, texture);
                }
                return texture;
              };
              _proto.releaseHandle = function releaseHandle(handle) {
                if (handle.refCount > 0) {
                  handle.refCount--;
                }
                if (!handle.refCount && handle.readyToBeDeleted) {
                  var hash = handle.skeletonHash ^ handle.clipHash;
                  var customChunkIdx = this._chunkIdxMap.get(hash);
                  (customChunkIdx !== undefined ? this._customPool : this._pool).free(handle.handle);
                  if (this._textureBuffers.get(hash) === handle) {
                    this._textureBuffers["delete"](hash);
                  }
                }
              };
              _proto.releaseSkeleton = function releaseSkeleton(skeleton) {
                var it = this._textureBuffers.values();
                var res = it.next();
                while (!res.done) {
                  var handle = res.value;
                  if (handle.skeletonHash === skeleton.hash) {
                    handle.readyToBeDeleted = true;
                    if (handle.refCount) {
                      this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
                    } else {
                      this.releaseHandle(handle);
                    }
                  }
                  res = it.next();
                }
              };
              _proto.releaseAnimationClip = function releaseAnimationClip(clip) {
                var it = this._textureBuffers.values();
                var res = it.next();
                while (!res.done) {
                  var handle = res.value;
                  if (handle.clipHash === clip.hash) {
                    handle.readyToBeDeleted = true;
                    if (handle.refCount) {
                      this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
                    } else {
                      this.releaseHandle(handle);
                    }
                  }
                  res = it.next();
                }
              };
              _proto._createAnimInfos = function _createAnimInfos(skeleton, clip, skinningRoot) {
                var animInfos = [];
                var joints = skeleton.joints,
                  bindposes = skeleton.bindposes;
                var jointCount = joints.length;
                var clipData = SkelAnimDataHub.getOrExtract(clip);
                for (var j = 0; j < jointCount; j++) {
                  var animPath = joints[j];
                  var source = clipData.joints[animPath];
                  var animNode = skinningRoot.getChildByPath(animPath);
                  var downstream = undefined;
                  var correctionPath = undefined;
                  while (!source) {
                    var idx = animPath.lastIndexOf('/');
                    animPath = animPath.substring(0, idx);
                    source = clipData.joints[animPath];
                    if (animNode) {
                      if (!downstream) {
                        downstream = new Mat4();
                      }
                      Mat4.fromRTS(m4_1$1, animNode.rotation, animNode.position, animNode.scale);
                      Mat4.multiply(downstream, m4_1$1, downstream);
                      animNode = animNode.parent;
                    } else {
                      correctionPath = animPath;
                    }
                    if (idx < 0) {
                      break;
                    }
                  }
                  var bindposeIdx = j;
                  var bindposeCorrection = undefined;
                  if (correctionPath !== undefined && source) {
                    bindposeIdx = j - 1;
                    for (var t = 0; t < jointCount; t++) {
                      if (joints[t] === correctionPath) {
                        bindposeIdx = t;
                        bindposeCorrection = new Mat4();
                        Mat4.multiply(bindposeCorrection, bindposes[t], skeleton.inverseBindposes[j]);
                        break;
                      }
                    }
                  }
                  animInfos.push({
                    curveData: source && source.transforms,
                    downstream: downstream,
                    bindposeIdx: bindposeIdx,
                    bindposeCorrection: bindposeCorrection
                  });
                }
                return animInfos;
              };
              _createClass(JointTexturePool, [{
                key: "pixelsPerJoint",
                get: function get() {
                  return this._pixelsPerJoint;
                }
              }]);
              return JointTexturePool;
            })();

            var stack = [];
            var pool = new Map();
            function getWorldMatrix(transform, stamp) {
              var i = 0;
              var res = Mat4.IDENTITY;
              while (transform) {
                if (transform.stamp === stamp || transform.stamp + 1 === stamp && !transform.node.hasChangedFlags) {
                  res = transform.world;
                  transform.stamp = stamp;
                  break;
                }
                transform.stamp = stamp;
                stack[i++] = transform;
                transform = transform.parent;
              }
              while (i > 0) {
                transform = stack[--i];
                stack[i] = null;
                var node = transform.node;
                Mat4.fromRTS(transform.local, node.rotation, node.position, node.scale);
                res = Mat4.multiply(transform.world, res, transform.local);
              }
              return res;
            }
            function getTransform(node, root) {
              var joint = null;
              var i = 0;
              while (node !== root) {
                var id = node.uuid;
                if (pool.has(id)) {
                  joint = pool.get(id);
                  break;
                } else {
                  joint = {
                    node: node,
                    local: new Mat4(),
                    world: new Mat4(),
                    stamp: -1,
                    parent: null
                  };
                  pool.set(id, joint);
                }
                stack[i++] = joint;
                node = node.parent;
                joint = null;
              }
              var child;
              while (i > 0) {
                child = stack[--i];
                stack[i] = null;
                child.parent = joint;
                joint = child;
              }
              return joint;
            }
            function deleteTransform(node) {
              var transform = pool.get(node.uuid) || null;
              while (transform) {
                pool["delete"](transform.node.uuid);
                transform = transform.parent;
              }
            }

            var uniformPatches = [{
              name: 'CC_USE_SKINNING',
              value: true
            }, {
              name: 'CC_USE_REAL_TIME_JOINT_TEXTURE',
              value: false
            }];
            var texturePatches = [{
              name: 'CC_USE_SKINNING',
              value: true
            }, {
              name: 'CC_USE_REAL_TIME_JOINT_TEXTURE',
              value: true
            }];
            function getRelevantBuffers(outIndices, outBuffers, jointMaps, targetJoint) {
              for (var i = 0; i < jointMaps.length; i++) {
                var idxMap = jointMaps[i];
                var index = -1;
                for (var j = 0; j < idxMap.length; j++) {
                  if (idxMap[j] === targetJoint) {
                    index = j;
                    break;
                  }
                }
                if (index >= 0) {
                  outBuffers.push(i);
                  outIndices.push(index);
                }
              }
            }
            var v3_min = new Vec3();
            var v3_max = new Vec3();
            var v3_1$1 = new Vec3();
            var v3_2 = new Vec3();
            var m4_1 = new Mat4();
            var ab_1 = new AABB();
            var RealTimeJointTexture = function RealTimeJointTexture() {
              this._format = 44;
              this._textures = [];
              this._buffers = [];
            };
            RealTimeJointTexture.WIDTH = 256;
            RealTimeJointTexture.HEIGHT = 3;
            var SkinningModel = function (_MorphModel) {
              _inheritsLoose(SkinningModel, _MorphModel);
              function SkinningModel() {
                var _this;
                _this = _MorphModel.call(this) || this;
                _this._buffers = [];
                _this._dataArray = [];
                _this._joints = [];
                _this._bufferIndices = null;
                _this._realTimeJointTexture = new RealTimeJointTexture();
                _this._realTimeTextureMode = false;
                _this.type = 1;
                return _this;
              }
              var _proto = SkinningModel.prototype;
              _proto.destroy = function destroy() {
                this.bindSkeleton();
                if (this._buffers.length) {
                  for (var i = 0; i < this._buffers.length; i++) {
                    this._buffers[i].destroy();
                  }
                  this._buffers.length = 0;
                }
                this._dataArray.length = 0;
                this._realTimeJointTexture._textures.forEach(function (tex) {
                  tex.destroy();
                });
                this._realTimeJointTexture._textures.length = 0;
                this._realTimeJointTexture._buffers.length = 0;
                _MorphModel.prototype.destroy.call(this);
              };
              _proto.uploadAnimation = function uploadAnimation() {};
              _proto.bindSkeleton = function bindSkeleton(skeleton, skinningRoot, mesh) {
                if (skeleton === undefined) {
                  skeleton = null;
                }
                if (skinningRoot === undefined) {
                  skinningRoot = null;
                }
                if (mesh === undefined) {
                  mesh = null;
                }
                for (var i = 0; i < this._joints.length; i++) {
                  deleteTransform(this._joints[i].target);
                }
                this._bufferIndices = null;
                this._joints.length = 0;
                if (!skeleton || !skinningRoot || !mesh) {
                  return;
                }
                this._realTimeTextureMode = false;
                if (UBOSkinning.JOINT_UNIFORM_CAPACITY < skeleton.joints.length) {
                  this._realTimeTextureMode = true;
                }
                this.transform = skinningRoot;
                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                var jointMaps = mesh.struct.jointMaps;
                this._ensureEnoughBuffers(jointMaps && jointMaps.length || 1);
                this._bufferIndices = mesh.jointBufferIndices;
                this._initRealTimeJointTexture();
                for (var index = 0; index < skeleton.joints.length; index++) {
                  var bound = boneSpaceBounds[index];
                  var target = skinningRoot.getChildByPath(skeleton.joints[index]);
                  if (!bound || !target) {
                    continue;
                  }
                  var transform = getTransform(target, skinningRoot);
                  var bindpose = skeleton.bindposes[index];
                  var indices = [];
                  var buffers = [];
                  if (!jointMaps) {
                    indices.push(index);
                    buffers.push(0);
                  } else {
                    getRelevantBuffers(indices, buffers, jointMaps, index);
                  }
                  this._joints.push({
                    indices: indices,
                    buffers: buffers,
                    bound: bound,
                    target: target,
                    bindpose: bindpose,
                    transform: transform
                  });
                }
              };
              _proto.updateTransform = function updateTransform(stamp) {
                var root = this.transform;
                if (root.hasChangedFlags || root.isTransformDirty()) {
                  root.updateWorldTransform();
                  this._localDataUpdated = true;
                }
                Vec3.set(v3_min, Infinity, Infinity, Infinity);
                Vec3.set(v3_max, -Infinity, -Infinity, -Infinity);
                for (var i = 0; i < this._joints.length; i++) {
                  var _this$_joints$i = this._joints[i],
                    bound = _this$_joints$i.bound,
                    transform = _this$_joints$i.transform;
                  var worldMatrix = getWorldMatrix(transform, stamp);
                  AABB.transform(ab_1, bound, worldMatrix);
                  ab_1.getBoundary(v3_1$1, v3_2);
                  Vec3.min(v3_min, v3_min, v3_1$1);
                  Vec3.max(v3_max, v3_max, v3_2);
                }
                var worldBounds = this._worldBounds;
                if (this._modelBounds && worldBounds) {
                  AABB.fromPoints(this._modelBounds, v3_min, v3_max);
                  this._modelBounds.transform(root._mat, root._pos, root._rot, root._scale, this._worldBounds);
                }
              };
              _proto.updateUBOs = function updateUBOs(stamp) {
                _MorphModel.prototype.updateUBOs.call(this, stamp);
                for (var i = 0; i < this._joints.length; i++) {
                  var _this$_joints$i2 = this._joints[i],
                    indices = _this$_joints$i2.indices,
                    buffers = _this$_joints$i2.buffers,
                    transform = _this$_joints$i2.transform,
                    bindpose = _this$_joints$i2.bindpose;
                  Mat4.multiply(m4_1, transform.world, bindpose);
                  for (var b = 0; b < buffers.length; b++) {
                    uploadJointData(this._dataArray[buffers[b]], indices[b] * 12, m4_1);
                  }
                }
                if (this._realTimeTextureMode) {
                  this._updateRealTimeJointTextureBuffer();
                } else {
                  for (var _b = 0; _b < this._buffers.length; _b++) {
                    this._buffers[_b].update(this._dataArray[_b]);
                  }
                }
                return true;
              };
              _proto.initSubModel = function initSubModel(idx, subMeshData, mat) {
                var original = subMeshData.vertexBuffers;
                var iaInfo = subMeshData.iaInfo;
                iaInfo.vertexBuffers = subMeshData.jointMappedBuffers;
                _MorphModel.prototype.initSubModel.call(this, idx, subMeshData, mat);
                iaInfo.vertexBuffers = original;
              };
              _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
                var superMacroPatches = _MorphModel.prototype.getMacroPatches.call(this, subModelIndex);
                var myPatches = uniformPatches;
                if (this._realTimeTextureMode) {
                  myPatches = texturePatches;
                }
                if (superMacroPatches) {
                  return myPatches.concat(superMacroPatches);
                }
                return myPatches;
              };
              _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                _MorphModel.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);
                var idx = this._bufferIndices[submodelIdx];
                if (this._realTimeTextureMode) {
                  this._bindRealTimeJointTexture(idx, descriptorSet);
                } else {
                  var buffer = this._buffers[idx];
                  if (buffer) {
                    descriptorSet.bindBuffer(UBOSkinning.BINDING, buffer);
                  }
                }
              };
              _proto._updateInstancedAttributes = function _updateInstancedAttributes(attributes, subModel) {
                var pass = subModel.passes[0];
                if (pass.batchingScheme !== 0) {
                  warnID(3936, this.node.getPathInHierarchy());
                }
                _MorphModel.prototype._updateInstancedAttributes.call(this, attributes, subModel);
              };
              _proto._ensureEnoughBuffers = function _ensureEnoughBuffers(count) {
                if (this._buffers.length) {
                  for (var i = 0; i < this._buffers.length; i++) {
                    this._buffers[i].destroy();
                  }
                  this._buffers.length = 0;
                }
                if (this._dataArray.length) this._dataArray.length = 0;
                if (!this._realTimeTextureMode) {
                  for (var _i = 0; _i < count; _i++) {
                    this._buffers[_i] = this._device.createBuffer(new BufferInfo(16 | 2, 2 | 1, UBOSkinning.SIZE, UBOSkinning.SIZE));
                    var maxJoints = UBOSkinning.JOINT_UNIFORM_CAPACITY;
                    this._dataArray[_i] = new Float32Array(12 * maxJoints);
                  }
                } else {
                  for (var _i2 = 0; _i2 < count; _i2++) {
                    var _maxJoints = RealTimeJointTexture.WIDTH;
                    this._dataArray[_i2] = new Float32Array(12 * _maxJoints);
                  }
                }
              };
              _proto._initRealTimeJointTexture = function _initRealTimeJointTexture() {
                if (this._realTimeJointTexture._textures.length) {
                  this._realTimeJointTexture._textures.forEach(function (tex) {
                    tex.destroy();
                  });
                  this._realTimeJointTexture._textures.length = 0;
                }
                this._realTimeJointTexture._buffers.length = 0;
                if (!this._realTimeTextureMode) return;
                var gfxDevice = director.root.device;
                var width = RealTimeJointTexture.WIDTH;
                var height = RealTimeJointTexture.HEIGHT;
                var hasFeatureFloatTexture = gfxDevice.getFormatFeatures(44) & 2;
                if (hasFeatureFloatTexture === 0) {
                  this._realTimeJointTexture._format = 35;
                  width = 4 * RealTimeJointTexture.WIDTH;
                }
                var textures = this._realTimeJointTexture._textures;
                var buffers = this._realTimeJointTexture._buffers;
                var pixelFormat = this._realTimeJointTexture._format;
                for (var i = 0; i < this._dataArray.length; i++) {
                  buffers[i] = new Float32Array(4 * RealTimeJointTexture.HEIGHT * RealTimeJointTexture.WIDTH);
                  var arrayBuffer = buffers[i];
                  var updateView = pixelFormat === 44 ? arrayBuffer : new Uint8Array(arrayBuffer.buffer);
                  var image = new ImageAsset({
                    width: width,
                    height: height,
                    _data: updateView,
                    _compressed: false,
                    format: pixelFormat
                  });
                  var texture = new Texture2D();
                  texture.setFilters(1, 1);
                  texture.setMipFilter(0);
                  texture.setWrapMode(2, 2, 2);
                  texture.image = image;
                  textures[i] = texture;
                }
              };
              _proto._bindRealTimeJointTexture = function _bindRealTimeJointTexture(idx, descriptorSet) {
                if (!this._realTimeTextureMode) return;
                var jointTexture = this._realTimeJointTexture._textures[idx];
                if (jointTexture) {
                  var gfxTexture = jointTexture.getGFXTexture();
                  var sampler = jointTexture.getGFXSampler();
                  descriptorSet.bindTexture(UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, gfxTexture);
                  descriptorSet.bindSampler(UNIFORM_REALTIME_JOINT_TEXTURE_BINDING, sampler);
                }
              };
              _proto._updateRealTimeJointTextureBuffer = function _updateRealTimeJointTextureBuffer() {
                if (!this._realTimeTextureMode) return;
                var textures = this._realTimeJointTexture._textures;
                var buffers = this._realTimeJointTexture._buffers;
                for (var idx = 0; idx < textures.length; idx++) {
                  var arrayBuffer = buffers[idx];
                  var src = this._dataArray[idx];
                  var count = src.length / 12;
                  var idxSrc = 0;
                  var idxDst = 0;
                  for (var i = 0; i < count; i++) {
                    idxDst = 4 * i;
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    idxDst = 4 * (i + RealTimeJointTexture.WIDTH);
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    idxDst = 4 * (i + 2 * RealTimeJointTexture.WIDTH);
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                    arrayBuffer[idxDst++] = src[idxSrc++];
                  }
                  var pixelFormat = this._realTimeJointTexture._format;
                  var updateView = pixelFormat === 44 ? arrayBuffer : new Uint8Array(arrayBuffer.buffer);
                  textures[idx].uploadData(updateView);
                }
              };
              return SkinningModel;
            }(MorphModel);

            var myPatches = [{
              name: 'CC_USE_SKINNING',
              value: true
            }, {
              name: 'CC_USE_BAKED_ANIMATION',
              value: true
            }];
            var BakedSkinningModel = function (_MorphModel) {
              _inheritsLoose(BakedSkinningModel, _MorphModel);
              function BakedSkinningModel() {
                var _this;
                _this = _MorphModel.call(this) || this;
                _this.uploadedAnim = undefined;
                _this._jointsMedium = undefined;
                _this._skeleton = null;
                _this._mesh = null;
                _this._dataPoolManager = undefined;
                _this._instAnimInfoIdx = -1;
                _this.type = 2;
                _this._dataPoolManager = cclegacy.director.root.dataPoolManager;
                var jointTextureInfo = new Float32Array(4);
                var animInfo = _this._dataPoolManager.jointAnimationInfo.getData();
                _this._jointsMedium = {
                  buffer: null,
                  jointTextureInfo: jointTextureInfo,
                  animInfo: animInfo,
                  texture: null,
                  boundsInfo: null
                };
                return _this;
              }
              var _proto = BakedSkinningModel.prototype;
              _proto.destroy = function destroy() {
                this.uploadedAnim = undefined;
                this._jointsMedium.boundsInfo = null;
                if (this._jointsMedium.buffer) {
                  this._jointsMedium.buffer.destroy();
                  this._jointsMedium.buffer = null;
                }
                this._applyJointTexture();
                _MorphModel.prototype.destroy.call(this);
              };
              _proto.bindSkeleton = function bindSkeleton(skeleton, skinningRoot, mesh) {
                if (skeleton === undefined) {
                  skeleton = null;
                }
                if (skinningRoot === undefined) {
                  skinningRoot = null;
                }
                if (mesh === undefined) {
                  mesh = null;
                }
                this._skeleton = skeleton;
                this._mesh = mesh;
                if (!skeleton || !skinningRoot || !mesh) {
                  return;
                }
                this.transform = skinningRoot;
                var resMgr = this._dataPoolManager;
                this._jointsMedium.animInfo = resMgr.jointAnimationInfo.getData(skinningRoot.uuid);
                if (!this._jointsMedium.buffer) {
                  this._jointsMedium.buffer = this._device.createBuffer(new BufferInfo(16 | 2, 1, UBOSkinningTexture.SIZE, UBOSkinningTexture.SIZE));
                }
              };
              _proto.updateTransform = function updateTransform(stamp) {
                _MorphModel.prototype.updateTransform.call(this, stamp);
                if (!this.uploadedAnim) {
                  return;
                }
                var _this$_jointsMedium = this._jointsMedium,
                  animInfo = _this$_jointsMedium.animInfo,
                  boundsInfo = _this$_jointsMedium.boundsInfo;
                var skelBound = boundsInfo[animInfo.data[0]];
                var worldBounds = this._worldBounds;
                if (worldBounds && skelBound) {
                  var node = this.transform;
                  skelBound.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                }
              };
              _proto.updateUBOs = function updateUBOs(stamp) {
                _MorphModel.prototype.updateUBOs.call(this, stamp);
                var info = this._jointsMedium.animInfo;
                var hasNonInstancingPass = false;
                var idx = this._instAnimInfoIdx;
                for (var i = 0; i < this._subModels.length; i++) {
                  var subModel = this._subModels[i];
                  if (idx >= 0) {
                    var view = subModel.instancedAttributeBlock.views[idx];
                    view[0] = info.data[0];
                  } else {
                    hasNonInstancingPass = true;
                  }
                }
                if (hasNonInstancingPass && info.dirty) {
                  info.buffer.update(info.data);
                  info.dirty = false;
                }
                return true;
              };
              _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
                var patches = _MorphModel.prototype.getMacroPatches.call(this, subModelIndex);
                return patches ? patches.concat(myPatches) : myPatches;
              };
              _proto.uploadAnimation = function uploadAnimation(anim) {
                if (!this._skeleton || !this._mesh || this.uploadedAnim === anim) {
                  return;
                }
                this.uploadedAnim = anim;
                var resMgr = this._dataPoolManager;
                var texture = null;
                if (anim) {
                  texture = resMgr.jointTexturePool.getSequencePoseTexture(this._skeleton, anim, this._mesh, this.transform);
                  this._jointsMedium.boundsInfo = texture && texture.bounds.get(this._mesh.hash);
                  this._modelBounds = null;
                } else {
                  texture = resMgr.jointTexturePool.getDefaultPoseTexture(this._skeleton, this._mesh, this.transform);
                  this._jointsMedium.boundsInfo = null;
                  this._modelBounds = texture && texture.bounds.get(this._mesh.hash)[0];
                }
                this._applyJointTexture(texture);
              };
              _proto._applyJointTexture = function _applyJointTexture(texture) {
                if (texture === undefined) {
                  texture = null;
                }
                var oldTex = this._jointsMedium.texture;
                if (oldTex && oldTex !== texture) {
                  this._dataPoolManager.jointTexturePool.releaseHandle(oldTex);
                }
                this._jointsMedium.texture = texture;
                if (!texture) {
                  return;
                }
                var _this$_jointsMedium2 = this._jointsMedium,
                  buffer = _this$_jointsMedium2.buffer,
                  jointTextureInfo = _this$_jointsMedium2.jointTextureInfo;
                jointTextureInfo[0] = texture.handle.texture.width;
                jointTextureInfo[1] = this._skeleton.joints.length;
                jointTextureInfo[2] = texture.pixelOffset + 0.1;
                jointTextureInfo[3] = 1 / jointTextureInfo[0];
                this.updateInstancedJointTextureInfo();
                if (buffer) {
                  buffer.update(jointTextureInfo);
                }
                var tex = texture.handle.texture;
                for (var i = 0; i < this._subModels.length; ++i) {
                  var descriptorSet = this._subModels[i].descriptorSet;
                  descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, tex);
                }
              };
              _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                _MorphModel.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);
                var _this$_jointsMedium3 = this._jointsMedium,
                  buffer = _this$_jointsMedium3.buffer,
                  texture = _this$_jointsMedium3.texture,
                  animInfo = _this$_jointsMedium3.animInfo;
                descriptorSet.bindBuffer(UBOSkinningTexture.BINDING, buffer);
                descriptorSet.bindBuffer(UBOSkinningAnimation.BINDING, animInfo.buffer);
                if (texture) {
                  var sampler = this._device.getSampler(jointTextureSamplerInfo);
                  descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, texture.handle.texture);
                  descriptorSet.bindSampler(UNIFORM_JOINT_TEXTURE_BINDING, sampler);
                }
              };
              _proto._updateInstancedAttributes = function _updateInstancedAttributes(attributes, subModel) {
                _MorphModel.prototype._updateInstancedAttributes.call(this, attributes, subModel);
                this._instAnimInfoIdx = subModel.getInstancedAttributeIndex(INST_JOINT_ANIM_INFO);
                this.updateInstancedJointTextureInfo();
              };
              _proto.updateInstancedJointTextureInfo = function updateInstancedJointTextureInfo() {
                var _this$_jointsMedium4 = this._jointsMedium,
                  jointTextureInfo = _this$_jointsMedium4.jointTextureInfo,
                  animInfo = _this$_jointsMedium4.animInfo;
                var idx = this._instAnimInfoIdx;
                for (var i = 0; i < this._subModels.length; i++) {
                  var subModel = this._subModels[i];
                  var views = subModel.instancedAttributeBlock.views;
                  if (idx >= 0 && views.length > 0) {
                    var view = views[idx];
                    view[0] = animInfo.data[0];
                    view[1] = jointTextureInfo[1];
                    view[2] = jointTextureInfo[2];
                  }
                }
              };
              return BakedSkinningModel;
            }(MorphModel);

            var _dec$f, _dec2$c, _dec3$a, _dec4$6, _dec5$4, _dec6$4, _class$f, _class2$c, _initializer$b, _initializer2$a;
            var SkinnedMeshRenderer = (_dec$f = ccclass$6('cc.SkinnedMeshRenderer'), _dec2$c = executionOrder$1(100), _dec3$a = type$5(Skeleton), _dec4$6 = type$5(Node$1), _dec5$4 = type$5(Skeleton), _dec6$4 = type$5(Node$1), _dec$f(_class$f = _dec2$c(_class$f = (_class2$c = function (_MeshRenderer) {
              _inheritsLoose(SkinnedMeshRenderer, _MeshRenderer);
              function SkinnedMeshRenderer() {
                var _this;
                _this = _MeshRenderer.call(this) || this;
                _this._skeleton = _initializer$b && _initializer$b();
                _this._skinningRoot = _initializer2$a && _initializer2$a();
                _this._clip = null;
                _this.associatedAnimation = null;
                _this._modelType = BakedSkinningModel;
                return _this;
              }
              var _proto = SkinnedMeshRenderer.prototype;
              _proto.onLoad = function onLoad() {
                _MeshRenderer.prototype.onLoad.call(this);
                this._tryBindAnimation();
              };
              _proto.onDestroy = function onDestroy() {
                if (this.associatedAnimation) {
                  this.associatedAnimation.notifySkinnedMeshRemoved(this);
                  assertIsTrue(this.associatedAnimation === null);
                }
                _MeshRenderer.prototype.onDestroy.call(this);
              };
              _proto.uploadAnimation = function uploadAnimation(clip) {
                this._clip = clip;
                if (this.model && this.model.uploadAnimation) {
                  this.model.uploadAnimation(clip);
                }
              };
              _proto.setUseBakedAnimation = function setUseBakedAnimation(val, force) {
                if (val === undefined) {
                  val = true;
                }
                if (force === undefined) {
                  force = false;
                }
                var modelType = val ? BakedSkinningModel : SkinningModel;
                if (!force && this._modelType === modelType) {
                  return;
                }
                this._modelType = modelType;
                if (this._model) {
                  cclegacy.director.root.destroyModel(this._model);
                  this._model = null;
                  this._models.length = 0;
                  this._updateModels();
                  this._updateCastShadow();
                  this._updateReceiveShadow();
                  this._updateUseLightProbe();
                  if (this.enabledInHierarchy) {
                    this._attachToScene();
                  }
                }
              };
              _proto.setSharedMaterial = function setSharedMaterial(material, index) {
                _MeshRenderer.prototype.setSharedMaterial.call(this, material, index);
                if (this._modelType === SkinningModel) {
                  this.getMaterialInstance(index);
                }
              };
              _proto._updateModelParams = function _updateModelParams() {
                this._update();
                _MeshRenderer.prototype._updateModelParams.call(this);
              };
              _proto._tryBindAnimation = function _tryBindAnimation() {
                var skinningRoot = this._skinningRoot;
                if (!skinningRoot) {
                  return;
                }
                var skinningRootIsParent = false;
                for (var current = this.node; current; current = current.parent) {
                  if (current === skinningRoot) {
                    skinningRootIsParent = true;
                    break;
                  }
                }
                if (!skinningRootIsParent) {
                  return;
                }
                var animation = skinningRoot.getComponent('cc.SkeletalAnimation');
                if (animation && animation.enabledInHierarchy) {
                  animation.notifySkinnedMeshAdded(this);
                } else {
                  this.setUseBakedAnimation(false);
                }
              };
              _proto._update = function _update() {
                if (this.model) {
                  this.model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh);
                  if (this.model.uploadAnimation) {
                    this.model.uploadAnimation(this._clip);
                  }
                }
              };
              _createClass(SkinnedMeshRenderer, [{
                key: "skeleton",
                get: function get() {
                  return this._skeleton;
                },
                set: function set(val) {
                  if (val === this._skeleton) {
                    return;
                  }
                  this._skeleton = val;
                  this._update();
                }
              }, {
                key: "skinningRoot",
                get: function get() {
                  return this._skinningRoot;
                },
                set: function set(value) {
                  if (value === this._skinningRoot) {
                    return;
                  }
                  this._skinningRoot = value;
                  this._tryBindAnimation();
                  this._update();
                }
              }, {
                key: "model",
                get: function get() {
                  return this._model;
                }
              }]);
              return SkinnedMeshRenderer;
            }(MeshRenderer), (_initializer$b = applyDecoratedInitializer(_class2$c.prototype, "_skeleton", [_dec3$a], function () {
              return null;
            }), _initializer2$a = applyDecoratedInitializer(_class2$c.prototype, "_skinningRoot", [_dec4$6], function () {
              return null;
            }), _applyDecoratedDescriptor(_class2$c.prototype, "skeleton", [_dec5$4], Object.getOwnPropertyDescriptor(_class2$c.prototype, "skeleton"), _class2$c.prototype), _applyDecoratedDescriptor(_class2$c.prototype, "skinningRoot", [_dec6$4], Object.getOwnPropertyDescriptor(_class2$c.prototype, "skinningRoot"), _class2$c.prototype)), _class2$c)) || _class$f) || _class$f); exports({ SkinnedMeshRenderer: SkinnedMeshRenderer, SkinningModelComponent: SkinnedMeshRenderer });

            var _dec$e, _dec2$b, _dec3$9, _dec4$5, _dec5$3, _class$e, _class2$b, _initializer$a, _initializer2$9, _initializer3$6, _initializer4$5, _initializer5$5, _initializer6$3, _dec6$3, _dec7$3, _dec8$3, _dec9$2, _class4$1, _class5$1, _initializer7$2, _initializer8$2, _initializer9$2;
            var repeat$1 = function repeat(n) {
              return n - Math.floor(n);
            };
            var batch_id = new Attribute("a_batch_id", 11);
            var batch_uv = new Attribute("a_batch_uv", 21);
            var batch_extras_size = FormatInfos[batch_id.format].size + FormatInfos[batch_uv.format].size;
            var SkinnedMeshUnit = (_dec$e = ccclass$6('cc.SkinnedMeshUnit'), _dec2$b = type$5(Mesh), _dec3$9 = type$5(Skeleton), _dec4$5 = type$5(Material), _dec5$3 = type$5(SkinnedMeshRenderer), _dec$e(_class$e = (_class2$b = function () {
              function SkinnedMeshUnit() {
                this.mesh = _initializer$a && _initializer$a();
                this.skeleton = _initializer2$9 && _initializer2$9();
                this.material = _initializer3$6 && _initializer3$6();
                this._localTransform = _initializer4$5 && _initializer4$5();
                this._offset = _initializer5$5 && _initializer5$5();
                this._size = _initializer6$3 && _initializer6$3();
              }
              _createClass(SkinnedMeshUnit, [{
                key: "offset",
                get: function get() {
                  return this._offset;
                },
                set: function set(offset) {
                  Vec2.copy(this._offset, offset);
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(size) {
                  Vec2.copy(this._size, size);
                }
              }, {
                key: "copyFrom",
                get: function get() {
                  return null;
                },
                set: function set(comp) {
                  if (!comp) {
                    return;
                  }
                  this.mesh = comp.mesh;
                  this.skeleton = comp.skeleton;
                  this.material = comp.getSharedMaterial(0);
                  if (comp.skinningRoot) {
                    getWorldTransformUntilRoot(comp.node, comp.skinningRoot, this._localTransform);
                  }
                }
              }]);
              return SkinnedMeshUnit;
            }(), (_initializer$a = applyDecoratedInitializer(_class2$b.prototype, "mesh", [_dec2$b], function () {
              return null;
            }), _initializer2$9 = applyDecoratedInitializer(_class2$b.prototype, "skeleton", [_dec3$9], function () {
              return null;
            }), _initializer3$6 = applyDecoratedInitializer(_class2$b.prototype, "material", [_dec4$5], function () {
              return null;
            }), _initializer4$5 = applyDecoratedInitializer(_class2$b.prototype, "_localTransform", [serializable$5], function () {
              return new Mat4();
            }), _initializer5$5 = applyDecoratedInitializer(_class2$b.prototype, "_offset", [serializable$5], function () {
              return new Vec2(0, 0);
            }), _initializer6$3 = applyDecoratedInitializer(_class2$b.prototype, "_size", [serializable$5], function () {
              return new Vec2(1, 1);
            }), _applyDecoratedDescriptor(_class2$b.prototype, "copyFrom", [_dec5$3], Object.getOwnPropertyDescriptor(_class2$b.prototype, "copyFrom"), _class2$b.prototype)), _class2$b)) || _class$e); exports({ SkinnedMeshUnit: SkinnedMeshUnit, SkinningModelUnit: SkinnedMeshUnit });
            var m4_local = new Mat4();
            new Mat4();
            var v3_1 = new Vec3();
            var SkinnedMeshBatchRenderer = (_dec6$3 = ccclass$6('cc.SkinnedMeshBatchRenderer'), _dec7$3 = executionOrder$1(100), _dec8$3 = type$5([CCString]), _dec9$2 = type$5([SkinnedMeshUnit]), _dec6$3(_class4$1 = _dec7$3(_class4$1 = (_class5$1 = function (_SkinnedMeshRenderer) {
              _inheritsLoose(SkinnedMeshBatchRenderer, _SkinnedMeshRenderer);
              function SkinnedMeshBatchRenderer() {
                var _this;
                _this = _SkinnedMeshRenderer.call(this) || this;
                _this.atlasSize = _initializer7$2 && _initializer7$2();
                _this.batchableTextureNames = _initializer8$2 && _initializer8$2();
                _this.units = _initializer9$2 && _initializer9$2();
                _this._textures = {};
                _this._batchMaterial = null;
                return _this;
              }
              var _proto = SkinnedMeshBatchRenderer.prototype;
              _proto.onLoad = function onLoad() {
                _SkinnedMeshRenderer.prototype.onLoad.call(this);
                this.cook();
              };
              _proto.onDestroy = function onDestroy() {
                for (var tex in this._textures) {
                  this._textures[tex].destroy();
                }
                this._textures = {};
                if (this._mesh) {
                  this._mesh.destroy();
                  this._mesh = null;
                }
                _SkinnedMeshRenderer.prototype.onDestroy.call(this);
              };
              _proto._onMaterialModified = function _onMaterialModified(idx, material) {
                this.cookMaterials();
                _SkinnedMeshRenderer.prototype._onMaterialModified.call(this, idx, this.getMaterialInstance(idx));
              };
              _proto.cook = function cook() {
                this.cookMaterials();
                this.cookSkeletons();
                this.cookMeshes();
              };
              _proto.cookMaterials = function cookMaterials() {
                var _this2 = this;
                if (!this._batchMaterial) {
                  this._batchMaterial = this.getSharedMaterial(0);
                }
                var mat = this.getMaterialInstance(0);
                if (!mat || !this._batchMaterial || !this._batchMaterial.effectAsset) {
                  warn('incomplete batch material!');
                  return;
                }
                mat.copy(this._batchMaterial);
                this.resizeAtlases();
                var tech = mat.effectAsset.techniques[mat.technique];
                var _loop = function _loop(i) {
                  var pass = tech.passes[i];
                  if (!pass.properties) {
                    return 1;
                  }
                  var _loop2 = function _loop2(prop) {
                    if (pass.properties[prop].type >= 26) {
                      var tex = null;
                      if (_this2.batchableTextureNames.find(function (n) {
                        return n === prop;
                      })) {
                        tex = _this2._textures[prop];
                        if (!tex) {
                          tex = _this2.createTexture(prop);
                        }
                        _this2.cookTextures(tex, prop, i);
                      } else {
                        _this2.units.some(function (u) {
                          return tex = u.material && u.material.getProperty(prop, i);
                        });
                      }
                      if (tex) {
                        mat.setProperty(prop, tex, i);
                      }
                    } else {
                      var value = [];
                      for (var u = 0; u < _this2.units.length; u++) {
                        var unit = _this2.units[u];
                        if (!unit.material) {
                          continue;
                        }
                        value.push(unit.material.getProperty(prop.slice(0, -3), i));
                      }
                      mat.setProperty(prop, value, i);
                    }
                  };
                  for (var prop in pass.properties) {
                    _loop2(prop);
                  }
                };
                for (var i = 0; i < tech.passes.length; i++) {
                  if (_loop(i)) continue;
                }
              };
              _proto.cookSkeletons = function cookSkeletons() {
                if (!this._skinningRoot) {
                  warn('no skinning root specified!');
                  return;
                }
                var joints = [];
                var bindposes = [];
                for (var u = 0; u < this.units.length; u++) {
                  var unit = this.units[u];
                  if (!unit || !unit.skeleton) {
                    continue;
                  }
                  var partial = unit.skeleton;
                  Mat4.invert(m4_local, unit._localTransform);
                  var _loop3 = function _loop3() {
                    var path = partial.joints[i];
                    var idx = joints.findIndex(function (p) {
                      return p === path;
                    });
                    if (idx >= 0) {
                      return 1;
                    }
                    joints.push(path);
                    bindposes.push(Mat4.multiply(new Mat4(), partial.bindposes[i] || Mat4.IDENTITY, m4_local));
                  };
                  for (var i = 0; i < partial.joints.length; i++) {
                    if (_loop3()) continue;
                  }
                }
                var idxMap = Array.from(Array(joints.length).keys()).sort(function (a, b) {
                  if (joints[a] > joints[b]) {
                    return 1;
                  }
                  if (joints[a] < joints[b]) {
                    return -1;
                  }
                  return 0;
                });
                var skeleton = new Skeleton();
                skeleton.joints = joints.map(function (_, idx, arr) {
                  return arr[idxMap[idx]];
                });
                skeleton.bindposes = bindposes.map(function (_, idx, arr) {
                  return arr[idxMap[idx]];
                });
                if (this._skeleton) {
                  this._skeleton.destroy();
                }
                this.skeleton = skeleton;
              };
              _proto.cookMeshes = function cookMeshes() {
                var _this4 = this;
                var isValid = false;
                for (var u = 0; u < this.units.length; u++) {
                  var unit = this.units[u];
                  if (unit.mesh) {
                    isValid = true;
                    break;
                  }
                }
                if (!isValid || !this._skinningRoot) {
                  return;
                }
                if (this._mesh) {
                  this._mesh.destroyRenderingMesh();
                } else {
                  this._mesh = new Mesh();
                }
                var posOffset = 0;
                var posFormat = 0;
                var normalOffset = 0;
                var normalFormat = 0;
                var tangentOffset = 0;
                var tangentFormat = 0;
                var uvOffset = 0;
                var uvFormat = 0;
                var jointOffset = 0;
                var jointFormat = 0;
                var jointIndexMap = new Array(this.units.length);
                var unitLen = this.units.length;
                for (var i = 0; i < unitLen; i++) {
                  var _unit = this.units[i];
                  if (!_unit || !_unit.skeleton) {
                    continue;
                  }
                  jointIndexMap[i] = _unit.skeleton.joints.map(function (j) {
                    return _this4._skeleton.joints.findIndex(function (ref) {
                      return j === ref;
                    });
                  });
                }
                var _loop4 = function _loop4() {
                  var unit = _this4.units[_i];
                  if (!unit || !unit.mesh || !unit.mesh.data) {
                    return 1;
                  }
                  var newMesh = _this4._createUnitMesh(_i, unit.mesh);
                  var dataView = new DataView(newMesh.data.buffer);
                  Mat4.invert(m4_local, unit._localTransform);
                  Mat4.transpose(m4_local, m4_local);
                  var offset = unit.offset;
                  var size = unit.size;
                  var _loop5 = function _loop5() {
                    var bundle = newMesh.struct.vertexBundles[b];
                    posOffset = bundle.view.offset;
                    posFormat = 0;
                    for (var a = 0; a < bundle.attributes.length; a++) {
                      var attr = bundle.attributes[a];
                      if (attr.name === "a_position") {
                        posFormat = attr.format;
                        break;
                      }
                      posOffset += FormatInfos[attr.format].size;
                    }
                    if (posFormat) {
                      var pos = readBuffer(dataView, posFormat, posOffset, bundle.view.length, bundle.view.stride);
                      for (var j = 0; j < pos.length; j += 3) {
                        Vec3.fromArray(v3_1, pos, j);
                        Vec3.transformMat4(v3_1, v3_1, unit._localTransform);
                        Vec3.toArray(pos, v3_1, j);
                      }
                      writeBuffer(dataView, pos, posFormat, posOffset, bundle.view.stride);
                    }
                    normalOffset = bundle.view.offset;
                    normalFormat = 0;
                    for (var _a = 0; _a < bundle.attributes.length; _a++) {
                      var _attr = bundle.attributes[_a];
                      if (_attr.name === "a_normal") {
                        normalFormat = _attr.format;
                        break;
                      }
                      normalOffset += FormatInfos[_attr.format].size;
                    }
                    if (normalFormat) {
                      var normal = readBuffer(dataView, normalFormat, normalOffset, bundle.view.length, bundle.view.stride);
                      for (var _j = 0; _j < normal.length; _j += 3) {
                        Vec3.fromArray(v3_1, normal, _j);
                        Vec3.transformMat4Normal(v3_1, v3_1, m4_local);
                        Vec3.toArray(normal, v3_1, _j);
                      }
                      writeBuffer(dataView, normal, normalFormat, normalOffset, bundle.view.stride);
                    }
                    tangentOffset = bundle.view.offset;
                    tangentFormat = 0;
                    for (var _a2 = 0; _a2 < bundle.attributes.length; _a2++) {
                      var _attr2 = bundle.attributes[_a2];
                      if (_attr2.name === "a_tangent") {
                        tangentFormat = _attr2.format;
                        break;
                      }
                      tangentOffset += FormatInfos[_attr2.format].size;
                    }
                    if (tangentFormat) {
                      var tangent = readBuffer(dataView, tangentFormat, tangentOffset, bundle.view.length, bundle.view.stride);
                      for (var _j2 = 0; _j2 < tangent.length; _j2 += 3) {
                        Vec3.fromArray(v3_1, tangent, _j2);
                        Vec3.transformMat4Normal(v3_1, v3_1, m4_local);
                        Vec3.toArray(tangent, v3_1, _j2);
                      }
                      writeBuffer(dataView, tangent, tangentFormat, tangentOffset, bundle.view.stride);
                    }
                    uvOffset = bundle.view.offset;
                    uvFormat = 0;
                    for (var _a3 = 0; _a3 < bundle.attributes.length; _a3++) {
                      var _attr3 = bundle.attributes[_a3];
                      if (_attr3.name === "a_batch_uv") {
                        uvFormat = _attr3.format;
                        break;
                      }
                      uvOffset += FormatInfos[_attr3.format].size;
                    }
                    if (uvFormat) {
                      mapBuffer(dataView, function (cur, idx) {
                        cur = repeat$1(cur);
                        var comp = idx === 0 ? 'x' : 'y';
                        return cur * size[comp] + offset[comp];
                      }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                    }
                    var idxMap = jointIndexMap[_i];
                    if (!idxMap) {
                      return 1;
                    }
                    jointOffset = bundle.view.offset;
                    jointFormat = 0;
                    for (var _a4 = 0; _a4 < bundle.attributes.length; _a4++) {
                      var _attr4 = bundle.attributes[_a4];
                      if (_attr4.name === "a_joints") {
                        jointFormat = _attr4.format;
                        break;
                      }
                      jointOffset += FormatInfos[_attr4.format].size;
                    }
                    if (jointFormat) {
                      mapBuffer(dataView, function (cur) {
                        return idxMap[cur];
                      }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                    }
                  };
                  for (var b = 0; b < newMesh.struct.vertexBundles.length; b++) {
                    if (_loop5()) continue;
                  }
                  _this4._mesh.merge(newMesh);
                };
                for (var _i = 0; _i < unitLen; _i++) {
                  if (_loop4()) continue;
                }
                this._onMeshChanged(this._mesh);
                this._updateModels();
              };
              _proto.cookTextures = function cookTextures(target, prop, passIdx) {
                var texImages = [];
                var texImageRegions = [];
                var texBuffers = [];
                var texBufferRegions = [];
                for (var u = 0; u < this.units.length; u++) {
                  var unit = this.units[u];
                  if (!unit.material) {
                    continue;
                  }
                  var partial = unit.material.getProperty(prop, passIdx);
                  if (partial && partial.image && partial.image.data) {
                    var region = new BufferTextureCopy();
                    region.texOffset.x = unit.offset.x * this.atlasSize;
                    region.texOffset.y = unit.offset.y * this.atlasSize;
                    region.texExtent.width = unit.size.x * this.atlasSize;
                    region.texExtent.height = unit.size.y * this.atlasSize;
                    var data = partial.image.data;
                    if (!ArrayBuffer.isView(data)) {
                      texImages.push(data);
                      texImageRegions.push(region);
                    } else {
                      texBuffers.push(data);
                      texBufferRegions.push(region);
                    }
                  }
                }
                var gfxTex = target.getGFXTexture();
                var _ref = cclegacy.director.root,
                  device = _ref.device;
                if (texBuffers.length > 0) {
                  device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions);
                }
                if (texImages.length > 0) {
                  device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
                }
              };
              _proto.createTexture = function createTexture(prop) {
                var tex = new Texture2D();
                tex.setFilters(2, 2);
                tex.setMipFilter(1);
                tex.reset({
                  width: this.atlasSize,
                  height: this.atlasSize,
                  format: 35
                });
                this._textures[prop] = tex;
                return tex;
              };
              _proto.resizeAtlases = function resizeAtlases() {
                for (var prop in this._textures) {
                  var tex = this._textures[prop];
                  tex.reset({
                    width: this.atlasSize,
                    height: this.atlasSize,
                    format: 35
                  });
                }
              };
              _proto._createUnitMesh = function _createUnitMesh(unitIdx, mesh) {
                var newMeshStruct = JSON.parse(JSON.stringify(mesh.struct));
                var modifiedBundles = {};
                for (var p = 0; p < mesh.struct.primitives.length; p++) {
                  var primitive = mesh.struct.primitives[p];
                  var uvOffset = 0;
                  var uvFormat = 0;
                  var bundleIdx = 0;
                  for (; bundleIdx < primitive.vertexBundelIndices.length; bundleIdx++) {
                    var bundle = mesh.struct.vertexBundles[primitive.vertexBundelIndices[bundleIdx]];
                    uvOffset = bundle.view.offset;
                    uvFormat = 0;
                    for (var a = 0; a < bundle.attributes.length; a++) {
                      var attr = bundle.attributes[a];
                      if (attr.name === "a_texCoord") {
                        uvFormat = attr.format;
                        break;
                      }
                      uvOffset += FormatInfos[attr.format].size;
                    }
                    if (uvFormat) {
                      break;
                    }
                  }
                  if (modifiedBundles[bundleIdx] !== undefined) {
                    continue;
                  }
                  modifiedBundles[bundleIdx] = [uvFormat, uvOffset];
                  var newBundle = newMeshStruct.vertexBundles[bundleIdx];
                  newBundle.attributes.push(batch_id);
                  newBundle.attributes.push(batch_uv);
                  newBundle.view.offset = 0;
                  newBundle.view.length += newBundle.view.count * batch_extras_size;
                  newBundle.view.stride += batch_extras_size;
                }
                var totalLength = 0;
                for (var b = 0; b < newMeshStruct.vertexBundles.length; b++) {
                  totalLength += newMeshStruct.vertexBundles[b].view.length;
                }
                for (var _p = 0; _p < newMeshStruct.primitives.length; _p++) {
                  var pm = newMeshStruct.primitives[_p];
                  if (pm.indexView) {
                    pm.indexView.offset = totalLength;
                    totalLength += pm.indexView.length;
                  }
                }
                var newMeshData = new Uint8Array(totalLength);
                var oldMeshData = mesh.data;
                var newDataView = new DataView(newMeshData.buffer);
                var oldDataView = new DataView(oldMeshData.buffer);
                var isLittleEndian = cclegacy.sys.isLittleEndian;
                for (var _b in modifiedBundles) {
                  var _newBundle = newMeshStruct.vertexBundles[_b];
                  var oldBundle = mesh.struct.vertexBundles[_b];
                  var _modifiedBundles$_b = modifiedBundles[_b],
                    _uvFormat = _modifiedBundles$_b[0],
                    _uvOffset = _modifiedBundles$_b[1];
                  var uvs = readBuffer(oldDataView, _uvFormat, _uvOffset, oldBundle.view.length, oldBundle.view.stride);
                  var oldView = oldBundle.view;
                  var newView = _newBundle.view;
                  var oldStride = oldView.stride;
                  var newStride = newView.stride;
                  var oldOffset = oldView.offset;
                  var newOffset = newView.offset;
                  for (var j = 0; j < newView.count; j++) {
                    var srcVertex = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
                    newMeshData.set(srcVertex, newOffset);
                    newDataView.setFloat32(newOffset + oldStride, unitIdx);
                    newDataView.setFloat32(newOffset + oldStride + 4, uvs[j * 2], isLittleEndian);
                    newDataView.setFloat32(newOffset + oldStride + 8, uvs[j * 2 + 1], isLittleEndian);
                    newOffset += newStride;
                    oldOffset += oldStride;
                  }
                }
                for (var k = 0; k < newMeshStruct.primitives.length; k++) {
                  var oldPrimitive = mesh.struct.primitives[k];
                  var newPrimitive = newMeshStruct.primitives[k];
                  if (oldPrimitive.indexView && newPrimitive.indexView) {
                    var _oldStride = oldPrimitive.indexView.stride;
                    var _newStride = newPrimitive.indexView.stride;
                    var _oldOffset = oldPrimitive.indexView.offset;
                    var _newOffset = newPrimitive.indexView.offset;
                    for (var _j3 = 0; _j3 < newPrimitive.indexView.count; _j3++) {
                      var srcIndices = oldMeshData.subarray(_oldOffset, _oldOffset + _oldStride);
                      newMeshData.set(srcIndices, _newOffset);
                      _newOffset += _newStride;
                      _oldOffset += _oldStride;
                    }
                  }
                }
                var newMesh = new Mesh();
                newMesh.reset({
                  struct: newMeshStruct,
                  data: newMeshData
                });
                return newMesh;
              };
              _createClass(SkinnedMeshBatchRenderer, [{
                key: "mesh",
                get: function get() {
                  return _SkinnedMeshRenderer.prototype.mesh;
                },
                set: function set(val) {
                  this.mesh = val;
                }
              }, {
                key: "skeleton",
                get: function get() {
                  return _SkinnedMeshRenderer.prototype.skeleton;
                },
                set: function set(val) {
                  this.skeleton = val;
                }
              }]);
              return SkinnedMeshBatchRenderer;
            }(SkinnedMeshRenderer), (_initializer7$2 = applyDecoratedInitializer(_class5$1.prototype, "atlasSize", [serializable$5], function () {
              return 1024;
            }), _initializer8$2 = applyDecoratedInitializer(_class5$1.prototype, "batchableTextureNames", [_dec8$3, serializable$5], function () {
              return [];
            }), _initializer9$2 = applyDecoratedInitializer(_class5$1.prototype, "units", [_dec9$2, serializable$5], function () {
              return [];
            }), _applyDecoratedDescriptor(_class5$1.prototype, "mesh", [override], Object.getOwnPropertyDescriptor(_class5$1.prototype, "mesh"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "skeleton", [override], Object.getOwnPropertyDescriptor(_class5$1.prototype, "skeleton"), _class5$1.prototype)), _class5$1)) || _class4$1) || _class4$1); exports({ SkinnedMeshBatchRenderer: SkinnedMeshBatchRenderer, BatchedSkinningModelComponent: SkinnedMeshBatchRenderer });

            cclegacy.SkinningModelComponent = SkinnedMeshRenderer;
            setClassAlias(SkinnedMeshRenderer, 'cc.SkinningModelComponent');
            cclegacy.SkinningModelUnit = SkinnedMeshUnit;
            setClassAlias(SkinnedMeshUnit, 'cc.SkinningModelUnit');
            cclegacy.BatchedSkinningModelComponent = SkinnedMeshBatchRenderer;
            setClassAlias(SkinnedMeshBatchRenderer, 'cc.BatchedSkinningModelComponent');

            var _dec$d, _dec2$a, _dec3$8, _dec4$4, _dec5$2, _class$d, _class2$a, _initializer$9, _initializer2$8, _dec6$2, _dec7$2, _dec8$2, _class4, _class5, _initializer3$5, _initializer4$4, _initializer5$4;
            var DEFAULT_SCREEN_OCCUPATION = [0.25, 0.125, 0.01];
            var LOD = exports("LOD", (_dec$d = ccclass$6('cc.LOD'), _dec2$a = type$5([MeshRenderer]), _dec3$8 = type$5(CCFloat), _dec4$4 = type$5([MeshRenderer]), _dec5$2 = type$5([CCInteger]), _dec$d(_class$d = (_class2$a = function () {
              function LOD() {
                this._screenUsagePercentage = _initializer$9 && _initializer$9();
                this._renderers = _initializer2$8 && _initializer2$8();
                this._LODData = new LODData();
                this._modelAddedCallback = undefined;
                this._LODData.screenUsagePercentage = this._screenUsagePercentage;
                this._modelAddedCallback = null;
              }
              var _proto = LOD.prototype;
              _proto.insertRenderer = function insertRenderer(index, renderer) {
                if (index < 0 || index > this._renderers.length) {
                  index = this._renderers.length;
                }
                this._renderers.splice(index, 0, renderer);
                var modelAdded = false;
                if (renderer.model) {
                  modelAdded = true;
                  this._LODData.addModel(renderer.model);
                }
                if (this._modelAddedCallback && modelAdded) {
                  this._modelAddedCallback();
                }
                return renderer;
              };
              _proto.deleteRenderer = function deleteRenderer(index) {
                var _renders$;
                var renders = this._renderers.splice(index, 1);
                var model = renders.length > 0 ? (_renders$ = renders[0]) == null ? undefined : _renders$.model : null;
                if (model) {
                  this._LODData.eraseModel(model);
                }
                return renders[0];
              };
              _proto.getRenderer = function getRenderer(index) {
                return this._renderers[index] || null;
              };
              _proto.setRenderer = function setRenderer(index, renderer) {
                if (index < 0 || index >= this.rendererCount) {
                  error('setRenderer to LOD error, index out of range');
                  return;
                }
                this.deleteRenderer(index);
                this.insertRenderer(index, renderer);
              };
              _createClass(LOD, [{
                key: "screenUsagePercentage",
                get: function get() {
                  return this._screenUsagePercentage;
                },
                set: function set(val) {
                  this._screenUsagePercentage = val;
                  this._LODData.screenUsagePercentage = val;
                }
              }, {
                key: "renderers",
                get: function get() {
                  return this._renderers;
                },
                set: function set(meshList) {
                  if (meshList === this._renderers) return;
                  var modelAdded = false;
                  this._renderers.length = 0;
                  this._LODData.clearModels();
                  for (var i = 0; i < meshList.length; i++) {
                    var _meshList$i;
                    this._renderers[i] = meshList[i];
                    var model = (_meshList$i = meshList[i]) == null ? undefined : _meshList$i.model;
                    if (model) {
                      modelAdded = true;
                      this._LODData.addModel(model);
                    }
                  }
                  if (this._modelAddedCallback && modelAdded) {
                    this._modelAddedCallback();
                  }
                }
              }, {
                key: "triangleCount",
                get: function get() {
                  var tris = [];
                  this._renderers.forEach(function (meshRenderer) {
                    var count = 0;
                    if (meshRenderer && meshRenderer.mesh) {
                      var primitives = meshRenderer.mesh.struct.primitives;
                      primitives == null ? undefined : primitives.forEach(function (subMesh) {
                        if (subMesh && subMesh.indexView) {
                          count += subMesh.indexView.count;
                        }
                      });
                    }
                    tris.push(count / 3);
                  });
                  return tris;
                }
              }, {
                key: "rendererCount",
                get: function get() {
                  return this._renderers.length;
                }
              }, {
                key: "lodData",
                get: function get() {
                  return this._LODData;
                }
              }, {
                key: "modelAddedCallback",
                set: function set(callback) {
                  this._modelAddedCallback = callback;
                }
              }]);
              return LOD;
            }(), (_initializer$9 = applyDecoratedInitializer(_class2$a.prototype, "_screenUsagePercentage", [serializable$5], function () {
              return 1.0;
            }), _initializer2$8 = applyDecoratedInitializer(_class2$a.prototype, "_renderers", [_dec2$a, serializable$5], function () {
              return [];
            }), _applyDecoratedDescriptor(_class2$a.prototype, "screenUsagePercentage", [_dec3$8], Object.getOwnPropertyDescriptor(_class2$a.prototype, "screenUsagePercentage"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "renderers", [_dec4$4], Object.getOwnPropertyDescriptor(_class2$a.prototype, "renderers"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "triangleCount", [_dec5$2], Object.getOwnPropertyDescriptor(_class2$a.prototype, "triangleCount"), _class2$a.prototype)), _class2$a)) || _class$d));
            var LODGroup = exports("LODGroup", (_dec6$2 = ccclass$6('cc.LODGroup'), _dec7$2 = type$5(CCFloat), _dec8$2 = type$5([LOD]), _dec6$2(_class4 = (_class5 = function (_Component) {
              _inheritsLoose(LODGroup, _Component);
              function LODGroup() {
                var _this;
                _this = _Component.call(this) || this;
                _this._localBoundaryCenter = _initializer3$5 && _initializer3$5();
                _this._objectSize = _initializer4$4 && _initializer4$4();
                _this._LODs = _initializer5$4 && _initializer5$4();
                _this._lodGroup = new LODGroup$1();
                _this._eventRegistered = false;
                _this._forceUsedLevels = [];
                return _this;
              }
              var _proto2 = LODGroup.prototype;
              _proto2.onLodModelAddedCallback = function onLodModelAddedCallback() {
                if (this.objectSize === 0) {
                  this.recalculateBounds();
                }
              };
              _proto2.insertLOD = function insertLOD(index, screenUsagePercentage, lod) {
                if (index < 0 || index > this.lodCount) {
                  index = this.lodCount;
                }
                if (!lod) {
                  lod = new LOD();
                }
                lod.modelAddedCallback = this.onLodModelAddedCallback.bind(this);
                if (!screenUsagePercentage) {
                  var preLod = this.getLOD(index - 1);
                  var nextLod = this.getLOD(index);
                  if (preLod && nextLod) {
                    screenUsagePercentage = (preLod.screenUsagePercentage + nextLod.screenUsagePercentage) / 2;
                  } else if (preLod && !nextLod) {
                    screenUsagePercentage = preLod.screenUsagePercentage / 2;
                    if (screenUsagePercentage > 0.01) {
                      screenUsagePercentage = 0.01;
                    }
                  } else if (nextLod && !preLod) {
                    screenUsagePercentage = nextLod.screenUsagePercentage;
                    var curNextLOD = this.getLOD(index + 1);
                    nextLod.screenUsagePercentage = (screenUsagePercentage + (curNextLOD ? curNextLOD.screenUsagePercentage : 0)) / 2;
                  } else {
                    screenUsagePercentage = DEFAULT_SCREEN_OCCUPATION[0];
                  }
                }
                lod.screenUsagePercentage = screenUsagePercentage;
                this._LODs.splice(index, 0, lod);
                this._lodGroup.insertLOD(index, lod.lodData);
                this._updateDataToScene();
                if (this.node) {
                  this._emitChangeNode(this.node);
                }
                return lod;
              };
              _proto2.eraseLOD = function eraseLOD(index) {
                if (index < 0 || index >= this.lodCount) {
                  warn('eraseLOD error, index out of range');
                  return null;
                }
                var lod = this._LODs[index];
                if (!lod) {
                  warn('eraseLOD error, LOD not exist at specified index.');
                  return null;
                }
                this._LODs.splice(index, 1);
                this._lodGroup.eraseLOD(index);
                this._updateDataToScene();
                this._emitChangeNode(this.node);
                return lod;
              };
              _proto2.getLOD = function getLOD(index) {
                if (index < 0 || index >= this.lodCount) {
                  warn('getLOD error, index out of range');
                  return null;
                }
                return this._LODs[index];
              };
              _proto2.setLOD = function setLOD(index, lod) {
                if (index < 0 || index >= this.lodCount) {
                  warn('setLOD error, index out of range');
                  return;
                }
                this._LODs[index] = lod;
                lod.modelAddedCallback = this.onLodModelAddedCallback.bind(this);
                this.lodGroup.updateLOD(index, lod.lodData);
                this._updateDataToScene();
              };
              _proto2.recalculateBounds = function recalculateBounds() {
                function getTransformedBoundary(c, e, transform) {
                  var minPos;
                  var maxPos;
                  var pts = new Array(new Vec3(c.x - e.x, c.y - e.y, c.z - e.z), new Vec3(c.x - e.x, c.y + e.y, c.z - e.z), new Vec3(c.x + e.x, c.y + e.y, c.z - e.z), new Vec3(c.x + e.x, c.y - e.y, c.z - e.z), new Vec3(c.x - e.x, c.y - e.y, c.z + e.z), new Vec3(c.x - e.x, c.y + e.y, c.z + e.z), new Vec3(c.x + e.x, c.y + e.y, c.z + e.z), new Vec3(c.x + e.x, c.y - e.y, c.z + e.z));
                  minPos = pts[0].transformMat4(transform);
                  maxPos = minPos.clone();
                  for (var i = 1; i < 8; ++i) {
                    var pt = pts[i].transformMat4(transform);
                    minPos = Vec3.min(minPos, minPos, pt);
                    maxPos = Vec3.max(maxPos, maxPos, pt);
                  }
                  return [minPos, maxPos];
                }
                var minPos = new Vec3();
                var maxPos = new Vec3();
                var boundsMin = null;
                var boundsMax = new Vec3();
                for (var i = 0; i < this.lodCount; ++i) {
                  var lod = this.getLOD(i);
                  if (lod) {
                    for (var j = 0; j < lod.rendererCount; ++j) {
                      var _renderer$model, _renderer$model2;
                      var renderer = lod.getRenderer(j);
                      if (!renderer) {
                        continue;
                      }
                      (_renderer$model = renderer.model) == null ? undefined : _renderer$model.updateWorldBound();
                      var worldBounds = (_renderer$model2 = renderer.model) == null ? undefined : _renderer$model2.worldBounds;
                      if (worldBounds) {
                        worldBounds.getBoundary(minPos, maxPos);
                        if (boundsMin) {
                          Vec3.min(boundsMin, boundsMin, minPos);
                          Vec3.max(boundsMax, boundsMax, maxPos);
                        } else {
                          boundsMin = minPos.clone();
                          boundsMax = maxPos.clone();
                        }
                      }
                    }
                  }
                }
                if (boundsMin) {
                  var boundsMin2 = boundsMin;
                  var c = new Vec3((boundsMax.x + boundsMin2.x) * 0.5, (boundsMax.y + boundsMin2.y) * 0.5, (boundsMax.z + boundsMin2.z) * 0.5);
                  var e = new Vec3((boundsMax.x - boundsMin2.x) * 0.5, (boundsMax.y - boundsMin2.y) * 0.5, (boundsMax.z - boundsMin2.z) * 0.5);
                  var _getTransformedBounda = getTransformedBoundary(c, e, this.node.worldMatrix.clone().invert()),
                    _minPos = _getTransformedBounda[0],
                    _maxPos = _getTransformedBounda[1];
                  c.set((_maxPos.x + _minPos.x) * 0.5, (_maxPos.y + _minPos.y) * 0.5, (_maxPos.z + _minPos.z) * 0.5);
                  e.set((_maxPos.x - _minPos.x) * 0.5, (_maxPos.y - _minPos.y) * 0.5, (_maxPos.z - _minPos.z) * 0.5);
                  this.localBoundaryCenter = c;
                  this.objectSize = Math.max(e.x, e.y, e.z) * 2.0;
                } else {
                  this.localBoundaryCenter = new Vec3(0, 0, 0);
                  this.objectSize = 0;
                }
                this._emitChangeNode(this.node);
              };
              _proto2.resetObjectSize = function resetObjectSize() {
                if (this.objectSize === 1.0) return;
                if (this.objectSize === 0) {
                  this.objectSize = 1.0;
                }
                var scale = 1.0 / this.objectSize;
                this.objectSize = 1.0;
                for (var i = 0; i < this.lodCount; ++i) {
                  var lod = this.getLOD(i);
                  if (lod) {
                    lod.screenUsagePercentage *= scale;
                  }
                }
                this._emitChangeNode(this.node);
              };
              _proto2.forceLOD = function forceLOD(lodLevel) {
                this._forceUsedLevels = lodLevel < 0 ? [] : [lodLevel];
                this.lodGroup.lockLODLevels(this._forceUsedLevels);
              };
              _proto2.forceLODs = function forceLODs(lodIndexArray) {
              };
              _proto2.onLoad = function onLoad() {
                this._lodGroup.node = this.node;
                this._lodGroup.objectSize = this._objectSize;
                this._lodGroup.localBoundaryCenter = this._localBoundaryCenter;
                if (!this._eventRegistered) {
                  this.node.on("component-removed", this._onRemove, this);
                  this._eventRegistered = true;
                }
                this._constructLOD();
              };
              _proto2._onRemove = function _onRemove(comp) {
                if (comp === this) {
                  this.onDisable();
                }
              };
              _proto2._constructLOD = function _constructLOD() {
                if (this.lodCount < 1) {
                  var size = DEFAULT_SCREEN_OCCUPATION.length;
                  for (var i = 0; i < size; i++) {
                    this.insertLOD(i, DEFAULT_SCREEN_OCCUPATION[i]);
                  }
                }
              };
              _proto2.onRestore = function onRestore() {
                this._constructLOD();
                if (this.enabledInHierarchy) {
                  this._attachToScene();
                }
              };
              _proto2.onEnable = function onEnable() {
                var _this2 = this;
                this._attachToScene();
                if (this.objectSize === 0) {
                  this.recalculateBounds();
                }
                this.lodGroup.lockLODLevels(this._forceUsedLevels);
                if (this.lodCount > 0 && this._lodGroup.lodCount < 1) {
                  this._LODs.forEach(function (lod, index) {
                    lod.lodData.screenUsagePercentage = lod.screenUsagePercentage;
                    var renderers = lod.renderers;
                    if (renderers !== null && renderers.length > 0) {
                      for (var i = 0; i < renderers.length; i++) {
                        var lodInstance = lod.lodData;
                        var renderer = renderers[i];
                        if (lodInstance && renderer && renderer.model) {
                          lodInstance.addModel(renderer.model);
                        }
                      }
                    }
                    _this2._lodGroup.insertLOD(index, lod.lodData);
                  });
                }
              };
              _proto2.onDisable = function onDisable() {
                this._detachFromScene();
                this.lodGroup.lockLODLevels([]);
              };
              _proto2._attachToScene = function _attachToScene() {
                if (this.node && this.node.scene) {
                  var renderScene = this._getRenderScene();
                  if (this._lodGroup.scene) {
                    this._detachFromScene();
                  }
                  renderScene.addLODGroup(this._lodGroup);
                }
              };
              _proto2._detachFromScene = function _detachFromScene() {
                if (this._lodGroup.scene) {
                  this._lodGroup.scene.removeLODGroup(this._lodGroup);
                }
              };
              _proto2._emitChangeNode = function _emitChangeNode(node) {
              };
              _proto2._updateDataToScene = function _updateDataToScene() {
                this._detachFromScene();
                this._attachToScene();
              };
              _createClass(LODGroup, [{
                key: "localBoundaryCenter",
                get: function get() {
                  return this._localBoundaryCenter.clone();
                },
                set: function set(val) {
                  this._localBoundaryCenter.set(val);
                  this._lodGroup.localBoundaryCenter = val;
                }
              }, {
                key: "lodCount",
                get: function get() {
                  return this._LODs.length;
                }
              }, {
                key: "objectSize",
                get: function get() {
                  return this._objectSize;
                },
                set: function set(val) {
                  this._objectSize = val;
                  this._lodGroup.objectSize = val;
                }
              }, {
                key: "LODs",
                get: function get() {
                  return this._LODs;
                },
                set: function set(valArray) {
                  var _this3 = this;
                  if (valArray === this._LODs) {
                    this._updateDataToScene();
                    return;
                  }
                  this._LODs.length = 0;
                  this.lodGroup.clearLODs();
                  valArray.forEach(function (lod, index) {
                    _this3.lodGroup.insertLOD(index, lod.lodData);
                    _this3._LODs[index] = lod;
                    lod.modelAddedCallback = _this3.onLodModelAddedCallback.bind(_this3);
                  });
                  this._updateDataToScene();
                }
              }, {
                key: "lodGroup",
                get: function get() {
                  return this._lodGroup;
                }
              }]);
              return LODGroup;
            }(Component), (_initializer3$5 = applyDecoratedInitializer(_class5.prototype, "_localBoundaryCenter", [serializable$5], function () {
              return new Vec3(0, 0, 0);
            }), _initializer4$4 = applyDecoratedInitializer(_class5.prototype, "_objectSize", [serializable$5], function () {
              return 0;
            }), _initializer5$4 = applyDecoratedInitializer(_class5.prototype, "_LODs", [serializable$5], function () {
              return [];
            }), _applyDecoratedDescriptor(_class5.prototype, "objectSize", [_dec7$2], Object.getOwnPropertyDescriptor(_class5.prototype, "objectSize"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "LODs", [_dec8$2], Object.getOwnPropertyDescriptor(_class5.prototype, "LODs"), _class5.prototype)), _class5)) || _class4));

            var REFLECTION_PROBE_DEFAULT_MASK$1 = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.UI_3D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER, Layers.Enum.IGNORE_RAYCAST]);
            var ReflectionProbeManager = exports("ReflectionProbeManager", function () {
              function ReflectionProbeManager() {
                this._probes = [];
                this._useCubeModels = new Map();
                this._usePlanarModels = new Map();
                this._updateForRuntime = true;
                this._dataTexture = null;
                this._registeredEvent = false;
              }
              var _proto = ReflectionProbeManager.prototype;
              _proto.registerEvent = function registerEvent() {
                if (!this._registeredEvent) {
                  cclegacy.director.on(cclegacy.DirectorEvent.BEFORE_UPDATE, this.onUpdateProbes, this);
                  this._registeredEvent = true;
                }
              };
              _proto.onUpdateProbes = function onUpdateProbes() {
                if (this._probes.length === 0) return;
                var scene = cclegacy.director.getScene();
                if (!scene || !scene.renderScene) {
                  return;
                }
                var models = scene.renderScene.models;
                for (var i = 0; i < models.length; i++) {
                  var model = models[i];
                  if (!model.node) continue;
                  if (model.node.layer & REFLECTION_PROBE_DEFAULT_MASK$1) {
                    if (model.reflectionProbeType === 1 || this._isUsedBlending(model)) {
                      this.selectReflectionProbe(model);
                    } else if (model.reflectionProbeType === 2) {
                      this.selectPlanarReflectionProbe(model);
                    }
                  }
                }
              };
              _proto.filterModelsForPlanarReflection = function filterModelsForPlanarReflection() {
                if (this._probes.length === 0) return;
                var scene = cclegacy.director.getScene();
                if (!scene || !scene.renderScene) {
                  return;
                }
                var models = scene.renderScene.models;
                for (var i = 0; i < models.length; i++) {
                  var model = models[i];
                  if (!model.node) continue;
                  if (model.node.layer & REFLECTION_PROBE_DEFAULT_MASK$1 && model.reflectionProbeType === 2) {
                    this.selectPlanarReflectionProbe(model);
                  }
                }
              };
              _proto.clearPlanarReflectionMap = function clearPlanarReflectionMap(probe) {
                for (var _iterator = _createForOfIteratorHelperLoose(this._usePlanarModels.entries()), _step; !(_step = _iterator()).done;) {
                  var entry = _step.value;
                  if (entry[1] === probe) {
                    this._updatePlanarMapOfModel(entry[0], null, null);
                  }
                }
              };
              _proto.register = function register(probe) {
                var index = this._probes.indexOf(probe);
                if (index === -1) {
                  this._probes.push(probe);
                  this.updateProbeData();
                }
              };
              _proto.unregister = function unregister(probe) {
                for (var i = 0; i < this._probes.length; i++) {
                  if (this._probes[i] === probe) {
                    var del = this._probes.splice(i, 1);
                    if (del[0]) {
                      this._removeDependentModels(del[0]);
                    }
                    break;
                  }
                }
                this.updateProbeData();
              };
              _proto.exists = function exists(probeId) {
                if (this._probes.length === 0) return false;
                for (var i = 0; i < this._probes.length; i++) {
                  if (this._probes[i].getProbeId() === probeId) {
                    return true;
                  }
                }
                return false;
              };
              _proto.getNewReflectionProbeId = function getNewReflectionProbeId() {
                var probeId = 0;
                while (true) {
                  if (this.exists(probeId)) {
                    probeId++;
                  } else {
                    return probeId;
                  }
                }
              };
              _proto.getProbes = function getProbes() {
                return this._probes;
              };
              _proto.getProbeById = function getProbeById(probeId) {
                for (var i = 0; i < this._probes.length; i++) {
                  if (this._probes[i].getProbeId() === probeId) {
                    return this._probes[i];
                  }
                }
                return null;
              };
              _proto.clearAll = function clearAll() {
                this._probes = [];
              };
              _proto.getProbeByCamera = function getProbeByCamera(camera) {
                for (var i = 0; i < this._probes.length; i++) {
                  if (this._probes[i].camera === camera) {
                    return this._probes[i];
                  }
                }
                return null;
              };
              _proto.updateBakedCubemap = function updateBakedCubemap(probe) {
                var models = this._getModelsByProbe(probe);
                if (!probe.cubemap) return;
                for (var i = 0; i < models.length; i++) {
                  var model = models[i];
                  this._updateCubemapOfModel(model, probe);
                }
                probe.needRefresh = false;
                if (models.length === 0) {
                  for (var _iterator2 = _createForOfIteratorHelperLoose(this._useCubeModels.entries()), _step2; !(_step2 = _iterator2()).done;) {
                    var entry = _step2.value;
                    if (entry[0].reflectionProbeBlendId === probe.getProbeId()) {
                      this._updateBlendCubemap(entry[0], probe);
                    }
                  }
                }
              };
              _proto.updatePlanarMap = function updatePlanarMap(probe, texture) {
                if (!probe.node || !probe.node.scene) return;
                var models = this._getModelsByProbe(probe);
                for (var i = 0; i < models.length; i++) {
                  this._updatePlanarMapOfModel(models[i], texture, probe);
                }
                if (probe.previewPlane) {
                  var meshRender = probe.previewPlane.getComponent(MeshRenderer);
                  if (meshRender) {
                    meshRender.updateProbePlanarMap(texture);
                  }
                }
              };
              _proto.selectPlanarReflectionProbe = function selectPlanarReflectionProbe(model) {
                if (!model.node || !model.worldBounds || model.reflectionProbeType !== 2) return;
                for (var i = 0; i < this._probes.length; i++) {
                  var probe = this._probes[i];
                  if (probe.probeType !== 1) continue;
                  if (model.node.layer & REFLECTION_PROBE_DEFAULT_MASK$1) {
                    model.updateWorldBound();
                    if (intersect.aabbWithAABB(model.worldBounds, probe.boundingBox)) {
                      this._usePlanarModels.set(model, probe);
                    } else if (this._usePlanarModels.has(model)) {
                      var old = this._usePlanarModels.get(model);
                      if (old === probe) {
                        this._usePlanarModels["delete"](model);
                        this._updatePlanarMapOfModel(model, null, null);
                      }
                    }
                  }
                }
                for (var _i = 0; _i < this._probes.length; _i++) {
                  if (this._probes[_i].probeType === 1) {
                    if (!this._probes[_i].realtimePlanarTexture) {
                      this.updatePlanarMap(this._probes[_i], null);
                    } else {
                      this.updatePlanarMap(this._probes[_i], this._probes[_i].realtimePlanarTexture.getGFXTexture());
                    }
                  }
                }
              };
              _proto.selectReflectionProbe = function selectReflectionProbe(model) {
                if (model.node && model.worldBounds && model.node.layer & REFLECTION_PROBE_DEFAULT_MASK$1) {
                  model.updateWorldBound();
                  var nearest = this._getNearestProbe(model);
                  if (!nearest) {
                    this._updateCubemapOfModel(model, null);
                    this._useCubeModels["delete"](model);
                  } else if (this._useCubeModels.has(model)) {
                    var old = this._useCubeModels.get(model);
                    if (old !== nearest) {
                      this._useCubeModels.set(model, nearest);
                    }
                    nearest.needRefresh = true;
                  } else {
                    this._useCubeModels.set(model, nearest);
                    nearest.needRefresh = true;
                  }
                }
                for (var i = 0; i < this._probes.length; i++) {
                  if (this._probes[i].needRefresh && this._probes[i].probeType === 0 || this._isUsedBlending(model)) {
                    this.updateBakedCubemap(this._probes[i]);
                  }
                }
              };
              _proto.updatePreviewSphere = function updatePreviewSphere(probe) {
                if (!probe || !probe.previewSphere) return;
                var meshRender = probe.previewSphere.getComponent(MeshRenderer);
                if (meshRender) {
                  meshRender.updateProbeCubemap(probe.cubemap);
                  meshRender.updateReflectionProbeId(probe.getProbeId());
                }
              };
              _proto.updatePreviewPlane = function updatePreviewPlane(probe) {
                if (!probe || !probe.previewPlane) return;
                var meshRender = probe.previewPlane.getComponent(MeshRenderer);
                if (meshRender) {
                  if (probe.realtimePlanarTexture) {
                    this.updatePlanarMap(probe, probe.realtimePlanarTexture.getGFXTexture());
                  }
                }
              };
              _proto.updateProbeData = function updateProbeData() {
                if (this._probes.length === 0) return;
                var maxId = this.getMaxProbeId();
                var height = maxId + 1;
                var dataWidth = 3;
                if (this._dataTexture) {
                  this._dataTexture.destroy();
                }
                var buffer = new Float32Array(4 * dataWidth * height);
                var bufferOffset = 0;
                for (var i = 0; i <= maxId; i++) {
                  var probe = this.getProbeById(i);
                  if (!probe) {
                    bufferOffset += 4 * dataWidth;
                    continue;
                  }
                  if (probe.probeType === 0) {
                    buffer[bufferOffset] = probe.node.worldPosition.x;
                    buffer[bufferOffset + 1] = probe.node.worldPosition.y;
                    buffer[bufferOffset + 2] = probe.node.worldPosition.z;
                    buffer[bufferOffset + 3] = 0.0;
                    buffer[bufferOffset + 4] = probe.size.x;
                    buffer[bufferOffset + 5] = probe.size.y;
                    buffer[bufferOffset + 6] = probe.size.z;
                    buffer[bufferOffset + 7] = 0.0;
                    var mipAndUseRGBE = probe.isRGBE() ? 1000 : 0;
                    buffer[bufferOffset + 8] = probe.cubemap ? probe.cubemap.mipmapLevel + mipAndUseRGBE : 1.0 + mipAndUseRGBE;
                  } else {
                    buffer[bufferOffset] = probe.node.up.x;
                    buffer[bufferOffset + 1] = probe.node.up.y;
                    buffer[bufferOffset + 2] = probe.node.up.z;
                    buffer[bufferOffset + 3] = 1.0;
                    buffer[bufferOffset + 4] = 1.0;
                    buffer[bufferOffset + 5] = 1.0;
                    buffer[bufferOffset + 6] = 0.0;
                    buffer[bufferOffset + 7] = 0.0;
                    buffer[bufferOffset + 8] = 1.0;
                  }
                  bufferOffset += 4 * dataWidth;
                }
                var updateView = new Uint8Array(buffer.buffer);
                var image = new ImageAsset({
                  _data: updateView,
                  _compressed: false,
                  width: dataWidth * 4,
                  height: height,
                  format: 35
                });
                this._dataTexture = new Texture2D();
                this._dataTexture.setFilters(0, 0);
                this._dataTexture.setMipFilter(0);
                this._dataTexture.setWrapMode(2, 2, 2);
                this._dataTexture.image = image;
                this._dataTexture.uploadData(updateView);
                for (var _i2 = 0; _i2 < this._probes.length; _i2++) {
                  var _probe = this._probes[_i2];
                  var models = this._getModelsByProbe(_probe);
                  for (var j = 0; j < models.length; j++) {
                    var meshRender = models[j].node.getComponent(MeshRenderer);
                    if (meshRender) {
                      meshRender.updateReflectionProbeDataMap(this._dataTexture);
                    }
                  }
                }
              };
              _proto.getMaxProbeId = function getMaxProbeId() {
                if (this._probes.length === 0) {
                  return -1;
                }
                if (this._probes.length === 1) {
                  return this._probes[0].getProbeId();
                }
                this._probes.sort(function (a, b) {
                  return a.getProbeId() - b.getProbeId();
                });
                return this._probes[this._probes.length - 1].getProbeId();
              };
              _proto.getUsedReflectionProbe = function getUsedReflectionProbe(model, planarReflection) {
                if (planarReflection) {
                  if (this._usePlanarModels.has(model)) {
                    return this._usePlanarModels.get(model);
                  }
                } else if (this._useCubeModels.has(model)) {
                  return this._useCubeModels.get(model);
                }
                return null;
              };
              _proto.setReflectionProbe = function setReflectionProbe(model, probe, blendProbe) {
                if (blendProbe === undefined) {
                  blendProbe = null;
                }
                if (!probe) return;
                this._useCubeModels.set(model, probe);
                this._updateCubemapOfModel(model, probe);
                if (blendProbe) {
                  this._updateBlendProbeInfo(model, probe, blendProbe);
                }
              };
              _proto.updateProbeOfModels = function updateProbeOfModels() {
                if (this._probes.length === 0) return;
                var scene = cclegacy.director.getScene();
                if (!scene || !scene.renderScene) {
                  return;
                }
                var models = scene.renderScene.models;
                for (var i = 0; i < models.length; i++) {
                  var model = models[i];
                  if (!model.node) continue;
                  if (model.node.layer & REFLECTION_PROBE_DEFAULT_MASK$1) {
                    if (model.reflectionProbeType === 1 || model.reflectionProbeType === 2 || this._isUsedBlending(model)) {
                      model.updateReflectionProbeId();
                    }
                  }
                }
              };
              _proto._getNearestProbe = function _getNearestProbe(model) {
                if (!model.node || !model.worldBounds || this._probes.length === 0) return null;
                var nearestProbe = null;
                var minDistance = Infinity;
                for (var _iterator3 = _createForOfIteratorHelperLoose(this._probes), _step3; !(_step3 = _iterator3()).done;) {
                  var probe = _step3.value;
                  if (probe.probeType !== 0 || !probe.validate() || !intersect.aabbWithAABB(model.worldBounds, probe.boundingBox)) {
                    continue;
                  }
                  var distance = Vec3.distance(model.node.worldPosition, probe.node.worldPosition);
                  if (distance < minDistance) {
                    minDistance = distance;
                    nearestProbe = probe;
                  }
                }
                return nearestProbe;
              };
              _proto._getBlendProbe = function _getBlendProbe(model) {
                if (!model || !model.node || !model.worldBounds || this._probes.length < 2) {
                  return null;
                }
                var temp = [];
                for (var i = 0; i < this._probes.length; i++) {
                  if (this._probes[i].probeType !== 0 || !this._probes[i].validate() || !intersect.aabbWithAABB(model.worldBounds, this._probes[i].boundingBox)) {
                    continue;
                  }
                  temp.push(this._probes[i]);
                }
                temp.sort(function (a, b) {
                  var aDistance = Vec3.distance(model.node.worldPosition, a.node.worldPosition);
                  var bDistance = Vec3.distance(model.node.worldPosition, b.node.worldPosition);
                  return aDistance - bDistance;
                });
                return temp.length > 1 ? temp[1] : null;
              };
              _proto._getModelsByProbe = function _getModelsByProbe(probe) {
                var models = [];
                var useModels = this._useCubeModels;
                if (probe.probeType === 1) {
                  useModels = this._usePlanarModels;
                }
                for (var _iterator4 = _createForOfIteratorHelperLoose(useModels.entries()), _step4; !(_step4 = _iterator4()).done;) {
                  var entry = _step4.value;
                  if (entry[1] === probe) {
                    models.push(entry[0]);
                  }
                }
                return models;
              };
              _proto._removeDependentModels = function _removeDependentModels(probe) {
                for (var _iterator5 = _createForOfIteratorHelperLoose(this._useCubeModels.keys()), _step5; !(_step5 = _iterator5()).done;) {
                  var key = _step5.value;
                  var p = this._useCubeModels.get(key);
                  if (p !== undefined && p === probe) {
                    this._useCubeModels["delete"](key);
                    this.selectReflectionProbe(key);
                  }
                }
                for (var _iterator6 = _createForOfIteratorHelperLoose(this._usePlanarModels.keys()), _step6; !(_step6 = _iterator6()).done;) {
                  var _key = _step6.value;
                  var _p = this._usePlanarModels.get(_key);
                  if (_p !== undefined && _p === probe) {
                    this._usePlanarModels["delete"](_key);
                    this.selectPlanarReflectionProbe(_key);
                  }
                }
              };
              _proto._updateCubemapOfModel = function _updateCubemapOfModel(model, probe) {
                var node = model.node;
                if (!node) {
                  return;
                }
                var meshRender = node.getComponent(MeshRenderer);
                if (!meshRender) {
                  return;
                }
                meshRender.updateProbeCubemap(probe ? probe.cubemap : null);
                meshRender.updateReflectionProbeId(probe && probe.cubemap ? probe.getProbeId() : -1);
                if (probe) {
                  meshRender.updateReflectionProbeDataMap(this._dataTexture);
                  if (this._isUsedBlending(model)) {
                    var blendProbe = this._getBlendProbe(model);
                    this._updateBlendProbeInfo(model, probe, blendProbe);
                  }
                }
              };
              _proto._updatePlanarMapOfModel = function _updatePlanarMapOfModel(model, texture, probe) {
                var meshRender = model.node.getComponent(MeshRenderer);
                if (meshRender) {
                  meshRender.updateProbePlanarMap(texture);
                  if (probe) {
                    meshRender.updateReflectionProbeId(probe.getProbeId());
                    meshRender.updateReflectionProbeDataMap(this._dataTexture);
                  } else {
                    meshRender.updateReflectionProbeId(-1);
                  }
                }
              };
              _proto._isUsedBlending = function _isUsedBlending(model) {
                if (model.reflectionProbeType === 3 || model.reflectionProbeType === 4) {
                  return true;
                }
                return false;
              };
              _proto._updateBlendProbeInfo = function _updateBlendProbeInfo(model, probe, blendProbe) {
                var node = model.node;
                if (!node) {
                  return;
                }
                var meshRender = node.getComponent(MeshRenderer);
                if (!meshRender) {
                  return;
                }
                {
                  meshRender.updateReflectionProbeBlendId(-1);
                  if (model.reflectionProbeType === 4) {
                    meshRender.updateReflectionProbeBlendWeight(this._calculateBlendWeight(model, probe, blendProbe));
                  }
                }
              };
              _proto._updateBlendCubemap = function _updateBlendCubemap(model, probe) {
                var node = model.node;
                if (!node) {
                  return;
                }
                if (!this._isUsedBlending(model)) {
                  return;
                }
                var meshRender = node.getComponent(MeshRenderer);
                if (meshRender) {
                  meshRender.updateProbeBlendCubemap(probe.cubemap);
                }
              };
              _proto._calculateBlendWeight = function _calculateBlendWeight(model, probe, blendProbe) {
                if (blendProbe) {
                  var d1 = Vec3.distance(model.node.worldPosition, probe.node.worldPosition);
                  var d2 = Vec3.distance(model.node.worldPosition, blendProbe.node.worldPosition);
                  return 1.0 - d2 / (d1 + d2);
                }
                if (model.reflectionProbeType === 3) {
                  return 0.0;
                } else if (model.reflectionProbeType === 4) {
                  return this._calculateBlendOfSkybox(model.worldBounds, probe.boundingBox);
                }
                return 0.0;
              };
              _proto._calculateBlendOfSkybox = function _calculateBlendOfSkybox(aabb1, aabb2) {
                if (!aabb1) return 1.0;
                var aMin = new Vec3();
                var aMax = new Vec3();
                var bMin = new Vec3();
                var bMax = new Vec3();
                Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
                Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
                Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
                Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
                var inside = aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
                if (inside) {
                  var fullSize = new Vec3();
                  Vec3.multiplyScalar(fullSize, aabb1.halfExtents, 2.0);
                  var boundaryXAdd = aMin.x + fullSize.x <= bMax.x && aMax.x + fullSize.x >= bMin.x;
                  var boundaryXSub = aMin.x - fullSize.x <= bMax.x && aMax.x - fullSize.x >= bMin.x;
                  var boundaryYAdd = aMin.y + fullSize.y <= bMax.y && aMax.y + fullSize.y >= bMin.y;
                  var boundaryYSub = aMin.y - fullSize.y <= bMax.y && aMax.y - fullSize.y >= bMin.y;
                  var boundaryZAdd = aMin.z + fullSize.z <= bMax.z && aMax.z + fullSize.z >= bMin.z;
                  var boundaryZSub = aMin.z - fullSize.z <= bMax.z && aMax.z - fullSize.z >= bMin.z;
                  var weights = [];
                  if (!boundaryXAdd) {
                    var offset = aMax.x - bMax.x;
                    weights.push(offset / fullSize.x);
                  }
                  if (!boundaryXSub) {
                    var _offset = Math.abs(aMin.x - bMin.x);
                    weights.push(_offset / fullSize.x);
                  }
                  if (!boundaryYAdd) {
                    var _offset2 = aMax.y - bMax.y;
                    weights.push(_offset2 / fullSize.y);
                  }
                  if (!boundaryYSub) {
                    var _offset3 = Math.abs(aMin.y - bMin.y);
                    weights.push(_offset3 / fullSize.y);
                  }
                  if (!boundaryZAdd) {
                    var _offset4 = aMax.z - bMax.z;
                    weights.push(_offset4 / fullSize.z);
                  }
                  if (!boundaryZSub) {
                    var _offset5 = Math.abs(aMin.z - bMin.z);
                    weights.push(_offset5 / fullSize.z);
                  }
                  if (weights.length > 0) {
                    weights.sort(function (a, b) {
                      return b - a;
                    });
                    return weights[0];
                  } else {
                    return 0.0;
                  }
                }
                return 1.0;
              };
              _createClass(ReflectionProbeManager, [{
                key: "updateForRuntime",
                get: function get() {
                  return this._updateForRuntime;
                },
                set: function set(val) {
                  this._updateForRuntime = val;
                }
              }]);
              return ReflectionProbeManager;
            }());
            ReflectionProbeManager.probeManager = undefined;
            ReflectionProbeManager.probeManager = new ReflectionProbeManager();
            cclegacy.internal.reflectionProbeManager = ReflectionProbeManager.probeManager;

            var _dec$c, _class$c, _class2$9, _initializer$8, _initializer2$7, _initializer3$4, _class3$5;
            var PostProcess = (_dec$c = ccclass$6('cc.PostProcess'), _dec$c(_class$c = disallowMultiple$1(_class$c = (_class2$9 = (_class3$5 = function (_Component) {
              _inheritsLoose(PostProcess, _Component);
              function PostProcess() {
                var _this;
                _this = _Component.call(this) || this;
                _this.global = _initializer$8 && _initializer$8();
                _this._shadingScale = _initializer2$7 && _initializer2$7();
                _this.enableShadingScaleInEditor = _initializer3$4 && _initializer3$4();
                _this.settings = new Map();
                return _this;
              }
              var _proto = PostProcess.prototype;
              _proto.addSetting = function addSetting(setting) {
                this.settings.set(setting.constructor, setting);
              };
              _proto.removeSetting = function removeSetting(setting) {
                this.settings["delete"](setting.constructor);
              };
              _proto.getSetting = function getSetting(ctor) {
                return this.settings.get(ctor);
              };
              _proto.onEnable = function onEnable() {
                PostProcess.all.push(this);
              };
              _proto.onDisable = function onDisable() {
                var idx = PostProcess.all.indexOf(this);
                if (idx !== -1) {
                  PostProcess.all.splice(idx, 1);
                }
              };
              _createClass(PostProcess, [{
                key: "shadingScale",
                get: function get() {
                  return this._shadingScale;
                },
                set: function set(v) {
                  this._shadingScale = v;
                }
              }]);
              return PostProcess;
            }(Component), _class3$5.all = [], _class3$5), (_initializer$8 = applyDecoratedInitializer(_class2$9.prototype, "global", [property$3, serializable$5], function () {
              return true;
            }), _initializer2$7 = applyDecoratedInitializer(_class2$9.prototype, "_shadingScale", [serializable$5], function () {
              return 1;
            }), _applyDecoratedDescriptor(_class2$9.prototype, "shadingScale", [property$3], Object.getOwnPropertyDescriptor(_class2$9.prototype, "shadingScale"), _class2$9.prototype), _initializer3$4 = applyDecoratedInitializer(_class2$9.prototype, "enableShadingScaleInEditor", [property$3, serializable$5], function () {
              return false;
            })), _class2$9)) || _class$c) || _class$c);

            var _dec$b, _dec2$9, _dec3$7, _dec4$3, _dec5$1, _dec6$1, _dec7$1, _dec8$1, _dec9$1, _dec10$1, _class$b, _class2$8, _initializer$7, _initializer2$6, _initializer3$3, _initializer4$3, _initializer5$3, _initializer6$2, _initializer7$1, _initializer8$1, _initializer9$1, _initializer10$1, _initializer11, _initializer12, _initializer13, _initializer14, _initializer15, _initializer16, _initializer17, _initializer18, _initializer19, _initializer20, _initializer21, _initializer22, _class3$4;
            var _temp_vec3_1 = new Vec3();
            var ProjectionType = Enum(CameraProjection);
            var FOVAxis = Enum(CameraFOVAxis);
            var Aperture = Enum(CameraAperture);
            var Shutter = Enum(CameraShutter);
            var ISO = Enum(CameraISO);
            var ClearFlag = Enum({
              SKYBOX: 8 | 6,
              SOLID_COLOR: 7,
              DEPTH_ONLY: 6,
              DONT_CLEAR: 0
            });
            var Camera = (_dec$b = ccclass$6('cc.Camera'), _dec2$9 = type$5(Layers.BitMask), _dec3$7 = type$5(ClearFlag), _dec4$3 = type$5(ProjectionType), _dec5$1 = type$5(FOVAxis), _dec6$1 = type$5(Aperture), _dec7$1 = type$5(Shutter), _dec8$1 = type$5(ISO), _dec9$1 = type$5(RenderTexture), _dec10$1 = type$5(PostProcess), _dec$b(_class$b = (_class2$8 = (_class3$4 = function (_Component) {
              _inheritsLoose(Camera, _Component);
              function Camera() {
                var _this;
                _this = _Component.call(this) || this;
                _this._projection = _initializer$7 && _initializer$7();
                _this._priority = _initializer2$6 && _initializer2$6();
                _this._fov = _initializer3$3 && _initializer3$3();
                _this._fovAxis = _initializer4$3 && _initializer4$3();
                _this._orthoHeight = _initializer5$3 && _initializer5$3();
                _this._near = _initializer6$2 && _initializer6$2();
                _this._far = _initializer7$1 && _initializer7$1();
                _this._color = _initializer8$1 && _initializer8$1();
                _this._depth = _initializer9$1 && _initializer9$1();
                _this._stencil = _initializer10$1 && _initializer10$1();
                _this._clearFlags = _initializer11 && _initializer11();
                _this._rect = _initializer12 && _initializer12();
                _this._aperture = _initializer13 && _initializer13();
                _this._shutter = _initializer14 && _initializer14();
                _this._iso = _initializer15 && _initializer15();
                _this._screenScale = _initializer16 && _initializer16();
                _this._visibility = _initializer17 && _initializer17();
                _this._targetTexture = _initializer18 && _initializer18();
                _this._postProcess = _initializer19 && _initializer19();
                _this._usePostProcess = _initializer20 && _initializer20();
                _this._camera = null;
                _this._inEditorMode = false;
                _this._flows = undefined;
                _this._cameraType = _initializer21 && _initializer21();
                _this._trackingType = _initializer22 && _initializer22();
                return _this;
              }
              var _proto = Camera.prototype;
              _proto.onLoad = function onLoad() {
                this._createCamera();
              };
              _proto.onEnable = function onEnable() {
                this.node.hasChangedFlags |= 1;
                if (this._camera) {
                  this._attachToScene();
                }
              };
              _proto.onDisable = function onDisable() {
                if (this._camera) {
                  this._detachFromScene();
                }
              };
              _proto.onDestroy = function onDestroy() {
                if (this._camera) {
                  this._camera.destroy();
                  this._camera = null;
                }
                if (this._targetTexture) {
                  this._targetTexture.off('resize');
                }
              };
              _proto.screenPointToRay = function screenPointToRay(x, y, out) {
                if (!out) {
                  out = Ray.create();
                }
                if (this._camera) {
                  this._camera.screenPointToRay(out, x, y);
                }
                return out;
              };
              _proto.worldToScreen = function worldToScreen(worldPos, out) {
                if (!out) {
                  out = new Vec3();
                }
                if (this._camera) {
                  this._camera.worldToScreen(out, worldPos);
                }
                return out;
              };
              _proto.screenToWorld = function screenToWorld(screenPos, out) {
                if (!out) {
                  out = this.node.getWorldPosition();
                }
                if (this._camera) {
                  this._camera.screenToWorld(out, screenPos);
                }
                return out;
              };
              _proto.convertToUINode = function convertToUINode(wpos, uiNode, out) {
                if (!out) {
                  out = new Vec3();
                }
                if (!this._camera) {
                  return out;
                }
                this.worldToScreen(wpos, _temp_vec3_1);
                var cmp = uiNode.getComponent('cc.UITransform');
                var view = cclegacy.view;
                var designSize = view.getVisibleSize();
                var xoffset = _temp_vec3_1.x - this._camera.width * 0.5;
                var yoffset = _temp_vec3_1.y - this._camera.height * 0.5;
                _temp_vec3_1.x = xoffset / view.getScaleX() + designSize.width * 0.5;
                _temp_vec3_1.y = yoffset / view.getScaleY() + designSize.height * 0.5;
                if (cmp) {
                  cmp.convertToNodeSpaceAR(_temp_vec3_1, out);
                }
                return out;
              };
              _proto._createCamera = function _createCamera() {
                if (!this._camera) {
                  this._camera = cclegacy.director.root.createCamera();
                  this._camera.initialize({
                    name: this.node.name,
                    node: this.node,
                    projection: this._projection,
                    window: this._inEditorMode ? cclegacy.director.root && cclegacy.director.root.mainWindow : cclegacy.director.root && cclegacy.director.root.tempWindow,
                    priority: this._priority,
                    cameraType: this.cameraType,
                    trackingType: this.trackingType
                  });
                  this._camera.setViewportInOrientedSpace(this._rect);
                  this._camera.fovAxis = this._fovAxis;
                  this._camera.fov = toRadian(this._fov);
                  this._camera.orthoHeight = this._orthoHeight;
                  this._camera.nearClip = this._near;
                  this._camera.farClip = this._far;
                  this._camera.clearColor = this._color;
                  this._camera.clearDepth = this._depth;
                  this._camera.clearStencil = this._stencil;
                  this._camera.clearFlag = this._clearFlags;
                  this._camera.visibility = this._visibility;
                  this._camera.aperture = this._aperture;
                  this._camera.shutter = this._shutter;
                  this._camera.iso = this._iso;
                  this._camera.postProcess = this._postProcess;
                  this._camera.usePostProcess = this._usePostProcess;
                  this._camera.update();
                }
                this._updateTargetTexture();
              };
              _proto._attachToScene = function _attachToScene() {
                if (!this.node.scene || !this._camera) {
                  return;
                }
                if (this._camera && this._camera.scene) {
                  this._camera.scene.removeCamera(this._camera);
                }
                var rs = this._getRenderScene();
                rs.addCamera(this._camera);
              };
              _proto._detachFromScene = function _detachFromScene() {
                if (this._camera && this._camera.scene) {
                  this._camera.scene.removeCamera(this._camera);
                }
              };
              _proto._checkTargetTextureEvent = function _checkTargetTextureEvent(old) {
                var _this2 = this;
                if (old) {
                  old.off('resize');
                }
                if (this._targetTexture) {
                  this._targetTexture.on('resize', function (window) {
                    if (_this2._camera) {
                      _this2._camera.setFixedSize(window.width, window.height);
                    }
                  }, this);
                }
              };
              _proto._updateTargetTexture = function _updateTargetTexture() {
                if (!this._camera) {
                  return;
                }
                if (this._targetTexture) {
                  var window = this._targetTexture.window;
                  this._camera.changeTargetWindow(window);
                  this._camera.setFixedSize(window.width, window.height);
                }
              };
              _createClass(Camera, [{
                key: "camera",
                get: function get() {
                  return this._camera;
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(val) {
                  this._priority = val;
                  if (this._camera) {
                    this._camera.priority = val;
                  }
                }
              }, {
                key: "visibility",
                get: function get() {
                  return this._visibility;
                },
                set: function set(val) {
                  this._visibility = val;
                  if (this._camera) {
                    this._camera.visibility = val;
                  }
                }
              }, {
                key: "clearFlags",
                get: function get() {
                  return this._clearFlags;
                },
                set: function set(val) {
                  this._clearFlags = val;
                  if (this._camera) {
                    this._camera.clearFlag = val;
                  }
                }
              }, {
                key: "clearColor",
                get: function get() {
                  return this._color;
                },
                set: function set(val) {
                  this._color.set(val);
                  if (this._camera) {
                    this._camera.clearColor = this._color;
                  }
                }
              }, {
                key: "clearDepth",
                get: function get() {
                  return this._depth;
                },
                set: function set(val) {
                  this._depth = val;
                  if (this._camera) {
                    this._camera.clearDepth = val;
                  }
                }
              }, {
                key: "clearStencil",
                get: function get() {
                  return this._stencil;
                },
                set: function set(val) {
                  this._stencil = val;
                  if (this._camera) {
                    this._camera.clearStencil = val;
                  }
                }
              }, {
                key: "projection",
                get: function get() {
                  return this._projection;
                },
                set: function set(val) {
                  this._projection = val;
                  if (this._camera) {
                    this._camera.projectionType = val;
                  }
                }
              }, {
                key: "fovAxis",
                get: function get() {
                  return this._fovAxis;
                },
                set: function set(val) {
                  if (val === this._fovAxis) {
                    return;
                  }
                  this._fovAxis = val;
                  if (this._camera) {
                    this._camera.fovAxis = val;
                    if (val === 0) {
                      this.fov = this._fov * this._camera.aspect;
                    } else {
                      this.fov = this._fov / this._camera.aspect;
                    }
                  }
                }
              }, {
                key: "fov",
                get: function get() {
                  return this._fov;
                },
                set: function set(val) {
                  this._fov = val;
                  if (this._camera) {
                    this._camera.fov = toRadian(val);
                  }
                }
              }, {
                key: "orthoHeight",
                get: function get() {
                  return this._orthoHeight;
                },
                set: function set(val) {
                  this._orthoHeight = val;
                  if (this._camera) {
                    this._camera.orthoHeight = val;
                  }
                }
              }, {
                key: "near",
                get: function get() {
                  return this._near;
                },
                set: function set(val) {
                  this._near = val;
                  if (this._camera) {
                    this._camera.nearClip = val;
                  }
                }
              }, {
                key: "far",
                get: function get() {
                  return this._far;
                },
                set: function set(val) {
                  this._far = val;
                  if (this._camera) {
                    this._camera.farClip = val;
                  }
                }
              }, {
                key: "aperture",
                get: function get() {
                  return this._aperture;
                },
                set: function set(val) {
                  this._aperture = val;
                  if (this._camera) {
                    this._camera.aperture = val;
                  }
                }
              }, {
                key: "shutter",
                get: function get() {
                  return this._shutter;
                },
                set: function set(val) {
                  this._shutter = val;
                  if (this._camera) {
                    this._camera.shutter = val;
                  }
                }
              }, {
                key: "iso",
                get: function get() {
                  return this._iso;
                },
                set: function set(val) {
                  this._iso = val;
                  if (this._camera) {
                    this._camera.iso = val;
                  }
                }
              }, {
                key: "rect",
                get: function get() {
                  return this._rect;
                },
                set: function set(val) {
                  this._rect = val;
                  if (this._camera) {
                    this._camera.setViewportInOrientedSpace(val);
                  }
                }
              }, {
                key: "targetTexture",
                get: function get() {
                  return this._targetTexture;
                },
                set: function set(value) {
                  if (this._targetTexture === value) {
                    return;
                  }
                  var old = this._targetTexture;
                  this._targetTexture = value;
                  this._checkTargetTextureEvent(old);
                  this._updateTargetTexture();
                  if (!value && this._camera) {
                    this._camera.changeTargetWindow(null);
                    this._camera.isWindowSize = true;
                  }
                  this.node.emit("tex-change", this);
                }
              }, {
                key: "usePostProcess",
                get: function get() {
                  return this._usePostProcess;
                },
                set: function set(v) {
                  this._usePostProcess = v;
                  if (this._camera) {
                    this._camera.usePostProcess = v;
                  }
                }
              }, {
                key: "postProcess",
                get: function get() {
                  return this._postProcess;
                },
                set: function set(v) {
                  this._postProcess = v;
                  if (this._camera) {
                    this._camera.postProcess = v;
                  }
                }
              }, {
                key: "screenScale",
                get: function get() {
                  return this._screenScale;
                },
                set: function set(val) {
                  this._screenScale = val;
                  if (this._camera) {
                    this._camera.screenScale = val;
                  }
                }
              }, {
                key: "inEditorMode",
                get: function get() {
                  return this._inEditorMode;
                },
                set: function set(value) {
                  this._inEditorMode = value;
                  if (this._camera) {
                    var root = cclegacy.director.root;
                    this._camera.changeTargetWindow(value ? root && root.mainWindow : root && root.tempWindow);
                  }
                }
              }, {
                key: "cameraType",
                get: function get() {
                  return this._cameraType;
                },
                set: function set(val) {
                  if (this._cameraType === val) {
                    return;
                  }
                  this._cameraType = val;
                  if (this.camera) {
                    this.camera.cameraType = val;
                  }
                }
              }, {
                key: "trackingType",
                get: function get() {
                  return this._trackingType;
                },
                set: function set(val) {
                  if (this._trackingType === val) {
                    return;
                  }
                  this._trackingType = val;
                  if (this.camera) {
                    this.camera.trackingType = val;
                  }
                }
              }]);
              return Camera;
            }(Component), _class3$4.ProjectionType = ProjectionType, _class3$4.FOVAxis = FOVAxis, _class3$4.ClearFlag = ClearFlag, _class3$4.Aperture = Aperture, _class3$4.Shutter = Shutter, _class3$4.ISO = ISO, _class3$4.TARGET_TEXTURE_CHANGE = "tex-change", _class3$4), (_initializer$7 = applyDecoratedInitializer(_class2$8.prototype, "_projection", [serializable$5], function () {
              return ProjectionType.PERSPECTIVE;
            }), _initializer2$6 = applyDecoratedInitializer(_class2$8.prototype, "_priority", [serializable$5], function () {
              return 0;
            }), _initializer3$3 = applyDecoratedInitializer(_class2$8.prototype, "_fov", [serializable$5], function () {
              return 45;
            }), _initializer4$3 = applyDecoratedInitializer(_class2$8.prototype, "_fovAxis", [serializable$5], function () {
              return FOVAxis.VERTICAL;
            }), _initializer5$3 = applyDecoratedInitializer(_class2$8.prototype, "_orthoHeight", [serializable$5], function () {
              return 10;
            }), _initializer6$2 = applyDecoratedInitializer(_class2$8.prototype, "_near", [serializable$5], function () {
              return 1;
            }), _initializer7$1 = applyDecoratedInitializer(_class2$8.prototype, "_far", [serializable$5], function () {
              return 1000;
            }), _initializer8$1 = applyDecoratedInitializer(_class2$8.prototype, "_color", [serializable$5], function () {
              return new Color('#333333');
            }), _initializer9$1 = applyDecoratedInitializer(_class2$8.prototype, "_depth", [serializable$5], function () {
              return 1;
            }), _initializer10$1 = applyDecoratedInitializer(_class2$8.prototype, "_stencil", [serializable$5], function () {
              return 0;
            }), _initializer11 = applyDecoratedInitializer(_class2$8.prototype, "_clearFlags", [serializable$5], function () {
              return ClearFlag.SOLID_COLOR;
            }), _initializer12 = applyDecoratedInitializer(_class2$8.prototype, "_rect", [serializable$5], function () {
              return new Rect(0, 0, 1, 1);
            }), _initializer13 = applyDecoratedInitializer(_class2$8.prototype, "_aperture", [serializable$5], function () {
              return Aperture.F16_0;
            }), _initializer14 = applyDecoratedInitializer(_class2$8.prototype, "_shutter", [serializable$5], function () {
              return Shutter.D125;
            }), _initializer15 = applyDecoratedInitializer(_class2$8.prototype, "_iso", [serializable$5], function () {
              return ISO.ISO100;
            }), _initializer16 = applyDecoratedInitializer(_class2$8.prototype, "_screenScale", [serializable$5], function () {
              return 1;
            }), _initializer17 = applyDecoratedInitializer(_class2$8.prototype, "_visibility", [serializable$5], function () {
              return CAMERA_DEFAULT_MASK;
            }), _initializer18 = applyDecoratedInitializer(_class2$8.prototype, "_targetTexture", [serializable$5], function () {
              return null;
            }), _initializer19 = applyDecoratedInitializer(_class2$8.prototype, "_postProcess", [serializable$5], function () {
              return null;
            }), _initializer20 = applyDecoratedInitializer(_class2$8.prototype, "_usePostProcess", [serializable$5], function () {
              return false;
            }), _initializer21 = applyDecoratedInitializer(_class2$8.prototype, "_cameraType", [serializable$5], function () {
              return -1;
            }), _initializer22 = applyDecoratedInitializer(_class2$8.prototype, "_trackingType", [serializable$5], function () {
              return 0;
            }), _applyDecoratedDescriptor(_class2$8.prototype, "visibility", [_dec2$9], Object.getOwnPropertyDescriptor(_class2$8.prototype, "visibility"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "clearFlags", [_dec3$7], Object.getOwnPropertyDescriptor(_class2$8.prototype, "clearFlags"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "projection", [_dec4$3], Object.getOwnPropertyDescriptor(_class2$8.prototype, "projection"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "fovAxis", [_dec5$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "fovAxis"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "aperture", [_dec6$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "aperture"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "shutter", [_dec7$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "shutter"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "iso", [_dec8$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "iso"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "targetTexture", [_dec9$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "targetTexture"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "usePostProcess", [property$3], Object.getOwnPropertyDescriptor(_class2$8.prototype, "usePostProcess"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "postProcess", [_dec10$1], Object.getOwnPropertyDescriptor(_class2$8.prototype, "postProcess"), _class2$8.prototype)), _class2$8)) || _class$b); exports({ Camera: Camera, CameraComponent: Camera });
            cclegacy.Camera = Camera;

            new Vec3();
            new Vec3();
            new Vec3();
            new Vec3();
            new Vec3();
            new Vec3();
            new Vec3();
            new Vec3();
            new Vec3();
            new Vec3();
            new Vec3();
            new Vec3();

            new Vec3(0, 0, 0);
            new Vec3(0, 0, 0);

            new Vec3(0, 0, 0);
            new Vec3(0, 0, 0);
            new Vec3(0, 0, 0);
            new Vec3(0, 0, 0);
            new Vec3(0, 0, 0);
            new Vec3(0, 0, 0);
            new Vec3(0, 0, 0);

            new Vec3(0, 0, 0);
            new Vec3(0, 0, 0);

            new Vec3();
            function absolute(v) {
              v.x = Math.abs(v.x);
              v.y = Math.abs(v.y);
              v.z = Math.abs(v.z);
              return v;
            }

            var _dec$a, _dec2$8, _dec3$6, _dec4$2, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _class$a, _class2$7, _initializer$6, _initializer2$5, _initializer3$2, _initializer4$2, _initializer5$2, _initializer6$1, _initializer7, _initializer8, _initializer9, _initializer10, _class3$3;
            var tmpVec3 = v3();
            var ProbeResolution = {
              Low_256x256: 256,
              Medium_512x512: 512,
              High_768x768: 768
            };
            var ReflectionProbe = exports("ReflectionProbe", (_dec$a = ccclass$6('cc.ReflectionProbe'), _dec2$8 = type$5(Vec3), _dec3$6 = type$5(Enum(ProbeType)), _dec4$2 = type$5(Enum(ProbeResolution)), _dec5 = type$5(Enum(ProbeClearFlag)), _dec6 = type$5(Color), _dec7 = type$5(Layers.BitMask), _dec8 = type$5(Camera), _dec9 = type$5(CCBoolean), _dec10 = type$5(TextureCube), _dec$a(_class$a = (_class2$7 = (_class3$3 = function (_Component) {
              _inheritsLoose(ReflectionProbe, _Component);
              function ReflectionProbe() {
                var _this;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._lastSize = v3();
                _this._resolution = _initializer$6 && _initializer$6();
                _this._clearFlag = _initializer2$5 && _initializer2$5();
                _this._backgroundColor = _initializer3$2 && _initializer3$2();
                _this._visibility = _initializer4$2 && _initializer4$2();
                _this._probeType = _initializer5$2 && _initializer5$2();
                _this._cubemap = _initializer6$1 && _initializer6$1();
                _this._size = _initializer7 && _initializer7();
                _this._sourceCamera = _initializer8 && _initializer8();
                _this._probeId = _initializer9 && _initializer9();
                _this._fastBake = _initializer10 && _initializer10();
                _this._probe = null;
                _this._previewSphere = null;
                _this._previewPlane = null;
                _this._sourceCameraPos = v3();
                _this._position = v3();
                return _this;
              }
              var _proto = ReflectionProbe.prototype;
              _proto.onLoad = function onLoad() {
                this._createProbe();
              };
              _proto._handleResize$ = function _handleResize$() {
                if (this.probe && this.sourceCamera && this.probeType === 1) {
                  this.probe.renderPlanarReflection(this.sourceCamera.camera);
                }
              };
              _proto.onEnable = function onEnable() {
                if (this._probe) {
                  var probe = ReflectionProbeManager.probeManager.getProbeById(this._probeId);
                  if (probe !== null && probe !== this._probe) {
                    this._probeId = ReflectionProbeManager.probeManager.getNewReflectionProbeId();
                    this._probe.updateProbeId(this._probeId);
                  }
                  ReflectionProbeManager.probeManager.register(this._probe);
                  ReflectionProbeManager.probeManager.onUpdateProbes();
                  this._probe.enable();
                }
                screen$1.on('window-resize', this._handleResize$, this);
                screen$1.on('fullscreen-change', this._handleResize$, this);
              };
              _proto.onDisable = function onDisable() {
                if (this._probe) {
                  ReflectionProbeManager.probeManager.unregister(this._probe);
                  this._probe.disable();
                }
                screen$1.off('window-resize', this._handleResize$, this);
                screen$1.off('fullscreen-change', this._handleResize$, this);
              };
              _proto.start = function start() {
                if (this._sourceCamera && this.probeType === 1) {
                  this.probe.renderPlanarReflection(this.sourceCamera.camera);
                  ReflectionProbeManager.probeManager.filterModelsForPlanarReflection();
                }
                ReflectionProbeManager.probeManager.updateProbeData();
                this.node.getWorldPosition(this._position);
              };
              _proto.onDestroy = function onDestroy() {
                if (this.probe) {
                  this.probe.destroy();
                }
              };
              _proto.update = function update(dt) {
                if (!this.probe) return;
                if (this.probeType === 1 && this.sourceCamera) {
                  if (this.sourceCamera.node.hasChangedFlags & 7 || !this._sourceCameraPos.equals(this.sourceCamera.node.getWorldPosition())) {
                    this._sourceCameraPos = this.sourceCamera.node.getWorldPosition();
                    this.probe.renderPlanarReflection(this.sourceCamera.camera);
                  }
                }
                if (this.node.hasChangedFlags & 1) {
                  this.probe.updateBoundingBox();
                  ReflectionProbeManager.probeManager.onUpdateProbes();
                  ReflectionProbeManager.probeManager.updateProbeData();
                }
                {
                  this.node.getWorldPosition(tmpVec3);
                  if (!this._position.equals(tmpVec3)) {
                    this._position.set(tmpVec3);
                    this.probe.updateBoundingBox();
                    ReflectionProbeManager.probeManager.updateProbeData();
                    ReflectionProbeManager.probeManager.updateProbeOfModels();
                  }
                }
              };
              _proto.clearBakedCubemap = function clearBakedCubemap() {
                this.cubemap = null;
                ReflectionProbeManager.probeManager.updateBakedCubemap(this.probe);
                ReflectionProbeManager.probeManager.updatePreviewSphere(this.probe);
              };
              _proto._createProbe = function _createProbe() {
                if (this._probeId === -1 || ReflectionProbeManager.probeManager.exists(this._probeId)) {
                  this._probeId = ReflectionProbeManager.probeManager.getNewReflectionProbeId();
                }
                this._probe = new ReflectionProbe$1(this._probeId);
                if (this._probe) {
                  var cameraNode = new Node$1('ReflectionProbeCamera');
                  cameraNode.hideFlags |= 8 | 1024;
                  this.node.scene.addChild(cameraNode);
                  this._probe.initialize(this.node, cameraNode);
                  if (this.enabled) {
                    ReflectionProbeManager.probeManager.register(this._probe);
                  }
                  this._probe.resolution = this._resolution;
                  this._probe.clearFlag = this._clearFlag;
                  this._probe.backgroundColor = this._backgroundColor;
                  this._probe.visibility = this._visibility;
                  this._probe.probeType = this._probeType;
                  this._probe.size = this._size;
                  this._probe.cubemap = this._cubemap;
                }
              };
              _createClass(ReflectionProbe, [{
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(value) {
                  this._size.set(value);
                  absolute(this._size);
                  this.probe.size = this._size;
                  if (this.probe) {
                    this.probe.updateBoundingBox();
                    ReflectionProbeManager.probeManager.onUpdateProbes();
                    ReflectionProbeManager.probeManager.updateProbeData();
                    ReflectionProbeManager.probeManager.updateProbeOfModels();
                  }
                }
              }, {
                key: "probeType",
                get: function get() {
                  return this._probeType;
                },
                set: function set(value) {
                  this.probe.probeType = value;
                  if (value !== this._probeType) {
                    var lastSize = this._size.clone();
                    var lastSizeIsNoExist = Vec3.equals(this._lastSize, Vec3.ZERO);
                    this._probeType = value;
                    if (this._probeType === 0) {
                      if (lastSizeIsNoExist) {
                        this._size.set(ReflectionProbe.DEFAULT_CUBE_SIZE);
                      }
                      this.probe.switchProbeType(value, null);
                      ReflectionProbeManager.probeManager.clearPlanarReflectionMap(this.probe);
                    } else {
                      if (lastSizeIsNoExist) {
                        this._size.set(ReflectionProbe.DEFAULT_PLANER_SIZE);
                      }
                      if (!this._sourceCamera) {
                        warn('the reflection camera is invalid, please set the reflection camera');
                      } else {
                        this.probe.switchProbeType(value, this._sourceCamera.camera);
                      }
                    }
                    if (!lastSizeIsNoExist) {
                      this._size.set(this._lastSize);
                    }
                    this._lastSize.set(lastSize);
                    this.size = this._size;
                  }
                }
              }, {
                key: "resolution",
                get: function get() {
                  return this._resolution;
                },
                set: function set(value) {
                  this._resolution = value;
                  this.probe.resolution = value;
                }
              }, {
                key: "clearFlag",
                get: function get() {
                  return this._clearFlag;
                },
                set: function set(value) {
                  this._clearFlag = value;
                  this.probe.clearFlag = this._clearFlag;
                }
              }, {
                key: "backgroundColor",
                get: function get() {
                  return this._backgroundColor;
                },
                set: function set(val) {
                  this._backgroundColor = val;
                  this.probe.backgroundColor = this._backgroundColor;
                }
              }, {
                key: "visibility",
                get: function get() {
                  return this._visibility;
                },
                set: function set(val) {
                  this._visibility = val;
                  this.probe.visibility = this._visibility;
                }
              }, {
                key: "sourceCamera",
                get: function get() {
                  return this._sourceCamera;
                },
                set: function set(camera) {
                  this._sourceCamera = camera;
                  if (camera) {
                    this.visibility = camera.visibility;
                    this.clearFlag = camera.clearFlags;
                    this.backgroundColor = camera.clearColor;
                    if (this.probeType === 1) {
                      this.probe.switchProbeType(this.probeType, camera.camera);
                    }
                  }
                }
              }, {
                key: "fastBake",
                get: function get() {
                  return this._fastBake;
                },
                set: function set(val) {
                  this._fastBake = val;
                }
              }, {
                key: "cubemap",
                get: function get() {
                  return this._cubemap;
                },
                set: function set(val) {
                  this._cubemap = val;
                  this.probe.cubemap = val;
                  ReflectionProbeManager.probeManager.onUpdateProbes();
                }
              }, {
                key: "probe",
                get: function get() {
                  return this._probe;
                }
              }, {
                key: "previewSphere",
                get: function get() {
                  return this._previewSphere;
                },
                set: function set(val) {
                  this._previewSphere = val;
                  if (this.probe) {
                    this.probe.previewSphere = val;
                    if (this._previewSphere) {
                      ReflectionProbeManager.probeManager.updatePreviewSphere(this.probe);
                    }
                  }
                }
              }, {
                key: "previewPlane",
                get: function get() {
                  return this._previewPlane;
                },
                set: function set(val) {
                  this._previewPlane = val;
                  if (this.probe) {
                    this.probe.previewPlane = val;
                    if (this._previewPlane) {
                      ReflectionProbeManager.probeManager.updatePreviewPlane(this.probe);
                    }
                  }
                }
              }]);
              return ReflectionProbe;
            }(Component), _class3$3.DEFAULT_CUBE_SIZE = v3(1, 1, 1), _class3$3.DEFAULT_PLANER_SIZE = v3(5, 0.5, 5), _class3$3), (_initializer$6 = applyDecoratedInitializer(_class2$7.prototype, "_resolution", [serializable$5], function () {
              return 256;
            }), _initializer2$5 = applyDecoratedInitializer(_class2$7.prototype, "_clearFlag", [serializable$5], function () {
              return 14;
            }), _initializer3$2 = applyDecoratedInitializer(_class2$7.prototype, "_backgroundColor", [serializable$5], function () {
              return new Color(0, 0, 0, 255);
            }), _initializer4$2 = applyDecoratedInitializer(_class2$7.prototype, "_visibility", [serializable$5], function () {
              return CAMERA_DEFAULT_MASK;
            }), _initializer5$2 = applyDecoratedInitializer(_class2$7.prototype, "_probeType", [serializable$5], function () {
              return 0;
            }), _initializer6$1 = applyDecoratedInitializer(_class2$7.prototype, "_cubemap", [serializable$5], function () {
              return null;
            }), _initializer7 = applyDecoratedInitializer(_class2$7.prototype, "_size", [serializable$5], function () {
              return v3(1, 1, 1);
            }), _initializer8 = applyDecoratedInitializer(_class2$7.prototype, "_sourceCamera", [serializable$5], function () {
              return null;
            }), _initializer9 = applyDecoratedInitializer(_class2$7.prototype, "_probeId", [serializable$5], function () {
              return -1;
            }), _initializer10 = applyDecoratedInitializer(_class2$7.prototype, "_fastBake", [serializable$5], function () {
              return false;
            }), _applyDecoratedDescriptor(_class2$7.prototype, "size", [_dec2$8], Object.getOwnPropertyDescriptor(_class2$7.prototype, "size"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "probeType", [_dec3$6], Object.getOwnPropertyDescriptor(_class2$7.prototype, "probeType"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "resolution", [_dec4$2], Object.getOwnPropertyDescriptor(_class2$7.prototype, "resolution"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "clearFlag", [_dec5], Object.getOwnPropertyDescriptor(_class2$7.prototype, "clearFlag"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "backgroundColor", [_dec6], Object.getOwnPropertyDescriptor(_class2$7.prototype, "backgroundColor"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "visibility", [_dec7], Object.getOwnPropertyDescriptor(_class2$7.prototype, "visibility"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "sourceCamera", [_dec8], Object.getOwnPropertyDescriptor(_class2$7.prototype, "sourceCamera"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "fastBake", [_dec9], Object.getOwnPropertyDescriptor(_class2$7.prototype, "fastBake"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "cubemap", [_dec10], Object.getOwnPropertyDescriptor(_class2$7.prototype, "cubemap"), _class2$7.prototype)), _class2$7)) || _class$a));

            legacyCC.utils = utils;

            legacyCC.log = log;
            legacyCC.warn = warn;
            legacyCC.error = error;
            legacyCC.assert = assert;
            legacyCC._throw = _throw;
            legacyCC.logID = logID;
            legacyCC.warnID = warnID;
            legacyCC.errorID = errorID;
            legacyCC.assertID = assertID;
            legacyCC.debug = debug$1;
            legacyCC.path = {
              join: join,
              extname: extname,
              mainFileName: mainFileName,
              basename: basename,
              dirname: dirname,
              changeExtname: changeExtname,
              changeBasename: changeBasename,
              _normalize: _normalize,
              stripSep: stripSep,
              get sep() {
                return getSeperator();
              }
            };

            function rayAABB2(ray, min, max) {
              var o = ray.o;
              var d = ray.d;
              var ix = 1 / d.x;
              var iy = 1 / d.y;
              var iz = 1 / d.z;
              var t1 = (min.x - o.x) * ix;
              var t2 = (max.x - o.x) * ix;
              var t3 = (min.y - o.y) * iy;
              var t4 = (max.y - o.y) * iy;
              var t5 = (min.z - o.z) * iz;
              var t6 = (max.z - o.z) * iz;
              var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
              var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
              if (tmax < 0 || tmin > tmax) {
                return 0;
              }
              return tmin > 0 ? tmin : tmax;
            }
            var raySubMesh = function () {
              var tri = Triangle.create();
              var deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: 2
              };
              var minDis = 0;
              var fillResult = function fillResult(m, d, i0, i1, i2, r) {
                if (m === 1) {
                  if (minDis > d || minDis === 0) {
                    minDis = d;
                    if (r) {
                      if (r.length === 0) {
                        r.push({
                          distance: d,
                          vertexIndex0: i0 / 3,
                          vertexIndex1: i1 / 3,
                          vertexIndex2: i2 / 3
                        });
                      } else {
                        r[0].distance = d;
                        r[0].vertexIndex0 = i0 / 3;
                        r[0].vertexIndex1 = i1 / 3;
                        r[0].vertexIndex2 = i2 / 3;
                      }
                    }
                  }
                } else {
                  minDis = d;
                  if (r) r.push({
                    distance: d,
                    vertexIndex0: i0 / 3,
                    vertexIndex1: i1 / 3,
                    vertexIndex2: i2 / 3
                  });
                }
              };
              var narrowphase = function narrowphase(vb, ib, pm, ray, opt) {
                if (pm === 7) {
                  var cnt = ib.length;
                  for (var j = 0; j < cnt; j += 3) {
                    var i0 = ib[j] * 3;
                    var i1 = ib[j + 1] * 3;
                    var i2 = ib[j + 2] * 3;
                    Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                    Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    var dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (dist === 0 || dist > opt.distance) continue;
                    fillResult(opt.mode, dist, i0, i1, i2, opt.result);
                    if (opt.mode === 2) return dist;
                  }
                } else if (pm === 8) {
                  var _cnt = ib.length - 2;
                  var rev = 0;
                  for (var _j = 0; _j < _cnt; _j += 1) {
                    var _i = ib[_j - rev] * 3;
                    var _i2 = ib[_j + rev + 1] * 3;
                    var _i3 = ib[_j + 2] * 3;
                    Vec3.set(tri.a, vb[_i], vb[_i + 1], vb[_i + 2]);
                    Vec3.set(tri.b, vb[_i2], vb[_i2 + 1], vb[_i2 + 2]);
                    Vec3.set(tri.c, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]);
                    rev = ~rev;
                    var _dist = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (_dist === 0 || _dist > opt.distance) continue;
                    fillResult(opt.mode, _dist, _i, _i2, _i3, opt.result);
                    if (opt.mode === 2) return _dist;
                  }
                } else if (pm === 9) {
                  var _cnt2 = ib.length - 1;
                  var _i4 = ib[0] * 3;
                  Vec3.set(tri.a, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);
                  for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                    var _i5 = ib[_j2] * 3;
                    var _i6 = ib[_j2 + 1] * 3;
                    Vec3.set(tri.b, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]);
                    Vec3.set(tri.c, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);
                    var _dist2 = intersect.rayTriangle(ray, tri, opt.doubleSided);
                    if (_dist2 === 0 || _dist2 > opt.distance) continue;
                    fillResult(opt.mode, _dist2, _i4, _i5, _i6, opt.result);
                    if (opt.mode === 2) return _dist2;
                  }
                }
                return minDis;
              };
              return function (ray, submesh, options) {
                minDis = 0;
                if (submesh.geometricInfo.positions.length === 0) return minDis;
                var opt = options === undefined ? deOpt : options;
                var min = submesh.geometricInfo.boundingBox.min;
                var max = submesh.geometricInfo.boundingBox.max;
                if (rayAABB2(ray, min, max)) {
                  var pm = submesh.primitiveMode;
                  var _submesh$geometricInf = submesh.geometricInfo,
                    vb = _submesh$geometricInf.positions,
                    ib = _submesh$geometricInf.indices;
                  narrowphase(vb, ib, pm, ray, opt);
                }
                return minDis;
              };
            }();
            var rayMesh = function () {
              var minDis = 0;
              var deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: 2
              };
              return function (ray, mesh, options) {
                minDis = 0;
                var opt = options === undefined ? deOpt : options;
                var length = mesh.renderingSubMeshes.length;
                var min = mesh.struct.minPosition;
                var max = mesh.struct.maxPosition;
                if (min && max && !rayAABB2(ray, min, max)) return minDis;
                for (var i = 0; i < length; i++) {
                  var sm = mesh.renderingSubMeshes[i];
                  var dis = raySubMesh(ray, sm, opt);
                  if (dis) {
                    if (opt.mode === 1) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);
                      if (opt.mode === 2) {
                        return dis;
                      }
                    }
                  }
                }
                if (minDis && opt.mode === 1) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }
                  if (opt.subIndices) opt.subIndices.length = 1;
                }
                return minDis;
              };
            }();
            var rayModel = function () {
              var minDis = 0;
              var deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: 2
              };
              var modelRay = new Ray();
              var m4 = new Mat4();
              return function (r, model, options) {
                minDis = 0;
                var opt = options === undefined ? deOpt : options;
                var wb = model.worldBounds;
                if (wb && !intersect.rayAABB(r, wb)) return minDis;
                Ray.copy(modelRay, r);
                if (model.node) {
                  Mat4.invert(m4, model.node.getWorldMatrix(m4));
                  Vec3.transformMat4(modelRay.o, r.o, m4);
                  Vec3.transformMat4Normal(modelRay.d, r.d, m4);
                }
                var subModels = model.subModels;
                for (var i = 0; i < subModels.length; i++) {
                  var subMesh = subModels[i].subMesh;
                  var dis = raySubMesh(modelRay, subMesh, opt);
                  if (dis) {
                    if (opt.mode === 1) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);
                      if (opt.mode === 2) {
                        return dis;
                      }
                    }
                  }
                }
                if (minDis && opt.mode === 1) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }
                  if (opt.subIndices) opt.subIndices.length = 1;
                }
                return minDis;
              };
            }();
            intersect.rayModel = rayModel;
            intersect.raySubMesh = raySubMesh;
            intersect.rayMesh = rayMesh;

            var _dec$9, _dec2$7, _class$9, _class2$6, _initializer$5;
            var ccclass = ccclass$6,
              serializable = serializable$5,
              type = type$5;
            var PrefabLink = exports("PrefabLink", (_dec$9 = ccclass('cc.PrefabLink'), _dec2$7 = type(Prefab), _dec$9(_class$9 = (_class2$6 = function (_Component) {
              _inheritsLoose(PrefabLink, _Component);
              function PrefabLink() {
                var _this;
                _this = _Component.call(this) || this;
                _this.prefab = _initializer$5 && _initializer$5();
                return _this;
              }
              return PrefabLink;
            }(Component), (_initializer$5 = applyDecoratedInitializer(_class2$6.prototype, "prefab", [_dec2$7, serializable], function () {
              return null;
            })), _class2$6)) || _class$9));

            replaceProperty(Camera, 'Camera', [{
              name: 'CameraClearFlag',
              newName: 'ClearFlag'
            }]);
            replaceProperty(Camera.prototype, 'Camera.prototype', [{
              name: 'color',
              newName: 'clearColor'
            }, {
              name: 'depth',
              newName: 'clearDepth'
            }, {
              name: 'stencil',
              newName: 'clearStencil'
            }]);
            markAsWarning(Renderer.prototype, 'Renderer.prototype', [{
              name: 'getMaterial',
              suggest: 'please use renderer.getSharedMaterial instead.'
            }]);
            cclegacy.CameraComponent = Camera;
            setClassAlias(Camera, 'cc.CameraComponent');
            cclegacy.RenderableComponent = ModelRenderer;
            setClassAlias(ModelRenderer, 'cc.RenderableComponent');

            var Destroyed = 1;
            var PersistentMask = -4192741;
            var objsToClearTmpVar = [];
            function hasImplementedInstantiate(original) {
              return typeof original._instantiate === 'function';
            }
            function isMountedChild(node) {
              var editorExtras = node[editorExtrasTag];
              if (typeof editorExtras === 'object') {
                return !!editorExtras.mountedRoot;
              }
              return false;
            }
            function instantiate(original, internalForce) {
              var clone;
              if (isCCObject(original)) {
                if (hasImplementedInstantiate(original)) {
                  cclegacy.game._isCloning = true;
                  clone = original._instantiate(null, true);
                  cclegacy.game._isCloning = false;
                  return clone;
                } else if (original instanceof cclegacy.Asset) {
                  throw new TypeError(getError(6903));
                }
              }
              cclegacy.game._isCloning = true;
              clone = doInstantiate(original);
              cclegacy.game._isCloning = false;
              return clone;
            }
            function doInstantiate(obj, parent) {
              var clone;
              if (obj._iN$t) {
                clone = obj._iN$t;
              } else if (obj.constructor) {
                var Klass = obj.constructor;
                clone = new Klass();
              } else {
                clone = Object.create(null);
              }
              enumerateObject(obj, clone, parent);
              for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
                objsToClearTmpVar[i]._iN$t = null;
              }
              objsToClearTmpVar.length = 0;
              return clone;
            }
            function enumerateCCClass(klass, obj, clone, parent) {
              var props = klass.__values__;
              for (var p = 0; p < props.length; p++) {
                var key = props[p];
                var value = obj[key];
                if (typeof value === 'object' && value) {
                  var initValue = clone[key];
                  if (initValue instanceof ValueType && initValue.constructor === value.constructor) {
                    initValue.set(value);
                  } else {
                    clone[key] = value._iN$t || instantiateObj(value, parent);
                  }
                } else {
                  clone[key] = value;
                }
              }
            }
            function enumerateObject(obj, clone, parent) {
              value(obj, '_iN$t', clone, true);
              objsToClearTmpVar.push(obj);
              var klass = obj.constructor;
              if (isCCClassOrFastDefined(klass)) {
                enumerateCCClass(klass, obj, clone, parent);
              } else {
                for (var key in obj) {
                  if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && key !== '__type__' && key !== '__prefab') {
                    continue;
                  }
                  var value$1 = obj[key];
                  if (typeof value$1 === 'object' && value$1) {
                    if (value$1 === clone) {
                      continue;
                    }
                    clone[key] = value$1._iN$t || instantiateObj(value$1, parent);
                  } else {
                    clone[key] = value$1;
                  }
                }
              }
              if (isCCObject(obj)) {
                clone._objFlags &= PersistentMask;
              }
            }
            function instantiateObj(obj, parent) {
              if (obj instanceof ValueType) {
                return obj.clone();
              }
              if (obj instanceof cclegacy.Asset) {
                return obj;
              }
              var clone;
              if (ArrayBuffer.isView(obj)) {
                var len = obj.length;
                clone = new obj.constructor(len);
                obj._iN$t = clone;
                objsToClearTmpVar.push(obj);
                for (var i = 0; i < len; ++i) {
                  clone[i] = obj[i];
                }
                return clone;
              }
              if (Array.isArray(obj)) {
                var _len = obj.length;
                clone = new Array(_len);
                obj._iN$t = clone;
                objsToClearTmpVar.push(obj);
                for (var _i = 0; _i < _len; ++_i) {
                  var value = obj[_i];
                  if (typeof value === 'object' && value) {
                    clone[_i] = value._iN$t || instantiateObj(value, parent);
                  } else {
                    clone[_i] = value;
                  }
                }
                return clone;
              } else if (obj._objFlags & Destroyed) {
                return null;
              }
              var ctor = obj.constructor;
              if (isCCClassOrFastDefined(ctor)) {
                if (parent) {
                  if (parent instanceof Component) {
                    if (obj instanceof Node$1 || obj instanceof Component) {
                      return obj;
                    }
                  } else if (parent instanceof Node$1) {
                    if (obj instanceof Node$1) {
                      if (!obj.isChildOf(parent) && !isMountedChild(obj)) {
                        return obj;
                      }
                    } else if (obj instanceof Component) {
                      if (obj.node && !obj.node.isChildOf(parent)) {
                        return obj;
                      }
                    }
                  }
                }
                clone = new ctor();
              } else if (ctor === Object) {
                clone = {};
              } else if (!ctor) {
                clone = Object.create(null);
              } else {
                return obj;
              }
              enumerateObject(obj, clone, parent);
              return clone;
            }
            instantiate._clone = doInstantiate;
            cclegacy.instantiate = instantiate;

            var NodePool = exports("NodePool", function () {
              function NodePool(poolHandlerComp) {
                this._pool = [];
                this.poolHandlerComp = poolHandlerComp;
              }
              var _proto = NodePool.prototype;
              _proto.size = function size() {
                return this._pool.length;
              };
              _proto.clear = function clear() {
                var count = this._pool.length;
                for (var i = 0; i < count; ++i) {
                  this._pool[i].destroy();
                }
                this._pool.length = 0;
              };
              _proto.put = function put(obj) {
                if (obj && this._pool.indexOf(obj) === -1) {
                  obj.removeFromParent();
                  var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                  if (handler && handler.unuse) {
                    handler.unuse();
                  }
                  this._pool.push(obj);
                }
              };
              _proto.get = function get() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                var last = this._pool.length - 1;
                if (last < 0) {
                  return null;
                } else {
                  var obj = this._pool[last];
                  this._pool.length = last;
                  var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                  if (handler && handler.reuse) {
                    handler.reuse(arguments);
                  }
                  return obj;
                }
              };
              return NodePool;
            }());
            legacyCC.NodePool = NodePool;

            var _globalThis$jsb, _globalJsb$copyTextTo;
            var globalJsb = (_globalThis$jsb = globalThis.jsb) !== null && _globalThis$jsb !== undefined ? _globalThis$jsb : {};
            var _native = exports("native", {
              DownloaderHints: globalJsb.DownloaderHints,
              Downloader: globalJsb.Downloader,
              zipUtils: globalJsb.zipUtils,
              fileUtils: globalJsb.fileUtils,
              DebugRenderer: globalJsb.DebugRenderer,
              copyTextToClipboard: (_globalJsb$copyTextTo = globalJsb.copyTextToClipboard) == null ? undefined : _globalJsb$copyTextTo.bind(globalJsb),
              garbageCollect: globalJsb.garbageCollect,
              reflection: globalJsb.reflection,
              bridge: globalJsb.bridge,
              jsbBridgeWrapper: globalJsb.jsbBridgeWrapper,
              AssetsManager: globalJsb.AssetsManager,
              EventAssetsManager: globalJsb.EventAssetsManager,
              Manifest: globalJsb.Manifest,
              saveImageData: globalJsb.saveImageData,
              process: globalJsb.process,
              adpf: globalJsb.adpf
            });

            legacyCC.renderer = renderer;

            var UpdateFrequency = {
              PER_INSTANCE: 0,
              PER_BATCH: 1,
              PER_PHASE: 2,
              PER_PASS: 3,
              COUNT: 4
            };
            var ParameterType = {
              CONSTANTS: 0,
              CBV: 1,
              UAV: 2,
              SRV: 3,
              TABLE: 4,
              SSV: 5
            };
            var ResourceResidency = {
              MANAGED: 0,
              MEMORYLESS: 1,
              PERSISTENT: 2,
              EXTERNAL: 3,
              BACKBUFFER: 4
            };
            var QueueHint = {
              NONE: 0,
              OPAQUE: 1,
              MASK: 2,
              BLEND: 3,
              RENDER_OPAQUE: 1,
              RENDER_CUTOUT: 2,
              RENDER_TRANSPARENT: 3
            };
            var ResourceDimension = {
              BUFFER: 0,
              TEXTURE1D: 1,
              TEXTURE2D: 2,
              TEXTURE3D: 3
            };
            var ResourceFlags = {
              NONE: 0,
              UNIFORM: 1,
              INDIRECT: 2,
              STORAGE: 4,
              SAMPLED: 8,
              COLOR_ATTACHMENT: 16,
              DEPTH_STENCIL_ATTACHMENT: 32,
              INPUT_ATTACHMENT: 64,
              SHADING_RATE: 128,
              TRANSFER_SRC: 256,
              TRANSFER_DST: 512
            };
            var TaskType = {
              SYNC: 0,
              ASYNC: 1
            };
            var SceneFlags = {
              NONE: 0,
              OPAQUE: 1,
              MASK: 2,
              BLEND: 4,
              OPAQUE_OBJECT: 1,
              CUTOUT_OBJECT: 2,
              TRANSPARENT_OBJECT: 4,
              SHADOW_CASTER: 8,
              UI: 16,
              DEFAULT_LIGHTING: 32,
              VOLUMETRIC_LIGHTING: 64,
              CLUSTERED_LIGHTING: 128,
              PLANAR_SHADOW: 256,
              GEOMETRY: 512,
              PROFILER: 1024,
              DRAW_INSTANCING: 2048,
              DRAW_NON_INSTANCING: 4096,
              REFLECTION_PROBE: 8192,
              GPU_DRIVEN: 16384,
              NON_BUILTIN: 32768,
              ALL: 4294967295
            };
            var LightingMode = {
              NONE: 0,
              DEFAULT: 1,
              CLUSTERED: 2
            };
            var AttachmentType = {
              RENDER_TARGET: 0,
              DEPTH_STENCIL: 1,
              SHADING_RATE: 2
            };
            var AccessType = {
              READ: 0,
              READ_WRITE: 1,
              WRITE: 2
            };
            var ClearValueType = {
              NONE: 0,
              FLOAT_TYPE: 1,
              INT_TYPE: 2
            };
            var LightInfo = function () {
              function LightInfo(light, level, culledByLight, probe) {
                if (light === undefined) {
                  light = null;
                }
                if (level === undefined) {
                  level = 0;
                }
                if (culledByLight === undefined) {
                  culledByLight = false;
                }
                if (probe === undefined) {
                  probe = null;
                }
                this.light = light;
                this.probe = probe;
                this.level = level;
                this.culledByLight = culledByLight;
              }
              var _proto = LightInfo.prototype;
              _proto.reset = function reset(light, level, culledByLight, probe) {
                this.light = light;
                this.probe = probe;
                this.level = level;
                this.culledByLight = culledByLight;
              };
              return LightInfo;
            }();
            var ResolveFlags = {
              NONE: 0,
              COLOR: 1,
              DEPTH: 2,
              STENCIL: 4
            };
            var ResolvePair = function () {
              function ResolvePair(source, target, resolveFlags, mode, mode1) {
                if (source === undefined) {
                  source = '';
                }
                if (target === undefined) {
                  target = '';
                }
                if (resolveFlags === undefined) {
                  resolveFlags = 0;
                }
                if (mode === undefined) {
                  mode = 1;
                }
                if (mode1 === undefined) {
                  mode1 = 1;
                }
                this.source = source;
                this.target = target;
                this.resolveFlags = resolveFlags;
                this.mode = mode;
                this.mode1 = mode1;
              }
              var _proto2 = ResolvePair.prototype;
              _proto2.reset = function reset(source, target, resolveFlags, mode, mode1) {
                this.source = source;
                this.target = target;
                this.resolveFlags = resolveFlags;
                this.mode = mode;
                this.mode1 = mode1;
              };
              return ResolvePair;
            }();
            var CopyPair = function () {
              function CopyPair(source, target, mipLevels, numSlices, sourceMostDetailedMip, sourceFirstSlice, sourcePlaneSlice, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice) {
                if (source === undefined) {
                  source = '';
                }
                if (target === undefined) {
                  target = '';
                }
                if (mipLevels === undefined) {
                  mipLevels = 0xFFFFFFFF;
                }
                if (numSlices === undefined) {
                  numSlices = 0xFFFFFFFF;
                }
                if (sourceMostDetailedMip === undefined) {
                  sourceMostDetailedMip = 0;
                }
                if (sourceFirstSlice === undefined) {
                  sourceFirstSlice = 0;
                }
                if (sourcePlaneSlice === undefined) {
                  sourcePlaneSlice = 0;
                }
                if (targetMostDetailedMip === undefined) {
                  targetMostDetailedMip = 0;
                }
                if (targetFirstSlice === undefined) {
                  targetFirstSlice = 0;
                }
                if (targetPlaneSlice === undefined) {
                  targetPlaneSlice = 0;
                }
                this.source = source;
                this.target = target;
                this.mipLevels = mipLevels;
                this.numSlices = numSlices;
                this.sourceMostDetailedMip = sourceMostDetailedMip;
                this.sourceFirstSlice = sourceFirstSlice;
                this.sourcePlaneSlice = sourcePlaneSlice;
                this.targetMostDetailedMip = targetMostDetailedMip;
                this.targetFirstSlice = targetFirstSlice;
                this.targetPlaneSlice = targetPlaneSlice;
              }
              var _proto3 = CopyPair.prototype;
              _proto3.reset = function reset(source, target, mipLevels, numSlices, sourceMostDetailedMip, sourceFirstSlice, sourcePlaneSlice, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice) {
                this.source = source;
                this.target = target;
                this.mipLevels = mipLevels;
                this.numSlices = numSlices;
                this.sourceMostDetailedMip = sourceMostDetailedMip;
                this.sourceFirstSlice = sourceFirstSlice;
                this.sourcePlaneSlice = sourcePlaneSlice;
                this.targetMostDetailedMip = targetMostDetailedMip;
                this.targetFirstSlice = targetFirstSlice;
                this.targetPlaneSlice = targetPlaneSlice;
              };
              return CopyPair;
            }();
            var UploadPair = function () {
              function UploadPair(source, target, mipLevels, numSlices, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice) {
                if (source === undefined) {
                  source = new Uint8Array(0);
                }
                if (target === undefined) {
                  target = '';
                }
                if (mipLevels === undefined) {
                  mipLevels = 0xFFFFFFFF;
                }
                if (numSlices === undefined) {
                  numSlices = 0xFFFFFFFF;
                }
                if (targetMostDetailedMip === undefined) {
                  targetMostDetailedMip = 0;
                }
                if (targetFirstSlice === undefined) {
                  targetFirstSlice = 0;
                }
                if (targetPlaneSlice === undefined) {
                  targetPlaneSlice = 0;
                }
                this.source = source;
                this.target = target;
                this.mipLevels = mipLevels;
                this.numSlices = numSlices;
                this.targetMostDetailedMip = targetMostDetailedMip;
                this.targetFirstSlice = targetFirstSlice;
                this.targetPlaneSlice = targetPlaneSlice;
              }
              var _proto4 = UploadPair.prototype;
              _proto4.reset = function reset(target, mipLevels, numSlices, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice) {
                this.target = target;
                this.mipLevels = mipLevels;
                this.numSlices = numSlices;
                this.targetMostDetailedMip = targetMostDetailedMip;
                this.targetFirstSlice = targetFirstSlice;
                this.targetPlaneSlice = targetPlaneSlice;
              };
              return UploadPair;
            }();
            var MovePair = function () {
              function MovePair(source, target, mipLevels, numSlices, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice) {
                if (source === undefined) {
                  source = '';
                }
                if (target === undefined) {
                  target = '';
                }
                if (mipLevels === undefined) {
                  mipLevels = 0xFFFFFFFF;
                }
                if (numSlices === undefined) {
                  numSlices = 0xFFFFFFFF;
                }
                if (targetMostDetailedMip === undefined) {
                  targetMostDetailedMip = 0;
                }
                if (targetFirstSlice === undefined) {
                  targetFirstSlice = 0;
                }
                if (targetPlaneSlice === undefined) {
                  targetPlaneSlice = 0;
                }
                this.source = source;
                this.target = target;
                this.mipLevels = mipLevels;
                this.numSlices = numSlices;
                this.targetMostDetailedMip = targetMostDetailedMip;
                this.targetFirstSlice = targetFirstSlice;
                this.targetPlaneSlice = targetPlaneSlice;
              }
              var _proto5 = MovePair.prototype;
              _proto5.reset = function reset(source, target, mipLevels, numSlices, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice) {
                this.source = source;
                this.target = target;
                this.mipLevels = mipLevels;
                this.numSlices = numSlices;
                this.targetMostDetailedMip = targetMostDetailedMip;
                this.targetFirstSlice = targetFirstSlice;
                this.targetPlaneSlice = targetPlaneSlice;
              };
              return MovePair;
            }();
            var PipelineStatistics = function () {
              function PipelineStatistics() {
                this.numRenderPasses = 0;
                this.numManagedTextures = 0;
                this.totalManagedTextures = 0;
                this.numUploadBuffers = 0;
                this.numUploadBufferViews = 0;
                this.numFreeUploadBuffers = 0;
                this.numFreeUploadBufferViews = 0;
                this.numDescriptorSets = 0;
                this.numFreeDescriptorSets = 0;
                this.numInstancingBuffers = 0;
                this.numInstancingUniformBlocks = 0;
              }
              var _proto6 = PipelineStatistics.prototype;
              _proto6.reset = function reset() {
                this.numRenderPasses = 0;
                this.numManagedTextures = 0;
                this.totalManagedTextures = 0;
                this.numUploadBuffers = 0;
                this.numUploadBufferViews = 0;
                this.numFreeUploadBuffers = 0;
                this.numFreeUploadBufferViews = 0;
                this.numDescriptorSets = 0;
                this.numFreeDescriptorSets = 0;
                this.numInstancingBuffers = 0;
                this.numInstancingUniformBlocks = 0;
              };
              return PipelineStatistics;
            }();
            function createPool$1(Constructor) {
              return new RecyclePool(function () {
                return new Constructor();
              }, 16);
            }
            var RenderCommonObjectPool = function () {
              function RenderCommonObjectPool() {
                this.li = createPool$1(LightInfo);
                this.rp = createPool$1(ResolvePair);
                this.cp = createPool$1(CopyPair);
                this.up = createPool$1(UploadPair);
                this.mp = createPool$1(MovePair);
                this.ps = createPool$1(PipelineStatistics);
              }
              var _proto7 = RenderCommonObjectPool.prototype;
              _proto7.reset = function reset() {
                this.li.reset();
                this.rp.reset();
                this.cp.reset();
                this.up.reset();
                this.mp.reset();
                this.ps.reset();
              };
              _proto7.createLightInfo = function createLightInfo(light, level, culledByLight, probe) {
                if (light === undefined) {
                  light = null;
                }
                if (level === undefined) {
                  level = 0;
                }
                if (culledByLight === undefined) {
                  culledByLight = false;
                }
                if (probe === undefined) {
                  probe = null;
                }
                var v = this.li.add();
                v.reset(light, level, culledByLight, probe);
                return v;
              };
              _proto7.createResolvePair = function createResolvePair(source, target, resolveFlags, mode, mode1) {
                if (source === undefined) {
                  source = '';
                }
                if (target === undefined) {
                  target = '';
                }
                if (resolveFlags === undefined) {
                  resolveFlags = 0;
                }
                if (mode === undefined) {
                  mode = 1;
                }
                if (mode1 === undefined) {
                  mode1 = 1;
                }
                var v = this.rp.add();
                v.reset(source, target, resolveFlags, mode, mode1);
                return v;
              };
              _proto7.createCopyPair = function createCopyPair(source, target, mipLevels, numSlices, sourceMostDetailedMip, sourceFirstSlice, sourcePlaneSlice, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice) {
                if (source === undefined) {
                  source = '';
                }
                if (target === undefined) {
                  target = '';
                }
                if (mipLevels === undefined) {
                  mipLevels = 0xFFFFFFFF;
                }
                if (numSlices === undefined) {
                  numSlices = 0xFFFFFFFF;
                }
                if (sourceMostDetailedMip === undefined) {
                  sourceMostDetailedMip = 0;
                }
                if (sourceFirstSlice === undefined) {
                  sourceFirstSlice = 0;
                }
                if (sourcePlaneSlice === undefined) {
                  sourcePlaneSlice = 0;
                }
                if (targetMostDetailedMip === undefined) {
                  targetMostDetailedMip = 0;
                }
                if (targetFirstSlice === undefined) {
                  targetFirstSlice = 0;
                }
                if (targetPlaneSlice === undefined) {
                  targetPlaneSlice = 0;
                }
                var v = this.cp.add();
                v.reset(source, target, mipLevels, numSlices, sourceMostDetailedMip, sourceFirstSlice, sourcePlaneSlice, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice);
                return v;
              };
              _proto7.createUploadPair = function createUploadPair(target, mipLevels, numSlices, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice) {
                if (target === undefined) {
                  target = '';
                }
                if (mipLevels === undefined) {
                  mipLevels = 0xFFFFFFFF;
                }
                if (numSlices === undefined) {
                  numSlices = 0xFFFFFFFF;
                }
                if (targetMostDetailedMip === undefined) {
                  targetMostDetailedMip = 0;
                }
                if (targetFirstSlice === undefined) {
                  targetFirstSlice = 0;
                }
                if (targetPlaneSlice === undefined) {
                  targetPlaneSlice = 0;
                }
                var v = this.up.add();
                v.reset(target, mipLevels, numSlices, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice);
                return v;
              };
              _proto7.createMovePair = function createMovePair(source, target, mipLevels, numSlices, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice) {
                if (source === undefined) {
                  source = '';
                }
                if (target === undefined) {
                  target = '';
                }
                if (mipLevels === undefined) {
                  mipLevels = 0xFFFFFFFF;
                }
                if (numSlices === undefined) {
                  numSlices = 0xFFFFFFFF;
                }
                if (targetMostDetailedMip === undefined) {
                  targetMostDetailedMip = 0;
                }
                if (targetFirstSlice === undefined) {
                  targetFirstSlice = 0;
                }
                if (targetPlaneSlice === undefined) {
                  targetPlaneSlice = 0;
                }
                var v = this.mp.add();
                v.reset(source, target, mipLevels, numSlices, targetMostDetailedMip, targetFirstSlice, targetPlaneSlice);
                return v;
              };
              _proto7.createPipelineStatistics = function createPipelineStatistics() {
                var v = this.ps.add();
                v.reset();
                return v;
              };
              return RenderCommonObjectPool;
            }();
            function saveLightInfo(a, v) {
              a.n(v.level);
              a.b(v.culledByLight);
            }
            function loadLightInfo(a, v) {
              v.level = a.n();
              v.culledByLight = a.b();
            }
            function saveResolvePair(a, v) {
              a.s(v.source);
              a.s(v.target);
              a.n(v.resolveFlags);
              a.n(v.mode);
              a.n(v.mode1);
            }
            function loadResolvePair(a, v) {
              v.source = a.s();
              v.target = a.s();
              v.resolveFlags = a.n();
              v.mode = a.n();
              v.mode1 = a.n();
            }
            function saveCopyPair(a, v) {
              a.s(v.source);
              a.s(v.target);
              a.n(v.mipLevels);
              a.n(v.numSlices);
              a.n(v.sourceMostDetailedMip);
              a.n(v.sourceFirstSlice);
              a.n(v.sourcePlaneSlice);
              a.n(v.targetMostDetailedMip);
              a.n(v.targetFirstSlice);
              a.n(v.targetPlaneSlice);
            }
            function loadCopyPair(a, v) {
              v.source = a.s();
              v.target = a.s();
              v.mipLevels = a.n();
              v.numSlices = a.n();
              v.sourceMostDetailedMip = a.n();
              v.sourceFirstSlice = a.n();
              v.sourcePlaneSlice = a.n();
              v.targetMostDetailedMip = a.n();
              v.targetFirstSlice = a.n();
              v.targetPlaneSlice = a.n();
            }
            function saveMovePair(a, v) {
              a.s(v.source);
              a.s(v.target);
              a.n(v.mipLevels);
              a.n(v.numSlices);
              a.n(v.targetMostDetailedMip);
              a.n(v.targetFirstSlice);
              a.n(v.targetPlaneSlice);
            }
            function loadMovePair(a, v) {
              v.source = a.s();
              v.target = a.s();
              v.mipLevels = a.n();
              v.numSlices = a.n();
              v.targetMostDetailedMip = a.n();
              v.targetFirstSlice = a.n();
              v.targetPlaneSlice = a.n();
            }
            function savePipelineStatistics(a, v) {
              a.n(v.numRenderPasses);
              a.n(v.numManagedTextures);
              a.n(v.totalManagedTextures);
              a.n(v.numUploadBuffers);
              a.n(v.numUploadBufferViews);
              a.n(v.numFreeUploadBuffers);
              a.n(v.numFreeUploadBufferViews);
              a.n(v.numDescriptorSets);
              a.n(v.numFreeDescriptorSets);
              a.n(v.numInstancingBuffers);
              a.n(v.numInstancingUniformBlocks);
            }
            function loadPipelineStatistics(a, v) {
              v.numRenderPasses = a.n();
              v.numManagedTextures = a.n();
              v.totalManagedTextures = a.n();
              v.numUploadBuffers = a.n();
              v.numUploadBufferViews = a.n();
              v.numFreeUploadBuffers = a.n();
              v.numFreeUploadBufferViews = a.n();
              v.numDescriptorSets = a.n();
              v.numFreeDescriptorSets = a.n();
              v.numInstancingBuffers = a.n();
              v.numInstancingUniformBlocks = a.n();
            }

            var _Symbol$iterator, _Symbol$iterator3, _Symbol$iterator5;
            var ED = function () {
              function ED(source, target) {
                this.source = undefined;
                this.target = undefined;
                this.source = source;
                this.target = target;
              }
              var _proto = ED.prototype;
              _proto.equals = function equals(rhs) {
                return this.source === rhs.source && this.target === rhs.target;
              };
              return ED;
            }();
            var OutE = function () {
              function OutE(target) {
                this.target = undefined;
                this.target = target;
              }
              var _proto3 = OutE.prototype;
              _proto3.equals = function equals(rhs) {
                return this.target === rhs.target;
              };
              return OutE;
            }();
            _Symbol$iterator = Symbol.iterator;
            var OutEI = function () {
              function OutEI(iterator, source) {
                this.iterator = undefined;
                this.source = undefined;
                this.iterator = iterator;
                this.source = source;
              }
              var _proto5 = OutEI.prototype;
              _proto5[_Symbol$iterator] = function () {
                return this;
              };
              _proto5.next = function next() {
                var res = this.iterator.next();
                if (res.done) {
                  return {
                    value: undefined,
                    done: true
                  };
                } else {
                  return {
                    value: new ED(this.source, res.value.target),
                    done: false
                  };
                }
              };
              return OutEI;
            }();
            _Symbol$iterator3 = Symbol.iterator;
            var InEI = function () {
              function InEI(iterator, source) {
                this.iterator = undefined;
                this.source = undefined;
                this.iterator = iterator;
                this.source = source;
              }
              var _proto7 = InEI.prototype;
              _proto7[_Symbol$iterator3] = function () {
                return this;
              };
              _proto7.next = function next() {
                var res = this.iterator.next();
                if (res.done) {
                  return {
                    value: undefined,
                    done: true
                  };
                } else {
                  return {
                    value: new ED(res.value.target, this.source),
                    done: false
                  };
                }
              };
              return InEI;
            }();
            _Symbol$iterator5 = Symbol.iterator;
            var AdjI = function () {
              function AdjI(graph, iterator) {
                this.graph = undefined;
                this.iterator = undefined;
                this.graph = graph;
                this.iterator = iterator;
              }
              var _proto9 = AdjI.prototype;
              _proto9[_Symbol$iterator5] = function () {
                return this;
              };
              _proto9.next = function next() {
                var res = this.iterator.next();
                if (res.done) {
                  return {
                    value: undefined,
                    done: true
                  };
                } else {
                  return {
                    value: this.graph.target(res.value),
                    done: false
                  };
                }
              };
              return AdjI;
            }();
            function getPath(g, v) {
              if (v === g.N) {
                return '';
              }
              var paths = [];
              for (; v !== g.N; v = g.getParent(v)) {
                paths.push(g.vertexName(v));
              }
              var path = '';
              for (var i = paths.length; i-- > 0;) {
                path += '/';
                path += paths[i];
              }
              return path;
            }
            function findRelative(g, v, path) {
              var pseudo = g.N;
              var names = path.split('/');
              if (names.length === 0) {
                return v;
              }
              var curr = v;
              var start = 0;
              if (names[0] === '') {
                curr = pseudo;
                ++start;
              }
              for (var i = start; i !== names.length; ++i) {
                var _name = names[i];
                if (_name === '') {
                  continue;
                }
                if (_name === '.') {
                  continue;
                }
                if (_name === '..') {
                  if (curr === pseudo) {
                    return pseudo;
                  }
                  curr = g.getParent(curr);
                  continue;
                }
                curr = g.locateChild(curr, _name);
                if (curr === pseudo) {
                  return pseudo;
                }
              }
              return curr;
            }
            var NoTermination = function () {
              function NoTermination() {}
              var _proto11 = NoTermination.prototype;
              _proto11.terminate = function terminate(v, g) {
                return false;
              };
              return NoTermination;
            }();
            function getDefaultStartingVertex(g) {
              var iter = g.v();
              var v = iter.next();
              if (v.done) {
                return g.N;
              } else {
                return v.value;
              }
            }
            var VertexInfo = function VertexInfo(v, e, iter) {
              this.v = undefined;
              this.e = undefined;
              this.iter = undefined;
              this.v = v;
              this.e = e;
              this.iter = iter;
            };
            function depthFirstVisitImpl(g, u, visitor, color, func) {
              var srcE = null;
              var ei = null;
              var stack = new Array();
              color.put(u, 1);
              visitor.discoverVertex(u, g);
              ei = g.oe(u);
              if (func.terminate(u, g)) {
                stack.push(new VertexInfo(u, null, null));
              } else {
                stack.push(new VertexInfo(u, null, ei));
              }
              while (stack.length) {
                var back = stack.pop();
                u = back.v;
                srcE = back.e;
                ei = back.iter;
                if (srcE !== null) {
                  visitor.finishEdge(srcE, g);
                }
                if (ei) {
                  for (var ev = ei.next(); !ev.done; ev = ei.next()) {
                    var _e2 = ev.value;
                    var _v = _e2.target;
                    visitor.examineEdge(_e2, g);
                    var vColor = color.get(_v);
                    if (vColor === 0) {
                      visitor.treeEdge(_e2, g);
                      srcE = _e2;
                      stack.push(new VertexInfo(u, srcE, ei));
                      u = _v;
                      color.put(u, 1);
                      visitor.discoverVertex(u, g);
                      ei = g.oe(u);
                      if (func.terminate(u, g)) {
                        break;
                      }
                    } else {
                      if (vColor === 1) {
                        visitor.backEdge(_e2, g);
                      } else {
                        visitor.forwardOrCrossEdge(_e2, g);
                      }
                      visitor.finishEdge(_e2, g);
                    }
                  }
                }
                color.put(u, 4);
                visitor.finishVertex(u, g);
              }
            }
            function depthFirstSearch(g, visitor, color, startVertex) {
              if (startVertex === undefined) {
                startVertex = null;
              }
              startVertex = startVertex || getDefaultStartingVertex(g);
              if (startVertex === null || g.nv() === 0) {
                return;
              }
              for (var _iterator2 = _createForOfIteratorHelperLoose(g.v()), _step2; !(_step2 = _iterator2()).done;) {
                var _u = _step2.value;
                color.put(_u, 0);
                visitor.initializeVertex(_u, g);
              }
              var terminator = new NoTermination();
              if (startVertex !== getDefaultStartingVertex(g)) {
                visitor.startVertex(startVertex, g);
                depthFirstVisitImpl(g, startVertex, visitor, color, terminator);
              }
              for (var _iterator3 = _createForOfIteratorHelperLoose(g.v()), _step3; !(_step3 = _iterator3()).done;) {
                var _u2 = _step3.value;
                if (color.get(_u2) === 0) {
                  visitor.startVertex(_u2, g);
                  depthFirstVisitImpl(g, _u2, visitor, color, terminator);
                }
              }
            }
            var DefaultVisitor = function () {
              function DefaultVisitor() {}
              var _proto12 = DefaultVisitor.prototype;
              _proto12.initializeVertex = function initializeVertex(v, g) {};
              _proto12.startVertex = function startVertex(v, g) {};
              _proto12.discoverVertex = function discoverVertex(v, g) {};
              _proto12.examineEdge = function examineEdge(e, g) {};
              _proto12.treeEdge = function treeEdge(e, g) {};
              _proto12.backEdge = function backEdge(e, g) {};
              _proto12.forwardOrCrossEdge = function forwardOrCrossEdge(e, g) {};
              _proto12.finishEdge = function finishEdge(e, g) {};
              _proto12.finishVertex = function finishVertex(v, g) {};
              return DefaultVisitor;
            }();
            var ReferenceGraphView = function () {
              function ReferenceGraphView(g) {
                this.g = undefined;
                this.g = g;
                this.N = g.N;
              }
              var _proto13 = ReferenceGraphView.prototype;
              _proto13.edge = function edge(u, v) {
                return this.g.reference(u, v);
              };
              _proto13.source = function source(e) {
                return this.g.parent(e);
              };
              _proto13.target = function target(e) {
                return this.g.child(e);
              };
              _proto13.oe = function oe(v) {
                return this.g.children(v);
              };
              _proto13.od = function od(v) {
                return this.g.numChildren(v);
              };
              _proto13.v = function v() {
                return this.g.v();
              };
              _proto13.nv = function nv() {
                return this.g.nv();
              };
              return ReferenceGraphView;
            }();

            function resetColor(v) {
              v.x = 0;
              v.y = 0;
              v.z = 0;
              v.w = 0;
            }
            function resetViewport(v) {
              v.left = 0;
              v.top = 0;
              v.width = 0;
              v.height = 0;
              v.minDepth = 0;
              v.maxDepth = 1;
            }
            var ClearValue = function () {
              function ClearValue(x, y, z, w) {
                if (x === undefined) {
                  x = 0;
                }
                if (y === undefined) {
                  y = 0;
                }
                if (z === undefined) {
                  z = 0;
                }
                if (w === undefined) {
                  w = 0;
                }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
              }
              var _proto = ClearValue.prototype;
              _proto.reset = function reset(x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
              };
              return ClearValue;
            }();
            var RasterView = function () {
              function RasterView(slotName, accessType, attachmentType, loadOp, storeOp, clearFlags, clearColor, shaderStageFlags) {
                if (slotName === undefined) {
                  slotName = '';
                }
                if (accessType === undefined) {
                  accessType = 2;
                }
                if (attachmentType === undefined) {
                  attachmentType = 0;
                }
                if (loadOp === undefined) {
                  loadOp = 0;
                }
                if (storeOp === undefined) {
                  storeOp = 0;
                }
                if (clearFlags === undefined) {
                  clearFlags = 7;
                }
                if (clearColor === undefined) {
                  clearColor = new Color$1();
                }
                if (shaderStageFlags === undefined) {
                  shaderStageFlags = 0;
                }
                this.slotName1 = '';
                this.slotID = 0;
                this.slotName = slotName;
                this.accessType = accessType;
                this.attachmentType = attachmentType;
                this.loadOp = loadOp;
                this.storeOp = storeOp;
                this.clearFlags = clearFlags;
                this.clearColor = clearColor;
                this.shaderStageFlags = shaderStageFlags;
              }
              var _proto2 = RasterView.prototype;
              _proto2.reset = function reset(slotName, accessType, attachmentType, loadOp, storeOp, clearFlags, shaderStageFlags) {
                this.slotName = slotName;
                this.slotName1 = '';
                this.accessType = accessType;
                this.attachmentType = attachmentType;
                this.loadOp = loadOp;
                this.storeOp = storeOp;
                this.clearFlags = clearFlags;
                resetColor(this.clearColor);
                this.slotID = 0;
                this.shaderStageFlags = shaderStageFlags;
              };
              return RasterView;
            }();
            var ComputeView = function () {
              function ComputeView(name, accessType, clearFlags, clearValueType, clearValue, shaderStageFlags) {
                if (name === undefined) {
                  name = '';
                }
                if (accessType === undefined) {
                  accessType = 0;
                }
                if (clearFlags === undefined) {
                  clearFlags = 0;
                }
                if (clearValueType === undefined) {
                  clearValueType = 0;
                }
                if (clearValue === undefined) {
                  clearValue = new ClearValue();
                }
                if (shaderStageFlags === undefined) {
                  shaderStageFlags = 0;
                }
                this.plane = 0;
                this.name = name;
                this.accessType = accessType;
                this.clearFlags = clearFlags;
                this.clearValueType = clearValueType;
                this.clearValue = clearValue;
                this.shaderStageFlags = shaderStageFlags;
              }
              var _proto3 = ComputeView.prototype;
              _proto3.reset = function reset(name, accessType, clearFlags, clearValueType, shaderStageFlags) {
                this.name = name;
                this.accessType = accessType;
                this.plane = 0;
                this.clearFlags = clearFlags;
                this.clearValueType = clearValueType;
                this.clearValue.reset(0, 0, 0, 0);
                this.shaderStageFlags = shaderStageFlags;
              };
              return ComputeView;
            }();
            var ResourceDesc = function () {
              function ResourceDesc() {
                this.dimension = 0;
                this.alignment = 0;
                this.width = 0;
                this.height = 0;
                this.depthOrArraySize = 0;
                this.mipLevels = 0;
                this.format = 0;
                this.sampleCount = 1;
                this.textureFlags = 0;
                this.flags = 0;
                this.viewType = 1;
              }
              var _proto4 = ResourceDesc.prototype;
              _proto4.reset = function reset() {
                this.dimension = 0;
                this.alignment = 0;
                this.width = 0;
                this.height = 0;
                this.depthOrArraySize = 0;
                this.mipLevels = 0;
                this.format = 0;
                this.sampleCount = 1;
                this.textureFlags = 0;
                this.flags = 0;
                this.viewType = 1;
              };
              return ResourceDesc;
            }();
            var ResourceTraits = function () {
              function ResourceTraits(residency) {
                if (residency === undefined) {
                  residency = 0;
                }
                this.residency = residency;
              }
              var _proto5 = ResourceTraits.prototype;
              _proto5.reset = function reset(residency) {
                this.residency = residency;
              };
              return ResourceTraits;
            }();
            var RenderSwapchain = function () {
              function RenderSwapchain(swapchain, isDepthStencil) {
                if (swapchain === undefined) {
                  swapchain = null;
                }
                if (isDepthStencil === undefined) {
                  isDepthStencil = false;
                }
                this.renderWindow = null;
                this.currentID = 0;
                this.numBackBuffers = 0;
                this.generation = 0xFFFFFFFF;
                this.swapchain = swapchain;
                this.isDepthStencil = isDepthStencil;
              }
              var _proto6 = RenderSwapchain.prototype;
              _proto6.reset = function reset(swapchain, isDepthStencil) {
                this.swapchain = swapchain;
                this.renderWindow = null;
                this.currentID = 0;
                this.numBackBuffers = 0;
                this.generation = 0xFFFFFFFF;
                this.isDepthStencil = isDepthStencil;
              };
              return RenderSwapchain;
            }();
            var ResourceStates = function () {
              function ResourceStates() {
                this.states = 0;
              }
              var _proto7 = ResourceStates.prototype;
              _proto7.reset = function reset() {
                this.states = 0;
              };
              return ResourceStates;
            }();
            var ManagedBuffer = function () {
              function ManagedBuffer(buffer) {
                if (buffer === undefined) {
                  buffer = null;
                }
                this.fenceValue = 0;
                this.buffer = buffer;
              }
              var _proto8 = ManagedBuffer.prototype;
              _proto8.reset = function reset(buffer) {
                this.buffer = buffer;
                this.fenceValue = 0;
              };
              return ManagedBuffer;
            }();
            var PersistentBuffer = function () {
              function PersistentBuffer(buffer) {
                if (buffer === undefined) {
                  buffer = null;
                }
                this.fenceValue = 0;
                this.buffer = buffer;
              }
              var _proto9 = PersistentBuffer.prototype;
              _proto9.reset = function reset(buffer) {
                this.buffer = buffer;
                this.fenceValue = 0;
              };
              return PersistentBuffer;
            }();
            var ManagedTexture = function () {
              function ManagedTexture(texture) {
                if (texture === undefined) {
                  texture = null;
                }
                this.fenceValue = 0;
                this.texture = texture;
              }
              var _proto10 = ManagedTexture.prototype;
              _proto10.reset = function reset(texture) {
                this.texture = texture;
                this.fenceValue = 0;
              };
              return ManagedTexture;
            }();
            var PersistentTexture = function () {
              function PersistentTexture(texture) {
                if (texture === undefined) {
                  texture = null;
                }
                this.fenceValue = 0;
                this.texture = texture;
              }
              var _proto11 = PersistentTexture.prototype;
              _proto11.reset = function reset(texture) {
                this.texture = texture;
                this.fenceValue = 0;
              };
              return PersistentTexture;
            }();
            var ManagedResource = function () {
              function ManagedResource() {
                this.unused = 0;
              }
              var _proto12 = ManagedResource.prototype;
              _proto12.reset = function reset() {
                this.unused = 0;
              };
              return ManagedResource;
            }();
            var Subpass = function () {
              function Subpass() {
                this.rasterViews = new Map();
                this.computeViews = new Map();
                this.resolvePairs = [];
              }
              var _proto13 = Subpass.prototype;
              _proto13.reset = function reset() {
                this.rasterViews.clear();
                this.computeViews.clear();
                this.resolvePairs.length = 0;
              };
              return Subpass;
            }();
            var SubpassGraphVertex = function SubpassGraphVertex() {
              this.o = [];
              this.i = [];
            };
            var SubpassGraph = function () {
              function SubpassGraph() {
                this.N = 0xFFFFFFFF;
                this.x = [];
                this._names = [];
                this._subpasses = [];
              }
              var _proto14 = SubpassGraph.prototype;
              _proto14.edge = function edge(u, v) {
                for (var _iterator = _createForOfIteratorHelperLoose(this.x[u].o), _step; !(_step = _iterator()).done;) {
                  var oe = _step.value;
                  if (v === oe.target) {
                    return true;
                  }
                }
                return false;
              };
              _proto14.source = function source(e) {
                return e.source;
              };
              _proto14.target = function target(e) {
                return e.target;
              };
              _proto14.oe = function oe(v) {
                return new OutEI(this.x[v].o.values(), v);
              };
              _proto14.od = function od(v) {
                return this.x[v].o.length;
              };
              _proto14.ie = function ie(v) {
                return new InEI(this.x[v].i.values(), v);
              };
              _proto14.id = function id(v) {
                return this.x[v].i.length;
              };
              _proto14.d = function d(v) {
                return this.od(v) + this.id(v);
              };
              _proto14.adj = function adj(v) {
                return new AdjI(this, this.oe(v));
              };
              _proto14.v = function v() {
                return this.x.keys();
              };
              _proto14.nv = function nv() {
                return this.x.length;
              };
              _proto14.ne = function ne() {
                var numEdges = 0;
                for (var _iterator2 = _createForOfIteratorHelperLoose(this.v()), _step2; !(_step2 = _iterator2()).done;) {
                  var v = _step2.value;
                  numEdges += this.od(v);
                }
                return numEdges;
              };
              _proto14.clear = function clear() {
                this._names.length = 0;
                this._subpasses.length = 0;
                this.x.length = 0;
              };
              _proto14.addVertex = function addVertex(name, subpass) {
                var vert = new SubpassGraphVertex();
                var v = this.x.length;
                this.x.push(vert);
                this._names.push(name);
                this._subpasses.push(subpass);
                return v;
              };
              _proto14.addEdge = function addEdge(u, v) {
                this.x[u].o.push(new OutE(v));
                this.x[v].i.push(new OutE(u));
                return new ED(u, v);
              };
              _proto14.vertexName = function vertexName(v) {
                return this._names[v];
              };
              _proto14.getName = function getName(v) {
                return this._names[v];
              };
              _proto14.setName = function setName(v, value) {
                this._names[v] = value;
              };
              _proto14.getSubpass = function getSubpass(v) {
                return this._subpasses[v];
              };
              return SubpassGraph;
            }();
            var RasterSubpass = function () {
              function RasterSubpass(subpassID, count, quality) {
                if (subpassID === undefined) {
                  subpassID = 0xFFFFFFFF;
                }
                if (count === undefined) {
                  count = 1;
                }
                if (quality === undefined) {
                  quality = 0;
                }
                this.rasterViews = new Map();
                this.computeViews = new Map();
                this.resolvePairs = [];
                this.viewport = new Viewport();
                this.showStatistics = false;
                this.subpassID = subpassID;
                this.count = count;
                this.quality = quality;
              }
              var _proto15 = RasterSubpass.prototype;
              _proto15.reset = function reset(subpassID, count, quality) {
                this.rasterViews.clear();
                this.computeViews.clear();
                this.resolvePairs.length = 0;
                resetViewport(this.viewport);
                this.subpassID = subpassID;
                this.count = count;
                this.quality = quality;
                this.showStatistics = false;
              };
              return RasterSubpass;
            }();
            var ComputeSubpass = function () {
              function ComputeSubpass(subpassID) {
                if (subpassID === undefined) {
                  subpassID = 0xFFFFFFFF;
                }
                this.rasterViews = new Map();
                this.computeViews = new Map();
                this.subpassID = subpassID;
              }
              var _proto16 = ComputeSubpass.prototype;
              _proto16.reset = function reset(subpassID) {
                this.rasterViews.clear();
                this.computeViews.clear();
                this.subpassID = subpassID;
              };
              return ComputeSubpass;
            }();
            var RasterPass = function () {
              function RasterPass() {
                this.rasterViews = new Map();
                this.computeViews = new Map();
                this.attachmentIndexMap = new Map();
                this.textures = new Map();
                this.subpassGraph = new SubpassGraph();
                this.width = 0;
                this.height = 0;
                this.count = 1;
                this.quality = 0;
                this.viewport = new Viewport();
                this.versionName = '';
                this.version = 0;
                this.hashValue = 0;
                this.showStatistics = false;
              }
              var _proto17 = RasterPass.prototype;
              _proto17.reset = function reset() {
                this.rasterViews.clear();
                this.computeViews.clear();
                this.attachmentIndexMap.clear();
                this.textures.clear();
                this.subpassGraph.clear();
                this.width = 0;
                this.height = 0;
                this.count = 1;
                this.quality = 0;
                resetViewport(this.viewport);
                this.versionName = '';
                this.version = 0;
                this.hashValue = 0;
                this.showStatistics = false;
              };
              return RasterPass;
            }();
            var PersistentRenderPassAndFramebuffer = function () {
              function PersistentRenderPassAndFramebuffer(renderPass, framebuffer) {
                if (renderPass === undefined) {
                  renderPass = null;
                }
                if (framebuffer === undefined) {
                  framebuffer = null;
                }
                this.clearColors = [];
                this.clearDepth = 0;
                this.clearStencil = 0;
                this.renderPass = renderPass;
                this.framebuffer = framebuffer;
              }
              var _proto18 = PersistentRenderPassAndFramebuffer.prototype;
              _proto18.reset = function reset(renderPass, framebuffer) {
                this.renderPass = renderPass;
                this.framebuffer = framebuffer;
                this.clearColors.length = 0;
                this.clearDepth = 0;
                this.clearStencil = 0;
              };
              return PersistentRenderPassAndFramebuffer;
            }();
            var FormatView = function () {
              function FormatView() {
                this.format = 0;
              }
              var _proto19 = FormatView.prototype;
              _proto19.reset = function reset() {
                this.format = 0;
              };
              return FormatView;
            }();
            var SubresourceView = function () {
              function SubresourceView() {
                this.textureView = null;
                this.format = 0;
                this.indexOrFirstMipLevel = 0;
                this.numMipLevels = 0;
                this.firstArraySlice = 0;
                this.numArraySlices = 0;
                this.firstPlane = 0;
                this.numPlanes = 0;
              }
              var _proto20 = SubresourceView.prototype;
              _proto20.reset = function reset() {
                this.textureView = null;
                this.format = 0;
                this.indexOrFirstMipLevel = 0;
                this.numMipLevels = 0;
                this.firstArraySlice = 0;
                this.numArraySlices = 0;
                this.firstPlane = 0;
                this.numPlanes = 0;
              };
              return SubresourceView;
            }();
            var ResourceGraphVertex = function ResourceGraphVertex(id, object) {
              this.o = [];
              this.i = [];
              this.t = undefined;
              this.j = undefined;
              this.id = id;
              this.object = object;
              this.t = id;
              this.j = object;
            };
            var ResourceGraph = function () {
              function ResourceGraph() {
                this.N = 0xFFFFFFFF;
                this.x = [];
                this._names = [];
                this._descs = [];
                this._traits = [];
                this._states = [];
                this._samplerInfo = [];
                this._valueIndex = new Map();
                this.renderPasses = new Map();
                this.nextFenceValue = 0;
                this.version = 0;
              }
              var _proto21 = ResourceGraph.prototype;
              _proto21.edge = function edge(u, v) {
                for (var _iterator3 = _createForOfIteratorHelperLoose(this.x[u].o), _step3; !(_step3 = _iterator3()).done;) {
                  var oe = _step3.value;
                  if (v === oe.target) {
                    return true;
                  }
                }
                return false;
              };
              _proto21.source = function source(e) {
                return e.source;
              };
              _proto21.target = function target(e) {
                return e.target;
              };
              _proto21.oe = function oe(v) {
                return new OutEI(this.x[v].o.values(), v);
              };
              _proto21.od = function od(v) {
                return this.x[v].o.length;
              };
              _proto21.ie = function ie(v) {
                return new InEI(this.x[v].i.values(), v);
              };
              _proto21.id = function id(v) {
                return this.x[v].i.length;
              };
              _proto21.d = function d(v) {
                return this.od(v) + this.id(v);
              };
              _proto21.adj = function adj(v) {
                return new AdjI(this, this.oe(v));
              };
              _proto21.v = function v() {
                return this.x.keys();
              };
              _proto21.nv = function nv() {
                return this.x.length;
              };
              _proto21.ne = function ne() {
                var numEdges = 0;
                for (var _iterator4 = _createForOfIteratorHelperLoose(this.v()), _step4; !(_step4 = _iterator4()).done;) {
                  var v = _step4.value;
                  numEdges += this.od(v);
                }
                return numEdges;
              };
              _proto21.clear = function clear() {
                this.renderPasses.clear();
                this.nextFenceValue = 0;
                this.version = 0;
                this._valueIndex.clear();
                this._names.length = 0;
                this._descs.length = 0;
                this._traits.length = 0;
                this._states.length = 0;
                this._samplerInfo.length = 0;
                this.x.length = 0;
              };
              _proto21.addVertex = function addVertex(id, object, name, desc, traits, states, sampler, u) {
                if (u === undefined) {
                  u = 0xFFFFFFFF;
                }
                var vert = new ResourceGraphVertex(id, object);
                var v = this.x.length;
                this.x.push(vert);
                this._names.push(name);
                this._descs.push(desc);
                this._traits.push(traits);
                this._states.push(states);
                this._samplerInfo.push(sampler);
                this._valueIndex.set(name, v);
                if (u !== 0xFFFFFFFF) {
                  this.addEdge(u, v);
                }
                return v;
              };
              _proto21.addEdge = function addEdge(u, v) {
                this.x[u].o.push(new OutE(v));
                this.x[v].i.push(new OutE(u));
                return new ED(u, v);
              };
              _proto21.vertexName = function vertexName(v) {
                return this._names[v];
              };
              _proto21.getName = function getName(v) {
                return this._names[v];
              };
              _proto21.setName = function setName(v, value) {
                this._names[v] = value;
              };
              _proto21.getDesc = function getDesc(v) {
                return this._descs[v];
              };
              _proto21.getTraits = function getTraits(v) {
                return this._traits[v];
              };
              _proto21.getStates = function getStates(v) {
                return this._states[v];
              };
              _proto21.getSampler = function getSampler(v) {
                return this._samplerInfo[v];
              };
              _proto21.h = function h(id, v) {
                return this.x[v].t === id;
              };
              _proto21.w = function w(v) {
                return this.x[v].t;
              };
              _proto21.object = function object(v) {
                return this.x[v].j;
              };
              _proto21.value = function value(id, v) {
                if (this.x[v].t === id) {
                  return this.x[v].j;
                } else {
                  throw Error('value id not match');
                }
              };
              _proto21.visitVertex = function visitVertex(visitor, v) {
                var vert = this.x[v];
                switch (vert.t) {
                  case 0:
                    return visitor.managed(vert.j);
                  case 1:
                    return visitor.managedBuffer(vert.j);
                  case 2:
                    return visitor.managedTexture(vert.j);
                  case 3:
                    return visitor.persistentBuffer(vert.j);
                  case 4:
                    return visitor.persistentTexture(vert.j);
                  case 5:
                    return visitor.framebuffer(vert.j);
                  case 6:
                    return visitor.swapchain(vert.j);
                  case 7:
                    return visitor.formatView(vert.j);
                  case 8:
                    return visitor.subresourceView(vert.j);
                  default:
                    throw Error('polymorphic type not found');
                }
              };
              _proto21.j = function j(v) {
                return this.x[v].j;
              };
              _proto21.reference = function reference(u, v) {
                for (var _iterator5 = _createForOfIteratorHelperLoose(this.x[u].o), _step5; !(_step5 = _iterator5()).done;) {
                  var oe = _step5.value;
                  if (v === oe.target) {
                    return true;
                  }
                }
                return false;
              };
              _proto21.parent = function parent(e) {
                return e.source;
              };
              _proto21.child = function child(e) {
                return e.target;
              };
              _proto21.children = function children(v) {
                return new OutEI(this.x[v].o.values(), v);
              };
              _proto21.numChildren = function numChildren(v) {
                return this.x[v].o.length;
              };
              _proto21.getParent = function getParent(v) {
                if (v === 0xFFFFFFFF) {
                  return 0xFFFFFFFF;
                }
                var list = this.x[v].i;
                if (list.length === 0) {
                  return 0xFFFFFFFF;
                } else {
                  return list[0].target;
                }
              };
              _proto21.addReference = function addReference(u, v) {
                return this.addEdge(u, v);
              };
              _proto21.contains = function contains(key) {
                return this._valueIndex.has(key);
              };
              _proto21.vertex = function vertex(key) {
                return this._valueIndex.get(key);
              };
              _proto21.find = function find(key) {
                var v = this._valueIndex.get(key);
                if (v === undefined) return 0xFFFFFFFF;
                return v;
              };
              return ResourceGraph;
            }();
            var ComputePass = function () {
              function ComputePass() {
                this.computeViews = new Map();
                this.textures = new Map();
              }
              var _proto22 = ComputePass.prototype;
              _proto22.reset = function reset() {
                this.computeViews.clear();
                this.textures.clear();
              };
              return ComputePass;
            }();
            var ResolvePass = function () {
              function ResolvePass() {
                this.resolvePairs = [];
              }
              var _proto23 = ResolvePass.prototype;
              _proto23.reset = function reset() {
                this.resolvePairs.length = 0;
              };
              return ResolvePass;
            }();
            var CopyPass = function () {
              function CopyPass() {
                this.copyPairs = [];
                this.uploadPairs = [];
              }
              var _proto24 = CopyPass.prototype;
              _proto24.reset = function reset() {
                this.copyPairs.length = 0;
                this.uploadPairs.length = 0;
              };
              return CopyPass;
            }();
            var MovePass = function () {
              function MovePass() {
                this.movePairs = [];
              }
              var _proto25 = MovePass.prototype;
              _proto25.reset = function reset() {
                this.movePairs.length = 0;
              };
              return MovePass;
            }();
            var RaytracePass = function () {
              function RaytracePass() {
                this.computeViews = new Map();
              }
              var _proto26 = RaytracePass.prototype;
              _proto26.reset = function reset() {
                this.computeViews.clear();
              };
              return RaytracePass;
            }();
            var ClearView = function () {
              function ClearView(slotName, clearFlags, clearColor) {
                if (slotName === undefined) {
                  slotName = '';
                }
                if (clearFlags === undefined) {
                  clearFlags = 7;
                }
                if (clearColor === undefined) {
                  clearColor = new Color$1();
                }
                this.slotName = slotName;
                this.clearFlags = clearFlags;
                this.clearColor = clearColor;
              }
              var _proto27 = ClearView.prototype;
              _proto27.reset = function reset(slotName, clearFlags) {
                this.slotName = slotName;
                this.clearFlags = clearFlags;
                resetColor(this.clearColor);
              };
              return ClearView;
            }();
            var RenderQueue$1 = function () {
              function RenderQueue(hint, phaseID, passLayoutID) {
                if (hint === undefined) {
                  hint = 1;
                }
                if (phaseID === undefined) {
                  phaseID = 0xFFFFFFFF;
                }
                if (passLayoutID === undefined) {
                  passLayoutID = 0xFFFFFFFF;
                }
                this.viewport = null;
                this.hint = hint;
                this.phaseID = phaseID;
                this.passLayoutID = passLayoutID;
              }
              var _proto28 = RenderQueue.prototype;
              _proto28.reset = function reset(hint, phaseID, passLayoutID) {
                this.hint = hint;
                this.phaseID = phaseID;
                this.passLayoutID = passLayoutID;
                this.viewport = null;
              };
              return RenderQueue;
            }();
            var SceneData = function () {
              function SceneData(scene, camera, flags, light, cullingFlags, shadingLight) {
                if (scene === undefined) {
                  scene = null;
                }
                if (camera === undefined) {
                  camera = null;
                }
                if (flags === undefined) {
                  flags = 0;
                }
                if (light === undefined) {
                  light = new LightInfo();
                }
                if (cullingFlags === undefined) {
                  cullingFlags = 1;
                }
                if (shadingLight === undefined) {
                  shadingLight = null;
                }
                this.scene = scene;
                this.camera = camera;
                this.light = light;
                this.flags = flags;
                this.cullingFlags = cullingFlags;
                this.shadingLight = shadingLight;
              }
              var _proto29 = SceneData.prototype;
              _proto29.reset = function reset(scene, camera, flags, cullingFlags, shadingLight) {
                this.scene = scene;
                this.camera = camera;
                this.light.reset(null, 0, false, null);
                this.flags = flags;
                this.cullingFlags = cullingFlags;
                this.shadingLight = shadingLight;
              };
              return SceneData;
            }();
            var Dispatch = function () {
              function Dispatch(material, passID, threadGroupCountX, threadGroupCountY, threadGroupCountZ) {
                if (material === undefined) {
                  material = null;
                }
                if (passID === undefined) {
                  passID = 0;
                }
                if (threadGroupCountX === undefined) {
                  threadGroupCountX = 0;
                }
                if (threadGroupCountY === undefined) {
                  threadGroupCountY = 0;
                }
                if (threadGroupCountZ === undefined) {
                  threadGroupCountZ = 0;
                }
                this.material = material;
                this.passID = passID;
                this.threadGroupCountX = threadGroupCountX;
                this.threadGroupCountY = threadGroupCountY;
                this.threadGroupCountZ = threadGroupCountZ;
              }
              var _proto30 = Dispatch.prototype;
              _proto30.reset = function reset(material, passID, threadGroupCountX, threadGroupCountY, threadGroupCountZ) {
                this.material = material;
                this.passID = passID;
                this.threadGroupCountX = threadGroupCountX;
                this.threadGroupCountY = threadGroupCountY;
                this.threadGroupCountZ = threadGroupCountZ;
              };
              return Dispatch;
            }();
            var Blit = function () {
              function Blit(material, passID, sceneFlags, camera, blitType) {
                if (material === undefined) {
                  material = null;
                }
                if (passID === undefined) {
                  passID = 0;
                }
                if (sceneFlags === undefined) {
                  sceneFlags = 0;
                }
                if (camera === undefined) {
                  camera = null;
                }
                if (blitType === undefined) {
                  blitType = 0;
                }
                this.models = [];
                this.material = material;
                this.passID = passID;
                this.sceneFlags = sceneFlags;
                this.camera = camera;
                this.blitType = blitType;
              }
              var _proto31 = Blit.prototype;
              _proto31.reset = function reset(material, passID, sceneFlags, camera, blitType) {
                this.material = material;
                this.passID = passID;
                this.sceneFlags = sceneFlags;
                this.camera = camera;
                this.blitType = blitType;
                this.models.length = 0;
              };
              return Blit;
            }();
            var RenderData$1 = function () {
              function RenderData() {
                this.constants = new Map();
                this.buffers = new Map();
                this.textures = new Map();
                this.samplers = new Map();
                this.custom = '';
              }
              var _proto32 = RenderData.prototype;
              _proto32.reset = function reset() {
                this.constants.clear();
                this.buffers.clear();
                this.textures.clear();
                this.samplers.clear();
                this.custom = '';
              };
              return RenderData;
            }();
            var RenderGraphVertex = function RenderGraphVertex(id, object) {
              this.o = [];
              this.i = [];
              this.c = [];
              this.p = [];
              this.t = undefined;
              this.j = undefined;
              this.id = id;
              this.object = object;
              this.t = id;
              this.j = object;
            };
            var RenderGraph = function () {
              function RenderGraph() {
                this.N = 0xFFFFFFFF;
                this.x = [];
                this._names = [];
                this._layoutNodes = [];
                this._data = [];
                this._valid = [];
                this.index = new Map();
                this.sortedVertices = [];
                this.globalRenderData = new RenderData$1();
              }
              var _proto33 = RenderGraph.prototype;
              _proto33.edge = function edge(u, v) {
                for (var _iterator6 = _createForOfIteratorHelperLoose(this.x[u].o), _step6; !(_step6 = _iterator6()).done;) {
                  var oe = _step6.value;
                  if (v === oe.target) {
                    return true;
                  }
                }
                return false;
              };
              _proto33.source = function source(e) {
                return e.source;
              };
              _proto33.target = function target(e) {
                return e.target;
              };
              _proto33.oe = function oe(v) {
                return new OutEI(this.x[v].o.values(), v);
              };
              _proto33.od = function od(v) {
                return this.x[v].o.length;
              };
              _proto33.ie = function ie(v) {
                return new InEI(this.x[v].i.values(), v);
              };
              _proto33.id = function id(v) {
                return this.x[v].i.length;
              };
              _proto33.d = function d(v) {
                return this.od(v) + this.id(v);
              };
              _proto33.adj = function adj(v) {
                return new AdjI(this, this.oe(v));
              };
              _proto33.v = function v() {
                return this.x.keys();
              };
              _proto33.nv = function nv() {
                return this.x.length;
              };
              _proto33.ne = function ne() {
                var numEdges = 0;
                for (var _iterator7 = _createForOfIteratorHelperLoose(this.v()), _step7; !(_step7 = _iterator7()).done;) {
                  var v = _step7.value;
                  numEdges += this.od(v);
                }
                return numEdges;
              };
              _proto33.clear = function clear() {
                this.index.clear();
                this.sortedVertices.length = 0;
                this.globalRenderData.reset();
                this._names.length = 0;
                this._layoutNodes.length = 0;
                this._data.length = 0;
                this._valid.length = 0;
                this.x.length = 0;
              };
              _proto33.addVertex = function addVertex(id, object, name, layout, data, valid, u) {
                if (u === undefined) {
                  u = 0xFFFFFFFF;
                }
                var vert = new RenderGraphVertex(id, object);
                var v = this.x.length;
                this.x.push(vert);
                this._names.push(name);
                this._layoutNodes.push(layout);
                this._data.push(data);
                this._valid.push(valid);
                if (u !== 0xFFFFFFFF) {
                  this.x[u].c.push(new OutE(v));
                  vert.p.push(new OutE(u));
                }
                return v;
              };
              _proto33.addEdge = function addEdge(u, v) {
                this.x[u].o.push(new OutE(v));
                this.x[v].i.push(new OutE(u));
                return new ED(u, v);
              };
              _proto33.vertexName = function vertexName(v) {
                return this._names[v];
              };
              _proto33.getName = function getName(v) {
                return this._names[v];
              };
              _proto33.setName = function setName(v, value) {
                this._names[v] = value;
              };
              _proto33.getLayout = function getLayout(v) {
                return this._layoutNodes[v];
              };
              _proto33.setLayout = function setLayout(v, value) {
                this._layoutNodes[v] = value;
              };
              _proto33.getData = function getData(v) {
                return this._data[v];
              };
              _proto33.getValid = function getValid(v) {
                return this._valid[v];
              };
              _proto33.setValid = function setValid(v, value) {
                this._valid[v] = value;
              };
              _proto33.h = function h(id, v) {
                return this.x[v].t === id;
              };
              _proto33.w = function w(v) {
                return this.x[v].t;
              };
              _proto33.object = function object(v) {
                return this.x[v].j;
              };
              _proto33.value = function value(id, v) {
                if (this.x[v].t === id) {
                  return this.x[v].j;
                } else {
                  throw Error('value id not match');
                }
              };
              _proto33.visitVertex = function visitVertex(visitor, v) {
                var vert = this.x[v];
                switch (vert.t) {
                  case 0:
                    return visitor.rasterPass(vert.j);
                  case 1:
                    return visitor.rasterSubpass(vert.j);
                  case 2:
                    return visitor.computeSubpass(vert.j);
                  case 3:
                    return visitor.compute(vert.j);
                  case 4:
                    return visitor.resolve(vert.j);
                  case 5:
                    return visitor.copy(vert.j);
                  case 6:
                    return visitor.move(vert.j);
                  case 7:
                    return visitor.raytrace(vert.j);
                  case 8:
                    return visitor.queue(vert.j);
                  case 9:
                    return visitor.scene(vert.j);
                  case 10:
                    return visitor.blit(vert.j);
                  case 11:
                    return visitor.dispatch(vert.j);
                  case 12:
                    return visitor.clear(vert.j);
                  case 13:
                    return visitor.viewport(vert.j);
                  default:
                    throw Error('polymorphic type not found');
                }
              };
              _proto33.j = function j(v) {
                return this.x[v].j;
              };
              _proto33.reference = function reference(u, v) {
                for (var _iterator8 = _createForOfIteratorHelperLoose(this.x[u].c), _step8; !(_step8 = _iterator8()).done;) {
                  var oe = _step8.value;
                  if (v === oe.target) {
                    return true;
                  }
                }
                return false;
              };
              _proto33.parent = function parent(e) {
                return e.source;
              };
              _proto33.child = function child(e) {
                return e.target;
              };
              _proto33.children = function children(v) {
                return new OutEI(this.x[v].c.values(), v);
              };
              _proto33.numChildren = function numChildren(v) {
                return this.x[v].c.length;
              };
              _proto33.getParent = function getParent(v) {
                if (v === 0xFFFFFFFF) {
                  return 0xFFFFFFFF;
                }
                var list = this.x[v].p;
                if (list.length === 0) {
                  return 0xFFFFFFFF;
                } else {
                  return list[0].target;
                }
              };
              _proto33.addReference = function addReference(u, v) {
                this.x[u].c.push(new OutE(v));
                this.x[v].p.push(new OutE(u));
                return new ED(u, v);
              };
              return RenderGraph;
            }();
            function createPool(Constructor) {
              return new RecyclePool(function () {
                return new Constructor();
              }, 16);
            }
            var RenderGraphObjectPool = function () {
              function RenderGraphObjectPool(renderCommon) {
                this.renderCommon = undefined;
                this.cv = createPool(ClearValue);
                this.rv = createPool(RasterView);
                this.cv1 = createPool(ComputeView);
                this.rd = createPool(ResourceDesc);
                this.rt = createPool(ResourceTraits);
                this.rs = createPool(RenderSwapchain);
                this.rs1 = createPool(ResourceStates);
                this.mb = createPool(ManagedBuffer);
                this.pb = createPool(PersistentBuffer);
                this.mt = createPool(ManagedTexture);
                this.pt = createPool(PersistentTexture);
                this.mr = createPool(ManagedResource);
                this.s = createPool(Subpass);
                this.sg = createPool(SubpassGraph);
                this.rs2 = createPool(RasterSubpass);
                this.cs = createPool(ComputeSubpass);
                this.rp = createPool(RasterPass);
                this.prpaf = createPool(PersistentRenderPassAndFramebuffer);
                this.fv = createPool(FormatView);
                this.sv = createPool(SubresourceView);
                this.rg = createPool(ResourceGraph);
                this.cp = createPool(ComputePass);
                this.rp1 = createPool(ResolvePass);
                this.cp1 = createPool(CopyPass);
                this.mp = createPool(MovePass);
                this.rp2 = createPool(RaytracePass);
                this.cv2 = createPool(ClearView);
                this.rq = createPool(RenderQueue$1);
                this.sd = createPool(SceneData);
                this.d = createPool(Dispatch);
                this.b = createPool(Blit);
                this.rd1 = createPool(RenderData$1);
                this.rg1 = createPool(RenderGraph);
                this.renderCommon = renderCommon;
              }
              var _proto34 = RenderGraphObjectPool.prototype;
              _proto34.reset = function reset() {
                this.cv.reset();
                this.rv.reset();
                this.cv1.reset();
                this.rd.reset();
                this.rt.reset();
                this.rs.reset();
                this.rs1.reset();
                this.mb.reset();
                this.pb.reset();
                this.mt.reset();
                this.pt.reset();
                this.mr.reset();
                this.s.reset();
                this.sg.reset();
                this.rs2.reset();
                this.cs.reset();
                this.rp.reset();
                this.prpaf.reset();
                this.fv.reset();
                this.sv.reset();
                this.rg.reset();
                this.cp.reset();
                this.rp1.reset();
                this.cp1.reset();
                this.mp.reset();
                this.rp2.reset();
                this.cv2.reset();
                this.rq.reset();
                this.sd.reset();
                this.d.reset();
                this.b.reset();
                this.rd1.reset();
                this.rg1.reset();
              };
              _proto34.createClearValue = function createClearValue(x, y, z, w) {
                if (x === undefined) {
                  x = 0;
                }
                if (y === undefined) {
                  y = 0;
                }
                if (z === undefined) {
                  z = 0;
                }
                if (w === undefined) {
                  w = 0;
                }
                var v = this.cv.add();
                v.reset(x, y, z, w);
                return v;
              };
              _proto34.createRasterView = function createRasterView(slotName, accessType, attachmentType, loadOp, storeOp, clearFlags, shaderStageFlags) {
                if (slotName === undefined) {
                  slotName = '';
                }
                if (accessType === undefined) {
                  accessType = 2;
                }
                if (attachmentType === undefined) {
                  attachmentType = 0;
                }
                if (loadOp === undefined) {
                  loadOp = 0;
                }
                if (storeOp === undefined) {
                  storeOp = 0;
                }
                if (clearFlags === undefined) {
                  clearFlags = 7;
                }
                if (shaderStageFlags === undefined) {
                  shaderStageFlags = 0;
                }
                var v = this.rv.add();
                v.reset(slotName, accessType, attachmentType, loadOp, storeOp, clearFlags, shaderStageFlags);
                return v;
              };
              _proto34.createComputeView = function createComputeView(name, accessType, clearFlags, clearValueType, shaderStageFlags) {
                if (name === undefined) {
                  name = '';
                }
                if (accessType === undefined) {
                  accessType = 0;
                }
                if (clearFlags === undefined) {
                  clearFlags = 0;
                }
                if (clearValueType === undefined) {
                  clearValueType = 0;
                }
                if (shaderStageFlags === undefined) {
                  shaderStageFlags = 0;
                }
                var v = this.cv1.add();
                v.reset(name, accessType, clearFlags, clearValueType, shaderStageFlags);
                return v;
              };
              _proto34.createResourceDesc = function createResourceDesc() {
                var v = this.rd.add();
                v.reset();
                return v;
              };
              _proto34.createResourceTraits = function createResourceTraits(residency) {
                if (residency === undefined) {
                  residency = 0;
                }
                var v = this.rt.add();
                v.reset(residency);
                return v;
              };
              _proto34.createRenderSwapchain = function createRenderSwapchain(swapchain, isDepthStencil) {
                if (swapchain === undefined) {
                  swapchain = null;
                }
                if (isDepthStencil === undefined) {
                  isDepthStencil = false;
                }
                var v = this.rs.add();
                v.reset(swapchain, isDepthStencil);
                return v;
              };
              _proto34.createResourceStates = function createResourceStates() {
                var v = this.rs1.add();
                v.reset();
                return v;
              };
              _proto34.createManagedBuffer = function createManagedBuffer(buffer) {
                if (buffer === undefined) {
                  buffer = null;
                }
                var v = this.mb.add();
                v.reset(buffer);
                return v;
              };
              _proto34.createPersistentBuffer = function createPersistentBuffer(buffer) {
                if (buffer === undefined) {
                  buffer = null;
                }
                var v = this.pb.add();
                v.reset(buffer);
                return v;
              };
              _proto34.createManagedTexture = function createManagedTexture(texture) {
                if (texture === undefined) {
                  texture = null;
                }
                var v = this.mt.add();
                v.reset(texture);
                return v;
              };
              _proto34.createPersistentTexture = function createPersistentTexture(texture) {
                if (texture === undefined) {
                  texture = null;
                }
                var v = this.pt.add();
                v.reset(texture);
                return v;
              };
              _proto34.createManagedResource = function createManagedResource() {
                var v = this.mr.add();
                v.reset();
                return v;
              };
              _proto34.createSubpass = function createSubpass() {
                var v = this.s.add();
                v.reset();
                return v;
              };
              _proto34.createSubpassGraph = function createSubpassGraph() {
                var v = this.sg.add();
                v.clear();
                return v;
              };
              _proto34.createRasterSubpass = function createRasterSubpass(subpassID, count, quality) {
                if (subpassID === undefined) {
                  subpassID = 0xFFFFFFFF;
                }
                if (count === undefined) {
                  count = 1;
                }
                if (quality === undefined) {
                  quality = 0;
                }
                var v = this.rs2.add();
                v.reset(subpassID, count, quality);
                return v;
              };
              _proto34.createComputeSubpass = function createComputeSubpass(subpassID) {
                if (subpassID === undefined) {
                  subpassID = 0xFFFFFFFF;
                }
                var v = this.cs.add();
                v.reset(subpassID);
                return v;
              };
              _proto34.createRasterPass = function createRasterPass() {
                var v = this.rp.add();
                v.reset();
                return v;
              };
              _proto34.createPersistentRenderPassAndFramebuffer = function createPersistentRenderPassAndFramebuffer(renderPass, framebuffer) {
                if (renderPass === undefined) {
                  renderPass = null;
                }
                if (framebuffer === undefined) {
                  framebuffer = null;
                }
                var v = this.prpaf.add();
                v.reset(renderPass, framebuffer);
                return v;
              };
              _proto34.createFormatView = function createFormatView() {
                var v = this.fv.add();
                v.reset();
                return v;
              };
              _proto34.createSubresourceView = function createSubresourceView() {
                var v = this.sv.add();
                v.reset();
                return v;
              };
              _proto34.createResourceGraph = function createResourceGraph() {
                var v = this.rg.add();
                v.clear();
                return v;
              };
              _proto34.createComputePass = function createComputePass() {
                var v = this.cp.add();
                v.reset();
                return v;
              };
              _proto34.createResolvePass = function createResolvePass() {
                var v = this.rp1.add();
                v.reset();
                return v;
              };
              _proto34.createCopyPass = function createCopyPass() {
                var v = this.cp1.add();
                v.reset();
                return v;
              };
              _proto34.createMovePass = function createMovePass() {
                var v = this.mp.add();
                v.reset();
                return v;
              };
              _proto34.createRaytracePass = function createRaytracePass() {
                var v = this.rp2.add();
                v.reset();
                return v;
              };
              _proto34.createClearView = function createClearView(slotName, clearFlags) {
                if (slotName === undefined) {
                  slotName = '';
                }
                if (clearFlags === undefined) {
                  clearFlags = 7;
                }
                var v = this.cv2.add();
                v.reset(slotName, clearFlags);
                return v;
              };
              _proto34.createRenderQueue = function createRenderQueue(hint, phaseID, passLayoutID) {
                if (hint === undefined) {
                  hint = 1;
                }
                if (phaseID === undefined) {
                  phaseID = 0xFFFFFFFF;
                }
                if (passLayoutID === undefined) {
                  passLayoutID = 0xFFFFFFFF;
                }
                var v = this.rq.add();
                v.reset(hint, phaseID, passLayoutID);
                return v;
              };
              _proto34.createSceneData = function createSceneData(scene, camera, flags, cullingFlags, shadingLight) {
                if (scene === undefined) {
                  scene = null;
                }
                if (camera === undefined) {
                  camera = null;
                }
                if (flags === undefined) {
                  flags = 0;
                }
                if (cullingFlags === undefined) {
                  cullingFlags = 1;
                }
                if (shadingLight === undefined) {
                  shadingLight = null;
                }
                var v = this.sd.add();
                v.reset(scene, camera, flags, cullingFlags, shadingLight);
                return v;
              };
              _proto34.createDispatch = function createDispatch(material, passID, threadGroupCountX, threadGroupCountY, threadGroupCountZ) {
                if (material === undefined) {
                  material = null;
                }
                if (passID === undefined) {
                  passID = 0;
                }
                if (threadGroupCountX === undefined) {
                  threadGroupCountX = 0;
                }
                if (threadGroupCountY === undefined) {
                  threadGroupCountY = 0;
                }
                if (threadGroupCountZ === undefined) {
                  threadGroupCountZ = 0;
                }
                var v = this.d.add();
                v.reset(material, passID, threadGroupCountX, threadGroupCountY, threadGroupCountZ);
                return v;
              };
              _proto34.createBlit = function createBlit(material, passID, sceneFlags, camera, blitType) {
                if (material === undefined) {
                  material = null;
                }
                if (passID === undefined) {
                  passID = 0;
                }
                if (sceneFlags === undefined) {
                  sceneFlags = 0;
                }
                if (camera === undefined) {
                  camera = null;
                }
                if (blitType === undefined) {
                  blitType = 0;
                }
                var v = this.b.add();
                v.reset(material, passID, sceneFlags, camera, blitType);
                return v;
              };
              _proto34.createRenderData = function createRenderData() {
                var v = this.rd1.add();
                v.reset();
                return v;
              };
              _proto34.createRenderGraph = function createRenderGraph() {
                var v = this.rg1.add();
                v.clear();
                return v;
              };
              return RenderGraphObjectPool;
            }();

            var PipelineType = {
              BASIC: 0,
              STANDARD: 1
            };
            var SubpassCapabilities = {
              NONE: 0,
              INPUT_DEPTH_STENCIL: 1,
              INPUT_COLOR: 2,
              INPUT_COLOR_MRT: 4,
              HETEROGENEOUS_SAMPLE_COUNT: 8
            };
            var PipelineCapabilities = function PipelineCapabilities() {
              this.subpass = 0;
            };

            function loadUniform(ar, v) {
              v.name = ar.s();
              v.type = ar.n();
              v.count = ar.n();
            }
            function loadUniformBlock(ar, v) {
              v.set = ar.n();
              v.binding = ar.n();
              v.name = ar.s();
              var sz = 0;
              sz = ar.n();
              v.members.length = sz;
              for (var i = 0; i !== sz; ++i) {
                var v1 = new Uniform();
                loadUniform(ar, v1);
                v.members[i] = v1;
              }
              v.count = ar.n();
            }
            function loadDescriptorSetLayoutBinding(ar, v) {
              v.binding = ar.n();
              v.descriptorType = ar.n();
              v.count = ar.n();
              v.stageFlags = ar.n();
            }
            function loadDescriptorSetLayoutInfo(ar, v) {
              var sz = ar.n();
              v.bindings.length = sz;
              for (var i = 0; i !== sz; ++i) {
                var v1 = new DescriptorSetLayoutBinding();
                loadDescriptorSetLayoutBinding(ar, v1);
                v.bindings[i] = v1;
              }
            }

            function resetDescriptorSetLayoutInfo(info) {
              info.bindings.length = 0;
            }
            var Layout = function Layout() {};
            Layout.type = 0;
            Layout.isWebGPU = false;
            var DescriptorData = function () {
              function DescriptorData(descriptorID, type, count) {
                if (descriptorID === undefined) {
                  descriptorID = 0;
                }
                if (type === undefined) {
                  type = 0;
                }
                if (count === undefined) {
                  count = 1;
                }
                this.descriptorID = descriptorID;
                this.type = type;
                this.count = count;
              }
              var _proto9 = DescriptorData.prototype;
              _proto9.reset = function reset(descriptorID, type, count) {
                this.descriptorID = descriptorID;
                this.type = type;
                this.count = count;
              };
              return DescriptorData;
            }();
            var DescriptorBlockData = function () {
              function DescriptorBlockData(type, visibility, capacity, accessType, viewDimension, sampleType, format) {
                if (type === undefined) {
                  type = 0;
                }
                if (visibility === undefined) {
                  visibility = 0;
                }
                if (capacity === undefined) {
                  capacity = 0;
                }
                if (accessType === undefined) {
                  accessType = 1;
                }
                if (viewDimension === undefined) {
                  viewDimension = 0;
                }
                if (sampleType === undefined) {
                  sampleType = 0;
                }
                if (format === undefined) {
                  format = 0;
                }
                this.offset = 0;
                this.descriptors = [];
                this.type = type;
                this.visibility = visibility;
                this.capacity = capacity;
                this.accessType = accessType;
                this.viewDimension = viewDimension;
                this.sampleType = sampleType;
                this.format = format;
              }
              var _proto10 = DescriptorBlockData.prototype;
              _proto10.reset = function reset(type, visibility, capacity, accessType, viewDimension, sampleType, format) {
                this.type = type;
                this.visibility = visibility;
                this.offset = 0;
                this.capacity = capacity;
                this.accessType = accessType;
                this.viewDimension = viewDimension;
                this.sampleType = sampleType;
                this.format = format;
                this.descriptors.length = 0;
              };
              return DescriptorBlockData;
            }();
            var DescriptorSetLayoutData = function () {
              function DescriptorSetLayoutData(slot, capacity, descriptorBlocks, uniformBlocks, bindingMap) {
                if (slot === undefined) {
                  slot = 0xFFFFFFFF;
                }
                if (capacity === undefined) {
                  capacity = 0;
                }
                if (descriptorBlocks === undefined) {
                  descriptorBlocks = [];
                }
                if (uniformBlocks === undefined) {
                  uniformBlocks = new Map();
                }
                if (bindingMap === undefined) {
                  bindingMap = new Map();
                }
                this.uniformBlockCapacity = 0;
                this.samplerTextureCapacity = 0;
                this.slot = slot;
                this.capacity = capacity;
                this.descriptorBlocks = descriptorBlocks;
                this.uniformBlocks = uniformBlocks;
                this.bindingMap = bindingMap;
              }
              var _proto11 = DescriptorSetLayoutData.prototype;
              _proto11.reset = function reset(slot, capacity) {
                this.slot = slot;
                this.capacity = capacity;
                this.uniformBlockCapacity = 0;
                this.samplerTextureCapacity = 0;
                this.descriptorBlocks.length = 0;
                this.uniformBlocks.clear();
                this.bindingMap.clear();
              };
              return DescriptorSetLayoutData;
            }();
            var DescriptorSetData = function () {
              function DescriptorSetData(descriptorSetLayoutData, descriptorSetLayout, descriptorSet) {
                if (descriptorSetLayoutData === undefined) {
                  descriptorSetLayoutData = new DescriptorSetLayoutData();
                }
                if (descriptorSetLayout === undefined) {
                  descriptorSetLayout = null;
                }
                if (descriptorSet === undefined) {
                  descriptorSet = null;
                }
                this.descriptorSetLayoutInfo = new DescriptorSetLayoutInfo();
                this.descriptorSetLayoutData = descriptorSetLayoutData;
                this.descriptorSetLayout = descriptorSetLayout;
                this.descriptorSet = descriptorSet;
              }
              var _proto12 = DescriptorSetData.prototype;
              _proto12.reset = function reset(descriptorSetLayout, descriptorSet) {
                this.descriptorSetLayoutData.reset(0xFFFFFFFF, 0);
                resetDescriptorSetLayoutInfo(this.descriptorSetLayoutInfo);
                this.descriptorSetLayout = descriptorSetLayout;
                this.descriptorSet = descriptorSet;
              };
              return DescriptorSetData;
            }();
            var PipelineLayoutData = function () {
              function PipelineLayoutData() {
                this.descriptorSets = new Map();
                this.descriptorGroups = new Map();
              }
              var _proto13 = PipelineLayoutData.prototype;
              _proto13.reset = function reset() {
                this.descriptorSets.clear();
                this.descriptorGroups.clear();
              };
              _proto13.getSets = function getSets() {
                return Layout.isWebGPU ? this.descriptorGroups : this.descriptorSets;
              };
              _proto13.getSet = function getSet(frequency) {
                return Layout.isWebGPU ? this.descriptorGroups.get(frequency) : this.descriptorSets.get(frequency);
              };
              return PipelineLayoutData;
            }();
            var ShaderBindingData = function () {
              function ShaderBindingData() {
                this.descriptorBindings = new Map();
              }
              var _proto14 = ShaderBindingData.prototype;
              _proto14.reset = function reset() {
                this.descriptorBindings.clear();
              };
              return ShaderBindingData;
            }();
            var ShaderLayoutData = function () {
              function ShaderLayoutData() {
                this.layoutData = new Map();
                this.bindingData = new Map();
              }
              var _proto15 = ShaderLayoutData.prototype;
              _proto15.reset = function reset() {
                this.layoutData.clear();
                this.bindingData.clear();
              };
              return ShaderLayoutData;
            }();
            var TechniqueData = function () {
              function TechniqueData() {
                this.passes = [];
              }
              var _proto16 = TechniqueData.prototype;
              _proto16.reset = function reset() {
                this.passes.length = 0;
              };
              return TechniqueData;
            }();
            var EffectData = function () {
              function EffectData() {
                this.techniques = new Map();
              }
              var _proto17 = EffectData.prototype;
              _proto17.reset = function reset() {
                this.techniques.clear();
              };
              return EffectData;
            }();
            var ShaderProgramData = function () {
              function ShaderProgramData() {
                this.layout = new PipelineLayoutData();
                this.pipelineLayout = null;
              }
              var _proto18 = ShaderProgramData.prototype;
              _proto18.reset = function reset() {
                this.layout.reset();
                this.pipelineLayout = null;
              };
              return ShaderProgramData;
            }();
            var RenderStageData = function () {
              function RenderStageData() {
                this.descriptorVisibility = new Map();
              }
              var _proto19 = RenderStageData.prototype;
              _proto19.reset = function reset() {
                this.descriptorVisibility.clear();
              };
              return RenderStageData;
            }();
            var RenderPhaseData = function () {
              function RenderPhaseData() {
                this.rootSignature = '';
                this.shaderPrograms = [];
                this.shaderIndex = new Map();
                this.pipelineLayout = null;
              }
              var _proto20 = RenderPhaseData.prototype;
              _proto20.reset = function reset() {
                this.rootSignature = '';
                this.shaderPrograms.length = 0;
                this.shaderIndex.clear();
                this.pipelineLayout = null;
              };
              return RenderPhaseData;
            }();
            var LayoutGraphDataVertex = function LayoutGraphDataVertex(id, object) {
              this.o = [];
              this.i = [];
              this.t = undefined;
              this.j = undefined;
              this.id = id;
              this.object = object;
              this.t = id;
              this.j = object;
            };
            var LayoutGraphData = function () {
              function LayoutGraphData() {
                this.N = 0xFFFFFFFF;
                this.x = [];
                this._names = [];
                this._updateFrequencies = [];
                this._layouts = [];
                this.valueNames = [];
                this.attributeIndex = new Map();
                this.constantIndex = new Map();
                this.shaderLayoutIndex = new Map();
                this.effects = new Map();
                this.constantMacros = '';
              }
              var _proto21 = LayoutGraphData.prototype;
              _proto21.edge = function edge(u, v) {
                for (var _iterator6 = _createForOfIteratorHelperLoose(this.x[u].o), _step6; !(_step6 = _iterator6()).done;) {
                  var oe = _step6.value;
                  if (v === oe.target) {
                    return true;
                  }
                }
                return false;
              };
              _proto21.source = function source(e) {
                return e.source;
              };
              _proto21.target = function target(e) {
                return e.target;
              };
              _proto21.oe = function oe(v) {
                return new OutEI(this.x[v].o.values(), v);
              };
              _proto21.od = function od(v) {
                return this.x[v].o.length;
              };
              _proto21.ie = function ie(v) {
                return new InEI(this.x[v].i.values(), v);
              };
              _proto21.id = function id(v) {
                return this.x[v].i.length;
              };
              _proto21.d = function d(v) {
                return this.od(v) + this.id(v);
              };
              _proto21.adj = function adj(v) {
                return new AdjI(this, this.oe(v));
              };
              _proto21.v = function v() {
                return this.x.keys();
              };
              _proto21.nv = function nv() {
                return this.x.length;
              };
              _proto21.ne = function ne() {
                var numEdges = 0;
                for (var _iterator7 = _createForOfIteratorHelperLoose(this.v()), _step7; !(_step7 = _iterator7()).done;) {
                  var v = _step7.value;
                  numEdges += this.od(v);
                }
                return numEdges;
              };
              _proto21.clear = function clear() {
                this.valueNames.length = 0;
                this.attributeIndex.clear();
                this.constantIndex.clear();
                this.shaderLayoutIndex.clear();
                this.effects.clear();
                this.constantMacros = '';
                this._names.length = 0;
                this._updateFrequencies.length = 0;
                this._layouts.length = 0;
                this.x.length = 0;
              };
              _proto21.addVertex = function addVertex(id, object, name, update, layout, u) {
                if (u === undefined) {
                  u = 0xFFFFFFFF;
                }
                var vert = new LayoutGraphDataVertex(id, object);
                var v = this.x.length;
                this.x.push(vert);
                this._names.push(name);
                this._updateFrequencies.push(update);
                this._layouts.push(layout);
                if (u !== 0xFFFFFFFF) {
                  this.addEdge(u, v);
                }
                return v;
              };
              _proto21.addEdge = function addEdge(u, v) {
                this.x[u].o.push(new OutE(v));
                this.x[v].i.push(new OutE(u));
                return new ED(u, v);
              };
              _proto21.vertexName = function vertexName(v) {
                return this._names[v];
              };
              _proto21.getName = function getName(v) {
                return this._names[v];
              };
              _proto21.getUpdate = function getUpdate(v) {
                return this._updateFrequencies[v];
              };
              _proto21.setUpdate = function setUpdate(v, value) {
                this._updateFrequencies[v] = value;
              };
              _proto21.getLayout = function getLayout(v) {
                return this._layouts[v];
              };
              _proto21.h = function h(id, v) {
                return this.x[v].t === id;
              };
              _proto21.w = function w(v) {
                return this.x[v].t;
              };
              _proto21.object = function object(v) {
                return this.x[v].j;
              };
              _proto21.value = function value(id, v) {
                if (this.x[v].t === id) {
                  return this.x[v].j;
                } else {
                  throw Error('value id not match');
                }
              };
              _proto21.visitVertex = function visitVertex(visitor, v) {
                var vert = this.x[v];
                switch (vert.t) {
                  case 0:
                    return visitor.renderStage(vert.j);
                  case 1:
                    return visitor.renderPhase(vert.j);
                  default:
                    throw Error('polymorphic type not found');
                }
              };
              _proto21.j = function j(v) {
                return this.x[v].j;
              };
              _proto21.reference = function reference(u, v) {
                for (var _iterator8 = _createForOfIteratorHelperLoose(this.x[u].o), _step8; !(_step8 = _iterator8()).done;) {
                  var oe = _step8.value;
                  if (v === oe.target) {
                    return true;
                  }
                }
                return false;
              };
              _proto21.parent = function parent(e) {
                return e.source;
              };
              _proto21.child = function child(e) {
                return e.target;
              };
              _proto21.children = function children(v) {
                return new OutEI(this.x[v].o.values(), v);
              };
              _proto21.numChildren = function numChildren(v) {
                return this.x[v].o.length;
              };
              _proto21.getParent = function getParent(v) {
                if (v === 0xFFFFFFFF) {
                  return 0xFFFFFFFF;
                }
                var list = this.x[v].i;
                if (list.length === 0) {
                  return 0xFFFFFFFF;
                } else {
                  return list[0].target;
                }
              };
              _proto21.addReference = function addReference(u, v) {
                return this.addEdge(u, v);
              };
              _proto21.locateChild = function locateChild(u, name) {
                if (u === 0xFFFFFFFF) {
                  for (var _iterator9 = _createForOfIteratorHelperLoose(this.x.keys()), _step9; !(_step9 = _iterator9()).done;) {
                    var v = _step9.value;
                    var vert = this.x[v];
                    if (vert.i.length === 0 && this._names[v] === name) {
                      return v;
                    }
                  }
                  return 0xFFFFFFFF;
                }
                for (var _iterator10 = _createForOfIteratorHelperLoose(this.x[u].o), _step10; !(_step10 = _iterator10()).done;) {
                  var oe = _step10.value;
                  var child = oe.target;
                  if (name === this._names[child]) {
                    return child;
                  }
                }
                return 0xFFFFFFFF;
              };
              _proto21.locate = function locate(absPath) {
                return findRelative(this, 0xFFFFFFFF, absPath);
              };
              _proto21.locateRelative = function locateRelative(path, start) {
                if (start === undefined) {
                  start = 0xFFFFFFFF;
                }
                return findRelative(this, start, path);
              };
              _proto21.path = function path(v) {
                return getPath(this, v);
              };
              return LayoutGraphData;
            }();
            function loadDescriptorData(a, v) {
              v.descriptorID = a.n();
              v.type = a.n();
              v.count = a.n();
            }
            function loadDescriptorBlockData(a, v) {
              v.type = a.n();
              v.visibility = a.n();
              v.offset = a.n();
              v.capacity = a.n();
              v.accessType = a.n();
              v.viewDimension = a.n();
              v.sampleType = a.n();
              v.format = a.n();
              var sz = 0;
              sz = a.n();
              v.descriptors.length = sz;
              for (var i1 = 0; i1 !== sz; ++i1) {
                var v1 = new DescriptorData();
                loadDescriptorData(a, v1);
                v.descriptors[i1] = v1;
              }
            }
            function loadDescriptorSetLayoutData(a, v) {
              v.slot = a.n();
              v.capacity = a.n();
              v.uniformBlockCapacity = a.n();
              v.samplerTextureCapacity = a.n();
              var sz = 0;
              sz = a.n();
              v.descriptorBlocks.length = sz;
              for (var i1 = 0; i1 !== sz; ++i1) {
                var v1 = new DescriptorBlockData();
                loadDescriptorBlockData(a, v1);
                v.descriptorBlocks[i1] = v1;
              }
              sz = a.n();
              for (var _i6 = 0; _i6 !== sz; ++_i6) {
                var k1 = a.n();
                var _v12 = new UniformBlock();
                loadUniformBlock(a, _v12);
                v.uniformBlocks.set(k1, _v12);
              }
              sz = a.n();
              for (var _i7 = 0; _i7 !== sz; ++_i7) {
                var _k6 = a.n();
                var _v13 = a.n();
                v.bindingMap.set(_k6, _v13);
              }
            }
            function loadDescriptorSetData(a, v) {
              loadDescriptorSetLayoutData(a, v.descriptorSetLayoutData);
              loadDescriptorSetLayoutInfo(a, v.descriptorSetLayoutInfo);
            }
            function loadPipelineLayoutData(a, v) {
              var sz = 0;
              sz = a.n();
              for (var i1 = 0; i1 !== sz; ++i1) {
                var k1 = a.n();
                var v1 = new DescriptorSetData();
                loadDescriptorSetData(a, v1);
                v.descriptorSets.set(k1, v1);
              }
              sz = a.n();
              for (var _i8 = 0; _i8 !== sz; ++_i8) {
                var _k8 = a.n();
                var _v15 = new DescriptorSetData();
                loadDescriptorSetData(a, _v15);
                v.descriptorGroups.set(_k8, _v15);
              }
            }
            function loadShaderBindingData(a, v) {
              var sz = 0;
              sz = a.n();
              for (var i1 = 0; i1 !== sz; ++i1) {
                var k1 = a.n();
                var v1 = a.n();
                v.descriptorBindings.set(k1, v1);
              }
            }
            function loadShaderLayoutData(a, v) {
              var sz = 0;
              sz = a.n();
              for (var i1 = 0; i1 !== sz; ++i1) {
                var k1 = a.n();
                var v1 = new DescriptorSetLayoutData();
                loadDescriptorSetLayoutData(a, v1);
                v.layoutData.set(k1, v1);
              }
              sz = a.n();
              for (var _i9 = 0; _i9 !== sz; ++_i9) {
                var _k10 = a.n();
                var _v17 = new ShaderBindingData();
                loadShaderBindingData(a, _v17);
                v.bindingData.set(_k10, _v17);
              }
            }
            function loadTechniqueData(a, v) {
              var sz = 0;
              sz = a.n();
              v.passes.length = sz;
              for (var i1 = 0; i1 !== sz; ++i1) {
                var v1 = new ShaderLayoutData();
                loadShaderLayoutData(a, v1);
                v.passes[i1] = v1;
              }
            }
            function loadEffectData(a, v) {
              var sz = 0;
              sz = a.n();
              for (var i1 = 0; i1 !== sz; ++i1) {
                var k1 = a.s();
                var v1 = new TechniqueData();
                loadTechniqueData(a, v1);
                v.techniques.set(k1, v1);
              }
            }
            function loadShaderProgramData(a, v) {
              loadPipelineLayoutData(a, v.layout);
            }
            function loadRenderStageData(a, v) {
              var sz = 0;
              sz = a.n();
              for (var i1 = 0; i1 !== sz; ++i1) {
                var k1 = a.n();
                var v1 = a.n();
                v.descriptorVisibility.set(k1, v1);
              }
            }
            function loadRenderPhaseData(a, v) {
              v.rootSignature = a.s();
              var sz = 0;
              sz = a.n();
              v.shaderPrograms.length = sz;
              for (var i1 = 0; i1 !== sz; ++i1) {
                var v1 = new ShaderProgramData();
                loadShaderProgramData(a, v1);
                v.shaderPrograms[i1] = v1;
              }
              sz = a.n();
              for (var _i10 = 0; _i10 !== sz; ++_i10) {
                var k1 = a.s();
                var _v19 = a.n();
                v.shaderIndex.set(k1, _v19);
              }
            }
            function loadLayoutGraphData(a, g) {
              var numVertices = a.n();
              a.n();
              a.n();
              a.n();
              for (var v = 0; v !== numVertices; ++v) {
                var _id2 = a.n();
                var u = a.n();
                var name = a.s();
                var update = a.n();
                var layout = new PipelineLayoutData();
                loadPipelineLayoutData(a, layout);
                switch (_id2) {
                  case 0:
                    {
                      var _renderStage2 = new RenderStageData();
                      loadRenderStageData(a, _renderStage2);
                      g.addVertex(0, _renderStage2, name, update, layout, u);
                      break;
                    }
                  case 1:
                    {
                      var _renderPhase2 = new RenderPhaseData();
                      loadRenderPhaseData(a, _renderPhase2);
                      g.addVertex(1, _renderPhase2, name, update, layout, u);
                      break;
                    }
                }
              }
              var sz = 0;
              sz = a.n();
              g.valueNames.length = sz;
              for (var i1 = 0; i1 !== sz; ++i1) {
                g.valueNames[i1] = a.s();
              }
              sz = a.n();
              for (var _i11 = 0; _i11 !== sz; ++_i11) {
                var k1 = a.s();
                var v1 = a.n();
                g.attributeIndex.set(k1, v1);
              }
              sz = a.n();
              for (var _i12 = 0; _i12 !== sz; ++_i12) {
                var _k14 = a.s();
                var _v25 = a.n();
                g.constantIndex.set(_k14, _v25);
              }
              sz = a.n();
              for (var _i13 = 0; _i13 !== sz; ++_i13) {
                var _k15 = a.s();
                var _v26 = a.n();
                g.shaderLayoutIndex.set(_k15, _v26);
              }
              sz = a.n();
              for (var _i14 = 0; _i14 !== sz; ++_i14) {
                var _k16 = a.s();
                var _v27 = new EffectData();
                loadEffectData(a, _v27);
                g.effects.set(_k16, _v27);
              }
            }

            var VectorGraphColorMap = function () {
              function VectorGraphColorMap(sz) {
                this.colors = undefined;
                this.colors = new Array(sz);
              }
              var _proto = VectorGraphColorMap.prototype;
              _proto.get = function get(u) {
                return this.colors[u];
              };
              _proto.put = function put(u, value) {
                this.colors[u] = value;
              };
              return VectorGraphColorMap;
            }();

            function getUBOTypeCount(type) {
              switch (type) {
                case 1:
                case 5:
                case 9:
                case 13:
                  return 1;
                case 6:
                case 14:
                case 10:
                case 2:
                  return 2;
                case 15:
                case 3:
                case 11:
                case 7:
                  return 3;
                case 4:
                case 16:
                case 12:
                case 8:
                  return 4;
                case 17:
                  return 4;
                case 18:
                case 20:
                  return 6;
                case 19:
                case 23:
                  return 8;
                case 21:
                  return 9;
                case 22:
                case 24:
                  return 12;
                case 25:
                  return 16;
                default:
                  return 0;
              }
            }

            new AABB(0.0, 0.0, 0.0, 0.5, 0.5, 0.5);
            new AABB();
            function getLoadOpOfClearFlag(clearFlag, attachment) {
              var loadOp = 1;
              if (!(clearFlag & 1) && attachment === 0) {
                if (clearFlag & 8) {
                  loadOp = 1;
                } else {
                  loadOp = 0;
                }
              }
              if ((clearFlag & 6) !== 6 && attachment === 1) {
                if (!(clearFlag & 2)) loadOp = 0;
                if (!(clearFlag & 4)) loadOp = 0;
              }
              return loadOp;
            }
            function getRenderArea(camera, width, height, light, level, out) {
              if (light === undefined) {
                light = null;
              }
              if (level === undefined) {
                level = 0;
              }
              if (out === undefined) {
                out = undefined;
              }
              out = out || new Rect$1();
              var vp = camera ? camera.viewport : new Rect$1(0, 0, 1, 1);
              var w = width;
              var h = height;
              out.x = vp.x * w;
              out.y = vp.y * h;
              out.width = vp.width * w;
              out.height = vp.height * h;
              if (light) {
                switch (light.type) {
                  case 0:
                    {
                      var mainLight = light;
                      if (mainLight.shadowFixedArea || mainLight.csmLevel === CSMLevel.LEVEL_1) {
                        out.x = 0;
                        out.y = 0;
                        out.width = w;
                        out.height = h;
                      } else {
                        var screenSpaceSignY = cclegacy.director.root.device.capabilities.screenSpaceSignY;
                        out.x = level % 2 * 0.5 * w;
                        if (screenSpaceSignY > 0) {
                          out.y = (1 - Math.floor(level / 2)) * 0.5 * h;
                        } else {
                          out.y = Math.floor(level / 2) * 0.5 * h;
                        }
                        out.width = 0.5 * w;
                        out.height = 0.5 * h;
                      }
                      break;
                    }
                  case 2:
                    {
                      out.x = 0;
                      out.y = 0;
                      out.width = w;
                      out.height = h;
                      break;
                    }
                }
              }
              return out;
            }
            function buildReflectionProbePass(camera, ppl, probe, renderWindow, faceIdx) {
              var cameraName = "Camera" + faceIdx;
              var area = probe.renderArea();
              var width = area.x;
              var height = area.y;
              var probeCamera = probe.camera;
              var probePassRTName = "reflectionProbePassColor" + cameraName;
              var probePassDSName = "reflectionProbePassDS" + cameraName;
              if (!ppl.containsResource(probePassRTName)) {
                ppl.addRenderWindow(probePassRTName, 35, width, height, renderWindow);
                ppl.addDepthStencil(probePassDSName, 55, width, height, 3);
              }
              ppl.updateRenderWindow(probePassRTName, renderWindow);
              ppl.updateDepthStencil(probePassDSName, width, height);
              var probePass = ppl.addRenderPass(width, height, 'default');
              probePass.name = "ReflectionProbePass" + faceIdx;
              probePass.setViewport(new Viewport(0, 0, width, height));
              probePass.addRenderTarget(probePassRTName, getLoadOpOfClearFlag(probeCamera.clearFlag, 0), 0, new Color$1(probeCamera.clearColor.x, probeCamera.clearColor.y, probeCamera.clearColor.z, probeCamera.clearColor.w));
              probePass.addDepthStencil(probePassDSName, getLoadOpOfClearFlag(probeCamera.clearFlag, 1), 0, probeCamera.clearDepth, probeCamera.clearStencil, probeCamera.clearFlag);
              var passBuilder = probePass.addQueue(1, 'reflect-map');
              var lightInfo = new LightInfo();
              lightInfo.probe = probe;
              passBuilder.addSceneOfCamera(camera, lightInfo, 8192 | 1);
              updateCameraUBO(passBuilder, probeCamera, ppl);
            }
            function updateCameraUBO(setter, camera, ppl) {
              var pipeline = cclegacy.director.root.pipeline;
              var sceneData = ppl.pipelineSceneData;
              var skybox = sceneData.skybox;
              setter.setMat4('cc_matView', camera.matView);
              setter.setMat4('cc_matViewInv', camera.node.worldMatrix);
              setter.setMat4('cc_matProj', camera.matProj);
              setter.setMat4('cc_matProjInv', camera.matProjInv);
              setter.setMat4('cc_matViewProj', camera.matViewProj);
              setter.setMat4('cc_matViewProjInv', camera.matViewProjInv);
              setter.setVec4('cc_cameraPos', new Vec4(camera.position.x, camera.position.y, camera.position.z, pipeline.getCombineSignY()));
              setter.setVec4('cc_surfaceTransform', new Vec4(camera.surfaceTransform, 0.0, Math.cos(toRadian(skybox.getRotationAngle())), Math.sin(toRadian(skybox.getRotationAngle()))));
              setter.setVec4('cc_screenScale', new Vec4(sceneData.shadingScale, sceneData.shadingScale, 1.0 / sceneData.shadingScale, 1.0 / sceneData.shadingScale));
              setter.setVec4('cc_exposure', new Vec4(camera.exposure, 1.0 / camera.exposure, sceneData.isHDR ? 1.0 : 0.0, 1.0 / Camera$1.standardExposureValue));
            }
            function bindDescValue(desc, binding, value) {
              if (value instanceof Buffer) {
                desc.bindBuffer(binding, value);
              } else if (value instanceof Texture) {
                desc.bindTexture(binding, value);
              } else if (value instanceof Sampler) {
                desc.bindSampler(binding, value);
              }
            }
            function bindGlobalDesc(desc, binding, value) {
              bindDescValue(desc, binding, value);
            }
            function getDescBinding(descId, descData) {
              var layoutData = descData;
              for (var _iterator = _createForOfIteratorHelperLoose(layoutData.descriptorSetLayoutData.descriptorBlocks), _step; !(_step = _iterator()).done;) {
                var block = _step.value;
                for (var i = 0; i !== block.descriptors.length; ++i) {
                  if (descId === block.descriptors[i].descriptorID) {
                    return block.offset + i;
                  }
                }
              }
              return -1;
            }
            var DescBuffManager = function () {
              function DescBuffManager(bufferSize, numBuffers) {
                if (numBuffers === undefined) {
                  numBuffers = 2;
                }
                this.buffers = [];
                this.currBuffIdx = 0;
                this.device = undefined;
                this.currUniform = undefined;
                this._root = undefined;
                var root = this._root = cclegacy.director.root;
                var device = root.device;
                this.device = device;
                this.currUniform = new Float32Array(bufferSize / 4);
                for (var i = 0; i < numBuffers; i++) {
                  var bufferInfo = new BufferInfo(16 | 2, 2 | 1, bufferSize, bufferSize);
                  this.buffers.push(this.device.createBuffer(bufferInfo));
                }
              }
              var _proto2 = DescBuffManager.prototype;
              _proto2.getCurrentBuffer = function getCurrentBuffer() {
                var director = cclegacy.director;
                this.currBuffIdx = director.getTotalFrames() % this.buffers.length;
                return this.buffers[this.currBuffIdx];
              };
              _proto2.updateData = function updateData(vals) {
                this.currUniform.set(vals);
              };
              _proto2.updateBuffer = function updateBuffer(bindId, setData) {
                var descriptorSet = setData.descriptorSet;
                var buffer = this.getCurrentBuffer();
                buffer.update(this.currUniform);
                bindGlobalDesc(descriptorSet, bindId, buffer);
              };
              return DescBuffManager;
            }();
            var buffsMap = new Map();
            var currBindBuffs = new Map();
            var layouts = new Map();
            function getDescriptorSetDataFromLayout(layoutName) {
              var descLayout = layouts.get(layoutName);
              if (descLayout) {
                return descLayout;
              }
              var webPip = cclegacy.director.root.pipeline;
              var stageId = webPip.layoutGraph.locateChild(webPip.layoutGraph.N, layoutName);
              var layout = webPip.layoutGraph.getLayout(stageId);
              var layoutData = layout.getSet(3);
              layouts.set(layoutName, layoutData);
              return layoutData;
            }
            function updateGlobalDescBinding(data, sceneId, idxRD, layoutName) {
              if (layoutName === undefined) {
                layoutName = 'default';
              }
              updatePerPassUBO(layoutName, sceneId, idxRD, data);
            }
            function getUniformBlock(block, layoutName) {
              var webPip = cclegacy.director.root.pipeline;
              var lg = webPip.layoutGraph;
              var nodeId = lg.locateChild(0xFFFFFFFF, layoutName);
              var ppl = lg.getLayout(nodeId);
              var layout = ppl.getSet(3).descriptorSetLayoutData;
              var nameID = lg.attributeIndex.get(block);
              return layout.uniformBlocks.get(nameID);
            }
            function getUniformOffset(uniform, block, layout) {
              var uniformBlock = getUniformBlock(block, layout);
              if (!uniformBlock) return -1;
              var offset = 0;
              for (var _iterator6 = _createForOfIteratorHelperLoose(uniformBlock.members), _step6; !(_step6 = _iterator6()).done;) {
                var currUniform = _step6.value;
                var currCount = getUBOTypeCount(currUniform.type);
                if (currUniform.name === uniform) {
                  return offset;
                }
                offset += currCount * currUniform.count;
              }
              return -1;
            }
            var uniformBlockMap = new Map();
            var ConstantBlockInfo = function ConstantBlockInfo() {
              this.offset = -1;
              this.buffer = [];
              this.blockId = -1;
            };
            var constantBlockMap = new Map();
            function copyToConstantBuffer(target, val, offset) {
              var isImparity = false;
              if (offset < 0 || offset > target.length) {
                return isImparity;
              }
              var length = Math.min(val.length, target.length - offset);
              for (var i = 0; i < length; i++) {
                if (target[offset + i] !== val[i]) {
                  target[offset + i] = val[i];
                  isImparity = true;
                }
              }
              return isImparity;
            }
            function addConstantBuffer(block, layout) {
              var buffers = uniformBlockMap.get(block);
              if (buffers) {
                return buffers;
              }
              buffers = [];
              var webPip = cclegacy.director.root.pipeline;
              webPip.layoutGraph;
              var currCount = 0;
              var currBlock = getUniformBlock(block, layout);
              if (!currBlock) return null;
              for (var _iterator7 = _createForOfIteratorHelperLoose(currBlock.members), _step7; !(_step7 = _iterator7()).done;) {
                var uniform = _step7.value;
                currCount += getUBOTypeCount(uniform.type) * uniform.count;
              }
              buffers.length = currCount;
              buffers.fill(0);
              uniformBlockMap.set(block, buffers);
              return buffers;
            }
            function updateGlobalDescBuffer(descKey, vals) {
              var currDescBuff = buffsMap.get(descKey);
              if (!currDescBuff) {
                buffsMap.set(descKey, new DescBuffManager(vals.length * 4, 2));
                currDescBuff = buffsMap.get(descKey);
              }
              currDescBuff.updateData(vals);
            }
            function updateConstantBlock(constantBuff, data, descriptorSetData, sceneId, idxRD) {
              var blockId = constantBuff.blockId;
              var buffer = constantBuff.buffer;
              var isImparity = copyToConstantBuffer(buffer, data, constantBuff.offset);
              var bindId = getDescBinding(blockId, descriptorSetData);
              var desc = descriptorSetData.descriptorSet;
              if (isImparity || !desc.getBuffer(bindId) && bindId !== -1) {
                var descKey = "" + blockId + bindId + idxRD + sceneId;
                currBindBuffs.set(descKey, bindId);
                updateGlobalDescBuffer(descKey, buffer);
              }
            }
            function updateDefaultConstantBlock(blockId, sceneId, idxRD, vals, setData) {
              var bindId = getDescBinding(blockId, setData);
              if (bindId === -1) {
                return;
              }
              var descKey = "" + blockId + bindId + idxRD + sceneId;
              currBindBuffs.set(descKey, bindId);
              updateGlobalDescBuffer(descKey, vals);
            }
            function updatePerPassUBO(layout, sceneId, idxRD, user) {
              var constants = user.constants,
                samplers = user.samplers,
                textures = user.textures,
                buffers = user.buffers;
              var webPip = cclegacy.director.root.pipeline;
              var lg = webPip.layoutGraph;
              var descriptorSetData = getDescriptorSetDataFromLayout(layout);
              currBindBuffs.clear();
              var _loop = function _loop() {
                var _step8$value = _step8.value,
                  key = _step8$value[0],
                  data = _step8$value[1];
                var constantBlock = constantBlockMap.get(key);
                if (!constantBlock) {
                  var currMemKey = Array.from(lg.constantIndex).find(function (_ref6) {
                    _ref6[0];
                      var v = _ref6[1];
                    return v === key;
                  })[0];
                  for (var _iterator13 = _createForOfIteratorHelperLoose(lg.attributeIndex), _step13; !(_step13 = _iterator13()).done;) {
                    var _step13$value = _step13.value,
                      block = _step13$value[0],
                      blockId = _step13$value[1];
                    var constantBuff = addConstantBuffer(block, layout);
                    if (!constantBuff) continue;
                    var offset = getUniformOffset(currMemKey, block, layout);
                    if (offset === -1) {
                      updateDefaultConstantBlock(blockId, sceneId, idxRD, constantBuff, descriptorSetData);
                      continue;
                    }
                    constantBlockMap.set(key, new ConstantBlockInfo());
                    constantBlock = constantBlockMap.get(key);
                    constantBlock.buffer = constantBuff;
                    constantBlock.blockId = blockId;
                    constantBlock.offset = offset;
                    updateConstantBlock(constantBlock, data, descriptorSetData, sceneId, idxRD);
                  }
                } else {
                  updateConstantBlock(constantBlock, data, descriptorSetData, sceneId, idxRD);
                }
              };
              for (var _iterator8 = _createForOfIteratorHelperLoose(constants), _step8; !(_step8 = _iterator8()).done;) {
                _loop();
              }
              var descriptorSet = descriptorSetData.descriptorSet;
              for (var _iterator9 = _createForOfIteratorHelperLoose(textures), _step9; !(_step9 = _iterator9()).done;) {
                var _step9$value = _step9.value,
                  key = _step9$value[0],
                  value = _step9$value[1];
                var bindId = getDescBinding(key, descriptorSetData);
                if (bindId === -1) {
                  continue;
                }
                var tex = descriptorSet.getTexture(bindId);
                if (value !== tex || !tex.gpuTexture && !(tex.gpuTextureView && tex.gpuTextureView.gpuTexture)) {
                  bindGlobalDesc(descriptorSet, bindId, value);
                }
              }
              for (var _iterator10 = _createForOfIteratorHelperLoose(samplers), _step10; !(_step10 = _iterator10()).done;) {
                var _step10$value = _step10.value,
                  _key = _step10$value[0],
                  _value = _step10$value[1];
                var _bindId = getDescBinding(_key, descriptorSetData);
                if (_bindId === -1) {
                  continue;
                }
                var sampler = descriptorSet.getSampler(_bindId);
                if (sampler !== _value) {
                  bindGlobalDesc(descriptorSet, _bindId, _value);
                }
              }
              for (var _iterator11 = _createForOfIteratorHelperLoose(currBindBuffs), _step11; !(_step11 = _iterator11()).done;) {
                var _step11$value = _step11.value,
                  _key2 = _step11$value[0],
                  _value2 = _step11$value[1];
                var buffManager = buffsMap.get(_key2);
                buffManager.updateBuffer(_value2, descriptorSetData);
              }
              for (var _iterator12 = _createForOfIteratorHelperLoose(buffers), _step12; !(_step12 = _iterator12()).done;) {
                var _step12$value = _step12.value,
                  _key3 = _step12$value[0],
                  _value3 = _step12$value[1];
                var _bindId2 = getDescBinding(_key3, descriptorSetData);
                if (_bindId2 === -1) {
                  continue;
                }
                var buffer = descriptorSet.getBuffer(_bindId2);
                if (!buffer) {
                  bindGlobalDesc(descriptorSet, _bindId2, _value3);
                }
              }
            }
            function hashCombineKey(val) {
              return val + "-";
            }
            function hashCombineStr(str) {
              var hash = 0;
              for (var i = 0; i < str.length; i++) {
                hash = (hash << 5) - hash + str.charCodeAt(i);
                hash |= 0;
              }
              return hash;
            }
            function bool(val) {
              return !!val;
            }
            function AlignUp(value, alignment) {
              return value + (alignment - 1) & ~(alignment - 1);
            }
            var kLightMeterScale = 10000;
            function SetLightUBO(light, bHDR, exposure, shadowInfo, buffer, offset, elemSize) {
              var vec4Array = new Float32Array(4);
              var size = 0.0;
              var range = 0.0;
              var luminanceHDR = 0.0;
              var luminanceLDR = 0.0;
              if (light && light.type === 1) {
                var sphereLight = light;
                vec4Array[0] = sphereLight.position.x;
                vec4Array[1] = sphereLight.position.y;
                vec4Array[2] = sphereLight.position.z;
                vec4Array[3] = 1;
                size = sphereLight.size;
                range = sphereLight.range;
                luminanceHDR = sphereLight.luminanceHDR;
                luminanceLDR = sphereLight.luminanceLDR;
              } else if (light && light.type === 2) {
                var spotLight = light;
                vec4Array[0] = spotLight.position.x;
                vec4Array[1] = spotLight.position.y;
                vec4Array[2] = spotLight.position.z;
                vec4Array[3] = 2;
                size = spotLight.size;
                range = spotLight.range;
                luminanceHDR = spotLight.luminanceHDR;
                luminanceLDR = spotLight.luminanceLDR;
              } else if (light && light.type === 3) {
                var pointLight = light;
                vec4Array[0] = pointLight.position.x;
                vec4Array[1] = pointLight.position.y;
                vec4Array[2] = pointLight.position.z;
                vec4Array[3] = 3;
                size = 0.0;
                range = pointLight.range;
                luminanceHDR = pointLight.luminanceHDR;
                luminanceLDR = pointLight.luminanceLDR;
              } else if (light && light.type === 4) {
                var rangedDirLight = light;
                vec4Array[0] = rangedDirLight.position.x;
                vec4Array[1] = rangedDirLight.position.y;
                vec4Array[2] = rangedDirLight.position.z;
                vec4Array[3] = 4;
                size = 0.0;
                range = 0.0;
                luminanceHDR = rangedDirLight.illuminanceHDR;
                luminanceLDR = rangedDirLight.illuminanceLDR;
              }
              var index = offset + 0;
              buffer.set(vec4Array, index);
              index = offset + 8;
              vec4Array.set([size, range, 0, 0]);
              buffer.set(vec4Array, index);
              index = offset + 4;
              var color = light ? light.color : new Color$1();
              if (light && light.useColorTemperature) {
                var tempRGB = light.colorTemperatureRGB;
                buffer[index++] = color.x * tempRGB.x;
                buffer[index++] = color.y * tempRGB.y;
                buffer[index++] = color.z * tempRGB.z;
              } else {
                buffer[index++] = color.x;
                buffer[index++] = color.y;
                buffer[index++] = color.z;
              }
              if (bHDR) {
                buffer[index] = luminanceHDR * exposure * kLightMeterScale;
              } else {
                buffer[index] = luminanceLDR;
              }
              switch (light ? light.type : 5) {
                case 1:
                  buffer[offset + 8 + 2] = 0;
                  buffer[offset + 8 + 3] = 0;
                  break;
                case 2:
                  {
                    var _spotLight = light;
                    buffer[offset + 8 + 2] = _spotLight.spotAngle;
                    buffer[offset + 8 + 3] = shadowInfo && shadowInfo.enabled && _spotLight.shadowEnabled && shadowInfo.type === ShadowType.ShadowMap ? 1.0 : 0.0;
                    index = offset + 12;
                    var direction = _spotLight.direction;
                    buffer[index++] = direction.x;
                    buffer[index++] = direction.y;
                    buffer[index] = direction.z;
                    buffer[offset + 16 + 0] = 0;
                    buffer[offset + 16 + 1] = 0;
                    buffer[offset + 16 + 2] = 0;
                    buffer[offset + 16 + 3] = _spotLight.angleAttenuationStrength;
                  }
                  break;
                case 3:
                  buffer[offset + 8 + 2] = 0;
                  buffer[offset + 8 + 3] = 0;
                  break;
                case 4:
                  {
                    var _rangedDirLight = light;
                    var right = _rangedDirLight.right;
                    buffer[offset + 8 + 0] = right.x;
                    buffer[offset + 8 + 1] = right.y;
                    buffer[offset + 8 + 2] = right.z;
                    buffer[offset + 8 + 3] = 0;
                    var _direction = _rangedDirLight.direction;
                    buffer[offset + 12 + 0] = _direction.x;
                    buffer[offset + 12 + 1] = _direction.y;
                    buffer[offset + 12 + 2] = _direction.z;
                    buffer[offset + 12 + 3] = 0;
                    var scale = _rangedDirLight.scale;
                    buffer[offset + 16 + 0] = scale.x * 0.5;
                    buffer[offset + 16 + 1] = scale.y * 0.5;
                    buffer[offset + 16 + 2] = scale.z * 0.5;
                    buffer[offset + 16 + 3] = 0;
                  }
                  break;
              }
            }
            function genHashValue(pass) {
              var hashCode = '';
              for (var _iterator14 = _createForOfIteratorHelperLoose(pass.rasterViews), _step14; !(_step14 = _iterator14()).done;) {
                var _step14$value = _step14.value,
                  name = _step14$value[0],
                  raster = _step14$value[1];
                hashCode += hashCombineKey(name);
                hashCode += hashCombineKey(raster.slotName);
                hashCode += hashCombineKey(raster.accessType);
                hashCode += hashCombineKey(raster.attachmentType);
                hashCode += hashCombineKey(raster.loadOp);
                hashCode += hashCombineKey(raster.storeOp);
                hashCode += hashCombineKey(raster.clearFlags);
                hashCode += hashCombineKey(raster.clearColor.x);
                hashCode += hashCombineKey(raster.clearColor.y);
                hashCode += hashCombineKey(raster.clearColor.z);
                hashCode += hashCombineKey(raster.clearColor.w);
                hashCode += hashCombineKey(raster.slotID);
                hashCode += hashCombineKey(raster.shaderStageFlags);
              }
              for (var _iterator15 = _createForOfIteratorHelperLoose(pass.computeViews), _step15; !(_step15 = _iterator15()).done;) {
                var _step15$value = _step15.value,
                  _name = _step15$value[0],
                  computes = _step15$value[1];
                hashCode += hashCombineKey(_name);
                for (var _iterator16 = _createForOfIteratorHelperLoose(computes), _step16; !(_step16 = _iterator16()).done;) {
                  var compute = _step16.value;
                  hashCode += hashCombineKey(compute.name);
                  hashCode += hashCombineKey(compute.accessType);
                  hashCode += hashCombineKey(compute.clearFlags);
                  hashCode += hashCombineKey(compute.clearValueType);
                  hashCode += hashCombineKey(compute.clearValue.x);
                  hashCode += hashCombineKey(compute.clearValue.y);
                  hashCode += hashCombineKey(compute.clearValue.z);
                  hashCode += hashCombineKey(compute.clearValue.w);
                  hashCode += hashCombineKey(compute.shaderStageFlags);
                }
              }
              hashCode += hashCombineKey(pass.showStatistics ? 1 : 0);
              pass.hashValue = hashCombineStr(hashCode);
            }

            var _uboVec$1 = new Vec4();
            var _uboVec3 = new Vec3();
            var _uboCol = new Color$1();
            var _matView = new Mat4();
            var _mulMatView = new Mat4();
            function setTextureUBOView(setter, cfg, layout) {
              var skybox = cfg.skybox;
              var director = cclegacy.director;
              var root = director.root;
              var pipeline = root.pipeline;
              if (skybox.reflectionMap) {
                var texture = skybox.reflectionMap.getGFXTexture();
                var sampler = root.device.getSampler(skybox.reflectionMap.getSamplerInfo());
                setter.setTexture('cc_environment', texture);
                setter.setSampler('cc_environment', sampler);
              } else {
                var envmap = skybox.envmap ? skybox.envmap : builtinResMgr.get('default-cube-texture');
                if (envmap) {
                  var _texture = envmap.getGFXTexture();
                  var _sampler = root.device.getSampler(envmap.getSamplerInfo());
                  setter.setTexture('cc_environment', _texture);
                  setter.setSampler('cc_environment', _sampler);
                }
              }
              var diffuseMap = skybox.diffuseMap ? skybox.diffuseMap : builtinResMgr.get('default-cube-texture');
              if (diffuseMap) {
                var _texture2 = diffuseMap.getGFXTexture();
                var _sampler2 = root.device.getSampler(diffuseMap.getSamplerInfo());
                setter.setTexture('cc_diffuseMap', _texture2);
                setter.setSampler('cc_diffuseMap', _sampler2);
              }
              if (!setter.hasSampler('cc_shadowMap')) {
                setter.setSampler('cc_shadowMap', pipeline.defaultSampler);
              }
              if (!setter.hasTexture('cc_shadowMap')) {
                setter.setTexture('cc_shadowMap', pipeline.defaultShadowTexture);
              }
              if (!setter.hasSampler('cc_spotShadowMap')) {
                setter.setSampler('cc_spotShadowMap', pipeline.defaultSampler);
              }
              if (!setter.hasTexture('cc_spotShadowMap')) {
                setter.setTexture('cc_spotShadowMap', pipeline.defaultShadowTexture);
              }
            }
            function setCameraUBOValues(setter, camera, cfg, scene, layoutName) {
              var _skybox$envmap;
              var director = cclegacy.director;
              var root = director.root;
              var pipeline = root.pipeline;
              var shadowInfo = cfg.shadows;
              var skybox = cfg.skybox;
              var shadingScale = cfg.shadingScale;
              if (camera) {
                setter.setMat4('cc_matView', camera.matView);
                setter.setMat4('cc_matViewInv', camera.node.worldMatrix);
                setter.setMat4('cc_matProj', camera.matProj);
                setter.setMat4('cc_matProjInv', camera.matProjInv);
                setter.setMat4('cc_matViewProj', camera.matViewProj);
                setter.setMat4('cc_matViewProjInv', camera.matViewProjInv);
                _uboVec$1.set(camera.surfaceTransform, camera.cameraUsage, Math.cos(toRadian(skybox.getRotationAngle())), Math.sin(toRadian(skybox.getRotationAngle())));
                setter.setVec4('cc_surfaceTransform', _uboVec$1);
                _uboVec$1.set(camera.exposure, 1.0 / camera.exposure, cfg.isHDR ? 1.0 : 0.0, 1.0 / Camera$1.standardExposureValue);
                setter.setVec4('cc_exposure', _uboVec$1);
              }
              if (camera) {
                _uboVec$1.set(camera.position.x, camera.position.y, camera.position.z, pipeline.getCombineSignY());
              } else {
                _uboVec$1.set(0, 0, 0, pipeline.getCombineSignY());
              }
              setter.setVec4('cc_cameraPos', _uboVec$1);
              _uboVec$1.set(cfg.shadingScale, cfg.shadingScale, 1.0 / cfg.shadingScale, 1.0 / cfg.shadingScale);
              setter.setVec4('cc_screenScale', _uboVec$1);
              var mainLight = scene && scene.mainLight;
              if (mainLight) {
                var shadowEnable = mainLight.shadowEnabled && shadowInfo.type === ShadowType.ShadowMap ? 1.0 : 0.0;
                _uboVec$1.set(mainLight.direction.x, mainLight.direction.y, mainLight.direction.z, shadowEnable);
                setter.setVec4('cc_mainLitDir', _uboVec$1);
                var r = mainLight.color.x;
                var g = mainLight.color.y;
                var b = mainLight.color.z;
                if (mainLight.useColorTemperature) {
                  r *= mainLight.colorTemperatureRGB.x;
                  g *= mainLight.colorTemperatureRGB.y;
                  b *= mainLight.colorTemperatureRGB.z;
                }
                var w = mainLight.illuminance;
                if (cfg.isHDR && camera) {
                  w *= camera.exposure;
                }
                _uboVec$1.set(r, g, b, w);
                setter.setVec4('cc_mainLitColor', _uboVec$1);
              } else {
                _uboVec$1.set(0, 0, 1, 0);
                setter.setVec4('cc_mainLitDir', _uboVec$1);
                _uboVec$1.set(0, 0, 0, 0);
                setter.setVec4('cc_mainLitColor', _uboVec$1);
              }
              var ambient = cfg.ambient;
              var skyColor = ambient.skyColor;
              if (cfg.isHDR) {
                skyColor.w = ambient.skyIllum * (camera ? camera.exposure : 1);
              } else {
                skyColor.w = ambient.skyIllum;
              }
              _uboVec$1.set(skyColor.x, skyColor.y, skyColor.z, skyColor.w);
              setter.setVec4('cc_ambientSky', _uboVec$1);
              _uboVec$1.set(ambient.groundAlbedo.x, ambient.groundAlbedo.y, ambient.groundAlbedo.z, skybox.envmap ? (_skybox$envmap = skybox.envmap) == null ? undefined : _skybox$envmap.mipmapLevel : 1.0);
              setter.setVec4('cc_ambientGround', _uboVec$1);
              var fog = cfg.fog;
              var colorTempRGB = fog.colorArray;
              _uboVec$1.set(colorTempRGB.x, colorTempRGB.y, colorTempRGB.z, colorTempRGB.z);
              setter.setVec4('cc_fogColor', _uboVec$1);
              _uboVec$1.set(fog.fogStart, fog.fogEnd, fog.fogDensity, 0.0);
              setter.setVec4('cc_fogBase', _uboVec$1);
              _uboVec$1.set(fog.fogTop, fog.fogRange, fog.fogAtten, 0.0);
              setter.setVec4('cc_fogAdd', _uboVec$1);
              if (camera) {
                _uboVec$1.set(camera.nearClip, camera.farClip, camera.getClipSpaceMinz(), 0.0);
                setter.setVec4('cc_nearFar', _uboVec$1);
                _uboVec$1.set(camera.viewport.x, camera.viewport.y, shadingScale * camera.window.width * camera.viewport.z, shadingScale * camera.window.height * camera.viewport.w);
                setter.setVec4('cc_viewPort', _uboVec$1);
              }
            }
            var DrawInstance = function () {
              function DrawInstance(subModel, priority, hash, depth, shaderID, passIndex) {
                if (subModel === undefined) {
                  subModel = null;
                }
                if (priority === undefined) {
                  priority = 0;
                }
                if (hash === undefined) {
                  hash = 0;
                }
                if (depth === undefined) {
                  depth = 0;
                }
                if (shaderID === undefined) {
                  shaderID = 0;
                }
                if (passIndex === undefined) {
                  passIndex = 0;
                }
                this.subModel = undefined;
                this.priority = undefined;
                this.hash = undefined;
                this.depth = undefined;
                this.shaderID = undefined;
                this.passIndex = undefined;
                this.subModel = subModel;
                this.priority = priority;
                this.hash = hash;
                this.depth = depth;
                this.shaderID = shaderID;
                this.passIndex = passIndex;
              }
              var _proto = DrawInstance.prototype;
              _proto.update = function update(subModel, priority, hash, depth, shaderID, passIndex) {
                if (subModel === undefined) {
                  subModel = null;
                }
                if (priority === undefined) {
                  priority = 0;
                }
                if (hash === undefined) {
                  hash = 0;
                }
                if (depth === undefined) {
                  depth = 0;
                }
                if (shaderID === undefined) {
                  shaderID = 0;
                }
                if (passIndex === undefined) {
                  passIndex = 0;
                }
                this.subModel = subModel;
                this.priority = priority;
                this.hash = hash;
                this.depth = depth;
                this.shaderID = shaderID;
                this.passIndex = passIndex;
              };
              return DrawInstance;
            }();
            var instancePool = new RecyclePool(function () {
              return new DrawInstance();
            }, 8);
            var CC_USE_RGBE_OUTPUT = 'CC_USE_RGBE_OUTPUT';
            function getLayoutId(passLayout, phaseLayout) {
              var r = cclegacy.rendering;
              return r.getPhaseID(r.getPassID(passLayout), phaseLayout);
            }
            function getPassIndexFromLayout(subModel, phaseLayoutId) {
              var passes = subModel.passes;
              for (var k = 0; k < passes.length; k++) {
                if (passes[k].phaseID === phaseLayoutId) {
                  return k;
                }
              }
              return -1;
            }
            var ProbeHelperQueue = function () {
              function ProbeHelperQueue() {
                this.probeMap = new Array();
                this.defaultId = getLayoutId('default', 'default');
              }
              var _proto2 = ProbeHelperQueue.prototype;
              _proto2.clear = function clear() {
                this.probeMap.length = 0;
              };
              _proto2.applyMacro = function applyMacro() {
                for (var _iterator = _createForOfIteratorHelperLoose(this.probeMap), _step; !(_step = _iterator()).done;) {
                  var subModel = _step.value;
                  var patches = [{
                    name: CC_USE_RGBE_OUTPUT,
                    value: true
                  }];
                  if (subModel.patches) {
                    patches = patches.concat(subModel.patches);
                  }
                  subModel.onMacroPatchesStateChanged(patches);
                }
              };
              _proto2.removeMacro = function removeMacro() {
                for (var _iterator2 = _createForOfIteratorHelperLoose(this.probeMap), _step2; !(_step2 = _iterator2()).done;) {
                  var subModel = _step2.value;
                  if (!subModel.patches) continue;
                  var patches = subModel.patches.filter(function (patch) {
                    return patch.name !== CC_USE_RGBE_OUTPUT;
                  });
                  if (patches.length === 0) {
                    subModel.onMacroPatchesStateChanged(null);
                  } else {
                    subModel.onMacroPatchesStateChanged(patches);
                  }
                }
              };
              _proto2.addToProbeQueue = function addToProbeQueue(model, probeLayoutId) {
                var subModels = model.subModels;
                for (var j = 0; j < subModels.length; j++) {
                  var subModel = subModels[j];
                  var isTransparent = subModel.passes[0].blendState.targets[0].blend;
                  if (isTransparent) {
                    continue;
                  }
                  var passIdx = getPassIndexFromLayout(subModel, probeLayoutId);
                  var bUseReflectPass = true;
                  if (passIdx < 0) {
                    probeLayoutId = this.defaultId;
                    passIdx = getPassIndexFromLayout(subModel, probeLayoutId);
                    bUseReflectPass = false;
                  }
                  if (passIdx < 0) {
                    continue;
                  }
                  if (!bUseReflectPass) {
                    this.probeMap.push(subModel);
                  }
                }
              };
              return ProbeHelperQueue;
            }();
            function setShadowUBOLightView(setter, camera, light, csmLevel, layout) {
              var director = cclegacy.director;
              var pipeline = director.root.pipeline;
              var device = pipeline.device;
              var sceneData = pipeline.pipelineSceneData;
              var shadowInfo = sceneData.shadows;
              if (shadowInfo.type === ShadowType.Planar) {
                return;
              }
              var csmLayers = sceneData.csmLayers;
              var packing = supportsR32FloatTexture(device) ? 0.0 : 1.0;
              var cap = pipeline.device.capabilities;
              if (shadowInfo.enabled) {
                if (shadowInfo.type === ShadowType.ShadowMap) {
                  if (light && light.node && light.type === 0) {
                    csmLayers.update(sceneData, camera);
                  }
                }
              }
              switch (light.type) {
                case 0:
                  {
                    var mainLight = light;
                    if (shadowInfo.enabled && mainLight && mainLight.shadowEnabled) {
                      if (shadowInfo.type === ShadowType.ShadowMap) {
                        var near = 0.1;
                        var far = 0;
                        var matShadowView;
                        var matShadowProj;
                        var matShadowViewProj;
                        var levelCount = 0;
                        if (mainLight.shadowFixedArea || mainLight.csmLevel === CSMLevel.LEVEL_1) {
                          matShadowView = csmLayers.specialLayer.matShadowView;
                          matShadowProj = csmLayers.specialLayer.matShadowProj;
                          matShadowViewProj = csmLayers.specialLayer.matShadowViewProj;
                          if (mainLight.shadowFixedArea) {
                            near = mainLight.shadowNear;
                            far = mainLight.shadowFar;
                            levelCount = 0;
                          } else {
                            near = 0.1;
                            far = csmLayers.specialLayer.shadowCameraFar;
                            levelCount = 1;
                          }
                          _uboVec$1.set(0, packing, mainLight.shadowNormalBias, 0);
                          setter.setVec4('cc_shadowLPNNInfo', _uboVec$1);
                        } else {
                          var layer = csmLayers.layers[csmLevel];
                          matShadowView = layer.matShadowView;
                          matShadowProj = layer.matShadowProj;
                          matShadowViewProj = layer.matShadowViewProj;
                          near = layer.splitCameraNear;
                          far = layer.splitCameraFar;
                          levelCount = mainLight.csmLevel;
                        }
                        setter.setMat4('cc_matLightView', matShadowView);
                        _uboVec$1.set(matShadowProj.m10, matShadowProj.m14, matShadowProj.m11, matShadowProj.m15);
                        setter.setVec4('cc_shadowProjDepthInfo', _uboVec$1);
                        _uboVec$1.set(matShadowProj.m00, matShadowProj.m05, 1.0 / matShadowProj.m00, 1.0 / matShadowProj.m05);
                        setter.setVec4('cc_shadowProjInfo', _uboVec$1);
                        setter.setMat4('cc_matLightViewProj', matShadowViewProj);
                        _uboVec$1.set(near, far, 0, 1.0 - mainLight.shadowSaturation);
                        setter.setVec4('cc_shadowNFLSInfo', _uboVec$1);
                        _uboVec$1.set(0, packing, mainLight.shadowNormalBias, levelCount);
                        setter.setVec4('cc_shadowLPNNInfo', _uboVec$1);
                        _uboVec$1.set(shadowInfo.size.x, shadowInfo.size.y, mainLight.shadowPcf, mainLight.shadowBias);
                        setter.setVec4('cc_shadowWHPBInfo', _uboVec$1);
                      }
                    }
                    break;
                  }
                case 2:
                  {
                    var spotLight = light;
                    if (shadowInfo.enabled && spotLight && spotLight.shadowEnabled) {
                      Mat4.invert(_matView, spotLight.node.getWorldMatrix());
                      setter.setMat4('cc_matLightView', _matView);
                      Mat4.perspective(_mulMatView, spotLight.angle, 1.0, 0.001, spotLight.range, true, cap.clipSpaceMinZ, cap.clipSpaceSignY, 0);
                      var matShadowInvProj = _mulMatView.clone().invert();
                      var _matShadowProj = _mulMatView.clone();
                      Mat4.multiply(_matView, _mulMatView, _matView);
                      setter.setMat4('cc_matLightViewProj', _matView);
                      _uboVec$1.set(0.01, light.range, 0.0, 0.0);
                      setter.setVec4('cc_shadowNFLSInfo', _uboVec$1);
                      _uboVec$1.set(shadowInfo.size.x, shadowInfo.size.y, spotLight.shadowPcf, spotLight.shadowBias);
                      setter.setVec4('cc_shadowWHPBInfo', _uboVec$1);
                      _uboVec$1.set(2, packing, spotLight.shadowNormalBias, 0.0);
                      setter.setVec4('cc_shadowLPNNInfo', _uboVec$1);
                      _uboVec$1.set(_matShadowProj.m10, _matShadowProj.m14, _matShadowProj.m11, _matShadowProj.m15);
                      setter.setVec4('cc_shadowProjDepthInfo', _uboVec$1);
                      _uboVec$1.set(matShadowInvProj.m10, matShadowInvProj.m14, matShadowInvProj.m11, matShadowInvProj.m15);
                      setter.setVec4('cc_shadowInvProjDepthInfo', _uboVec$1);
                      _uboVec$1.set(_matShadowProj.m00, _matShadowProj.m05, 1.0 / _matShadowProj.m00, 1.0 / _matShadowProj.m05);
                      setter.setVec4('cc_shadowProjInfo', _uboVec$1);
                    }
                    break;
                  }
                case 1:
                  {
                    _uboVec$1.set(shadowInfo.size.x, shadowInfo.size.y, 1.0, 0.0);
                    setter.setVec4('cc_shadowWHPBInfo', _uboVec$1);
                    _uboVec$1.set(1, packing, 0.0, 0.0);
                    setter.setVec4('cc_shadowLPNNInfo', _uboVec$1);
                    break;
                  }
                case 3:
                  {
                    _uboVec$1.set(shadowInfo.size.x, shadowInfo.size.y, 1.0, 0.0);
                    setter.setVec4('cc_shadowWHPBInfo', _uboVec$1);
                    _uboVec$1.set(3, packing, 0.0, 0.0);
                    setter.setVec4('cc_shadowLPNNInfo', _uboVec$1);
                    break;
                  }
              }
              _uboCol.set(shadowInfo.shadowColor.x, shadowInfo.shadowColor.y, shadowInfo.shadowColor.z, shadowInfo.shadowColor.w);
              setter.setColor('cc_shadowColor', _uboCol);
            }
            function getPCFRadius(shadowInfo, mainLight) {
              var shadowMapSize = shadowInfo.size.x;
              switch (mainLight.shadowPcf) {
                case PCFType.HARD:
                  return 0.0;
                case PCFType.SOFT:
                  return 1.0 / (shadowMapSize * 0.5);
                case PCFType.SOFT_2X:
                  return 2.0 / (shadowMapSize * 0.5);
                case PCFType.SOFT_4X:
                  return 3.0 / (shadowMapSize * 0.5);
              }
              return 0.0;
            }
            function setShadowUBOView(setter, camera, layout) {
              var director = cclegacy.director;
              var pipeline = director.root.pipeline;
              var device = pipeline.device;
              var scene = director.getScene();
              var mainLight = camera && camera.scene ? camera.scene.mainLight : scene ? scene.renderScene.mainLight : null;
              var sceneData = pipeline.pipelineSceneData;
              var shadowInfo = sceneData.shadows;
              var csmLayers = sceneData.csmLayers;
              var csmSupported = sceneData.csmSupported;
              var packing = supportsR32FloatTexture(device) ? 0.0 : 1.0;
              if (mainLight && shadowInfo.enabled) {
                if (shadowInfo.type === ShadowType.ShadowMap) {
                  if (mainLight.shadowEnabled) {
                    if (mainLight.shadowFixedArea || mainLight.csmLevel === CSMLevel.LEVEL_1 || !csmSupported) {
                      var matShadowView = csmLayers.specialLayer.matShadowView;
                      var matShadowProj = csmLayers.specialLayer.matShadowProj;
                      var matShadowViewProj = csmLayers.specialLayer.matShadowViewProj;
                      var near = mainLight.shadowNear;
                      var far = mainLight.shadowFar;
                      setter.setMat4('cc_matLightView', matShadowView);
                      _uboVec$1.set(matShadowProj.m10, matShadowProj.m14, matShadowProj.m11, matShadowProj.m15);
                      setter.setVec4('cc_shadowProjDepthInfo', _uboVec$1);
                      _uboVec$1.set(matShadowProj.m00, matShadowProj.m05, 1.0 / matShadowProj.m00, 1.0 / matShadowProj.m05);
                      setter.setVec4('cc_shadowProjInfo', _uboVec$1);
                      setter.setMat4('cc_matLightViewProj', matShadowViewProj);
                      _uboVec$1.set(near, far, 0, 1.0 - mainLight.shadowSaturation);
                      setter.setVec4('cc_shadowNFLSInfo', _uboVec$1);
                      _uboVec$1.set(0, packing, mainLight.shadowNormalBias, 0);
                      setter.setVec4('cc_shadowLPNNInfo', _uboVec$1);
                    } else {
                      var layerThreshold = getPCFRadius(shadowInfo, mainLight);
                      for (var i = 0; i < mainLight.csmLevel; i++) {
                        var layer = csmLayers.layers[i];
                        var _matShadowView = layer.matShadowView;
                        _uboVec$1.set(_matShadowView.m00, _matShadowView.m04, _matShadowView.m08, layerThreshold);
                        setter.setVec4('cc_csmViewDir0', _uboVec$1, i);
                        _uboVec$1.set(_matShadowView.m01, _matShadowView.m05, _matShadowView.m09, layer.splitCameraNear);
                        setter.setVec4('cc_csmViewDir1', _uboVec$1, i);
                        _uboVec$1.set(_matShadowView.m02, _matShadowView.m06, _matShadowView.m10, layer.splitCameraFar);
                        setter.setVec4('cc_csmViewDir2', _uboVec$1, i);
                        var csmAtlas = layer.csmAtlas;
                        setter.setVec4('cc_csmAtlas', csmAtlas, i);
                        var _matShadowViewProj = layer.matShadowViewProj;
                        setter.setMat4('cc_matCSMViewProj', _matShadowViewProj, i);
                        var _matShadowProj2 = layer.matShadowProj;
                        _uboVec$1.set(_matShadowProj2.m10, _matShadowProj2.m14, _matShadowProj2.m11, _matShadowProj2.m15);
                        setter.setVec4('cc_csmProjDepthInfo', _uboVec$1, i);
                        _uboVec$1.set(_matShadowProj2.m00, _matShadowProj2.m05, 1.0 / _matShadowProj2.m00, 1.0 / _matShadowProj2.m05);
                        setter.setVec4('cc_csmProjInfo', _uboVec$1, i);
                      }
                      _uboVec$1.set(mainLight.csmTransitionRange, 0, 0, 0);
                      setter.setVec4('cc_csmSplitsInfo', _uboVec$1);
                      _uboVec$1.set(0.1, mainLight.shadowDistance, 0, 1.0 - mainLight.shadowSaturation);
                      setter.setVec4('cc_shadowNFLSInfo', _uboVec$1);
                      _uboVec$1.set(0, packing, mainLight.shadowNormalBias, mainLight.csmLevel);
                      setter.setVec4('cc_shadowLPNNInfo', _uboVec$1);
                    }
                    _uboVec$1.set(shadowInfo.size.x, shadowInfo.size.y, mainLight.shadowPcf, mainLight.shadowBias);
                    setter.setVec4('cc_shadowWHPBInfo', _uboVec$1);
                  }
                } else {
                  Vec3.normalize(_uboVec3, shadowInfo.normal);
                  _uboVec$1.set(_uboVec3.x, _uboVec3.y, _uboVec3.z, -shadowInfo.distance);
                  setter.setVec4('cc_planarNDInfo', _uboVec$1);
                  _uboVec$1.set(0, 0, 0, shadowInfo.planeBias);
                  setter.setVec4('cc_shadowWHPBInfo', _uboVec$1);
                }
                setter.setMathColor('cc_shadowColor', shadowInfo.shadowColor);
              }
            }
            var WebSetter = function () {
              function WebSetter(data, lg) {
                this._data = undefined;
                this._lg = undefined;
                this._vertID = -1;
                this._currBlock = undefined;
                this._currStage = '';
                this._currFrequency = 3;
                this._currCount = undefined;
                this._currConstant = [];
                this._data = data;
                this._lg = lg;
              }
              var _proto3 = WebSetter.prototype;
              _proto3.setMat4 = function setMat4(name, mat, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                WebSetter.setMat4(this._lg, this._data, name, mat, idx);
              };
              WebSetter.setMat4 = function setMat4(lg, data, name, mat, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                var info = WebSetter.getConstantInfo(lg, data, name);
                Mat4.toArray(info.dataArr, mat, idx * 16);
                data.constants.set(info.constantID, info.dataArr);
              };
              _proto3.setQuaternion = function setQuaternion(name, quat, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                WebSetter.setQuaternion(this._lg, this._data, name, quat, idx);
              };
              WebSetter.setQuaternion = function setQuaternion(lg, data, name, quat, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                var info = WebSetter.getConstantInfo(lg, data, name);
                Quat.toArray(info.dataArr, quat, idx * 4);
                data.constants.set(info.constantID, info.dataArr);
              };
              _proto3.setColor = function setColor(name, color, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                WebSetter.setColor(this._lg, this._data, name, color, idx);
              };
              WebSetter.setColor = function setColor(lg, data, name, color, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                var info = WebSetter.getConstantInfo(lg, data, name);
                var currIdx = idx * 4;
                info.dataArr[0 + currIdx] = color.x;
                info.dataArr[1 + currIdx] = color.y;
                info.dataArr[2 + currIdx] = color.z;
                info.dataArr[3 + currIdx] = color.w;
                data.constants.set(info.constantID, info.dataArr);
              };
              _proto3.setMathColor = function setMathColor(name, color, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                WebSetter.setMathColor(this._lg, this._data, name, color, idx);
              };
              WebSetter.setMathColor = function setMathColor(lg, data, name, color, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                var info = WebSetter.getConstantInfo(lg, data, name);
                Color.toArray(info.dataArr, color, idx * 4);
                data.constants.set(info.constantID, info.dataArr);
              };
              WebSetter.getConstantInfo = function getConstantInfo(lg, data, name) {
                var constantID = lg.constantIndex.get(name);
                if (constantID === undefined) {
                  throw new Error("Constant with name " + name + " not found.");
                }
                var dataArr = data.constants.get(constantID) || [];
                return {
                  constantID: constantID,
                  dataArr: dataArr
                };
              };
              _proto3.setVec4 = function setVec4(name, vec, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                WebSetter.setVec4(this._lg, this._data, name, vec, idx);
              };
              WebSetter.setVec4 = function setVec4(lg, data, name, vec, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                var info = WebSetter.getConstantInfo(lg, data, name);
                Vec4.toArray(info.dataArr, vec, idx * 4);
                data.constants.set(info.constantID, info.dataArr);
              };
              _proto3.setVec2 = function setVec2(name, vec, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                WebSetter.setVec2(this._lg, this._data, name, vec, idx);
              };
              WebSetter.setVec2 = function setVec2(lg, data, name, vec, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                var info = WebSetter.getConstantInfo(lg, data, name);
                Vec2.toArray(info.dataArr, vec, idx * 2);
                data.constants.set(info.constantID, info.dataArr);
              };
              _proto3.setFloat = function setFloat(name, v, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                WebSetter.setFloat(this._lg, this._data, name, v, idx);
              };
              WebSetter.setFloat = function setFloat(lg, data, name, v, idx) {
                if (idx === undefined) {
                  idx = 0;
                }
                var info = WebSetter.getConstantInfo(lg, data, name);
                info.dataArr[0 + idx] = v;
                data.constants.set(info.constantID, info.dataArr);
              };
              _proto3.setArrayBuffer = function setArrayBuffer(name, arrayBuffer) {
                WebSetter.setArrayBuffer(this._lg, this._data, name, arrayBuffer);
              };
              WebSetter.setArrayBuffer = function setArrayBuffer(lg, data, name, arrayBuffer) {
                throw new Error('Method not implemented.');
              };
              _proto3.setBuffer = function setBuffer(name, buffer) {
                WebSetter.setBuffer(this._lg, this._data, name, buffer);
              };
              WebSetter.setBuffer = function setBuffer(lg, data, name, buffer) {
                var num = lg.attributeIndex.get(name);
                data.buffers.set(num, buffer);
              };
              _proto3.setTexture = function setTexture(name, texture) {
                WebSetter.setTexture(this._lg, this._data, name, texture);
              };
              WebSetter.setTexture = function setTexture(lg, data, name, texture) {
                var num = lg.attributeIndex.get(name);
                data.textures.set(num, texture);
              };
              _proto3.setReadWriteBuffer = function setReadWriteBuffer(name, buffer) {
                WebSetter.setReadWriteBuffer(this._lg, this._data, name, buffer);
              };
              WebSetter.setReadWriteBuffer = function setReadWriteBuffer(lg, data, name, buffer) {
                var num = lg.attributeIndex.get(name);
                data.buffers.set(num, buffer);
              };
              _proto3.setReadWriteTexture = function setReadWriteTexture(name, texture) {
                WebSetter.setReadWriteTexture(this._lg, this._data, name, texture);
              };
              WebSetter.setReadWriteTexture = function setReadWriteTexture(lg, data, name, texture) {
                var num = lg.attributeIndex.get(name);
                data.textures.set(num, texture);
              };
              _proto3.setSampler = function setSampler(name, sampler) {
                WebSetter.setSampler(this._lg, this._data, name, sampler);
              };
              WebSetter.setSampler = function setSampler(lg, data, name, sampler) {
                var num = lg.attributeIndex.get(name);
                data.samplers.set(num, sampler);
              };
              _proto3.getParentLayout = function getParentLayout() {
                var director = cclegacy.director;
                var root = director.root;
                var pipeline = root.pipeline;
                var parId = pipeline.renderGraph.getParent(this._vertID);
                var layoutName = pipeline.renderGraph.getLayout(parId);
                return layoutName;
              };
              _proto3.getCurrentLayout = function getCurrentLayout() {
                var director = cclegacy.director;
                var root = director.root;
                var pipeline = root.pipeline;
                var layoutName = pipeline.renderGraph.getLayout(this._vertID);
                return layoutName;
              };
              _proto3.setBuiltinCameraConstants = function setBuiltinCameraConstants(camera) {
                var director = cclegacy.director;
                var root = director.root;
                var pipeline = root.pipeline;
                this.getParentLayout();
                setCameraUBOValues(this, camera, pipeline.pipelineSceneData, camera.scene);
              };
              _proto3.setBuiltinDirectionalLightFrustumConstants = function setBuiltinDirectionalLightFrustumConstants(camera, light, csmLevel) {
                if (csmLevel === undefined) {
                  csmLevel = 0;
                }
                setShadowUBOLightView(this, camera, light, csmLevel);
              };
              _proto3.setBuiltinSpotLightFrustumConstants = function setBuiltinSpotLightFrustumConstants(light) {
                setShadowUBOLightView(this, null, light, 0);
              };
              _proto3.setBuiltinDirectionalLightConstants = function setBuiltinDirectionalLightConstants(light, camera) {
                setShadowUBOView(this, null, this.getParentLayout());
              };
              _proto3.setBuiltinSphereLightConstants = function setBuiltinSphereLightConstants(light, camera) {
                var director = cclegacy.director;
                var pipeline = director.root.pipeline;
                var sceneData = pipeline.pipelineSceneData;
                _uboVec$1.set(light.position.x, light.position.y, light.position.z, 1);
                this.setVec4('cc_lightPos', _uboVec$1);
                _uboVec$1.set(light.size, light.range, 0.0, 0.0);
                this.setVec4('cc_lightSizeRangeAngle', _uboVec$1);
                var isHDR = sceneData.isHDR;
                var lightMeterScale = 10000.0;
                _uboVec$1.set(light.color.x, light.color.y, light.color.z, 0);
                if (light.useColorTemperature) {
                  var finalColor = light.finalColor;
                  _uboVec$1.x = finalColor.x;
                  _uboVec$1.y = finalColor.y;
                  _uboVec$1.z = finalColor.z;
                }
                if (isHDR) {
                  _uboVec$1.w = light.luminance * camera.exposure * lightMeterScale;
                } else {
                  _uboVec$1.w = light.luminance;
                }
                this.setVec4('cc_lightColor', _uboVec$1);
              };
              _proto3.setBuiltinSpotLightConstants = function setBuiltinSpotLightConstants(light, camera) {
                var director = cclegacy.director;
                var pipeline = director.root.pipeline;
                var sceneData = pipeline.pipelineSceneData;
                var shadowInfo = sceneData.shadows;
                _uboVec$1.set(light.position.x, light.position.y, light.position.z, 2);
                this.setVec4('cc_lightPos', _uboVec$1);
                _uboVec$1.set(light.size, light.range, light.spotAngle, shadowInfo.enabled && light.shadowEnabled && shadowInfo.type === ShadowType.ShadowMap ? 1 : 0);
                this.setVec4('cc_lightSizeRangeAngle', _uboVec$1);
                _uboVec$1.set(light.direction.x, light.direction.y, light.direction.z, 0);
                this.setVec4('cc_lightDir', _uboVec$1);
                var isHDR = sceneData.isHDR;
                var lightMeterScale = 10000.0;
                _uboVec$1.set(light.color.x, light.color.y, light.color.z, 0);
                if (light.useColorTemperature) {
                  var finalColor = light.finalColor;
                  _uboVec$1.x = finalColor.x;
                  _uboVec$1.y = finalColor.y;
                  _uboVec$1.z = finalColor.z;
                }
                if (isHDR) {
                  _uboVec$1.w = light.luminance * camera.exposure * lightMeterScale;
                } else {
                  _uboVec$1.w = light.luminance;
                }
                this.setVec4('cc_lightColor', _uboVec$1);
                _uboVec$1.set(0, 0, 0, light.angleAttenuationStrength);
                this.setVec4('cc_lightBoundingSizeVS', _uboVec$1);
              };
              _proto3.setBuiltinPointLightConstants = function setBuiltinPointLightConstants(light, camera) {
                var director = cclegacy.director;
                var pipeline = director.root.pipeline;
                var sceneData = pipeline.pipelineSceneData;
                _uboVec$1.set(light.position.x, light.position.y, light.position.z, 3);
                this.setVec4('cc_lightPos', _uboVec$1);
                _uboVec$1.set(0.0, light.range, 0.0, 0.0);
                this.setVec4('cc_lightSizeRangeAngle', _uboVec$1);
                var isHDR = sceneData.isHDR;
                var lightMeterScale = 10000.0;
                if (light.useColorTemperature) {
                  var finalColor = light.finalColor;
                  _uboVec$1.x = finalColor.x;
                  _uboVec$1.y = finalColor.y;
                  _uboVec$1.z = finalColor.z;
                }
                if (isHDR) {
                  _uboVec$1.w = light.luminance * camera.exposure * lightMeterScale;
                } else {
                  _uboVec$1.w = light.luminance;
                }
                _uboVec$1.set(light.color.x, light.color.y, light.color.z, 0);
                this.setVec4('cc_lightColor', _uboVec$1);
              };
              _proto3.setBuiltinRangedDirectionalLightConstants = function setBuiltinRangedDirectionalLightConstants(light, camera) {
                var director = cclegacy.director;
                var pipeline = director.root.pipeline;
                var sceneData = pipeline.pipelineSceneData;
                _uboVec$1.set(light.position.x, light.position.y, light.position.z, 4);
                this.setVec4('cc_lightPos', _uboVec$1);
                _uboVec$1.set(light.right.x, light.right.y, light.right.z, 0.0);
                this.setVec4('cc_lightSizeRangeAngle', _uboVec$1);
                _uboVec$1.set(light.direction.x, light.direction.y, light.direction.z, 0);
                this.setVec4('cc_lightDir', _uboVec$1);
                var scale = light.scale;
                _uboVec$1.set(scale.x * 0.5, scale.y * 0.5, scale.z * 0.5, 0);
                this.setVec4('cc_lightBoundingSizeVS', _uboVec$1);
                var isHDR = sceneData.isHDR;
                _uboVec$1.set(light.color.x, light.color.y, light.color.z, 0);
                if (light.useColorTemperature) {
                  var finalColor = light.finalColor;
                  _uboVec$1.x = finalColor.x;
                  _uboVec$1.y = finalColor.y;
                  _uboVec$1.z = finalColor.z;
                }
                if (isHDR) {
                  _uboVec$1.w = light.illuminance * camera.exposure;
                } else {
                  _uboVec$1.w = light.illuminance;
                }
                this.setVec4('cc_lightColor', _uboVec$1);
              };
              _proto3.hasSampler = function hasSampler(name) {
                var id = this._lg.constantIndex.get(name);
                if (id === undefined) {
                  return false;
                }
                return this._data.samplers.has(id);
              };
              _proto3.hasTexture = function hasTexture(name) {
                var id = this._lg.constantIndex.get(name);
                if (id === undefined) {
                  return false;
                }
                return this._data.textures.has(id);
              };
              _proto3.setCustomBehavior = function setCustomBehavior(name) {
                throw new Error('Method not implemented.');
              };
              _createClass(WebSetter, [{
                key: "name",
                get: function get() {
                  return '';
                },
                set: function set(name) {}
              }]);
              return WebSetter;
            }();
            var RenderDrawQueue = function () {
              function RenderDrawQueue() {
                this.instances = new Array();
              }
              var _proto4 = RenderDrawQueue.prototype;
              _proto4.empty = function empty() {
                return this.instances.length === 0;
              };
              _proto4.clear = function clear() {
                this.instances.length = 0;
              };
              _proto4.add = function add(model, depth, subModelIdx, passIdx) {
                var subModel = model.subModels[subModelIdx];
                var pass = subModel.passes[passIdx];
                var passPriority = pass.priority;
                var modelPriority = subModel.priority;
                var shaderId = subModel.shaders[passIdx].typedID;
                var hash = 0 << 30 | passPriority << 16 | modelPriority << 8 | passIdx;
                var priority = model.priority;
                var instance = instancePool.add();
                instance.update(subModel, priority, hash, depth, shaderId, passIdx);
                this.instances.push(instance);
              };
              _proto4.sortOpaqueOrCutout = function sortOpaqueOrCutout() {
                this.instances.sort(function (lhs, rhs) {
                  if (lhs.hash !== rhs.hash) {
                    return lhs.hash - rhs.hash;
                  }
                  if (lhs.depth !== rhs.depth) {
                    return lhs.depth - rhs.depth;
                  }
                  return lhs.shaderID - rhs.shaderID;
                });
              };
              _proto4.sortTransparent = function sortTransparent() {
                this.instances.sort(function (lhs, rhs) {
                  if (lhs.priority !== rhs.priority) {
                    return lhs.priority - rhs.priority;
                  }
                  if (lhs.hash !== rhs.hash) {
                    return lhs.hash - rhs.hash;
                  }
                  if (lhs.depth !== rhs.depth) {
                    return rhs.depth - lhs.depth;
                  }
                  return lhs.shaderID - rhs.shaderID;
                });
              };
              _proto4.recordCommandBuffer = function recordCommandBuffer(device, renderPass, cmdBuffer, ds, offset, dynamicOffsets) {
                if (ds === undefined) {
                  ds = null;
                }
                if (offset === undefined) {
                  offset = 0;
                }
                if (dynamicOffsets === undefined) {
                  dynamicOffsets = null;
                }
                for (var _iterator3 = _createForOfIteratorHelperLoose(this.instances), _step3; !(_step3 = _iterator3()).done;) {
                  var instance = _step3.value;
                  var subModel = instance.subModel;
                  var passIdx = instance.passIndex;
                  var inputAssembler = subModel.inputAssembler;
                  var pass = subModel.passes[passIdx];
                  var shader = subModel.shaders[passIdx];
                  var pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, renderPass, inputAssembler);
                  cmdBuffer.bindPipelineState(pso);
                  cmdBuffer.bindDescriptorSet(1, pass.descriptorSet);
                  if (ds) {
                    cmdBuffer.bindDescriptorSet(0, ds, [offset]);
                  }
                  if (dynamicOffsets) {
                    cmdBuffer.bindDescriptorSet(2, subModel.descriptorSet, dynamicOffsets);
                  } else {
                    cmdBuffer.bindDescriptorSet(2, subModel.descriptorSet);
                  }
                  cmdBuffer.bindInputAssembler(inputAssembler);
                  cmdBuffer.draw(inputAssembler);
                }
              };
              return RenderDrawQueue;
            }();
            var RenderInstancingQueue = function () {
              function RenderInstancingQueue() {
                this.passInstances = new Map();
                this.instanceBuffers = new Array();
              }
              var _proto5 = RenderInstancingQueue.prototype;
              _proto5.empty = function empty() {
                return this.passInstances.size === 0;
              };
              _proto5.add = function add(pass, subModel, passID) {
                var iter = this.passInstances.get(pass);
                if (iter === undefined) {
                  var instanceBufferID = this.passInstances.size;
                  if (instanceBufferID >= this.instanceBuffers.length) {
                    this.instanceBuffers.push(new InstancedBuffer(pass));
                  }
                  this.passInstances.set(pass, instanceBufferID);
                  var instanceBuffer = this.instanceBuffers[instanceBufferID];
                  instanceBuffer.pass = pass;
                  instanceBuffer.instances;
                }
                var instancedBuffer = this.instanceBuffers[this.passInstances.get(pass)];
                instancedBuffer.merge(subModel, passID);
              };
              _proto5.clear = function clear() {
                this.passInstances.clear();
                var instanceBuffers = this.instanceBuffers;
                instanceBuffers.forEach(function (instance) {
                  instance.clear();
                });
              };
              _proto5.sort = function sort() {
                this.instanceBuffers = this.instanceBuffers.sort(instancingCompareFn);
              };
              _proto5.uploadBuffers = function uploadBuffers(cmdBuffer) {
                for (var _iterator4 = _createForOfIteratorHelperLoose(this.passInstances.entries()), _step4; !(_step4 = _iterator4()).done;) {
                  var _step4$value = _step4.value;
                    _step4$value[0];
                    var bufferID = _step4$value[1];
                  var instanceBuffer = this.instanceBuffers[bufferID];
                  if (instanceBuffer.hasPendingModels) {
                    instanceBuffer.uploadBuffers(cmdBuffer);
                  }
                }
              };
              _proto5.recordCommandBuffer = function recordCommandBuffer(renderPass, cmdBuffer, ds, offset, dynamicOffsets) {
                if (ds === undefined) {
                  ds = null;
                }
                if (offset === undefined) {
                  offset = 0;
                }
                if (dynamicOffsets === undefined) {
                  dynamicOffsets = null;
                }
                var renderQueue = this.instanceBuffers;
                for (var _iterator5 = _createForOfIteratorHelperLoose(renderQueue), _step5; !(_step5 = _iterator5()).done;) {
                  var instanceBuffer = _step5.value;
                  if (!instanceBuffer.hasPendingModels) {
                    continue;
                  }
                  var instances = instanceBuffer.instances;
                  var drawPass = instanceBuffer.pass;
                  cmdBuffer.bindDescriptorSet(1, drawPass.descriptorSet);
                  var lastPSO = null;
                  for (var _iterator6 = _createForOfIteratorHelperLoose(instances), _step6; !(_step6 = _iterator6()).done;) {
                    var instance = _step6.value;
                    if (!instance.count) {
                      continue;
                    }
                    var pso = PipelineStateManager.getOrCreatePipelineState(deviceManager.gfxDevice, drawPass, instance.shader, renderPass, instance.ia);
                    if (lastPSO !== pso) {
                      cmdBuffer.bindPipelineState(pso);
                      lastPSO = pso;
                    }
                    if (ds) {
                      cmdBuffer.bindDescriptorSet(0, ds, [offset]);
                    }
                    if (dynamicOffsets) {
                      cmdBuffer.bindDescriptorSet(2, instance.descriptorSet, dynamicOffsets);
                    } else {
                      cmdBuffer.bindDescriptorSet(2, instance.descriptorSet, instanceBuffer.dynamicOffsets);
                    }
                    cmdBuffer.bindInputAssembler(instance.ia);
                    cmdBuffer.draw(instance.ia);
                  }
                }
              };
              return RenderInstancingQueue;
            }();
            var RenderQueueQuery = function () {
              function RenderQueueQuery(frustumCulledResultID, lightBoundsCulledResultID, renderQueueTargetIn) {
                if (frustumCulledResultID === undefined) {
                  frustumCulledResultID = 0xFFFFFFFF;
                }
                if (lightBoundsCulledResultID === undefined) {
                  lightBoundsCulledResultID = 0xFFFFFFFF;
                }
                if (renderQueueTargetIn === undefined) {
                  renderQueueTargetIn = 0xFFFFFFFF;
                }
                this.frustumCulledResultID = undefined;
                this.lightBoundsCulledResultID = undefined;
                this.renderQueueTarget = undefined;
                this.frustumCulledResultID = frustumCulledResultID;
                this.lightBoundsCulledResultID = lightBoundsCulledResultID;
                this.renderQueueTarget = renderQueueTargetIn;
              }
              var _proto6 = RenderQueueQuery.prototype;
              _proto6.update = function update(culledSourceIn, lightBoundsCulledResultID, renderQueueTargetIn) {
                if (culledSourceIn === undefined) {
                  culledSourceIn = 0xFFFFFFFF;
                }
                if (lightBoundsCulledResultID === undefined) {
                  lightBoundsCulledResultID = 0xFFFFFFFF;
                }
                if (renderQueueTargetIn === undefined) {
                  renderQueueTargetIn = 0xFFFFFFFF;
                }
                this.frustumCulledResultID = culledSourceIn;
                this.lightBoundsCulledResultID = lightBoundsCulledResultID;
                this.renderQueueTarget = renderQueueTargetIn;
              };
              return RenderQueueQuery;
            }();
            function recordCommand(cmdBuffer, _renderPass, pass, localDesc, shader, ia) {
              var pso;
              if (shader && ia) {
                pso = PipelineStateManager.getOrCreatePipelineState(deviceManager.gfxDevice, pass, shader, _renderPass, ia);
              }
              if (pso) {
                var _ia = ia;
                cmdBuffer.bindPipelineState(pso);
                cmdBuffer.bindDescriptorSet(1, pass.descriptorSet);
                cmdBuffer.bindDescriptorSet(2, localDesc);
                cmdBuffer.bindInputAssembler(_ia);
                cmdBuffer.draw(_ia);
              }
            }
            var RenderQueue = function () {
              function RenderQueue() {
                this.probeQueue = new ProbeHelperQueue();
                this.opaqueQueue = new RenderDrawQueue();
                this.transparentQueue = new RenderDrawQueue();
                this.opaqueInstancingQueue = new RenderInstancingQueue();
                this.transparentInstancingQueue = new RenderInstancingQueue();
                this.camera = null;
                this.sceneFlags = 0;
                this.lightByteOffset = 0xFFFFFFFF;
              }
              var _proto7 = RenderQueue.prototype;
              _proto7.sort = function sort() {
                this.opaqueQueue.sortOpaqueOrCutout();
                this.transparentQueue.sortTransparent();
                this.opaqueInstancingQueue.sort();
                this.transparentInstancingQueue.sort();
              };
              _proto7.update = function update() {
                this.probeQueue.clear();
                this.opaqueQueue.clear();
                this.transparentQueue.clear();
                this.opaqueInstancingQueue.clear();
                this.transparentInstancingQueue.clear();
                this.camera = null;
                this.sceneFlags = 0;
                this.lightByteOffset = 0xFFFFFFFF;
              };
              _proto7.empty = function empty() {
                return this.opaqueQueue.empty() && this.transparentQueue.empty() && this.opaqueInstancingQueue.empty() && this.transparentInstancingQueue.empty();
              };
              _proto7.recordCommands = function recordCommands(cmdBuffer, renderPass, sceneFlags) {
                var offsets = this.lightByteOffset === 0xFFFFFFFF ? null : [this.lightByteOffset];
                if (sceneFlags & (1 | 2)) {
                  this.opaqueQueue.recordCommandBuffer(deviceManager.gfxDevice, renderPass, cmdBuffer, null, 0, offsets);
                  this.opaqueInstancingQueue.recordCommandBuffer(renderPass, cmdBuffer, null, 0, offsets);
                }
                if (sceneFlags & 4) {
                  this.transparentInstancingQueue.recordCommandBuffer(renderPass, cmdBuffer, null, 0, offsets);
                  this.transparentQueue.recordCommandBuffer(deviceManager.gfxDevice, renderPass, cmdBuffer, null, 0, offsets);
                }
              };
              return RenderQueue;
            }();

            var INVALID_ID$1 = 0xFFFFFFFF;
            var ENABLE_SUBPASS = true;
            function getGfxDescriptorType(type) {
              switch (type) {
                case 0:
                  return 1;
                case 1:
                  return 2;
                case 2:
                  return 16;
                case 3:
                  return 32;
                case 4:
                  return 64;
                case 5:
                  return 4;
                case 6:
                  return 8;
                case 7:
                  return 128;
                case 8:
                  return 256;
                default:
                  error('DescriptorType not found');
                  return 256;
              }
            }
            function getDescriptorTypeOrder(type) {
              switch (type) {
                case 1:
                  return 0;
                case 2:
                  return 1;
                case 16:
                  return 2;
                case 32:
                  return 3;
                case 64:
                  return 4;
                case 4:
                  return 5;
                case 8:
                  return 6;
                case 128:
                  return 7;
                case 256:
                  return 8;
                case 0:
                default:
                  error('DescriptorTypeOrder not found');
                  return 8;
              }
            }
            function getCustomPassID(lg, name) {
              return lg.locateChild(lg.N, name || 'default');
            }
            function getCustomSubpassID(lg, passID, name) {
              return lg.locateChild(passID, name);
            }
            function getCustomPhaseID(lg, subpassOrPassID, name) {
              if (name === undefined) {
                return lg.locateChild(subpassOrPassID, 'default');
              }
              if (typeof name === 'number') {
                return lg.locateChild(subpassOrPassID, name.toString());
              }
              return lg.locateChild(subpassOrPassID, name);
            }
            var DEFAULT_UNIFORM_COUNTS = new Map([['cc_lightPos', 1], ['cc_lightColor', 1], ['cc_lightSizeRangeAngle', 1], ['cc_lightDir', 1], ['cc_lightBoundingSizeVS', 1]]);
            function getUniformBlockSize(blockMembers) {
              var prevSize = 0;
              for (var _iterator = _createForOfIteratorHelperLoose(blockMembers), _step; !(_step = _iterator()).done;) {
                var m = _step.value;
                if (m.count) {
                  prevSize += GetTypeSize(m.type) * m.count;
                  continue;
                }
                var iter = DEFAULT_UNIFORM_COUNTS.get(m.name);
                if (iter !== undefined) {
                  prevSize += GetTypeSize(m.type) * iter;
                  continue;
                }
                if (m.name === 'cc_joints') {
                  var sz = GetTypeSize(m.type) * UBOSkinning.LAYOUT.members[0].count;
                  assert(sz !== UBOSkinning.SIZE);
                  prevSize += sz;
                  continue;
                }
                error("Invalid uniform count: " + m.name);
              }
              assert(!!prevSize);
              return prevSize;
            }
            function sortDescriptorBlocks(lhs, rhs) {
              var lhsIndex = JSON.parse(lhs[0]);
              var rhsIndex = JSON.parse(rhs[0]);
              var lhsValue = lhsIndex.updateFrequency * 10000 + lhsIndex.parameterType * 1000 + lhsIndex.descriptorType * 100 + lhsIndex.visibility;
              var rhsValue = rhsIndex.updateFrequency * 10000 + rhsIndex.parameterType * 1000 + rhsIndex.descriptorType * 100 + rhsIndex.visibility;
              return lhsValue - rhsValue;
            }
            function sortDescriptorGroupBlocks(lhs, rhs) {
              var lhsIndex = JSON.parse(lhs[0]);
              var rhsIndex = JSON.parse(rhs[0]);
              var lhsValue = lhsIndex.updateFrequency * 1000000000 + lhsIndex.parameterType * 100000000 + lhsIndex.descriptorType * 10000000 + lhsIndex.visibility * 1000000 + lhsIndex.accessType * 100000 + lhsIndex.viewDimension * 10000 + lhsIndex.sampleType * 1000 + lhsIndex.format;
              var rhsValue = rhsIndex.updateFrequency * 1000000000 + rhsIndex.parameterType * 100000000 + rhsIndex.descriptorType * 10000000 + rhsIndex.visibility * 1000000 + rhsIndex.accessType * 100000 + rhsIndex.viewDimension * 10000 + rhsIndex.sampleType * 1000 + rhsIndex.format;
              return lhsValue - rhsValue;
            }
            function getOrCreateDescriptorID(lg, name) {
              var nameID = lg.attributeIndex.get(name);
              if (nameID === undefined) {
                var newID = lg.valueNames.length;
                lg.attributeIndex.set(name, newID);
                lg.valueNames.push(name);
                return newID;
              }
              return nameID;
            }
            function createDescriptorInfo(layoutData, info) {
              info.bindings.length = 0;
              for (var i = 0; i < layoutData.descriptorBlocks.length; ++i) {
                var block = layoutData.descriptorBlocks[i];
                var slot = block.offset;
                for (var j = 0; j < block.descriptors.length; ++j) {
                  var d = block.descriptors[j];
                  var binding = new DescriptorSetLayoutBinding();
                  binding.binding = slot;
                  binding.descriptorType = getGfxDescriptorType(block.type);
                  binding.count = d.count;
                  binding.stageFlags = block.visibility;
                  binding.access = block.accessType;
                  binding.viewDimension = block.viewDimension;
                  binding.sampleType = block.sampleType;
                  binding.format = block.format;
                  binding.immutableSamplers = [];
                  info.bindings.push(binding);
                  slot += d.count;
                }
              }
            }
            function createDescriptorSetLayout(device, layoutData) {
              var info = new DescriptorSetLayoutInfo();
              createDescriptorInfo(layoutData, info);
              if (device) {
                return device.createDescriptorSetLayout(info);
              } else {
                return null;
              }
            }
            function createGfxDescriptorSetsAndPipelines(device, g) {
              for (var i = 0; i < g._layouts.length; ++i) {
                var ppl = g.getLayout(i);
                var sets = ppl.getSets();
                sets.forEach(function (value, key) {
                  var level = value;
                  var layoutData = level.descriptorSetLayoutData;
                  if (device) {
                    var layout = createDescriptorSetLayout(device, layoutData);
                    if (layout) {
                      level.descriptorSetLayout = layout;
                      level.descriptorSet = device.createDescriptorSet(new DescriptorSetInfo(layout));
                    }
                  } else {
                    createDescriptorInfo(layoutData, level.descriptorSetLayoutInfo);
                  }
                });
              }
            }
            function getDescriptorBlockData(map, index) {
              var key = JSON.stringify(index);
              var block = map.get(key);
              if (block) {
                return block;
              }
              var newBlock = new DescriptorBlockData(index.descriptorType, index.visibility, 0);
              map.set(key, newBlock);
              return newBlock;
            }
            function getDescriptorGroupBlockData(map, index) {
              var key = JSON.stringify(index);
              var block = map.get(key);
              if (block) {
                return block;
              }
              var newBlock = new DescriptorBlockData(index.descriptorType, index.visibility, 0, index.accessType, index.viewDimension, index.sampleType, index.format);
              map.set(key, newBlock);
              return newBlock;
            }
            function getViewDimension(type) {
              switch (type) {
                case 26:
                case 33:
                case 39:
                  return 2;
                case 28:
                case 35:
                case 41:
                  return 4;
                case 29:
                case 36:
                case 42:
                  return 5;
                case 31:
                case 38:
                case 44:
                  return 9;
                case 30:
                case 37:
                case 43:
                  return 8;
                default:
                  return 0;
              }
            }
            function makeDescriptorSetLayoutData(lg, rate, set, descriptors) {
              var map = new Map();
              var uniformBlocks = new Map();
              for (var i = 0; i < descriptors.blocks.length; i++) {
                var cb = descriptors.blocks[i];
                var block = Layout.isWebGPU ? getDescriptorGroupBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 0,
                  visibility: cb.stageFlags,
                  accessType: 1,
                  viewDimension: 1,
                  sampleType: 0,
                  format: 0
                }) : getDescriptorBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 0,
                  visibility: cb.stageFlags
                });
                var nameID = getOrCreateDescriptorID(lg, cb.name);
                block.descriptors.push(new DescriptorData(nameID, 0, 1));
                uniformBlocks.set(nameID, new UniformBlock(set, 0xFFFFFFFF, cb.name, cb.members, 1));
              }
              for (var _i = 0; _i < descriptors.samplerTextures.length; _i++) {
                var samplerTexture = descriptors.samplerTextures[_i];
                var _block = Layout.isWebGPU ? getDescriptorGroupBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 2,
                  visibility: samplerTexture.stageFlags,
                  accessType: 1,
                  viewDimension: getViewDimension(samplerTexture.type),
                  sampleType: samplerTexture.sampleType,
                  format: 0
                }) : getDescriptorBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 2,
                  visibility: samplerTexture.stageFlags
                });
                var _nameID = getOrCreateDescriptorID(lg, samplerTexture.name);
                _block.descriptors.push(new DescriptorData(_nameID, samplerTexture.type, samplerTexture.count));
              }
              for (var _i2 = 0; _i2 < descriptors.samplers.length; _i2++) {
                var sampler = descriptors.samplers[_i2];
                var _block2 = Layout.isWebGPU ? getDescriptorGroupBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 3,
                  visibility: sampler.stageFlags,
                  accessType: 1,
                  viewDimension: 0,
                  sampleType: 0,
                  format: 0
                }) : getDescriptorBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 3,
                  visibility: sampler.stageFlags
                });
                var _nameID2 = getOrCreateDescriptorID(lg, sampler.name);
                _block2.descriptors.push(new DescriptorData(_nameID2, 32, sampler.count));
              }
              for (var _i3 = 0; _i3 < descriptors.textures.length; _i3++) {
                var texture = descriptors.textures[_i3];
                var _block3 = Layout.isWebGPU ? getDescriptorGroupBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 4,
                  visibility: texture.stageFlags,
                  accessType: 1,
                  viewDimension: getViewDimension(texture.type),
                  sampleType: texture.sampleType,
                  format: 0
                }) : getDescriptorBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 4,
                  visibility: texture.stageFlags
                });
                var _nameID3 = getOrCreateDescriptorID(lg, texture.name);
                _block3.descriptors.push(new DescriptorData(_nameID3, texture.type, texture.count));
              }
              for (var _i4 = 0; _i4 < descriptors.buffers.length; _i4++) {
                var buffer = descriptors.buffers[_i4];
                var _block4 = Layout.isWebGPU ? getDescriptorGroupBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 5,
                  visibility: buffer.stageFlags,
                  accessType: 1,
                  viewDimension: 1,
                  sampleType: 0,
                  format: 0
                }) : getDescriptorBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 5,
                  visibility: buffer.stageFlags
                });
                var _nameID4 = getOrCreateDescriptorID(lg, buffer.name);
                _block4.descriptors.push(new DescriptorData(_nameID4, 0, 1));
              }
              for (var _i5 = 0; _i5 < descriptors.images.length; _i5++) {
                var image = descriptors.images[_i5];
                var _block5 = Layout.isWebGPU ? getDescriptorGroupBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 7,
                  visibility: image.stageFlags,
                  accessType: 1,
                  viewDimension: getViewDimension(image.type),
                  sampleType: 0,
                  format: 0
                }) : getDescriptorBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 7,
                  visibility: image.stageFlags
                });
                var _nameID5 = getOrCreateDescriptorID(lg, image.name);
                _block5.descriptors.push(new DescriptorData(_nameID5, image.type, image.count));
              }
              for (var _i6 = 0; _i6 < descriptors.subpassInputs.length; _i6++) {
                var subpassInput = descriptors.subpassInputs[_i6];
                var _block6 = Layout.isWebGPU ? getDescriptorGroupBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 8,
                  visibility: subpassInput.stageFlags,
                  accessType: 1,
                  viewDimension: 4,
                  sampleType: 0,
                  format: 0
                }) : getDescriptorBlockData(map, {
                  updateFrequency: rate,
                  parameterType: 4,
                  descriptorType: 8,
                  visibility: subpassInput.stageFlags
                });
                var _nameID6 = getOrCreateDescriptorID(lg, subpassInput.name);
                _block6.descriptors.push(new DescriptorData(_nameID6, 0, subpassInput.count));
              }
              var flattenedBlocks = Layout.isWebGPU ? Array.from(map).sort(sortDescriptorGroupBlocks) : Array.from(map).sort(sortDescriptorBlocks);
              var data = new DescriptorSetLayoutData(set, 0);
              var capacity = 0;
              for (var _iterator2 = _createForOfIteratorHelperLoose(flattenedBlocks), _step2; !(_step2 = _iterator2()).done;) {
                var _step2$value = _step2.value,
                  key = _step2$value[0],
                  _block7 = _step2$value[1];
                var index = JSON.parse(key);
                _block7.offset = capacity;
                for (var _iterator3 = _createForOfIteratorHelperLoose(_block7.descriptors), _step3; !(_step3 = _iterator3()).done;) {
                  var d = _step3.value;
                  if (index.descriptorType === 0) {
                    var ub = uniformBlocks.get(d.descriptorID);
                    if (!ub) {
                      error("Uniform block not found for " + d.descriptorID);
                      continue;
                    }
                    assert(ub.binding === 0xFFFFFFFF);
                    ub.binding = _block7.capacity;
                    data.uniformBlocks.set(d.descriptorID, ub);
                  }
                  var binding = data.bindingMap.get(d.descriptorID);
                  if (binding !== undefined) {
                    error("Duplicated descriptor " + d.descriptorID);
                  }
                  data.bindingMap.set(d.descriptorID, _block7.offset + _block7.capacity);
                  _block7.capacity += d.count;
                }
                capacity += _block7.capacity;
                data.capacity += _block7.capacity;
                if (index.descriptorType === 0 || index.descriptorType === 1) {
                  data.uniformBlockCapacity += _block7.capacity;
                } else if (index.descriptorType === 2) {
                  data.samplerTextureCapacity += _block7.capacity;
                }
                data.descriptorBlocks.push(_block7);
              }
              return data;
            }
            function initializeDescriptorSetLayoutInfo(layoutData, info) {
              info.bindings.length = 0;
              for (var i = 0; i < layoutData.descriptorBlocks.length; ++i) {
                var block = layoutData.descriptorBlocks[i];
                var slot = block.offset;
                for (var j = 0; j < block.descriptors.length; ++j) {
                  var d = block.descriptors[j];
                  var binding = new DescriptorSetLayoutBinding();
                  binding.binding = slot;
                  binding.descriptorType = getGfxDescriptorType(block.type);
                  binding.count = d.count;
                  binding.stageFlags = block.visibility;
                  binding.access = block.accessType;
                  binding.viewDimension = block.viewDimension;
                  binding.sampleType = block.sampleType;
                  binding.format = block.format;
                  binding.immutableSamplers = [];
                  info.bindings.push(binding);
                  slot += d.count;
                }
              }
            }
            var _emptyDescriptorSetLayout;
            var _emptyPipelineLayout;
            function populatePipelineLayoutInfo(layout, rate, info) {
              var set = layout.getSet(rate);
              if (set && set.descriptorSetLayout) {
                info.setLayouts.push(set.descriptorSetLayout);
              } else {
                info.setLayouts.push(_emptyDescriptorSetLayout);
              }
            }
            function generateConstantMacros(device, constantMacros) {
              "\n  #define CC_DEVICE_SUPPORT_FLOAT_TEXTURE " + (device.getFormatFeatures(44) & (1 | 2) ? '1' : '0') + "\n  #define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS " + device.capabilities.maxVertexUniformVectors + "\n  #define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS " + device.capabilities.maxFragmentUniformVectors + "\n  #define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT " + (device.hasFeature(5) ? '1' : '0') + "\n  #define CC_PLATFORM_ANDROID_AND_WEBGL 0\n  #define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES 0\n  #define CC_JOINT_UNIFORM_CAPACITY " + UBOSkinning.JOINT_UNIFORM_CAPACITY;
            }
            function initializeLayoutGraphData(device, lg) {
              Layout.type = device.gfxAPI === 8 ? 1 : 0;
              Layout.isWebGPU = device.gfxAPI === 8;
              _emptyDescriptorSetLayout = device.createDescriptorSetLayout(new DescriptorSetLayoutInfo());
              _emptyPipelineLayout = device.createPipelineLayout(new PipelineLayoutInfo());
              for (var _iterator4 = _createForOfIteratorHelperLoose(lg.v()), _step4; !(_step4 = _iterator4()).done;) {
                var v = _step4.value;
                var layoutData = lg.getLayout(v);
                var sets = layoutData.getSets();
                for (var _iterator6 = _createForOfIteratorHelperLoose(sets), _step6; !(_step6 = _iterator6()).done;) {
                  var _step6$value = _step6.value;
                    _step6$value[0];
                    var set = _step6$value[1];
                  if (set.descriptorSetLayout !== null) {
                    warn('descriptor set layout already initialized. It will be overwritten');
                  }
                  initializeDescriptorSetLayoutInfo(set.descriptorSetLayoutData, set.descriptorSetLayoutInfo);
                  set.descriptorSetLayout = device.createDescriptorSetLayout(set.descriptorSetLayoutInfo);
                }
              }
              for (var _iterator5 = _createForOfIteratorHelperLoose(lg.v()), _step5; !(_step5 = _iterator5()).done;) {
                var _v = _step5.value;
                if (!lg.h(1, _v)) {
                  continue;
                }
                var subpassOrPassID = lg.getParent(_v);
                var phaseID = _v;
                var passLayout = lg.getLayout(subpassOrPassID);
                var phaseLayout = lg.getLayout(phaseID);
                var info = new PipelineLayoutInfo();
                populatePipelineLayoutInfo(passLayout, 3, info);
                populatePipelineLayoutInfo(phaseLayout, 2, info);
                populatePipelineLayoutInfo(phaseLayout, 1, info);
                populatePipelineLayoutInfo(phaseLayout, 0, info);
                var phase = lg.j(phaseID);
                phase.pipelineLayout = device.createPipelineLayout(info);
              }
            }
            function terminateLayoutGraphData(lg) {
              for (var _iterator7 = _createForOfIteratorHelperLoose(lg.v()), _step7; !(_step7 = _iterator7()).done;) {
                var v = _step7.value;
                var layoutData = lg.getLayout(v);
                var sets = layoutData.getSets();
                for (var _iterator8 = _createForOfIteratorHelperLoose(sets), _step8; !(_step8 = _iterator8()).done;) {
                  var _step8$value = _step8.value;
                    _step8$value[0];
                    var set = _step8$value[1];
                  if (set.descriptorSetLayout !== null) {
                    set.descriptorSetLayout.destroy();
                  }
                }
              }
              _emptyPipelineLayout.destroy();
              _emptyDescriptorSetLayout.destroy();
            }
            function getEmptyDescriptorSetLayout() {
              return _emptyDescriptorSetLayout;
            }
            function getEmptyPipelineLayout() {
              return _emptyPipelineLayout;
            }
            function getOrCreateDescriptorSetLayout(lg, subpassOrPassID, phaseID, rate) {
              if (rate < 3) {
                var phaseData = lg.getLayout(phaseID);
                var _data = phaseData.getSet(rate);
                if (_data) {
                  if (!_data.descriptorSetLayout) {
                    error('descriptor set layout not initialized');
                    return _emptyDescriptorSetLayout;
                  }
                  return _data.descriptorSetLayout;
                }
                return _emptyDescriptorSetLayout;
              }
              assert(rate === 3);
              assert(subpassOrPassID === lg.getParent(phaseID));
              var passData = lg.getLayout(subpassOrPassID);
              var data = passData.getSet(rate);
              if (data) {
                if (!data.descriptorSetLayout) {
                  error('descriptor set layout not initialized');
                  return _emptyDescriptorSetLayout;
                }
                return data.descriptorSetLayout;
              }
              return _emptyDescriptorSetLayout;
            }
            function getDescriptorSetLayout(lg, subpassOrPassID, phaseID, rate) {
              if (rate < 3) {
                var phaseData = lg.getLayout(phaseID);
                var _data2 = phaseData.getSet(rate);
                if (_data2) {
                  if (!_data2.descriptorSetLayout) {
                    error('descriptor set layout not initialized');
                    return null;
                  }
                  return _data2.descriptorSetLayout;
                }
                return null;
              }
              assert(rate === 3);
              assert(subpassOrPassID === lg.getParent(phaseID));
              var passData = lg.getLayout(subpassOrPassID);
              var data = passData.getSet(rate);
              if (data) {
                if (!data.descriptorSetLayout) {
                  error('descriptor set layout not initialized');
                  return null;
                }
                return data.descriptorSetLayout;
              }
              return null;
            }
            function getProgramID(lg, phaseID, programName) {
              assert(phaseID !== lg.N);
              var phase = lg.j(phaseID);
              var programID = phase.shaderIndex.get(programName);
              if (programID === undefined) {
                return INVALID_ID$1;
              }
              return programID;
            }
            function getDescriptorNameID(lg, name) {
              var nameID = lg.attributeIndex.get(name);
              if (nameID === undefined) {
                return INVALID_ID$1;
              }
              return nameID;
            }
            function getDescriptorName(lg, nameID) {
              if (nameID >= lg.valueNames.length) {
                return '';
              }
              return lg.valueNames[nameID];
            }

            var CullingPools = function CullingPools() {
              this.frustumCullingKeyRecycle = new RecyclePool(function () {
                return new FrustumCullingKey();
              }, 8);
              this.frustumCullingsRecycle = new RecyclePool(function () {
                return new FrustumCulling();
              }, 8);
              this.lightBoundsCullingRecycle = new RecyclePool(function () {
                return new LightBoundsCulling();
              }, 8);
              this.lightBoundsCullingResultRecycle = new RecyclePool(function () {
                return new LightBoundsCullingResult();
              }, 8);
              this.lightBoundsCullingKeyRecycle = new RecyclePool(function () {
                return new LightBoundsCullingKey();
              }, 8);
              this.renderQueueRecycle = new RecyclePool(function () {
                return new RenderQueue();
              }, 8);
              this.renderQueueQueryRecycle = new RecyclePool(function () {
                return new RenderQueueQuery();
              }, 8);
            };
            var REFLECTION_PROBE_DEFAULT_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.UI_3D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER]);
            var objIdMap = new WeakMap();
            var cullingKeys = '';
            var objectCount = 0;
            function objectID(claze) {
              if (!objIdMap.has(claze)) objIdMap.set(claze, ++objectCount);
              return objIdMap.get(claze);
            }
            function computeCullingKey(sceneData, castShadows, refId) {
              if (refId === undefined) {
                refId = -1;
              }
              cullingKeys = '';
              var camera = sceneData.camera;
              var light = sceneData.light.light;
              var lightLevel = sceneData.light.level;
              var reflectProbe = sceneData.light.probe;
              var shadeLight = sceneData.shadingLight;
              cullingKeys += hashCombineKey(camera ? objectID(camera) : 0);
              cullingKeys += hashCombineKey(reflectProbe ? objectID(reflectProbe) : 0);
              cullingKeys += hashCombineKey(refId === -1 && light ? objectID(light) : 0);
              cullingKeys += hashCombineKey(refId !== -1 && shadeLight ? objectID(shadeLight) : 0);
              cullingKeys += hashCombineKey(refId === -1 ? lightLevel : 0);
              cullingKeys += hashCombineKey(castShadows ? 1 : 0);
              cullingKeys += hashCombineKey(refId);
              return cullingKeys;
            }
            var FrustumCullingKey = function () {
              function FrustumCullingKey(sceneData, castShadows) {
                if (sceneData === undefined) {
                  sceneData = null;
                }
                if (castShadows === undefined) {
                  castShadows = false;
                }
                this.sceneData = null;
                this.castShadows = false;
                this.sceneData = sceneData;
                this.castShadows = castShadows;
              }
              var _proto = FrustumCullingKey.prototype;
              _proto.update = function update(sceneData, castShadows) {
                this.sceneData = sceneData;
                this.castShadows = castShadows;
              };
              return FrustumCullingKey;
            }();
            var LightBoundsCullingKey = function () {
              function LightBoundsCullingKey(sceneData, frustumCullingID) {
                if (sceneData === undefined) {
                  sceneData = null;
                }
                if (frustumCullingID === undefined) {
                  frustumCullingID = -1;
                }
                this.sceneData = null;
                this.frustumCullingID = -1;
                this.sceneData = sceneData;
                this.frustumCullingID = frustumCullingID;
              }
              var _proto2 = LightBoundsCullingKey.prototype;
              _proto2.update = function update(sceneData, frustumCullingID) {
                if (sceneData === undefined) {
                  sceneData = null;
                }
                if (frustumCullingID === undefined) {
                  frustumCullingID = -1;
                }
                this.sceneData = sceneData;
                this.frustumCullingID = frustumCullingID;
              };
              return LightBoundsCullingKey;
            }();
            var LightBoundsCulling = function () {
              function LightBoundsCulling() {
                this.resultKeyIndex = new Map();
                this.resultIndex = new Map();
              }
              var _proto3 = LightBoundsCulling.prototype;
              _proto3.update = function update() {
                this.resultIndex.clear();
                this.resultKeyIndex.clear();
              };
              return LightBoundsCulling;
            }();
            var LightBoundsCullingResult = function () {
              function LightBoundsCullingResult() {
                this.instances = [];
                this.lightByteOffset = 0xFFFFFFFF;
              }
              var _proto4 = LightBoundsCullingResult.prototype;
              _proto4.update = function update() {
                this.instances.length = 0;
                this.lightByteOffset = 0xFFFFFFFF;
                return this;
              };
              return LightBoundsCullingResult;
            }();
            function makeRenderQueueKey(frustumCulledResultID, lightBoundsCulledResultID, queueLayoutID) {
              return frustumCulledResultID + "-" + lightBoundsCulledResultID + "-" + queueLayoutID;
            }
            function extractRenderQueueKey(key) {
              var keys = key.split('-');
              return [parseInt(keys[0]), parseInt(keys[1]), parseInt(keys[2])];
            }
            var pSceneData;
            var FrustumCulling = function () {
              function FrustumCulling() {
                this.resultIndex = new Map();
                this.resultKeyIndex = new Map();
              }
              var _proto5 = FrustumCulling.prototype;
              _proto5.update = function update() {
                this.resultIndex.clear();
                this.resultKeyIndex.clear();
              };
              return FrustumCulling;
            }();
            function isNodeVisible(node, visibility) {
              return node && (visibility & node.layer) === node.layer;
            }
            function isModelVisible(model, visibility) {
              return !!(visibility & model.visFlags);
            }
            function isVisible(model, visibility) {
              return isNodeVisible(model.node, visibility) || isModelVisible(model, visibility);
            }
            function isReflectProbeMask(model) {
              return bool((model.node.layer & REFLECTION_PROBE_DEFAULT_MASK) === model.node.layer || REFLECTION_PROBE_DEFAULT_MASK & model.visFlags);
            }
            var transWorldBounds = new AABB();
            function isFrustumVisible(model, frustum, castShadow) {
              var modelWorldBounds = model.worldBounds;
              var shadows = pSceneData.shadows;
              if (castShadow && shadows.type === ShadowType.Planar) {
                AABB.transform(transWorldBounds, modelWorldBounds, shadows.matLight);
                return !intersect.aabbFrustum(transWorldBounds, frustum);
              }
              return !intersect.aabbFrustum(modelWorldBounds, frustum);
            }
            function isIntersectAABB(lAABB, rAABB) {
              return !intersect.aabbWithAABB(lAABB, rAABB);
            }
            function sceneCulling(scene, camera, camOrLightFrustum, castShadow, probe, models) {
              var skybox = pSceneData.skybox;
              var skyboxModel = skybox.model;
              var visibility = camera.visibility;
              var camSkyboxFlag = camera.clearFlag & 8;
              if (!castShadow && skybox && skybox.enabled && skyboxModel && camSkyboxFlag) {
                models.push(skyboxModel);
              }
              for (var _iterator = _createForOfIteratorHelperLoose(scene.models), _step; !(_step = _iterator()).done;) {
                var model = _step.value;
                if (!model.enabled || !model.node || castShadow && !model.castShadow) {
                  continue;
                }
                if (scene.isCulledByLod(camera, model)) {
                  continue;
                }
                var wBounds = model.worldBounds;
                if (!probe) {
                  if (!isVisible(model, visibility)) {
                    continue;
                  }
                  if (wBounds && isFrustumVisible(model, camOrLightFrustum, castShadow)) {
                    continue;
                  }
                  models.push(model);
                } else if (probe.probeType === 0) {
                  if (!isVisible(model, visibility)) {
                    continue;
                  }
                  if (wBounds && isIntersectAABB(wBounds, probe.boundingBox)) {
                    continue;
                  }
                  models.push(model);
                } else if (isReflectProbeMask(model)) {
                  models.push(model);
                }
              }
            }
            var _tempVec3 = new Vec3();
            function computeSortingDepth(camera, model) {
              var depth = 0;
              if (model.node) {
                Vec3.subtract(_tempVec3, model.worldBounds ? model.worldBounds.center : model.node.worldPosition, camera.position);
                depth = Vec3.dot(_tempVec3, camera.forward);
              }
              return depth;
            }
            function addRenderObject(phaseLayoutId, isDrawOpaqueOrMask, isDrawBlend, isDrawProbe, camera, model, queue) {
              var probeQueue = queue.probeQueue;
              if (isDrawProbe) {
                probeQueue.addToProbeQueue(model, phaseLayoutId);
              }
              var subModels = model.subModels;
              var subModelCount = subModels.length;
              var skyboxModel = pSceneData.skybox.model;
              var depth = computeSortingDepth(camera, model);
              for (var subModelIdx = 0; subModelIdx < subModelCount; ++subModelIdx) {
                var subModel = subModels[subModelIdx];
                var passes = subModel.passes;
                var passCount = passes.length;
                var probePhase = probeQueue.probeMap.includes(subModel);
                if (probePhase) phaseLayoutId = probeQueue.defaultId;
                for (var passIdx = 0; passIdx < passCount; ++passIdx) {
                  if (model === skyboxModel && !subModelIdx && !passIdx && isDrawOpaqueOrMask) {
                    queue.opaqueQueue.add(model, depth, subModelIdx, passIdx);
                    continue;
                  }
                  var pass = passes[passIdx];
                  var phaseAllowed = phaseLayoutId === pass.phaseID;
                  if (!phaseAllowed) {
                    continue;
                  }
                  var is_blend = pass.blendState.targets[0].blend;
                  var isOpaqueOrMask = !is_blend;
                  if (!isDrawBlend && is_blend) {
                    continue;
                  }
                  if (!isDrawOpaqueOrMask && isOpaqueOrMask) {
                    continue;
                  }
                  if (pass.batchingScheme === 1) {
                    if (is_blend) {
                      queue.transparentInstancingQueue.add(pass, subModel, passIdx);
                    } else {
                      queue.opaqueInstancingQueue.add(pass, subModel, passIdx);
                    }
                  } else if (is_blend) {
                    queue.transparentQueue.add(model, depth, subModelIdx, passIdx);
                  } else {
                    queue.opaqueQueue.add(model, depth, subModelIdx, passIdx);
                  }
                }
              }
            }
            var rangedDirLightBoundingBox = new AABB(0, 0, 0, 0.5, 0.5, 0.5);
            var lightAABB = new AABB();
            var SceneCulling = function () {
              function SceneCulling() {
                this.frustumCullings = new Map();
                this.frustumCullingResults = [];
                this.lightBoundsCullings = new Map();
                this.lightBoundsCullingResults = [];
                this.renderQueueIndex = new Map();
                this.renderQueues = [];
                this.renderQueueQueryIndex = new Map();
                this.cullingPools = new CullingPools();
                this.numFrustumCulling = 0;
                this.numLightBoundsCulling = 0;
                this.numRenderQueues = 0;
                this.layoutGraph = undefined;
                this.renderGraph = undefined;
                this.enableLightCulling = true;
                this.kFilterMask = 8 | 8192;
                this.kDrawMask = 1 | 2 | 4;
                this.kAllMask = this.kFilterMask | this.kDrawMask;
              }
              var _proto6 = SceneCulling.prototype;
              _proto6.resetPool = function resetPool() {
                var cullingPools = this.cullingPools;
                cullingPools.frustumCullingKeyRecycle.reset();
                cullingPools.frustumCullingsRecycle.reset();
                cullingPools.lightBoundsCullingRecycle.reset();
                cullingPools.lightBoundsCullingResultRecycle.reset();
                cullingPools.lightBoundsCullingKeyRecycle.reset();
                cullingPools.renderQueueRecycle.reset();
                cullingPools.renderQueueQueryRecycle.reset();
                instancePool.reset();
              };
              _proto6.clear = function clear() {
                this.resetPool();
                this.frustumCullings.clear();
                this.frustumCullingResults.length = 0;
                this.lightBoundsCullings.clear();
                this.lightBoundsCullingResults.length = 0;
                this.renderQueueIndex.clear();
                this.renderQueues.length = 0;
                this.renderQueueQueryIndex.clear();
                this.numLightBoundsCulling = 0;
                this.numFrustumCulling = 0;
                this.numRenderQueues = 0;
              };
              _proto6.buildRenderQueues = function buildRenderQueues(rg, lg, pplSceneData) {
                this.layoutGraph = lg;
                this.renderGraph = rg;
                pSceneData = pplSceneData;
                this.collectCullingQueries(rg);
                this.batchFrustumCulling(pplSceneData);
                this.batchLightBoundsCulling();
                this.fillRenderQueues();
              };
              _proto6.getOrCreateLightBoundsCulling = function getOrCreateLightBoundsCulling(sceneData, frustumCullingID) {
                var _sceneData$shadingLig;
                if (!(sceneData.cullingFlags & 4)) {
                  return 0xFFFFFFFF;
                }
                if (((_sceneData$shadingLig = sceneData.shadingLight) == null ? undefined : _sceneData$shadingLig.type) === 0) {
                  return 0xFFFFFFFF;
                }
                if (!this.enableLightCulling) {
                  return 0xFFFFFFFF;
                }
                var scene = sceneData.scene;
                var queries = this.lightBoundsCullings.get(scene);
                if (!queries) {
                  var cullingQuery = this.cullingPools.lightBoundsCullingRecycle.add();
                  cullingQuery.update();
                  this.lightBoundsCullings.set(scene, cullingQuery);
                  queries = this.lightBoundsCullings.get(scene);
                }
                var key = computeCullingKey(sceneData, false, frustumCullingID);
                var cullNum = queries.resultIndex.get(key);
                if (cullNum !== undefined) {
                  return cullNum;
                }
                var lightBoundsCullingID = this.numLightBoundsCulling++;
                if (this.numLightBoundsCulling > this.lightBoundsCullingResults.length) {
                  this.lightBoundsCullingResults.push(this.cullingPools.lightBoundsCullingResultRecycle.add().update());
                }
                queries.resultIndex.set(key, lightBoundsCullingID);
                var cullingKey = this.cullingPools.lightBoundsCullingKeyRecycle.add();
                cullingKey.update(sceneData, frustumCullingID);
                queries.resultKeyIndex.set(key, cullingKey);
                return lightBoundsCullingID;
              };
              _proto6.getOrCreateFrustumCulling = function getOrCreateFrustumCulling(sceneId) {
                var sceneData = this.renderGraph.j(sceneId);
                var scene = sceneData.scene;
                var queries = this.frustumCullings.get(scene);
                if (!queries) {
                  var cullingQuery = this.cullingPools.frustumCullingsRecycle.add();
                  cullingQuery.update();
                  this.frustumCullings.set(scene, cullingQuery);
                  queries = this.frustumCullings.get(scene);
                }
                var castShadow = bool(sceneData.flags & 8);
                var key = computeCullingKey(sceneData, castShadow);
                var cullNum = queries.resultIndex.get(key);
                if (cullNum !== undefined) {
                  return cullNum;
                }
                var frustumCulledResultID = this.numFrustumCulling++;
                if (this.numFrustumCulling > this.frustumCullingResults.length) {
                  this.frustumCullingResults.push([]);
                }
                queries.resultIndex.set(key, frustumCulledResultID);
                var cullingKey = this.cullingPools.frustumCullingKeyRecycle.add();
                cullingKey.update(sceneData, castShadow);
                queries.resultKeyIndex.set(key, cullingKey);
                return frustumCulledResultID;
              };
              _proto6.getOrCreateRenderQueue = function getOrCreateRenderQueue(renderQueueKey, sceneFlags, camera) {
                var renderQueueID = this.renderQueueIndex.get(renderQueueKey);
                if (renderQueueID !== undefined) {
                  var _rq = this.renderQueues[renderQueueID];
                  {
                    assert(_rq.camera === camera);
                    assert((_rq.sceneFlags & this.kFilterMask) === (sceneFlags & this.kFilterMask));
                  }
                  _rq.sceneFlags |= sceneFlags & this.kDrawMask;
                  return renderQueueID;
                }
                var targetID = this.numRenderQueues++;
                if (this.numRenderQueues > this.renderQueues.length) {
                  var renderQueue = this.cullingPools.renderQueueRecycle.add();
                  renderQueue.update();
                  this.renderQueues.push(renderQueue);
                }
                var rq = this.renderQueues[targetID];
                this.renderQueueIndex.set(renderQueueKey, targetID);
                {
                  assert(rq.empty());
                  assert(rq.camera === null);
                  assert(rq.sceneFlags === 0);
                  assert(camera !== null);
                  assert(this.renderQueueIndex.size === this.numRenderQueues);
                }
                rq.camera = camera;
                rq.sceneFlags = sceneFlags & this.kAllMask;
                return targetID;
              };
              _proto6.collectCullingQueries = function collectCullingQueries(rg) {
                for (var _iterator2 = _createForOfIteratorHelperLoose(rg.v()), _step2; !(_step2 = _iterator2()).done;) {
                  var v = _step2.value;
                  if (!rg.h(9, v) || !rg.getValid(v)) {
                    continue;
                  }
                  var sceneData = rg.j(v);
                  if (!sceneData.scene) {
                    continue;
                  }
                  var frustumCulledResultID = this.getOrCreateFrustumCulling(v);
                  var lightBoundsCullingID = this.getOrCreateLightBoundsCulling(sceneData, frustumCulledResultID);
                  var queueID = rg.getParent(v);
                  {
                    assert(queueID !== 0xFFFFFFFF);
                    assert(rg.h(8, queueID));
                  }
                  var renderQueue = rg.j(queueID);
                  var phaseLayoutID = renderQueue.phaseID;
                  var renderQueueKey = makeRenderQueueKey(frustumCulledResultID, lightBoundsCullingID, phaseLayoutID);
                  var renderQueueID = this.getOrCreateRenderQueue(renderQueueKey, sceneData.flags, sceneData.camera);
                  var renderQueueQuery = this.cullingPools.renderQueueQueryRecycle.add();
                  renderQueueQuery.update(frustumCulledResultID, lightBoundsCullingID, renderQueueID);
                  this.renderQueueQueryIndex.set(v, renderQueueQuery);
                }
              };
              _proto6.uploadInstancing = function uploadInstancing(cmdBuffer) {
                for (var queueID = 0; queueID !== this.numRenderQueues; ++queueID) {
                  var queue = this.renderQueues[queueID];
                  queue.opaqueInstancingQueue.uploadBuffers(cmdBuffer);
                  queue.transparentInstancingQueue.uploadBuffers(cmdBuffer);
                }
              };
              _proto6._getPhaseIdFromScene = function _getPhaseIdFromScene(scene) {
                var rg = this.renderGraph;
                var renderQueueId = rg.getParent(scene);
                var graphRenderQueue = rg.j(renderQueueId);
                return graphRenderQueue.phaseID;
              };
              _proto6.getBuiltinShadowFrustum = function getBuiltinShadowFrustum(pplSceneData, camera, mainLight, level) {
                var csmLayers = pplSceneData.csmLayers;
                var csmLevel = mainLight.csmLevel;
                var shadows = pplSceneData.shadows;
                if (shadows.type === ShadowType.Planar) {
                  return camera.frustum;
                }
                if (shadows.enabled && shadows.type === ShadowType.ShadowMap && mainLight && mainLight.node) {
                  csmLayers.update(pplSceneData, camera);
                }
                if (mainLight.shadowFixedArea || csmLevel === CSMLevel.LEVEL_1) {
                  return csmLayers.specialLayer.validFrustum;
                }
                return csmLayers.layers[level].validFrustum;
              };
              _proto6.batchFrustumCulling = function batchFrustumCulling(pplSceneData) {
                for (var _iterator3 = _createForOfIteratorHelperLoose(this.frustumCullings), _step3; !(_step3 = _iterator3()).done;) {
                  var _step3$value = _step3.value,
                    scene = _step3$value[0],
                    queries = _step3$value[1];
                  for (var _iterator4 = _createForOfIteratorHelperLoose(queries.resultIndex), _step4; !(_step4 = _iterator4()).done;) {
                    var _step4$value = _step4.value,
                      key = _step4$value[0],
                      frustomCulledResultID = _step4$value[1];
                    var cullingKey = queries.resultKeyIndex.get(key);
                    var sceneData = cullingKey.sceneData;
                    var light = sceneData.light.light;
                    var level = sceneData.light.level;
                    var castShadow = cullingKey.castShadows;
                    var probe = sceneData.light.probe;
                    var camera = probe ? probe.camera : sceneData.camera;
                    var models = this.frustumCullingResults[frustomCulledResultID];
                    if (probe) {
                      sceneCulling(scene, camera, camera.frustum, castShadow, probe, models);
                      continue;
                    }
                    if (light) {
                      switch (light.type) {
                        case 2:
                          sceneCulling(scene, camera, light.frustum, castShadow, null, models);
                          break;
                        case 0:
                          {
                            var frustum = this.getBuiltinShadowFrustum(pplSceneData, camera, light, level);
                            sceneCulling(scene, camera, frustum, castShadow, null, models);
                          }
                          break;
                      }
                    } else {
                      sceneCulling(scene, camera, camera.frustum, castShadow, null, models);
                    }
                  }
                }
              };
              _proto6.executeSphereLightCulling = function executeSphereLightCulling(light, frustumCullingResult, lightBoundsCullingResult) {
                var lightAABB = light.aabb;
                for (var _iterator5 = _createForOfIteratorHelperLoose(frustumCullingResult), _step5; !(_step5 = _iterator5()).done;) {
                  var model = _step5.value;
                  var modelBounds = model.worldBounds;
                  if (!modelBounds || intersect.aabbWithAABB(modelBounds, lightAABB)) {
                    lightBoundsCullingResult.push(model);
                  }
                }
              };
              _proto6.executeSpotLightCulling = function executeSpotLightCulling(light, frustumCullingResult, lightBoundsCullingResult) {
                var lightAABB = light.aabb;
                var lightFrustum = light.frustum;
                for (var _iterator6 = _createForOfIteratorHelperLoose(frustumCullingResult), _step6; !(_step6 = _iterator6()).done;) {
                  var model = _step6.value;
                  var modelBounds = model.worldBounds;
                  if (!modelBounds || intersect.aabbWithAABB(lightAABB, modelBounds) && intersect.aabbFrustum(modelBounds, lightFrustum)) {
                    lightBoundsCullingResult.push(model);
                  }
                }
              };
              _proto6.executePointLightCulling = function executePointLightCulling(light, frustumCullingResult, lightBoundsCullingResult) {
                var lightAABB = light.aabb;
                for (var _iterator7 = _createForOfIteratorHelperLoose(frustumCullingResult), _step7; !(_step7 = _iterator7()).done;) {
                  var model = _step7.value;
                  var modelBounds = model.worldBounds;
                  if (!modelBounds || intersect.aabbWithAABB(lightAABB, modelBounds)) {
                    lightBoundsCullingResult.push(model);
                  }
                }
              };
              _proto6.executeRangedDirectionalLightCulling = function executeRangedDirectionalLightCulling(light, frustumCullingResult, lightBoundsCullingResult) {
                rangedDirLightBoundingBox.transform(light.node.worldMatrix, null, null, null, lightAABB);
                for (var _iterator8 = _createForOfIteratorHelperLoose(frustumCullingResult), _step8; !(_step8 = _iterator8()).done;) {
                  var model = _step8.value;
                  var modelBounds = model.worldBounds;
                  if (!modelBounds || intersect.aabbWithAABB(lightAABB, modelBounds)) {
                    lightBoundsCullingResult.push(model);
                  }
                }
              };
              _proto6.batchLightBoundsCulling = function batchLightBoundsCulling() {
                for (var _iterator9 = _createForOfIteratorHelperLoose(this.lightBoundsCullings), _step9; !(_step9 = _iterator9()).done;) {
                  var _step9$value = _step9.value;
                    _step9$value[0];
                    var queries = _step9$value[1];
                  for (var _iterator10 = _createForOfIteratorHelperLoose(queries.resultIndex), _step10; !(_step10 = _iterator10()).done;) {
                    var _step10$value = _step10.value,
                      key = _step10$value[0],
                      cullingID = _step10$value[1];
                    var cullingKey = queries.resultKeyIndex.get(key);
                    var sceneData = cullingKey.sceneData;
                    var frustumCullingID = cullingKey.frustumCullingID;
                    var frustumCullingResult = this.frustumCullingResults[frustumCullingID];
                    var lightBoundsCullingResult = this.lightBoundsCullingResults[cullingID];
                    switch (sceneData.shadingLight.type) {
                      case 1:
                        {
                          var light = sceneData.shadingLight;
                          this.executeSphereLightCulling(light, frustumCullingResult, lightBoundsCullingResult.instances);
                        }
                        break;
                      case 2:
                        {
                          var _light = sceneData.shadingLight;
                          this.executeSpotLightCulling(_light, frustumCullingResult, lightBoundsCullingResult.instances);
                        }
                        break;
                      case 3:
                        {
                          var _light2 = sceneData.shadingLight;
                          this.executePointLightCulling(_light2, frustumCullingResult, lightBoundsCullingResult.instances);
                        }
                        break;
                      case 4:
                        {
                          var _light3 = sceneData.shadingLight;
                          this.executeRangedDirectionalLightCulling(_light3, frustumCullingResult, lightBoundsCullingResult.instances);
                        }
                        break;
                    }
                  }
                }
              };
              _proto6._getModelsByCullingResults = function _getModelsByCullingResults(lightBoundsCullingID, frustomCulledResultID) {
                if (lightBoundsCullingID !== 0xFFFFFFFF) {
                  if (lightBoundsCullingID < this.lightBoundsCullingResults.length) {
                    return this.lightBoundsCullingResults[lightBoundsCullingID].instances;
                  } else {
                    return [];
                  }
                }
                if (frustomCulledResultID < this.frustumCullingResults.length) {
                  return this.frustumCullingResults[frustomCulledResultID];
                } else {
                  return [];
                }
              };
              _proto6.fillRenderQueues = function fillRenderQueues() {
                for (var _iterator11 = _createForOfIteratorHelperLoose(this.renderQueueIndex), _step11; !(_step11 = _iterator11()).done;) {
                  var _step11$value = _step11.value,
                    key = _step11$value[0],
                    targetID = _step11$value[1];
                  var renderQueue = this.renderQueues[targetID];
                  {
                    assert(targetID < this.renderQueues.length);
                    assert(renderQueue.empty());
                  }
                  var _extractRenderQueueKe = extractRenderQueueKey(key),
                    frustomCulledResultID = _extractRenderQueueKe[0],
                    lightBoundsCullingID = _extractRenderQueueKe[1],
                    phaseLayoutID = _extractRenderQueueKe[2];
                  var isDrawBlend = bool(renderQueue.sceneFlags & 4);
                  var isDrawOpaqueOrMask = bool(renderQueue.sceneFlags & (1 | 2));
                  var isDrawShadowCaster = bool(renderQueue.sceneFlags & 8);
                  var isDrawProbe = bool(renderQueue.sceneFlags & 8192);
                  if (!isDrawShadowCaster && !isDrawBlend && !isDrawOpaqueOrMask && !isDrawProbe) {
                    continue;
                  }
                  var sourceModels = this._getModelsByCullingResults(lightBoundsCullingID, frustomCulledResultID);
                  var camera = renderQueue.camera;
                  for (var _iterator12 = _createForOfIteratorHelperLoose(sourceModels), _step12; !(_step12 = _iterator12()).done;) {
                    var model = _step12.value;
                    addRenderObject(phaseLayoutID, isDrawOpaqueOrMask, isDrawBlend, isDrawProbe, camera, model, renderQueue);
                  }
                  renderQueue.sort();
                }
              };
              return SceneCulling;
            }();
            var LightResource = function () {
              function LightResource() {
                this.cpuBuffer = undefined;
                this.programLibrary = undefined;
                this.device = null;
                this.elementSize = 0;
                this.maxNumLights = 16;
                this.binding = 0xFFFFFFFF;
                this.resized = false;
                this.lightBuffer = undefined;
                this.firstLightBufferView = null;
                this.lights = [];
                this.lightIndex = new Map();
              }
              var _proto7 = LightResource.prototype;
              _proto7.init = function init(programLib, deviceIn, maxNumLights) {
                this.device = deviceIn;
                this.programLibrary = programLib;
                var instanceLayout = this.programLibrary.localLayoutData;
                var attrID = programLib.layoutGraph.attributeIndex.get('CCForwardLight');
                var uniformBlock = instanceLayout.uniformBlocks.get(attrID);
                this.elementSize = AlignUp(getUniformBlockSize(uniformBlock.members), this.device.capabilities.uboOffsetAlignment);
                this.maxNumLights = maxNumLights;
                this.binding = programLib.localLayoutData.bindingMap.get(attrID);
                var bufferSize = this.elementSize * this.maxNumLights;
                this.lightBuffer = this.device.createBuffer(new BufferInfo(16 | 2, 2 | 1, bufferSize, this.elementSize));
                this.firstLightBufferView = this.device.createBuffer(new BufferViewInfo(this.lightBuffer, 0, this.elementSize));
                this.cpuBuffer = new Float32Array(bufferSize / 4);
                this.resized = true;
              };
              _proto7.buildLights = function buildLights(sceneCulling, bHDR, shadowInfo) {
                for (var _iterator13 = _createForOfIteratorHelperLoose(sceneCulling.lightBoundsCullings), _step13; !(_step13 = _iterator13()).done;) {
                  var _step13$value = _step13.value;
                    _step13$value[0];
                    var lightBoundsCullings = _step13$value[1];
                  for (var _iterator15 = _createForOfIteratorHelperLoose(lightBoundsCullings.resultIndex), _step15; !(_step15 = _iterator15()).done;) {
                    var _step15$value = _step15.value,
                      key = _step15$value[0],
                      lightBoundsCullingID = _step15$value[1];
                    var lightBoundsCulling = lightBoundsCullings.resultKeyIndex.get(key);
                    var sceneData = lightBoundsCulling.sceneData;
                    var exposure = 1.0;
                    if (sceneData.camera) {
                      exposure = sceneData.camera.exposure;
                    } else if (sceneData.light.probe && sceneData.light.probe.camera) {
                      exposure = sceneData.light.probe.camera.exposure;
                    } else {
                      throw new Error('Unexpected situation: No camera or probe found.');
                    }
                    var lightByteOffset = this.addLight(sceneData.shadingLight, bHDR, exposure, shadowInfo);
                    var result = sceneCulling.lightBoundsCullingResults[lightBoundsCullingID];
                    result.lightByteOffset = lightByteOffset;
                  }
                }
                for (var _iterator14 = _createForOfIteratorHelperLoose(sceneCulling.renderQueueQueryIndex), _step14; !(_step14 = _iterator14()).done;) {
                  var _step14$value = _step14.value;
                    _step14$value[0];
                    var query = _step14$value[1];
                  if (query.lightBoundsCulledResultID === 0xFFFFFFFF) {
                    continue;
                  }
                  var _lightByteOffset = sceneCulling.lightBoundsCullingResults[query.lightBoundsCulledResultID].lightByteOffset;
                  sceneCulling.renderQueues[query.renderQueueTarget].lightByteOffset = _lightByteOffset;
                }
              };
              _proto7.tryUpdateRenderSceneLocalDescriptorSet = function tryUpdateRenderSceneLocalDescriptorSet(sceneCulling) {
                if (!sceneCulling.lightBoundsCullings.size) {
                  return;
                }
                for (var _iterator16 = _createForOfIteratorHelperLoose(sceneCulling.frustumCullings), _step16; !(_step16 = _iterator16()).done;) {
                  var _step16$value = _step16.value,
                    scene = _step16$value[0];
                    _step16$value[1];
                  for (var _iterator17 = _createForOfIteratorHelperLoose(scene.models), _step17; !(_step17 = _iterator17()).done;) {
                    var model = _step17.value;
                    if (!model) {
                      throw new Error('Unexpected null model.');
                    }
                    for (var _iterator18 = _createForOfIteratorHelperLoose(model.subModels), _step18; !(_step18 = _iterator18()).done;) {
                      var submodel = _step18.value;
                      var set = submodel.descriptorSet;
                      var prev = set.getBuffer(this.binding);
                      if (this.resized || prev !== this.firstLightBufferView) {
                        set.bindBuffer(this.binding, this.firstLightBufferView);
                        set.update();
                      }
                    }
                  }
                }
                this.resized = false;
              };
              _proto7.clear = function clear() {
                this.cpuBuffer.fill(0);
                this.lights.length = 0;
                this.lightIndex.clear();
              };
              _proto7.addLight = function addLight(light, bHDR, exposure, shadowInfo) {
                var existingLightID = this.lightIndex.get(light);
                if (existingLightID !== undefined) {
                  return existingLightID;
                }
                if (this.lights.length === this.maxNumLights) {
                  this.resized = true;
                  this.maxNumLights *= 2;
                  var bufferSize = this.elementSize * this.maxNumLights;
                  this.lightBuffer.resize(bufferSize);
                  this.firstLightBufferView = this.device.createBuffer(new BufferViewInfo(this.lightBuffer, 0, this.elementSize));
                  var prevCpuBuffer = this.cpuBuffer;
                  this.cpuBuffer = new Float32Array(bufferSize / 4);
                  this.cpuBuffer.set(prevCpuBuffer);
                }
                var lightID = this.lights.length;
                this.lights[lightID] = light;
                this.lightIndex.set(light, lightID);
                var offset = this.elementSize / 4 * lightID;
                SetLightUBO(light, bHDR, exposure, shadowInfo, this.cpuBuffer, offset, this.elementSize);
                return lightID * this.elementSize;
              };
              _proto7.buildLightBuffer = function buildLightBuffer(cmdBuffer) {
                cmdBuffer.updateBuffer(this.lightBuffer, this.cpuBuffer, this.lights.length * this.elementSize / 4);
              };
              return LightResource;
            }();

            var ResourceVisitor$1 = function () {
              function ResourceVisitor(resName) {
                if (resName === undefined) {
                  resName = '';
                }
                this.name = undefined;
                this.name = resName;
                if (context$1) {
                  var ppl = context$1.pipeline;
                  ppl.resourceUses.push(resName);
                }
              }
              var _proto = ResourceVisitor.prototype;
              _proto.checkTexture = function checkTexture(name) {
                var dTex = context$1.deviceTextures.get(name);
                if (!dTex) return false;
                var _context$resourceGrap = context$1.resourceGraph.getDesc(context$1.resourceGraph.vertex(name)),
                  descWidth = _context$resourceGrap.width,
                  descHeight = _context$resourceGrap.height;
                var checkDimensions = function checkDimensions(actualWidth, actualHeight) {
                  return actualWidth === descWidth && actualHeight === descHeight;
                };
                return dTex.texture ? checkDimensions(dTex.texture.width, dTex.texture.height) : dTex.swapchain ? checkDimensions(dTex.swapchain.width, dTex.swapchain.height) : false;
              };
              _proto.createDeviceTex = function createDeviceTex(value) {
                var dTex = context$1.deviceTextures.get(this.name);
                if (!dTex || !this.checkTexture(this.name)) {
                  var _dTex;
                  if ((_dTex = dTex) != null && _dTex.texture) {
                    dTex.texture.destroy();
                  }
                  dTex = new DeviceTexture(this.name, value);
                  context$1.deviceTextures.set(this.name, dTex);
                }
              };
              _proto.checkBuffer = function checkBuffer(name) {
                var dBuf = context$1.deviceBuffers.get(name);
                var resID = context$1.resourceGraph.vertex(this.name);
                var desc = context$1.resourceGraph.getDesc(resID);
                return dBuf.buffer.size >= desc.width;
              };
              _proto.createDeviceBuf = function createDeviceBuf(value) {
                var dBuf = context$1.deviceBuffers.get(this.name);
                if (!dBuf || !this.checkBuffer(this.name)) {
                  var _dBuf;
                  if ((_dBuf = dBuf) != null && _dBuf.buffer) {
                    dBuf.buffer.destroy();
                  }
                  dBuf = new DeviceBuffer(this.name, value);
                  context$1.deviceBuffers.set(this.name, dBuf);
                }
              };
              _proto.managed = function managed(value) {
                this.createDeviceTex(value);
              };
              _proto.managedBuffer = function managedBuffer(value) {
                this.createDeviceBuf(value);
              };
              _proto.managedTexture = function managedTexture(value) {};
              _proto.persistentBuffer = function persistentBuffer(value) {
                this.createDeviceBuf(value);
              };
              _proto.persistentTexture = function persistentTexture(value) {
                this.createDeviceTex(value);
              };
              _proto.framebuffer = function framebuffer(value) {
                this.createDeviceTex(value);
              };
              _proto.swapchain = function swapchain(value) {
                this.createDeviceTex(value);
              };
              _proto.formatView = function formatView(value) {};
              _proto.subresourceView = function subresourceView(value) {};
              _createClass(ResourceVisitor, [{
                key: "resName",
                set: function set(value) {
                  this.name = value;
                }
              }]);
              return ResourceVisitor;
            }();
            var context$1;
            var DeviceResource = function () {
              function DeviceResource(name) {
                this._name = undefined;
                this._name = name;
              }
              _createClass(DeviceResource, [{
                key: "name",
                get: function get() {
                  return this._name;
                }
              }]);
              return DeviceResource;
            }();
            var DeviceTexture = function (_DeviceResource) {
              _inheritsLoose(DeviceTexture, _DeviceResource);
              function DeviceTexture(name, tex) {
                var _this;
                _this = _DeviceResource.call(this, name) || this;
                _this._texture = null;
                _this._swapchain = null;
                _this._framebuffer = null;
                _this._desc = null;
                _this._trait = null;
                var resGraph = context$1.resourceGraph;
                var verID = resGraph.vertex(name);
                _this._desc = resGraph.getDesc(verID);
                _this._trait = resGraph.getTraits(verID);
                if (tex instanceof Texture) {
                  _this._texture = tex;
                } else if (tex instanceof Framebuffer) {
                  _this._framebuffer = tex;
                } else if (tex instanceof RenderSwapchain) {
                  _this._swapchain = tex.swapchain;
                } else {
                  _this.createTextureFromDesc(_this._desc);
                }
                return _this;
              }
              var _proto2 = DeviceTexture.prototype;
              _proto2.createTextureFromDesc = function createTextureFromDesc(desc) {
                var type = 1;
                switch (desc.dimension) {
                  case 1:
                    type = 0;
                    break;
                  case 3:
                    type = 2;
                    break;
                }
                var usageFlags = [[16, 16], [32, 32], [64, 64], [8, 4], [4, 8], [256, 1], [512, 2]].reduce(function (acc, _ref) {
                  var flag = _ref[0],
                    bit = _ref[1];
                  return desc.flags & flag ? acc | bit : acc;
                }, 0);
                this._texture = context$1.device.createTexture(new TextureInfo(type, usageFlags, desc.format, desc.width, desc.height));
              };
              _proto2.release = function release() {
                var _this$framebuffer, _this$texture;
                (_this$framebuffer = this.framebuffer) == null ? undefined : _this$framebuffer.destroy();
                this._framebuffer = null;
                (_this$texture = this.texture) == null ? undefined : _this$texture.destroy();
                this._texture = null;
              };
              _createClass(DeviceTexture, [{
                key: "texture",
                get: function get() {
                  return this._texture;
                }
              }, {
                key: "framebuffer",
                get: function get() {
                  return this._framebuffer;
                },
                set: function set(val) {
                  this._framebuffer = val;
                }
              }, {
                key: "description",
                get: function get() {
                  return this._desc;
                }
              }, {
                key: "trait",
                get: function get() {
                  return this._trait;
                }
              }, {
                key: "swapchain",
                get: function get() {
                  return this._swapchain;
                }
              }]);
              return DeviceTexture;
            }(DeviceResource);
            function isShadowMap(scene) {
              var pSceneData = cclegacy.director.root.pipeline.pipelineSceneData;
              return !!(pSceneData.shadows.enabled && pSceneData.shadows.type === ShadowType.ShadowMap && scene && (scene.flags & 8) !== 0);
            }
            var DeviceBuffer = function (_DeviceResource2) {
              _inheritsLoose(DeviceBuffer, _DeviceResource2);
              function DeviceBuffer(name, buffer) {
                var _this2;
                _this2 = _DeviceResource2.call(this, name) || this;
                _this2._buffer = null;
                var resGraph = context$1.resourceGraph;
                var verID = resGraph.vertex(name);
                var desc = resGraph.getDesc(verID);
                var bufferInfo = new BufferInfo(_this2.calculateBufferUsage(desc.flags), 1, desc.width);
                _this2._buffer = context$1.device.createBuffer(bufferInfo);
                return _this2;
              }
              var _proto3 = DeviceBuffer.prototype;
              _proto3.calculateBufferUsage = function calculateBufferUsage(flags) {
                var flagToUsageMap = [[2, 64], [1, 16], [4, 32], [256, 1], [512, 2]];
                return flagToUsageMap.reduce(function (acc, _ref2) {
                  var flag = _ref2[0],
                    usage = _ref2[1];
                  return flags & flag ? acc | usage : acc;
                }, 0);
              };
              _proto3.release = function release() {
                var _this$_buffer;
                (_this$_buffer = this._buffer) == null ? undefined : _this$_buffer.destroy();
                this._buffer = null;
              };
              _createClass(DeviceBuffer, [{
                key: "buffer",
                get: function get() {
                  return this._buffer;
                }
              }]);
              return DeviceBuffer;
            }(DeviceResource);
            var _vec4Array = new Float32Array(4);
            var BlitDesc = function () {
              function BlitDesc(blit) {
                this._isUpdate = false;
                this._isGatherLight = false;
                this._blit = undefined;
                this._screenQuad = null;
                this._stageDesc = undefined;
                this._lightVolumeBuffer = null;
                this._lightMeterScale = 10000.0;
                this._lightBufferData = undefined;
                this._blit = blit;
              }
              var _proto4 = BlitDesc.prototype;
              _proto4._createQuadInputAssembler = function _createQuadInputAssembler() {
                return context$1.blit.pipelineIAData;
              };
              _proto4.createScreenQuad = function createScreenQuad() {
                if (!this._screenQuad) {
                  this._screenQuad = this._createQuadInputAssembler();
                }
              };
              _proto4._gatherVolumeLights = function _gatherVolumeLights(camera) {
                var _this3 = this;
                if (!camera.scene) return;
                var pipeline = context$1.pipeline;
                var cmdBuff = context$1.commandBuffer;
                var sphereLights = camera.scene.sphereLights;
                var spotLights = camera.scene.spotLights;
                var exposure = camera.exposure;
                var maxLights = UBODeferredLight.LIGHTS_PER_PASS;
                var elementLen = Vec4.length;
                var fieldLen = elementLen * maxLights;
                var _sphere = Sphere.create(0, 0, 0, 1);
                var idx = 0;
                var processLight = function processLight(light, isSpot) {
                  if (idx >= maxLights) return;
                  Sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);
                  if (intersect.sphereFrustum(_sphere, camera.frustum)) {
                    Vec3.toArray(_vec4Array, light.position);
                    _vec4Array[3] = isSpot ? 1 : 0;
                    _this3._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 0);
                    Vec3.toArray(_vec4Array, light.color);
                    if (light.useColorTemperature) {
                      var tempRGB = light.colorTemperatureRGB;
                      _vec4Array[0] *= tempRGB.x;
                      _vec4Array[1] *= tempRGB.y;
                      _vec4Array[2] *= tempRGB.z;
                    }
                    _vec4Array[3] = pipeline.pipelineSceneData.isHDR ? light.luminance * exposure * _this3._lightMeterScale : light.luminance;
                    _this3._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 1);
                    _vec4Array[0] = light.size;
                    _vec4Array[1] = light.range;
                    _vec4Array[2] = isSpot ? light.spotAngle : 0.0;
                    _this3._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 2);
                    if (isSpot) {
                      Vec3.toArray(_vec4Array, light.direction);
                      _this3._lightBufferData.set(_vec4Array, idx * elementLen + fieldLen * 3);
                    }
                    idx++;
                  }
                };
                for (var _iterator = _createForOfIteratorHelperLoose(sphereLights), _step; !(_step = _iterator()).done;) {
                  var light = _step.value;
                  processLight(light, false);
                }
                for (var _iterator2 = _createForOfIteratorHelperLoose(spotLights), _step2; !(_step2 = _iterator2()).done;) {
                  var _light = _step2.value;
                  processLight(_light, true);
                }
                var offset = fieldLen * 3 + 3;
                this._lightBufferData.set([idx], offset);
                cmdBuff.updateBuffer(this._lightVolumeBuffer, this._lightBufferData);
              };
              _proto4.update = function update() {
                if (this.blit.sceneFlags & 64 && this.blit.camera && !this._isGatherLight) {
                  this._gatherVolumeLights(this.blit.camera);
                  this._isGatherLight = true;
                  this._isUpdate = false;
                }
                if (!this._isUpdate) {
                  this._stageDesc.update();
                  this._isUpdate = true;
                }
              };
              _proto4.reset = function reset() {
                this._isUpdate = false;
                this._isGatherLight = false;
              };
              _proto4.createStageDescriptor = function createStageDescriptor() {
                var blit = this.blit;
                var pass = blit.material.passes[blit.passID];
                var device = context$1.device;
                this._stageDesc = context$1.blit.stageDescs.get(pass) || device.createDescriptorSet(new DescriptorSetInfo(pass.localSetLayout));
                context$1.blit.stageDescs.set(pass, this._stageDesc);
                if (this.blit.sceneFlags & 64) {
                  this._lightVolumeBuffer = context$1.blit.lightVolumeBuffer;
                  var deferredLitsBufView = context$1.blit.deferredLitsBufView;
                  this._lightBufferData = context$1.blit.lightBufferData;
                  this._lightBufferData.fill(0);
                  this._stageDesc.bindBuffer(UBOForwardLight.BINDING, deferredLitsBufView);
                }
                this._stageDesc.bindBuffer(UBOLocal.BINDING, context$1.blit.emptyLocalUBO);
              };
              _createClass(BlitDesc, [{
                key: "screenQuad",
                get: function get() {
                  return this._screenQuad;
                }
              }, {
                key: "blit",
                get: function get() {
                  return this._blit;
                },
                set: function set(blit) {
                  this._blit = blit;
                }
              }, {
                key: "stageDesc",
                get: function get() {
                  return this._stageDesc;
                }
              }]);
              return BlitDesc;
            }();
            var DeviceComputeQueue = function () {
              function DeviceComputeQueue() {
                this._devicePass = undefined;
                this._hint = 0;
                this._phaseID = getPhaseID$1('default');
                this._renderPhase = null;
                this._descSetData = null;
                this._layoutID = -1;
                this._isUpdateUBO = false;
                this._isUploadInstance = false;
                this._isUploadBatched = false;
                this._queueId = -1;
              }
              var _proto5 = DeviceComputeQueue.prototype;
              _proto5.preRecord = function preRecord() {};
              _proto5.postRecord = function postRecord() {};
              _proto5.init = function init(devicePass, renderQueue, id) {
                this.reset();
                this.queueHint = renderQueue.hint;
                this.queueId = id;
                this._devicePass = devicePass;
                this._phaseID = cclegacy.rendering.getPhaseID(devicePass.passID, context$1.renderGraph.getLayout(id));
              };
              _proto5.reset = function reset() {
                this._isUpdateUBO = false;
                this._isUploadInstance = false;
                this._isUploadBatched = false;
              };
              _proto5.record = function record() {
                if (this._descSetData && this._descSetData.descriptorSet) {
                  context$1.commandBuffer.bindDescriptorSet(3, this._descSetData.descriptorSet);
                }
              };
              _createClass(DeviceComputeQueue, [{
                key: "phaseID",
                get: function get() {
                  return this._phaseID;
                }
              }, {
                key: "layoutID",
                get: function get() {
                  return this._layoutID;
                },
                set: function set(value) {
                  this._layoutID = value;
                  var layoutGraph = context$1.layoutGraph;
                  this._renderPhase = layoutGraph.h(1, value) ? layoutGraph.j(value) : null;
                  var layout = layoutGraph.getLayout(value);
                  this._descSetData = layout.getSet(2);
                }
              }, {
                key: "descSetData",
                get: function get() {
                  return this._descSetData;
                }
              }, {
                key: "renderPhase",
                get: function get() {
                  return this._renderPhase;
                }
              }, {
                key: "queueId",
                get: function get() {
                  return this._queueId;
                },
                set: function set(val) {
                  this._queueId = val;
                }
              }, {
                key: "isUpdateUBO",
                get: function get() {
                  return this._isUpdateUBO;
                },
                set: function set(update) {
                  this._isUpdateUBO = update;
                }
              }, {
                key: "isUploadInstance",
                get: function get() {
                  return this._isUploadInstance;
                },
                set: function set(value) {
                  this._isUploadInstance = value;
                }
              }, {
                key: "isUploadBatched",
                get: function get() {
                  return this._isUploadBatched;
                },
                set: function set(value) {
                  this._isUploadBatched = value;
                }
              }, {
                key: "queueHint",
                get: function get() {
                  return this._hint;
                },
                set: function set(value) {
                  this._hint = value;
                }
              }, {
                key: "devicePass",
                get: function get() {
                  return this._devicePass;
                }
              }]);
              return DeviceComputeQueue;
            }();
            var DeviceRenderQueue = function () {
              function DeviceRenderQueue() {
                this._renderScenes = [];
                this._devicePass = undefined;
                this._hint = 0;
                this._graphQueue = undefined;
                this._phaseID = getPhaseID$1('default');
                this._renderPhase = null;
                this._descSetData = null;
                this._viewport = null;
                this._scissor = null;
                this._layoutID = -1;
                this._isUpdateUBO = false;
                this._isUploadInstance = false;
                this._isUploadBatched = false;
                this._blitDesc = null;
                this._queueId = -1;
              }
              var _proto6 = DeviceRenderQueue.prototype;
              _proto6.init = function init(devicePass, renderQueue, id) {
                this.reset();
                this._graphQueue = renderQueue;
                this.queueHint = renderQueue.hint;
                var viewport = this._viewport = renderQueue.viewport;
                if (viewport) {
                  this._scissor = new Rect$1(viewport.left, viewport.top, viewport.width, viewport.height);
                }
                this.queueId = id;
                this._devicePass = devicePass;
                this._phaseID = cclegacy.rendering.getPhaseID(devicePass.passID, context$1.renderGraph.getLayout(id));
              };
              _proto6.createBlitDesc = function createBlitDesc(blit) {
                if (!this._blitDesc) {
                  this._blitDesc = new BlitDesc(blit);
                }
                this._blitDesc.createScreenQuad();
                this._blitDesc.createStageDescriptor();
              };
              _proto6.setScene = function setScene(sceneID, scene, blit) {
                var deviceScene = context$1.pools.addDeviceScene();
                deviceScene.init(this, sceneID, scene, blit);
                this._renderScenes.push(deviceScene);
                return deviceScene;
              };
              _proto6.reset = function reset() {
                var _this$_blitDesc;
                this._renderScenes.length = 0;
                this._isUpdateUBO = false;
                this._isUploadInstance = false;
                this._isUploadBatched = false;
                (_this$_blitDesc = this._blitDesc) == null ? undefined : _this$_blitDesc.reset();
              };
              _proto6.preRecord = function preRecord() {};
              _proto6.record = function record() {
                if (this._descSetData && this._descSetData.descriptorSet) {
                  context$1.commandBuffer.bindDescriptorSet(3, this._descSetData.descriptorSet);
                }
                this._renderScenes.forEach(function (scene) {
                  scene.record();
                });
              };
              _proto6.postRecord = function postRecord() {};
              _createClass(DeviceRenderQueue, [{
                key: "phaseID",
                get: function get() {
                  return this._phaseID;
                }
              }, {
                key: "layoutID",
                get: function get() {
                  return this._layoutID;
                },
                set: function set(value) {
                  this._layoutID = value;
                  var layoutGraph = context$1.layoutGraph;
                  this._renderPhase = layoutGraph.h(1, value) ? layoutGraph.j(value) : null;
                  var layout = layoutGraph.getLayout(value);
                  this._descSetData = layout.getSet(2);
                }
              }, {
                key: "descSetData",
                get: function get() {
                  return this._descSetData;
                }
              }, {
                key: "renderPhase",
                get: function get() {
                  return this._renderPhase;
                }
              }, {
                key: "viewport",
                get: function get() {
                  return this._viewport;
                }
              }, {
                key: "scissor",
                get: function get() {
                  return this._scissor;
                }
              }, {
                key: "queueId",
                get: function get() {
                  return this._queueId;
                },
                set: function set(val) {
                  this._queueId = val;
                }
              }, {
                key: "isUpdateUBO",
                get: function get() {
                  return this._isUpdateUBO;
                },
                set: function set(update) {
                  this._isUpdateUBO = update;
                }
              }, {
                key: "isUploadInstance",
                get: function get() {
                  return this._isUploadInstance;
                },
                set: function set(value) {
                  this._isUploadInstance = value;
                }
              }, {
                key: "isUploadBatched",
                get: function get() {
                  return this._isUploadBatched;
                },
                set: function set(value) {
                  this._isUploadBatched = value;
                }
              }, {
                key: "graphQueue",
                get: function get() {
                  return this._graphQueue;
                }
              }, {
                key: "blitDesc",
                get: function get() {
                  return this._blitDesc;
                }
              }, {
                key: "renderScenes",
                get: function get() {
                  return this._renderScenes;
                }
              }, {
                key: "queueHint",
                get: function get() {
                  return this._hint;
                },
                set: function set(value) {
                  this._hint = value;
                }
              }, {
                key: "devicePass",
                get: function get() {
                  return this._devicePass;
                }
              }]);
              return DeviceRenderQueue;
            }();
            var RenderPassLayoutInfo = function () {
              function RenderPassLayoutInfo(layoutId, vertId, input) {
                this._layoutID = 0;
                this._vertID = -1;
                this._resID = -1;
                this._stage = null;
                this._layout = undefined;
                this._inputName = undefined;
                this._descriptorSet = null;
                this._inputName = input[0];
                this._layoutID = layoutId;
                this._vertID = vertId;
                var lg = context$1.layoutGraph;
                this._stage = lg.j(layoutId);
                this._layout = lg.getLayout(layoutId);
                var layoutData = this._layout.getSet(3);
                if (!layoutData) {
                  return;
                }
                var layoutDesc = layoutData.descriptorSet;
                var deviceTex = context$1.deviceTextures.get(this._inputName);
                var gfxTex = deviceTex == null ? undefined : deviceTex.texture;
                var deviceBuf = context$1.deviceBuffers.get(this._inputName);
                var gfxBuf = deviceBuf == null ? undefined : deviceBuf.buffer;
                if (!gfxTex && !gfxBuf) {
                  throw Error("Could not find texture with resource name " + this._inputName);
                }
                this._resID = context$1.resourceGraph.vertex(this._inputName);
                var samplerInfo = context$1.resourceGraph.getSampler(this._resID);
                for (var _iterator3 = _createForOfIteratorHelperLoose(input[1]), _step3; !(_step3 = _iterator3()).done;) {
                  var descriptor = _step3.value;
                  var descriptorName = descriptor.name;
                  var descriptorID = lg.attributeIndex.get(descriptorName);
                  if (descriptorID === undefined) {
                    continue;
                  }
                  this.bindDescriptor(layoutDesc, descriptorID, gfxTex, gfxBuf, samplerInfo, input[1][0].accessType);
                }
              }
              var _proto7 = RenderPassLayoutInfo.prototype;
              _proto7.bindDescriptor = function bindDescriptor(layoutDesc, descriptorID, gfxTex, gfxBuf, samplerInfo, accessType) {
                var layoutData = this._layout.getSet(3);
                var desc = context$1.resourceGraph.getDesc(this._resID);
                for (var _iterator4 = _createForOfIteratorHelperLoose(layoutData.descriptorSetLayoutData.descriptorBlocks), _step4; !(_step4 = _iterator4()).done;) {
                  var block = _step4.value;
                  for (var i = 0; i < block.descriptors.length; ++i) {
                    if (descriptorID === block.descriptors[i].descriptorID) {
                      var offset = block.offset;
                      if (gfxTex) {
                        layoutDesc.bindTexture(offset + i, gfxTex);
                        var renderData = context$1.renderGraph.getData(this._vertID);
                        var sampler = renderData.samplers.get(descriptorID) || context$1.device.getSampler(samplerInfo);
                        layoutDesc.bindSampler(offset + i, sampler);
                      } else if (desc.flags & 4) {
                        var access = accessType !== 0 ? 8388608 : 32768;
                        layoutDesc.bindBuffer(block.offset + i, gfxBuf, 0, access);
                      } else {
                        layoutDesc.bindBuffer(offset + i, gfxBuf);
                      }
                      if (!this._descriptorSet) {
                        this._descriptorSet = layoutDesc;
                      }
                      break;
                    }
                  }
                }
              };
              _createClass(RenderPassLayoutInfo, [{
                key: "descriptorSet",
                get: function get() {
                  return this._descriptorSet;
                }
              }, {
                key: "layoutID",
                get: function get() {
                  return this._layoutID;
                }
              }, {
                key: "vertID",
                get: function get() {
                  return this._vertID;
                }
              }, {
                key: "stage",
                get: function get() {
                  return this._stage;
                }
              }, {
                key: "layout",
                get: function get() {
                  return this._layout;
                }
              }]);
              return RenderPassLayoutInfo;
            }();
            var profilerViewport = new Viewport();
            var renderPassArea = new Rect$1();
            var resourceVisitor = new ResourceVisitor$1();
            var DeviceRenderPass = function () {
              function DeviceRenderPass(rasterID, rasterPass) {
                this._renderPass = undefined;
                this._framebuffer = undefined;
                this._clearColor = [];
                this._deviceQueues = new Map();
                this._clearDepth = 1;
                this._clearStencil = 0;
                this._passID = undefined;
                this._rasterID = undefined;
                this._rasterPass = undefined;
                this._layoutName = undefined;
                this._viewport = null;
                this._layout = null;
                this._idxOfRenderData = 0;
                this._rasterID = rasterID;
                this._rasterPass = rasterPass;
                var device = context$1.device;
                this._layoutName = context$1.renderGraph.getLayout(rasterID);
                this._passID = cclegacy.rendering.getPassID(this._layoutName);
                var depAtt = new DepthStencilAttachment();
                depAtt.format = 55;
                var colors = [];
                var colorTexs = [];
                var depthTex = null;
                var swapchain = null;
                var framebuffer = null;
                for (var _iterator5 = _createForOfIteratorHelperLoose(rasterPass.rasterViews), _step5; !(_step5 = _iterator5()).done;) {
                  var _step5$value = _step5.value,
                    resName = _step5$value[0],
                    rasterV = _step5$value[1];
                  var resTex = context$1.deviceTextures.get(resName);
                  if (!resTex) {
                    this.visitResource(resName);
                    resTex = context$1.deviceTextures.get(resName);
                  } else {
                    var resGraph = context$1.resourceGraph;
                    var resId = resGraph.vertex(resName);
                    var resFbo = resGraph.object(resId);
                    if (resTex.framebuffer && resFbo instanceof Framebuffer && resTex.framebuffer !== resFbo) {
                      resTex.framebuffer = resFbo;
                    } else if (resTex.texture) {
                      var desc = resGraph.getDesc(resId);
                      if (resTex.texture.width !== desc.width || resTex.texture.height !== desc.height) {
                        resTex.texture.resize(desc.width, desc.height);
                      }
                    }
                  }
                  if (!swapchain) swapchain = resTex.swapchain;
                  if (!framebuffer) framebuffer = resTex.framebuffer;
                  if (rasterV.attachmentType === 0) {
                    if (!resTex.swapchain && !resTex.framebuffer) colorTexs.push(resTex.texture);
                    var colAtt = new ColorAttachment();
                    colAtt.format = resTex.description.format;
                    colAtt.sampleCount = resTex.description.sampleCount;
                    colAtt.loadOp = rasterV.loadOp;
                    colAtt.storeOp = rasterV.storeOp;
                    colAtt.barrier = device.getGeneralBarrier(new GeneralBarrierInfo(rasterV.loadOp === 0 ? 2097152 : 0, rasterV.storeOp === 0 ? 2097152 : 0));
                    var currCol = new Color$1();
                    currCol.copy(rasterV.clearColor);
                    this._clearColor.push(currCol);
                    colors.push(colAtt);
                  } else if (rasterV.attachmentType === 1) {
                    depAtt.depthStoreOp = rasterV.storeOp;
                    depAtt.stencilStoreOp = rasterV.storeOp;
                    depAtt.depthLoadOp = rasterV.loadOp;
                    depAtt.stencilLoadOp = rasterV.loadOp;
                    depAtt.barrier = device.getGeneralBarrier(new GeneralBarrierInfo(rasterV.loadOp === 0 ? 4194304 : 0, rasterV.storeOp === 0 ? 4194304 : 0));
                    if (!resTex.swapchain && !resTex.framebuffer) {
                      depthTex = resTex.texture;
                    } else if (resTex.swapchain) {
                      depthTex = resTex.swapchain.depthStencilTexture;
                    }
                    this._clearDepth = rasterV.clearColor.x;
                    this._clearStencil = rasterV.clearColor.y;
                  }
                }
                if (colors.length === 0) {
                  var colorAttachment = new ColorAttachment();
                  colors.push(colorAttachment);
                }
                if (colorTexs.length === 0 && !swapchain && !framebuffer) {
                  var currTex = device.createTexture(new TextureInfo());
                  colorTexs.push(currTex);
                }
                var renderPassInfo = new RenderPassInfo();
                renderPassInfo.colorAttachments = colors;
                var depth = swapchain ? swapchain.depthStencilTexture : depthTex;
                if (depth) {
                  renderPassInfo.depthStencilAttachment = depAtt;
                }
                this._renderPass = device.createRenderPass(renderPassInfo);
                this._createFramebuffer(framebuffer, swapchain ? [swapchain.colorTexture] : colorTexs, swapchain ? swapchain.depthStencilTexture : depthTex);
              }
              var _proto8 = DeviceRenderPass.prototype;
              _proto8.addIdxOfRD = function addIdxOfRD() {
                this._idxOfRenderData++;
              };
              _proto8.visitResource = function visitResource(resName) {
                var resourceGraph = context$1.resourceGraph;
                var vertId = resourceGraph.vertex(resName);
                resourceVisitor.resName = resName;
                resourceGraph.visitVertex(resourceVisitor, vertId);
              };
              _proto8.addQueue = function addQueue(queue) {
                this._deviceQueues.set(queue.queueId, queue);
              };
              _proto8.preRecord = function preRecord() {
                context$1.passDescriptorSet = getDescriptorSetDataFromLayout(this.layoutName).descriptorSet;
              };
              _proto8._applyRenderLayout = function _applyRenderLayout(input) {
                var stageName = context$1.renderGraph.getLayout(this._rasterID);
                if (stageName) {
                  var layoutGraph = context$1.layoutGraph;
                  var stageId = layoutGraph.locateChild(layoutGraph.N, stageName);
                  if (stageId !== 0xFFFFFFFF) {
                    this._layout = new RenderPassLayoutInfo(stageId, this._rasterID, input);
                  }
                }
              };
              _proto8.getGlobalDescData = function getGlobalDescData() {
                var stageId = context$1.layoutGraph.locateChild(context$1.layoutGraph.N, 'default');
                var layout = context$1.layoutGraph.getLayout(stageId);
                var layoutData = layout.getSet(3);
                return layoutData;
              };
              _proto8._applyViewport = function _applyViewport(frameTex) {
                this._viewport = null;
                var viewport = this._rasterPass.viewport;
                if (viewport.left !== 0 || viewport.top !== 0 || viewport.width !== 0 || viewport.height !== 0) {
                  this._viewport = viewport;
                }
              };
              _proto8.beginPass = function beginPass() {
                var tex = this.framebuffer.colorTextures[0];
                this._applyViewport(tex);
                var cmdBuff = context$1.commandBuffer;
                if (this._viewport) {
                  renderPassArea.x = this._viewport.left;
                  renderPassArea.y = this._viewport.top;
                  renderPassArea.width = this._viewport.width;
                  renderPassArea.height = this._viewport.height;
                } else {
                  renderPassArea.y = renderPassArea.x = 0;
                  renderPassArea.width = tex.width;
                  renderPassArea.height = tex.height;
                }
                cmdBuff.beginRenderPass(this.renderPass, this.framebuffer, renderPassArea, this.clearColor, this.clearDepth, this.clearStencil);
                if (context$1.passDescriptorSet) {
                  cmdBuff.bindDescriptorSet(0, context$1.passDescriptorSet);
                }
              };
              _proto8.endPass = function endPass() {
                var cmdBuff = context$1.commandBuffer;
                cmdBuff.endRenderPass();
              };
              _proto8.record = function record() {
                this.beginPass();
                for (var _iterator6 = _createForOfIteratorHelperLoose(this._deviceQueues.values()), _step6; !(_step6 = _iterator6()).done;) {
                  var queue = _step6.value;
                  queue.record();
                }
                this.endPass();
              };
              _proto8.postRecord = function postRecord() {};
              _proto8._processRenderLayout = function _processRenderLayout(pass) {
                for (var _iterator7 = _createForOfIteratorHelperLoose(pass.computeViews), _step7; !(_step7 = _iterator7()).done;) {
                  var cv = _step7.value;
                  this._applyRenderLayout(cv);
                }
                if (this.renderLayout && this.renderLayout.descriptorSet) {
                  this.renderLayout.descriptorSet.update();
                }
              };
              _proto8.processRenderLayout = function processRenderLayout() {
                this._processRenderLayout(this._rasterPass);
              };
              _proto8._createFramebuffer = function _createFramebuffer(fbo, cols, depthTex) {
                if (!fbo && !cols.length) return;
                if (this._framebuffer && fbo !== this._framebuffer) this._framebuffer.destroy();
                this._framebuffer = fbo || context$1.device.createFramebuffer(new FramebufferInfo(this._renderPass, cols, depthTex));
              };
              _proto8.resetResource = function resetResource(id, pass) {
                var _currFramebuffer$dept, _currFramebuffer$widt, _currFramebuffer$heig, _currFramebuffer$need;
                this._rasterID = id;
                this._rasterPass = pass;
                this._layoutName = context$1.renderGraph.getLayout(id);
                this._passID = cclegacy.rendering.getPassID(this._layoutName);
                this._deviceQueues.clear();
                this._idxOfRenderData = 0;
                var framebuffer = null;
                var colTextures = [];
                var currFramebuffer = this._framebuffer;
                var currFBDepthTex = (_currFramebuffer$dept = currFramebuffer == null ? undefined : currFramebuffer.depthStencilTexture) !== null && _currFramebuffer$dept !== undefined ? _currFramebuffer$dept : null;
                var depTexture = currFramebuffer ? currFBDepthTex : null;
                var currentWidth = (_currFramebuffer$widt = currFramebuffer == null ? undefined : currFramebuffer.width) !== null && _currFramebuffer$widt !== undefined ? _currFramebuffer$widt : 0;
                var currentHeight = (_currFramebuffer$heig = currFramebuffer == null ? undefined : currFramebuffer.height) !== null && _currFramebuffer$heig !== undefined ? _currFramebuffer$heig : 0;
                var width = 0,
                  height = 0;
                for (var _iterator8 = _createForOfIteratorHelperLoose(pass.rasterViews), _step8; !(_step8 = _iterator8()).done;) {
                  var _step8$value = _step8.value,
                    resName = _step8$value[0],
                    rasterV = _step8$value[1];
                  if (rasterV.attachmentType !== 2) {
                    var resDesc = context$1.resourceGraph.getDesc(context$1.resourceGraph.vertex(resName));
                    width = resDesc.width;
                    height = resDesc.height;
                    break;
                  }
                }
                var isInsideTexDestroy = (currFramebuffer == null ? undefined : currFramebuffer.colorTextures.some(function (colTex) {
                  return !colTex || colTex.getTextureHandle() === 0;
                })) || currFBDepthTex && currFBDepthTex.getTextureHandle() === 0;
                var needRebuild = width !== currentWidth || height !== currentHeight || ((_currFramebuffer$need = currFramebuffer == null ? undefined : currFramebuffer.needRebuild) !== null && _currFramebuffer$need !== undefined ? _currFramebuffer$need : false) || isInsideTexDestroy;
                for (var _iterator9 = _createForOfIteratorHelperLoose(pass.rasterViews), _step9; !(_step9 = _iterator9()).done;) {
                  var _step9$value = _step9.value,
                    _resName = _step9$value[0],
                    _rasterV = _step9$value[1];
                  var deviceTex = context$1.deviceTextures.get(_resName);
                  if (!deviceTex) {
                    this.visitResource(_resName);
                    deviceTex = context$1.deviceTextures.get(_resName);
                  }
                  var resGraph = context$1.resourceGraph;
                  var resId = resGraph.vertex(_resName);
                  var resFbo = resGraph.object(resId);
                  var _resDesc = resGraph.getDesc(resId);
                  if (deviceTex.framebuffer && resFbo instanceof Framebuffer && (deviceTex.framebuffer !== resFbo || resFbo !== this._framebuffer)) {
                    framebuffer = this._framebuffer = deviceTex.framebuffer = resFbo;
                  } else if (deviceTex.texture && needRebuild) {
                    var gfxTex = deviceTex.texture;
                    gfxTex.resize(_resDesc.width, _resDesc.height);
                    if (_rasterV.attachmentType === 0) {
                      colTextures.push(gfxTex);
                    } else if (_rasterV.attachmentType === 1) {
                      depTexture = gfxTex;
                    }
                  }
                }
                this._createFramebuffer(framebuffer, colTextures, depTexture);
              };
              _createClass(DeviceRenderPass, [{
                key: "indexOfRD",
                get: function get() {
                  return this._idxOfRenderData;
                }
              }, {
                key: "rasterID",
                get: function get() {
                  return this._rasterID;
                }
              }, {
                key: "layoutName",
                get: function get() {
                  return this._layoutName;
                }
              }, {
                key: "passID",
                get: function get() {
                  return this._passID;
                }
              }, {
                key: "renderLayout",
                get: function get() {
                  return this._layout;
                }
              }, {
                key: "renderPass",
                get: function get() {
                  return this._renderPass;
                }
              }, {
                key: "framebuffer",
                get: function get() {
                  return this._framebuffer;
                }
              }, {
                key: "clearColor",
                get: function get() {
                  return this._clearColor;
                }
              }, {
                key: "clearDepth",
                get: function get() {
                  return this._clearDepth;
                }
              }, {
                key: "clearStencil",
                get: function get() {
                  return this._clearStencil;
                }
              }, {
                key: "deviceQueues",
                get: function get() {
                  return this._deviceQueues;
                }
              }, {
                key: "viewport",
                get: function get() {
                  return this._viewport;
                }
              }]);
              return DeviceRenderPass;
            }();
            var ComputePassInfo = function () {
              function ComputePassInfo() {
                this._id = undefined;
                this._pass = undefined;
              }
              var _proto9 = ComputePassInfo.prototype;
              _proto9.applyInfo = function applyInfo(id, pass) {
                this._id = id;
                this._pass = pass;
              };
              _createClass(ComputePassInfo, [{
                key: "id",
                get: function get() {
                  return this._id;
                }
              }, {
                key: "pass",
                get: function get() {
                  return this._pass;
                }
              }]);
              return ComputePassInfo;
            }();
            var DeviceComputePass = function () {
              function DeviceComputePass(passInfo) {
                this._deviceQueues = [];
                this._passID = undefined;
                this._layoutName = undefined;
                this._viewport = null;
                this._computeInfo = undefined;
                this._layout = null;
                this._computeInfo = passInfo;
                this._layoutName = context$1.renderGraph.getLayout(passInfo.id);
                this._passID = cclegacy.rendering.getPassID(this._layoutName);
                for (var _iterator10 = _createForOfIteratorHelperLoose(passInfo.pass.computeViews), _step10; !(_step10 = _iterator10()).done;) {
                  var cv = _step10.value;
                  var resTex = context$1.deviceTextures.get(cv[0]);
                  if (!resTex) {
                    this.visitResource(cv[0]);
                    resTex = context$1.deviceTextures.get(cv[0]);
                  }
                  this._applyRenderLayout(cv);
                }
                if (this.renderLayout && this.renderLayout.descriptorSet) {
                  this.renderLayout.descriptorSet.update();
                }
              }
              var _proto10 = DeviceComputePass.prototype;
              _proto10.preRecord = function preRecord() {
                context$1.passDescriptorSet = getDescriptorSetDataFromLayout(this.layoutName).descriptorSet;
              };
              _proto10.postRecord = function postRecord() {};
              _proto10.visitResource = function visitResource(resName) {
                var resourceGraph = context$1.resourceGraph;
                var vertId = resourceGraph.vertex(resName);
                resourceVisitor.resName = resName;
                resourceGraph.visitVertex(resourceVisitor, vertId);
              };
              _proto10.addQueue = function addQueue(queue) {
                this._deviceQueues.push(queue);
              };
              _proto10._applyRenderLayout = function _applyRenderLayout(input) {
                var stageName = context$1.renderGraph.getLayout(this._computeInfo.id);
                if (stageName) {
                  var layoutGraph = context$1.layoutGraph;
                  var stageId = layoutGraph.locateChild(layoutGraph.N, stageName);
                  if (stageId !== 0xFFFFFFFF) {
                    this._layout = new RenderPassLayoutInfo(stageId, this._computeInfo.id, input);
                  }
                }
              };
              _proto10.getGlobalDescData = function getGlobalDescData() {
                var stageId = context$1.layoutGraph.locateChild(context$1.layoutGraph.N, 'default');
                var layout = context$1.layoutGraph.getLayout(stageId);
                var layoutData = layout.getSet(3);
                return layoutData;
              };
              _proto10.record = function record() {
                var cmdBuff = context$1.commandBuffer;
                if (context$1.passDescriptorSet) {
                  cmdBuff.bindDescriptorSet(0, context$1.passDescriptorSet);
                }
                for (var _iterator11 = _createForOfIteratorHelperLoose(this._deviceQueues), _step11; !(_step11 = _iterator11()).done;) {
                  var queue = _step11.value;
                  queue.record();
                }
                var renderData = context$1.renderGraph.getData(this._computeInfo.id);
                updateGlobalDescBinding(renderData, -1, 0, context$1.renderGraph.getLayout(this._computeInfo.id));
              };
              _proto10.resetResource = function resetResource(id, pass) {
                this._computeInfo.applyInfo(id, pass);
                this._layoutName = context$1.renderGraph.getLayout(id);
                this._passID = cclegacy.rendering.getPassID(this._layoutName);
                this._deviceQueues.length = 0;
                for (var _iterator12 = _createForOfIteratorHelperLoose(this._computeInfo.pass.computeViews), _step12; !(_step12 = _iterator12()).done;) {
                  var cv = _step12.value;
                  this._applyRenderLayout(cv);
                }
                if (this.renderLayout && this.renderLayout.descriptorSet) {
                  this.renderLayout.descriptorSet.update();
                }
              };
              _createClass(DeviceComputePass, [{
                key: "layoutName",
                get: function get() {
                  return this._layoutName;
                }
              }, {
                key: "passID",
                get: function get() {
                  return this._passID;
                }
              }, {
                key: "renderLayout",
                get: function get() {
                  return this._layout;
                }
              }, {
                key: "deviceQueues",
                get: function get() {
                  return this._deviceQueues;
                }
              }, {
                key: "computePassInfo",
                get: function get() {
                  return this._computeInfo;
                }
              }]);
              return DeviceComputePass;
            }();
            var sceneViewport = new Viewport();
            var DeviceRenderScene = function () {
              function DeviceRenderScene() {
                this._currentQueue = undefined;
                this._renderPass = undefined;
                this._scene = null;
                this._camera = null;
                this._sceneData = undefined;
                this._blit = undefined;
                this._sceneID = -1;
              }
              var _proto11 = DeviceRenderScene.prototype;
              _proto11.preRecord = function preRecord() {
                if (this._blit && this._blit.blitType === 0) {
                  this._currentQueue.createBlitDesc(this._blit);
                  this._currentQueue.blitDesc.update();
                }
                context$1.lightResource.buildLightBuffer(context$1.commandBuffer);
                context$1.lightResource.tryUpdateRenderSceneLocalDescriptorSet(context$1.culling);
              };
              _proto11.postRecord = function postRecord() {};
              _proto11.init = function init(queue, sceneID, scene, blit) {
                this._currentQueue = queue;
                this._sceneData = scene;
                this._blit = blit;
                this._sceneID = sceneID;
                this._renderPass = queue.devicePass.renderPass;
                var camera = scene && scene.camera ? scene.camera : blit && blit.camera ? blit.camera : null;
                if (camera) {
                  this._scene = camera.scene;
                  this._camera = camera;
                }
              };
              _proto11._record3D = function _record3D() {
                var blit = this._blit;
                var device = context$1.device;
                var cmdBuff = context$1.commandBuffer;
                for (var _iterator13 = _createForOfIteratorHelperLoose(blit.models), _step13; !(_step13 = _iterator13()).done;) {
                  var model = _step13.value;
                  for (var _iterator14 = _createForOfIteratorHelperLoose(model.subModels), _step14; !(_step14 = _iterator14()).done;) {
                    var subModel = _step14.value;
                    var inputAssembler = subModel.inputAssembler;
                    var passCount = subModel.passes.length;
                    for (var passId = 0; passId < passCount; ++passId) {
                      var pass = subModel.passes[passId];
                      var shader = subModel.shaders[passId];
                      var pso = PipelineStateManager.getOrCreatePipelineState(device, pass, shader, this._renderPass, inputAssembler);
                      cmdBuff.bindPipelineState(pso);
                      cmdBuff.bindDescriptorSet(1, pass.descriptorSet);
                      cmdBuff.bindDescriptorSet(2, subModel.descriptorSet);
                      cmdBuff.bindInputAssembler(inputAssembler);
                      cmdBuff.draw(inputAssembler);
                    }
                  }
                }
              };
              _proto11._recordUI = function _recordUI() {
                var batches = this.camera.scene.batches;
                for (var i = 0; i < batches.length; i++) {
                  var batch = batches[i];
                  var visible = false;
                  if (this.camera.visibility & batch.visFlags) {
                    visible = true;
                  }
                  if (!visible) continue;
                  var count = batch.shaders.length;
                  for (var j = 0; j < count; j++) {
                    var pass = batch.passes[j];
                    if (pass.phaseID !== this._currentQueue.phaseID) continue;
                    var shader = batch.shaders[j];
                    var ia = batch.inputAssembler;
                    var ds = batch.descriptorSet;
                    recordCommand(context$1.commandBuffer, this._renderPass, pass, ds, shader, ia);
                  }
                }
              };
              _proto11._showProfiler = function _showProfiler() {
                var rect = renderPassArea;
                var profiler = context$1.pipeline.profiler;
                if (!profiler || !profiler.enabled || !context$1.passShowStatistics) {
                  return;
                }
                var profilerDesc = context$1.profilerDescriptorSet;
                var renderPass = this._renderPass;
                var cmdBuff = context$1.commandBuffer;
                var submodel = profiler.subModels[0];
                var pass = submodel.passes[0];
                var ia = submodel.inputAssembler;
                profilerViewport.width = rect.width;
                profilerViewport.height = rect.height;
                cmdBuff.setViewport(profilerViewport);
                cmdBuff.setScissor(rect);
                cmdBuff.bindDescriptorSet(0, profilerDesc);
                recordCommand(cmdBuff, renderPass, pass, submodel.descriptorSet, submodel.shaders[0], ia);
              };
              _proto11._recordBlit = function _recordBlit() {
                if (!this.blit) {
                  return;
                }
                var blit = this.blit;
                var currMat = blit.material;
                var pass = currMat.passes[blit.passID];
                pass.update();
                var shader = pass.getShaderVariant();
                var blitDesc = this._currentQueue.blitDesc;
                var screenIa = blitDesc.screenQuad.quadIA;
                recordCommand(context$1.commandBuffer, this._renderPass, pass, blitDesc.stageDesc, shader, screenIa);
              };
              _proto11._updateGlobal = function _updateGlobal(data, sceneId) {
                var devicePass = this._currentQueue.devicePass;
                devicePass.addIdxOfRD();
                updateGlobalDescBinding(data, sceneId, devicePass.indexOfRD, context$1.renderGraph.getLayout(devicePass.rasterID));
              };
              _proto11._updateRenderData = function _updateRenderData() {
                var _context$passDescript;
                if (this._currentQueue.isUpdateUBO) return;
                var devicePass = this._currentQueue.devicePass;
                var rasterId = devicePass.rasterID;
                var passRenderData = context$1.renderGraph.getData(rasterId);
                var sceneId = this.sceneID;
                this._updateGlobal(context$1.renderGraph.globalRenderData, sceneId);
                this._updateGlobal(passRenderData, sceneId);
                var queueId = this._currentQueue.queueId;
                var queueRenderData = context$1.renderGraph.getData(queueId);
                this._updateGlobal(queueRenderData, sceneId);
                var sceneRenderData = context$1.renderGraph.getData(sceneId);
                if (sceneRenderData) this._updateGlobal(sceneRenderData, sceneId);
                devicePass.processRenderLayout();
                (_context$passDescript = context$1.passDescriptorSet) == null ? undefined : _context$passDescript.update();
                this._currentQueue.isUpdateUBO = true;
              };
              _proto11._applyViewport = function _applyViewport() {
                var queueViewport = this._currentQueue.viewport;
                if (queueViewport) {
                  context$1.commandBuffer.setViewport(queueViewport);
                  context$1.commandBuffer.setScissor(this._currentQueue.scissor);
                } else if (!this._currentQueue.devicePass.viewport) {
                  var texture = this._currentQueue.devicePass.framebuffer.colorTextures[0];
                  var lightInfo = this.sceneData ? this.sceneData.light : null;
                  var area = isShadowMap(this.sceneData) && this.sceneData && lightInfo.light ? getRenderArea(this.camera, texture.width, texture.height, lightInfo.light, lightInfo.level) : getRenderArea(this.camera, texture.width, texture.height);
                  sceneViewport.left = area.x;
                  sceneViewport.top = area.y;
                  sceneViewport.width = area.width;
                  sceneViewport.height = area.height;
                  context$1.commandBuffer.setViewport(sceneViewport);
                  context$1.commandBuffer.setScissor(area);
                }
              };
              _proto11.record = function record() {
                var devicePass = this._currentQueue.devicePass;
                var sceneCulling = context$1.culling;
                this._updateRenderData();
                this._applyViewport();
                if (this.blit) {
                  switch (this.blit.blitType) {
                    case 0:
                      this._recordBlit();
                      break;
                    case 1:
                      this._recordUI();
                      break;
                    case 2:
                      this._showProfiler();
                      break;
                    case 3:
                      this._record3D();
                      break;
                  }
                  return;
                }
                var rqQuery = sceneCulling.renderQueueQueryIndex.get(this.sceneID);
                var rq = sceneCulling.renderQueues[rqQuery.renderQueueTarget];
                var graphSceneData = this.sceneData;
                var isProbe = bool(graphSceneData.flags & 8192);
                if (isProbe) rq.probeQueue.applyMacro();
                rq.recordCommands(context$1.commandBuffer, this._renderPass, graphSceneData.flags);
                if (isProbe) rq.probeQueue.removeMacro();
                if (graphSceneData.flags & 512) {
                  var _geometryRenderer;
                  (_geometryRenderer = this.camera.geometryRenderer) == null ? undefined : _geometryRenderer.render(devicePass.renderPass, context$1.commandBuffer, context$1.pipeline.pipelineSceneData);
                }
              };
              _createClass(DeviceRenderScene, [{
                key: "blit",
                get: function get() {
                  return this._blit;
                }
              }, {
                key: "sceneData",
                get: function get() {
                  return this._sceneData;
                }
              }, {
                key: "sceneID",
                get: function get() {
                  return this._sceneID;
                }
              }, {
                key: "camera",
                get: function get() {
                  return this._camera;
                }
              }]);
              return DeviceRenderScene;
            }();
            var ExecutorPools = function () {
              function ExecutorPools() {
                this.deviceQueuePool = undefined;
                this.computeQueuePool = undefined;
                this.passPool = undefined;
                this.deviceScenePool = undefined;
                this.deviceQueuePool = new RecyclePool(function () {
                  return new DeviceRenderQueue();
                }, 16);
                this.deviceScenePool = new RecyclePool(function () {
                  return new DeviceRenderScene();
                }, 16);
                this.computeQueuePool = new RecyclePool(function () {
                  return new DeviceComputeQueue();
                }, 16);
                this.passPool = new RecyclePool(function () {
                  return {
                    priority: 0,
                    hash: 0,
                    depth: 0,
                    shaderId: 0,
                    subModel: null,
                    passIdx: 0
                  };
                }, 64);
              }
              var _proto12 = ExecutorPools.prototype;
              _proto12.addDeviceQueue = function addDeviceQueue() {
                return this.deviceQueuePool.add();
              };
              _proto12.addComputeQueue = function addComputeQueue() {
                return this.computeQueuePool.add();
              };
              _proto12.addDeviceScene = function addDeviceScene() {
                return this.deviceScenePool.add();
              };
              _proto12.reset = function reset() {
                this.deviceQueuePool.reset();
                this.computeQueuePool.reset();
                this.deviceScenePool.reset();
              };
              return ExecutorPools;
            }();
            var quadRect = new Rect$1();
            var volLightAttrCount = 5;
            var BlitInfo = function () {
              function BlitInfo(context) {
                this._pipelineIAData = undefined;
                this._context = undefined;
                this._width = undefined;
                this._height = undefined;
                this._lightVolumeBuffer = undefined;
                this._lightBufferData = undefined;
                this._deferredLitsBufView = undefined;
                this._localUBO = undefined;
                this._stageDescs = new Map();
                this._context = context;
                this._width = context.width;
                this._height = context.height;
                this._pipelineIAData = this._createQuadInputAssembler();
                var vb = this._genQuadVertexData(0, new Rect$1(0, 0, context.width, context.height));
                this._pipelineIAData.quadVB.update(vb);
                this._createLightVolumes();
                var size = 224;
                this._localUBO = context.device.createBuffer(new BufferInfo(16 | 2, 1, size, size));
              }
              var _proto13 = BlitInfo.prototype;
              _proto13.resize = function resize(width, height) {
                if (width !== this._width || height !== this._height) {
                  quadRect.y = quadRect.x = 0;
                  quadRect.width = width;
                  quadRect.height = height;
                  var vb = this._genQuadVertexData(0, quadRect);
                  this._pipelineIAData.quadVB.update(vb);
                }
              };
              _proto13._createLightVolumes = function _createLightVolumes() {
                var device = this._context.root.device;
                var totalSize = 4 * volLightAttrCount * 4 * UBODeferredLight.LIGHTS_PER_PASS;
                totalSize = Math.ceil(totalSize / device.capabilities.uboOffsetAlignment) * device.capabilities.uboOffsetAlignment;
                this._lightVolumeBuffer = device.createBuffer(new BufferInfo(16 | 2, 2 | 1, totalSize, device.capabilities.uboOffsetAlignment));
                this._deferredLitsBufView = device.createBuffer(new BufferViewInfo(this._lightVolumeBuffer, 0, totalSize));
                this._lightBufferData = new Float32Array(totalSize / 4);
              };
              _proto13._genQuadVertexData = function _genQuadVertexData(surfaceTransform, renderArea) {
                var minX = renderArea.x / this._context.width;
                var maxX = (renderArea.x + renderArea.width) / this._context.width;
                var minY = renderArea.y / this._context.height;
                var maxY = (renderArea.y + renderArea.height) / this._context.height;
                if (this._context.root.device.capabilities.screenSpaceSignY > 0) {
                  var _ref3 = [maxY, minY];
                  minY = _ref3[0];
                  maxY = _ref3[1];
                }
                var vbData = new Float32Array(16);
                var fillVertices = function fillVertices(x1, y1, u1, v1, x2, y2, u2, v2, x3, y3, u3, v3, x4, y4, u4, v4) {
                  vbData.set([x1, y1, u1, v1, x2, y2, u2, v2, x3, y3, u3, v3, x4, y4, u4, v4]);
                };
                switch (surfaceTransform) {
                  case 0:
                    fillVertices(-1, -1, minX, maxY, 1, -1, maxX, maxY, -1, 1, minX, minY, 1, 1, maxX, minY);
                    break;
                  case 1:
                    fillVertices(-1, -1, maxX, maxY, 1, -1, maxX, minY, -1, 1, minX, maxY, 1, 1, minX, minY);
                    break;
                  case 2:
                    fillVertices(-1, -1, minX, minY, 1, -1, maxX, minY, -1, 1, minX, maxY, 1, 1, maxX, maxY);
                    break;
                  case 3:
                    fillVertices(-1, -1, minX, minY, 1, -1, minX, maxY, -1, 1, maxX, minY, 1, 1, maxX, maxY);
                    break;
                }
                return vbData;
              };
              _proto13._createQuadInputAssembler = function _createQuadInputAssembler() {
                var inputAssemblerData = new PipelineInputAssemblerData();
                var vbStride = 4 * 4;
                var vbSize = vbStride * 4;
                var device = cclegacy.director.root.device;
                var quadVB = device.createBuffer(new BufferInfo(8 | 2, 1 | 2, vbSize, vbStride));
                if (!quadVB) {
                  return inputAssemblerData;
                }
                var ibStride = 2;
                var ibSize = ibStride * 6;
                var quadIB = device.createBuffer(new BufferInfo(4 | 2, 1, ibSize, ibStride));
                if (!quadIB) {
                  return inputAssemblerData;
                }
                var indices = new Uint16Array(6);
                indices[0] = 0;
                indices[1] = 1;
                indices[2] = 2;
                indices[3] = 1;
                indices[4] = 3;
                indices[5] = 2;
                quadIB.update(indices.buffer);
                var attributes = new Array(2);
                attributes[0] = new Attribute('a_position', 21);
                attributes[1] = new Attribute('a_texCoord', 21);
                var quadIA = device.createInputAssembler(new InputAssemblerInfo(attributes, [quadVB], quadIB));
                inputAssemblerData.quadIB = quadIB;
                inputAssemblerData.quadVB = quadVB;
                inputAssemblerData.quadIA = quadIA;
                return inputAssemblerData;
              };
              _createClass(BlitInfo, [{
                key: "pipelineIAData",
                get: function get() {
                  return this._pipelineIAData;
                }
              }, {
                key: "deferredLitsBufView",
                get: function get() {
                  return this._deferredLitsBufView;
                }
              }, {
                key: "lightVolumeBuffer",
                get: function get() {
                  return this._lightVolumeBuffer;
                }
              }, {
                key: "lightBufferData",
                get: function get() {
                  return this._lightBufferData;
                }
              }, {
                key: "stageDescs",
                get: function get() {
                  return this._stageDescs;
                }
              }, {
                key: "emptyLocalUBO",
                get: function get() {
                  return this._localUBO;
                }
              }]);
              return BlitInfo;
            }();
            var ExecutorContext = function () {
              function ExecutorContext(pipeline, device, resourceGraph, renderGraph, layoutGraph, width, height, descriptorSet) {
                if (descriptorSet === undefined) {
                  descriptorSet = null;
                }
                this.device = undefined;
                this.pipeline = undefined;
                this.commandBuffer = undefined;
                this.pipelineSceneData = undefined;
                this.resourceGraph = undefined;
                this.devicePasses = new Map();
                this.deviceTextures = new Map();
                this.deviceBuffers = new Map();
                this.layoutGraph = undefined;
                this.root = undefined;
                this.pools = undefined;
                this.blit = undefined;
                this.culling = undefined;
                this.lightResource = new LightResource();
                this.renderGraph = undefined;
                this.width = undefined;
                this.height = undefined;
                this.cullCamera = undefined;
                this.passDescriptorSet = undefined;
                this.profilerDescriptorSet = undefined;
                this.passShowStatistics = false;
                this.pipeline = pipeline;
                this.device = device;
                this.commandBuffer = device.commandBuffer;
                this.pipelineSceneData = pipeline.pipelineSceneData;
                this.resourceGraph = resourceGraph;
                this.renderGraph = renderGraph;
                this.root = legacyCC.director.root;
                this.layoutGraph = layoutGraph;
                this.width = width;
                this.height = height;
                this.pools = new ExecutorPools();
                this.blit = new BlitInfo(this);
                this.culling = new SceneCulling();
                this.passDescriptorSet = descriptorSet;
                this.profilerDescriptorSet = getDescriptorSetDataFromLayout('default').descriptorSet;
              }
              var _proto14 = ExecutorContext.prototype;
              _proto14.reset = function reset() {
                this.culling.clear();
                this.pools.reset();
                this.cullCamera = null;
                this.lightResource.clear();
                this.passShowStatistics = false;
              };
              _proto14.resize = function resize(width, height) {
                this.width = width;
                this.height = height;
                this.blit.resize(width, height);
              };
              return ExecutorContext;
            }();
            var Executor = function () {
              function Executor(pipeline, device, resourceGraph, layoutGraph, width, height) {
                this._context = undefined;
                this._visitor = undefined;
                context$1 = this._context = new ExecutorContext(pipeline, device, resourceGraph, new RenderGraph(), layoutGraph, width, height);
                var programLib = cclegacy.rendering.programLib;
                context$1.lightResource.init(programLib, device, 16);
              }
              var _proto15 = Executor.prototype;
              _proto15.resize = function resize(width, height) {
                context$1.resize(width, height);
              };
              _proto15._removeDeviceResource = function _removeDeviceResource() {
                var pipeline = context$1.pipeline;
                var resourceUses = pipeline.resourceUses;
                var deletes = [];
                var deviceTexs = context$1.deviceTextures;
                for (var _iterator15 = _createForOfIteratorHelperLoose(deviceTexs), _step15; !(_step15 = _iterator15()).done;) {
                  var _step15$value = _step15.value,
                    _name2 = _step15$value[0];
                    _step15$value[1];
                  var resId = context$1.resourceGraph.vertex(_name2);
                  var trait = context$1.resourceGraph.getTraits(resId);
                  if (!resourceUses.includes(_name2)) {
                    switch (trait.residency) {
                      case 0:
                        deletes.push(_name2);
                        break;
                    }
                  }
                }
                for (var _i = 0, _deletes = deletes; _i < _deletes.length; _i++) {
                  var name = _deletes[_i];
                  deviceTexs.get(name).release();
                  deviceTexs["delete"](name);
                }
                var deletesBuff = [];
                var deviceBuffs = context$1.deviceBuffers;
                for (var _iterator16 = _createForOfIteratorHelperLoose(deviceBuffs), _step16; !(_step16 = _iterator16()).done;) {
                  var _step16$value = _step16.value,
                    _name3 = _step16$value[0];
                    _step16$value[1];
                  var _resId = context$1.resourceGraph.vertex(_name3);
                  var _trait = context$1.resourceGraph.getTraits(_resId);
                  if (!resourceUses.includes(_name3)) {
                    switch (_trait.residency) {
                      case 0:
                        deletesBuff.push(_name3);
                        break;
                    }
                  }
                }
                for (var _i2 = 0, _deletesBuff = deletesBuff; _i2 < _deletesBuff.length; _i2++) {
                  var _name = _deletesBuff[_i2];
                  deviceBuffs.get(_name).release();
                  deviceBuffs["delete"](_name);
                }
                resourceUses.length = 0;
              };
              _proto15.execute = function execute(rg) {
                context$1.renderGraph = rg;
                context$1.reset();
                var cmdBuff = context$1.commandBuffer;
                var culling = context$1.culling;
                culling.buildRenderQueues(rg, context$1.layoutGraph, context$1.pipelineSceneData);
                context$1.lightResource.buildLights(culling, context$1.pipelineSceneData.isHDR, context$1.pipelineSceneData.shadows);
                this._removeDeviceResource();
                cmdBuff.begin();
                culling.uploadInstancing(cmdBuff);
                if (!this._visitor) this._visitor = new RenderVisitor();
                depthFirstSearch(this._visitor.graphView, this._visitor, this._visitor.colorMap);
                cmdBuff.end();
                context$1.device.queue.submit([cmdBuff]);
              };
              _proto15.release = function release() {
                context$1.devicePasses.clear();
                for (var _iterator17 = _createForOfIteratorHelperLoose(context$1.deviceTextures), _step17; !(_step17 = _iterator17()).done;) {
                  var _step17$value = _step17.value;
                    _step17$value[0];
                    var v = _step17$value[1];
                  v.release();
                }
                context$1.deviceTextures.clear();
                for (var _iterator18 = _createForOfIteratorHelperLoose(context$1.deviceBuffers), _step18; !(_step18 = _iterator18()).done;) {
                  var _step18$value = _step18.value;
                    _step18$value[0];
                    var _v = _step18$value[1];
                  _v.release();
                }
                context$1.deviceBuffers.clear();
              };
              return Executor;
            }();
            var BaseRenderVisitor = function () {
              function BaseRenderVisitor() {
                this.queueID = 0xFFFFFFFF;
                this.sceneID = 0xFFFFFFFF;
                this.passID = 0xFFFFFFFF;
                this.dispatchID = 0xFFFFFFFF;
                this.currPass = undefined;
                this.currQueue = undefined;
                this.rg = undefined;
                this.rg = context$1.renderGraph;
              }
              var _proto16 = BaseRenderVisitor.prototype;
              _proto16._isRasterPass = function _isRasterPass(u) {
                return context$1.renderGraph.h(0, u);
              };
              _proto16.isComputePass = function isComputePass(u) {
                return context$1.renderGraph.h(3, u);
              };
              _proto16.isDispatch = function isDispatch(u) {
                return context$1.renderGraph.h(11, u);
              };
              _proto16._isQueue = function _isQueue(u) {
                return context$1.renderGraph.h(8, u);
              };
              _proto16._isScene = function _isScene(u) {
                return context$1.renderGraph.h(9, u);
              };
              _proto16._isBlit = function _isBlit(u) {
                return context$1.renderGraph.h(10, u);
              };
              _proto16.applyID = function applyID(id) {
                if (this._isRasterPass(id)) {
                  this.passID = id;
                } else if (this._isQueue(id)) {
                  this.queueID = id;
                } else if (this._isScene(id) || this._isBlit(id)) {
                  this.sceneID = id;
                } else if (this.isComputePass(id)) {
                  this.passID = id;
                } else if (this.isDispatch(id)) {
                  this.dispatchID = id;
                }
              };
              return BaseRenderVisitor;
            }();
            var PreRenderVisitor = function (_BaseRenderVisitor) {
              _inheritsLoose(PreRenderVisitor, _BaseRenderVisitor);
              function PreRenderVisitor() {
                return _BaseRenderVisitor.call(this) || this;
              }
              var _proto17 = PreRenderVisitor.prototype;
              _proto17.clear = function clear(value) {};
              _proto17.viewport = function viewport(value) {};
              _proto17.rasterPass = function rasterPass(pass) {
                if (!this.rg.getValid(this.passID)) return;
                var devicePasses = context$1.devicePasses;
                var passHash = pass.hashValue;
                this.currPass = devicePasses.get(passHash);
                if (!this.currPass) {
                  this.currPass = new DeviceRenderPass(this.passID, pass);
                  devicePasses.set(passHash, this.currPass);
                } else {
                  this.currPass.resetResource(this.passID, pass);
                }
                this.currPass.preRecord();
              };
              _proto17.rasterSubpass = function rasterSubpass(value) {};
              _proto17.computeSubpass = function computeSubpass(value) {};
              _proto17.resolve = function resolve(value) {};
              _proto17.move = function move(value) {};
              _proto17.raytrace = function raytrace(value) {};
              _proto17.compute = function compute(pass) {
                if (!this.rg.getValid(this.passID)) return;
                context$1.devicePasses;
                var computeInfo = new ComputePassInfo();
                computeInfo.applyInfo(this.passID, pass);
                this.currPass = new DeviceComputePass(computeInfo);
                this.currPass.preRecord();
                this.currPass.record();
              };
              _proto17.copy = function copy(value) {
                if (value.uploadPairs.length) {
                  for (var _iterator19 = _createForOfIteratorHelperLoose(value.uploadPairs), _step19; !(_step19 = _iterator19()).done;) {
                    var upload = _step19.value;
                    var resBuffers = context$1.deviceBuffers;
                    var resourceGraph = context$1.resourceGraph;
                    var vertId = resourceGraph.vertex(upload.target);
                    resourceVisitor.resName = upload.target;
                    resourceGraph.visitVertex(resourceVisitor, vertId);
                    var gfxBuffer = resBuffers.get(upload.target);
                    context$1.device.commandBuffer.updateBuffer(gfxBuffer.buffer, upload.source, upload.source.byteLength);
                  }
                }
              };
              _proto17.queue = function queue(value) {
                if (!this.rg.getValid(this.queueID)) return;
                var deviceQueue;
                if (this.currPass instanceof DeviceRenderPass) {
                  deviceQueue = context$1.pools.addDeviceQueue();
                  deviceQueue.init(this.currPass, value, this.queueID);
                  this.currQueue = deviceQueue;
                  this.currPass.addQueue(deviceQueue);
                } else {
                  deviceQueue = context$1.pools.addComputeQueue();
                  deviceQueue.init(this.currPass, value, this.queueID);
                  this.currQueue = deviceQueue;
                  this.currPass.addQueue(deviceQueue);
                }
                var layoutName = this.rg.getLayout(this.queueID);
                if (layoutName) {
                  var layoutGraph = context$1.layoutGraph;
                  if (this.currPass.renderLayout) {
                    var layoutId = layoutGraph.locateChild(this.currPass.renderLayout.layoutID, layoutName);
                    this.currQueue.layoutID = layoutId;
                  }
                }
                this.currQueue.preRecord();
              };
              _proto17.scene = function scene(value) {
                if (!this.rg.getValid(this.sceneID)) return;
                var renderQueue = this.currQueue;
                var renderScene = renderQueue.setScene(this.sceneID, value);
                renderScene.preRecord();
              };
              _proto17.blit = function blit(value) {
                if (!this.rg.getValid(this.sceneID)) return;
                var renderQueue = this.currQueue;
                var renderScene = renderQueue.setScene(this.sceneID, undefined, value);
                renderScene.preRecord();
              };
              _proto17.dispatch = function dispatch(value) {
                var _value$material;
                var pso = null;
                var devicePass = this.currPass;
                var pass = (_value$material = value.material) == null ? undefined : _value$material.passes[value.passID];
                pass == null ? undefined : pass.update();
                var shader = pass == null ? undefined : pass.getShaderVariant();
                if (pass !== null && shader !== null) {
                  var psoInfo = new PipelineStateInfo(shader, pass == null ? undefined : pass.pipelineLayout);
                  psoInfo.bindPoint = 1;
                  pso = deviceManager.gfxDevice.createPipelineState(psoInfo);
                }
                var cmdBuff = context$1.commandBuffer;
                if (pso) {
                  cmdBuff.bindPipelineState(pso);
                  var layoutStage = devicePass.renderLayout;
                  var layoutDesc = layoutStage.descriptorSet;
                  cmdBuff.bindDescriptorSet(0, layoutDesc);
                }
                var gx = value.threadGroupCountX;
                var gy = value.threadGroupCountY;
                var gz = value.threadGroupCountZ;
                cmdBuff.dispatch(new DispatchInfo(gx, gy, gz));
              };
              return PreRenderVisitor;
            }(BaseRenderVisitor);
            var PostRenderVisitor = function (_BaseRenderVisitor2) {
              _inheritsLoose(PostRenderVisitor, _BaseRenderVisitor2);
              function PostRenderVisitor() {
                return _BaseRenderVisitor2.call(this) || this;
              }
              var _proto18 = PostRenderVisitor.prototype;
              _proto18.clear = function clear(value) {};
              _proto18.viewport = function viewport(value) {};
              _proto18.rasterPass = function rasterPass(pass) {
                var devicePasses = context$1.devicePasses;
                var passHash = pass.hashValue;
                var currPass = devicePasses.get(passHash);
                if (!currPass) return;
                this.currPass = currPass;
                context$1.passShowStatistics = pass.showStatistics;
                this.currPass.record();
              };
              _proto18.rasterSubpass = function rasterSubpass(value) {};
              _proto18.computeSubpass = function computeSubpass(value) {};
              _proto18.resolve = function resolve(value) {};
              _proto18.compute = function compute(value) {};
              _proto18.copy = function copy(value) {};
              _proto18.move = function move(value) {};
              _proto18.raytrace = function raytrace(value) {};
              _proto18.queue = function queue(value) {};
              _proto18.scene = function scene(value) {};
              _proto18.blit = function blit(value) {};
              _proto18.dispatch = function dispatch(value) {};
              return PostRenderVisitor;
            }(BaseRenderVisitor);
            var RenderVisitor = function (_DefaultVisitor) {
              _inheritsLoose(RenderVisitor, _DefaultVisitor);
              function RenderVisitor() {
                var _this4;
                _this4 = _DefaultVisitor.call(this) || this;
                _this4._preVisitor = undefined;
                _this4._postVisitor = undefined;
                _this4._graphView = undefined;
                _this4._colorMap = undefined;
                _this4._preVisitor = new PreRenderVisitor();
                _this4._postVisitor = new PostRenderVisitor();
                _this4._graphView = new ReferenceGraphView(context$1.renderGraph);
                _this4._colorMap = new VectorGraphColorMap(context$1.renderGraph.nv());
                return _this4;
              }
              var _proto19 = RenderVisitor.prototype;
              _proto19.discoverVertex = function discoverVertex(u, gv) {
                var g = gv.g;
                this._preVisitor.applyID(u);
                g.visitVertex(this._preVisitor, u);
              };
              _proto19.finishVertex = function finishVertex(v, gv) {
                var g = gv.g;
                g.visitVertex(this._postVisitor, v);
              };
              _createClass(RenderVisitor, [{
                key: "graphView",
                get: function get() {
                  return this._graphView;
                }
              }, {
                key: "colorMap",
                get: function get() {
                  return this._colorMap;
                }
              }]);
              return RenderVisitor;
            }(DefaultVisitor);

            var readViews = new Map();
            var PassVisitor = function () {
              function PassVisitor(context) {
                this.queueID = 0xFFFFFFFF;
                this.sceneID = 0xFFFFFFFF;
                this.passID = 0xFFFFFFFF;
                this.dispatchID = 0xFFFFFFFF;
                this.resID = 0xFFFFFFFF;
                this.context = undefined;
                this._currPass = null;
                this._resVisitor = undefined;
                this.context = context;
                this._resVisitor = new ResourceVisitor(this.context);
              }
              var _proto = PassVisitor.prototype;
              _proto._isRasterPass = function _isRasterPass(u) {
                return this.context.renderGraph.h(0, u);
              };
              _proto._isCopyPass = function _isCopyPass(u) {
                return this.context.renderGraph.h(5, u);
              };
              _proto._isCompute = function _isCompute(u) {
                return this.context.renderGraph.h(3, u);
              };
              _proto._isDispatch = function _isDispatch(u) {
                return this.context.renderGraph.h(11, u);
              };
              _proto._isQueue = function _isQueue(u) {
                return this.context.renderGraph.h(8, u);
              };
              _proto._isShadowMap = function _isShadowMap(u) {
                var sceneData = this._getSceneData(u);
                if (sceneData) {
                  return sceneData.light && !!sceneData.light.light && (sceneData.flags & 8) !== 0;
                }
                return false;
              };
              _proto._getSceneData = function _getSceneData(u) {
                if (!this.context.renderGraph.h(9, u)) {
                  return null;
                }
                return this.context.renderGraph.j(u);
              };
              _proto._isScene = function _isScene(u) {
                return this.context.renderGraph.h(9, u);
              };
              _proto._isBlit = function _isBlit(u) {
                return this.context.renderGraph.h(10, u);
              };
              _proto._useResourceInfo = function _useResourceInfo(input, raster) {
                var resContext = this.context.resourceContext;
                var useContext = resContext.get(input);
                var resGraph = this.context.resourceGraph;
                if (useContext) {
                  var rasters = useContext.rasters;
                  var passRaster = rasters.get(this.passID);
                  if (passRaster === raster) {
                    return;
                  }
                  var computes = useContext.computes;
                  for (var _iterator = _createForOfIteratorHelperLoose(rasters), _step; !(_step = _iterator()).done;) {
                    var _step$value = _step.value,
                      passId = _step$value[0];
                      _step$value[1];
                    if (passId > this.passID) ;
                  }
                  for (var _iterator2 = _createForOfIteratorHelperLoose(computes), _step2; !(_step2 = _iterator2()).done;) {
                    var _step2$value = _step2.value,
                      _passId = _step2$value[0];
                    if (_passId > this.passID) {
                      break;
                    }
                  }
                  rasters.set(this.passID, raster);
                } else {
                  var resId = resGraph.vertex(input);
                  var trait = resGraph.getTraits(resId);
                  switch (trait.residency) {
                          }
                  var _useContext = new ResourceUseContext();
                  resContext.set(input, _useContext);
                  _useContext.rasters.set(this.passID, raster);
                }
              };
              _proto._fetchValidPass = function _fetchValidPass() {
                var rg = this.context.renderGraph;
                var resContext = this.context.resourceContext;
                var outputId = this.resID;
                var outputName = this.context.resourceGraph.vertexName(outputId);
                readViews.clear();
                var pass = this._currPass;
                var validPass = rg.getValid(this.passID);
                for (var _iterator3 = _createForOfIteratorHelperLoose(pass.rasterViews), _step3; !(_step3 = _iterator3()).done;) {
                  var _step3$value = _step3.value,
                    _readName = _step3$value[0],
                    _raster2 = _step3$value[1];
                  if (_readName === outputName && _raster2.accessType !== 0) {
                    this._useResourceInfo(_readName, _raster2);
                    rg.setValid(this.passID, true);
                    rg.setValid(this.queueID, true);
                    rg.setValid(this.sceneID, true);
                    continue;
                  }
                  if (_raster2.accessType !== 2) {
                    readViews.set(_readName, _raster2);
                  }
                }
                if (validPass) return;
                if (rg.getValid(this.sceneID)) {
                  for (var _iterator4 = _createForOfIteratorHelperLoose(pass.rasterViews), _step4; !(_step4 = _iterator4()).done;) {
                    var _step4$value = _step4.value,
                      readName = _step4$value[0];
                      _step4$value[1];
                    context.pipeline.resourceUses.push(readName);
                  }
                  var resourceGraph;
                  var vertID;
                  for (var _iterator5 = _createForOfIteratorHelperLoose(readViews), _step5; !(_step5 = _iterator5()).done;) {
                    var _step5$value = _step5.value,
                      rasterName = _step5$value[0];
                      _step5$value[1];
                    resourceGraph = this.context.resourceGraph;
                    vertID = resourceGraph.find(rasterName);
                    if (vertID !== 0xFFFFFFFF) {
                      this._resVisitor.resID = vertID;
                      resourceGraph.visitVertex(this._resVisitor, vertID);
                    }
                  }
                  for (var _iterator6 = _createForOfIteratorHelperLoose(pass.computeViews), _step6; !(_step6 = _iterator6()).done;) {
                    var _step6$value = _step6.value,
                      computeName = _step6$value[0],
                      cViews = _step6$value[1];
                    var resUseContext = resContext.get(computeName);
                    if (!resUseContext) {
                      resUseContext = new ResourceUseContext();
                      resContext.set(computeName, resUseContext);
                    }
                    var computes = resUseContext.computes;
                    var currUseComputes = computes.get(this.passID);
                    if (currUseComputes) {
                      currUseComputes.push(cViews);
                    } else {
                      computes.set(this.passID, [cViews]);
                    }
                    resourceGraph = this.context.resourceGraph;
                    vertID = resourceGraph.find(computeName);
                    if (vertID !== 0xFFFFFFFF) {
                      this._resVisitor.resID = vertID;
                      resourceGraph.visitVertex(this._resVisitor, vertID);
                    }
                  }
                  genHashValue(pass);
                }
              };
              _proto.applyID = function applyID(id, resId) {
                this.resID = resId;
                if (this._isRasterPass(id) || this._isCopyPass(id) || this._isCompute(id)) {
                  this.passID = id;
                } else if (this._isQueue(id)) {
                  this.queueID = id;
                } else if (this._isScene(id) || this._isBlit(id)) {
                  this.sceneID = id;
                } else if (this._isDispatch(id)) {
                  this.dispatchID = id;
                }
              };
              _proto.rasterPass = function rasterPass(pass) {
                this._currPass = pass;
              };
              _proto.rasterSubpass = function rasterSubpass(value) {};
              _proto.computeSubpass = function computeSubpass(value) {};
              _proto.compute = function compute(value) {
                this._currPass = value;
                var rg = context.renderGraph;
                rg.setValid(this.passID, true);
              };
              _proto.resolve = function resolve(value) {};
              _proto.copy = function copy(value) {
                var rg = context.renderGraph;
                if (rg.getValid(this.passID)) {
                  return;
                }
                var resourceGraph = this.context.resourceGraph;
                this._currPass = value;
                var outputId = this.resID;
                var outputName = resourceGraph.vertexName(outputId);
                var vertID;
                for (var _iterator7 = _createForOfIteratorHelperLoose(value.copyPairs), _step7; !(_step7 = _iterator7()).done;) {
                  var pair = _step7.value;
                  if (pair.target === outputName) {
                    rg.setValid(this.passID, true);
                    vertID = resourceGraph.find(pair.source);
                    if (vertID !== 0xFFFFFFFF) {
                      this._resVisitor.resID = vertID;
                      resourceGraph.visitVertex(this._resVisitor, vertID);
                    }
                  }
                }
              };
              _proto.move = function move(value) {};
              _proto.raytrace = function raytrace(value) {};
              _proto.queue = function queue(value) {};
              _proto.scene = function scene(value) {
                this._fetchValidPass();
              };
              _proto.blit = function blit(value) {
                this._fetchValidPass();
              };
              _proto.dispatch = function dispatch(value) {
                var rg = this.context.renderGraph;
                rg.setValid(this.queueID, true);
                rg.setValid(this.dispatchID, true);
              };
              _proto.clear = function clear(value) {};
              _proto.viewport = function viewport(value) {};
              return PassVisitor;
            }();
            var PassManagerVisitor = function (_DefaultVisitor) {
              _inheritsLoose(PassManagerVisitor, _DefaultVisitor);
              function PassManagerVisitor(context, resId) {
                var _this;
                _this = _DefaultVisitor.call(this) || this;
                _this._colorMap = undefined;
                _this._graphView = undefined;
                _this._passVisitor = undefined;
                _this._resId = 0xFFFFFFFF;
                _this._resId = resId;
                _this._passVisitor = new PassVisitor(context);
                _this._graphView = new ReferenceGraphView(context.renderGraph);
                _this._colorMap = new VectorGraphColorMap(context.renderGraph.nv());
                return _this;
              }
              var _proto2 = PassManagerVisitor.prototype;
              _proto2.discoverVertex = function discoverVertex(u, gv) {
                var g = gv.g;
                this._passVisitor.applyID(u, this.resId);
                g.visitVertex(this._passVisitor, u);
              };
              _createClass(PassManagerVisitor, [{
                key: "resId",
                get: function get() {
                  return this._resId;
                },
                set: function set(value) {
                  this._resId = value;
                  this._colorMap.colors.length = context.renderGraph.nv();
                }
              }, {
                key: "graphView",
                get: function get() {
                  return this._graphView;
                }
              }, {
                key: "colorMap",
                get: function get() {
                  return this._colorMap;
                }
              }]);
              return PassManagerVisitor;
            }(DefaultVisitor);
            var ResourceVisitor = function () {
              function ResourceVisitor(context) {
                this._context = undefined;
                this.resID = 0xFFFFFFFF;
                this._passManagerVis = undefined;
                this._context = context;
              }
              var _proto3 = ResourceVisitor.prototype;
              _proto3.managedBuffer = function managedBuffer(value) {};
              _proto3.managedTexture = function managedTexture(value) {};
              _proto3.managed = function managed(value) {
                this.dependency();
              };
              _proto3.persistentBuffer = function persistentBuffer(value) {};
              _proto3.dependency = function dependency() {
                if (!this._passManagerVis) {
                  this._passManagerVis = new PassManagerVisitor(this._context, this.resID);
                } else {
                  this._passManagerVis.resId = this.resID;
                }
                depthFirstSearch(this._passManagerVis.graphView, this._passManagerVis, this._passManagerVis.colorMap);
              };
              _proto3.persistentTexture = function persistentTexture(value) {
                this.dependency();
              };
              _proto3.framebuffer = function framebuffer(value) {
                this.dependency();
              };
              _proto3.swapchain = function swapchain(value) {
                this.dependency();
              };
              _proto3.formatView = function formatView(value) {};
              _proto3.subresourceView = function subresourceView(value) {};
              return ResourceVisitor;
            }();
            var ResourceUseContext = function ResourceUseContext() {
              this.rasters = new Map();
              this.computes = new Map();
            };
            var CompilerContext = function () {
              function CompilerContext() {
                this.resourceGraph = undefined;
                this.pipeline = undefined;
                this.renderGraph = undefined;
                this.layoutGraph = undefined;
                this.resourceContext = undefined;
              }
              var _proto4 = CompilerContext.prototype;
              _proto4.set = function set(pipeline, resGraph, renderGraph, layoutGraph) {
                this.pipeline = pipeline;
                this.resourceGraph = resGraph;
                this.renderGraph = renderGraph;
                this.layoutGraph = layoutGraph;
                if (!this.resourceContext) {
                  this.resourceContext = new Map();
                }
                this.resourceContext.clear();
              };
              return CompilerContext;
            }();
            var Compiler = function () {
              function Compiler(pipeline, renderGraph, resGraph, layoutGraph) {
                this._resourceGraph = undefined;
                this._pipeline = undefined;
                this._layoutGraph = undefined;
                this._visitor = undefined;
                this._pipeline = pipeline;
                this._resourceGraph = resGraph;
                this._layoutGraph = layoutGraph;
                context.set(this._pipeline, this._resourceGraph, renderGraph, this._layoutGraph);
                this._visitor = new ResourceManagerVisitor(context);
              }
              var _proto5 = Compiler.prototype;
              _proto5.compile = function compile(rg) {
                context.set(this._pipeline, this._resourceGraph, rg, this._layoutGraph);
                context.pipeline.resourceUses.length = 0;
                this._visitor.colorMap.colors.length = context.resourceGraph.nv();
                depthFirstSearch(this._resourceGraph, this._visitor, this._visitor.colorMap);
              };
              return Compiler;
            }();
            var context = new CompilerContext();
            var ResourceManagerVisitor = function (_DefaultVisitor2) {
              _inheritsLoose(ResourceManagerVisitor, _DefaultVisitor2);
              function ResourceManagerVisitor(context) {
                var _this2;
                _this2 = _DefaultVisitor2.call(this) || this;
                _this2._colorMap = undefined;
                _this2._resourceGraph = undefined;
                _this2._resVisitor = undefined;
                _this2._colorMap = new VectorGraphColorMap(context.resourceGraph.nv());
                _this2._resourceGraph = context.resourceGraph;
                _this2._resVisitor = new ResourceVisitor(context);
                return _this2;
              }
              var _proto6 = ResourceManagerVisitor.prototype;
              _proto6.discoverVertex = function discoverVertex(u, gv) {
                var traits = this._resourceGraph.getTraits(u);
                if (traits.residency === 0 || traits.residency === 1) {
                  return;
                }
                this._resVisitor.resID = u;
                this._resourceGraph.visitVertex(this._resVisitor, u);
              };
              _createClass(ResourceManagerVisitor, [{
                key: "colorMap",
                get: function get() {
                  return this._colorMap;
                }
              }]);
              return ResourceManagerVisitor;
            }(DefaultVisitor);

            var _uboVec = new Vec4();
            var _samplerPointInfo = new SamplerInfo(1, 1, 0, 2, 2, 2);
            var PipelinePool = function () {
              function PipelinePool() {
                var _this = this;
                this.renderData = new RenderData$1();
                this.layoutGraph = new LayoutGraphData();
                this.rg = new RenderGraph();
                this.vertId = -1;
                this.sceneData = new SceneData();
                this.resourceGraph = new ResourceGraph();
                this.computePass = new ComputePass();
                this.rasterPass = new RasterPass();
                this.rasterSubpass = new RasterSubpass();
                this.renderQueue = new RenderQueue$1();
                this.sceneBuilder = new RecyclePool(function () {
                  return new WebSceneBuilder(_this.renderData, _this.layoutGraph, _this.rg, _this.vertId, _this.sceneData);
                }, 16);
                this.renderPassBuilder = new RecyclePool(function () {
                  return new WebRenderPassBuilder(_this.renderData, _this.rg, _this.layoutGraph, _this.resourceGraph, _this.vertId, _this.rasterPass, _this.getPipelineSceneData());
                }, 16);
                this.computeQueueBuilder = new RecyclePool(function () {
                  return new WebComputeQueueBuilder(_this.renderData, _this.rg, _this.layoutGraph, _this.vertId, _this.renderQueue, _this.getPipelineSceneData());
                }, 16);
                this.renderQueueBuilder = new RecyclePool(function () {
                  return new WebRenderQueueBuilder(_this.renderData, _this.rg, _this.layoutGraph, _this.vertId, _this.renderQueue, _this.getPipelineSceneData());
                }, 16);
                this.renderSubpassBuilder = new RecyclePool(function () {
                  return new WebRenderSubpassBuilder(_this.renderData, _this.rg, _this.layoutGraph, _this.vertId, _this.rasterSubpass, _this.getPipelineSceneData());
                }, 16);
                this.computePassBuilder = new RecyclePool(function () {
                  return new WebComputePassBuilder(_this.renderData, _this.rg, _this.layoutGraph, _this.resourceGraph, _this.vertId, _this.computePass, _this.getPipelineSceneData());
                }, 16);
                this.samplerInfo = new RecyclePool(function () {
                  return new SamplerInfo();
                }, 16);
                this.color = new RecyclePool(function () {
                  return new Color$1();
                }, 16);
                this.renderCommonObjectPool = new RenderCommonObjectPool();
                this.renderGraphPool = new RenderGraphObjectPool(this.renderCommonObjectPool);
                this.viewport = new RecyclePool(function () {
                  return new Viewport();
                }, 16);
              }
              var _proto = PipelinePool.prototype;
              _proto.getPipelineSceneData = function getPipelineSceneData() {
                return legacyCC.director.root.pipeline.pipelineSceneData;
              };
              _proto.createColor = function createColor(x, y, z, w) {
                if (x === undefined) {
                  x = 0;
                }
                if (y === undefined) {
                  y = 0;
                }
                if (z === undefined) {
                  z = 0;
                }
                if (w === undefined) {
                  w = 0;
                }
                var color = this.color.add();
                color.set(x, y, z, w);
                return color;
              };
              _proto.createSamplerInfo = function createSamplerInfo(minFilter, magFilter, mipFilter, addressU, addressV, addressW, maxAnisotropy, cmpFunc) {
                if (minFilter === undefined) {
                  minFilter = 2;
                }
                if (magFilter === undefined) {
                  magFilter = 2;
                }
                if (mipFilter === undefined) {
                  mipFilter = 0;
                }
                if (addressU === undefined) {
                  addressU = 0;
                }
                if (addressV === undefined) {
                  addressV = 0;
                }
                if (addressW === undefined) {
                  addressW = 0;
                }
                if (maxAnisotropy === undefined) {
                  maxAnisotropy = 0;
                }
                if (cmpFunc === undefined) {
                  cmpFunc = 7;
                }
                var samplerInfo = this.samplerInfo.add();
                samplerInfo.minFilter = minFilter;
                samplerInfo.magFilter = magFilter;
                samplerInfo.mipFilter = mipFilter;
                samplerInfo.addressU = addressU;
                samplerInfo.addressV = addressV;
                samplerInfo.addressW = addressW;
                samplerInfo.maxAnisotropy = maxAnisotropy;
                samplerInfo.cmpFunc = cmpFunc;
                return samplerInfo;
              };
              _proto.reset = function reset() {
                this.sceneBuilder.reset();
                this.renderPassBuilder.reset();
                this.computePassBuilder.reset();
                this.computeQueueBuilder.reset();
                this.renderCommonObjectPool.reset();
                this.renderGraphPool.reset();
                this.viewport.reset();
                this.samplerInfo.reset();
                this.color.reset();
                this.renderQueueBuilder.reset();
                this.renderSubpassBuilder.reset();
              };
              return PipelinePool;
            }();
            var pipelinePool;
            var renderGraphPool;
            function setComputeConstants(setter, layoutName) {
              var director = cclegacy.director;
              var root = director.root;
              root.pipeline;
            }
            function getTextureType(dimension, arraySize) {
              switch (dimension) {
                case 1:
                  return arraySize > 1 ? 4 : 0;
                case 2:
                  return arraySize > 1 ? 5 : 1;
                case 3:
                  return 2;
                case 0:
                  return 1;
              }
              return 1;
            }
            function getResourceDimension(type) {
              switch (type) {
                case 0:
                case 4:
                  return 1;
                case 1:
                case 5:
                case 3:
                  return 2;
                case 2:
                  return 3;
              }
              return 2;
            }
            var emptyMaterial = new Material();
            var emptyRenderData = new RenderData$1();
            var WebSceneBuilder = function (_WebSetter) {
              _inheritsLoose(WebSceneBuilder, _WebSetter);
              function WebSceneBuilder(data, layoutGraph, rg, sceneId, scene) {
                var _this2;
                _this2 = _WebSetter.call(this, data, layoutGraph) || this;
                _this2._renderGraph = undefined;
                _this2._scene = undefined;
                _this2._renderGraph = rg;
                _this2._scene = scene;
                _this2._vertID = sceneId;
                return _this2;
              }
              var _proto2 = WebSceneBuilder.prototype;
              _proto2.update = function update(data, layoutGraph, rg, sceneId, scene) {
                this._data = data;
                this._lg = layoutGraph;
                this._renderGraph = rg;
                this._scene = scene;
                this._vertID = sceneId;
              };
              _proto2.useLightFrustum = function useLightFrustum(light, csmLevel, optCamera) {
                if (csmLevel === undefined) {
                  csmLevel = 0;
                }
                if (optCamera === undefined) {
                  optCamera = undefined;
                }
                this._scene.light.light = light;
                this._scene.light.level = csmLevel;
                this._scene.light.culledByLight = true;
                if (optCamera) {
                  this._scene.camera = optCamera;
                }
                if (this._scene.flags & 32768) {
                  return;
                }
                var queueId = this._renderGraph.getParent(this._vertID);
                var passId = this._renderGraph.getParent(queueId);
                this._renderGraph.getLayout(passId);
                setShadowUBOLightView(this, this._scene.camera, light, csmLevel);
              };
              return WebSceneBuilder;
            }(WebSetter);
            var WebRenderQueueBuilder = function (_WebSetter2) {
              _inheritsLoose(WebRenderQueueBuilder, _WebSetter2);
              function WebRenderQueueBuilder(data, renderGraph, layoutGraph, vertID, queue, pipeline) {
                var _this3;
                _this3 = _WebSetter2.call(this, data, layoutGraph) || this;
                _this3._renderGraph = undefined;
                _this3._queue = undefined;
                _this3._pipeline = undefined;
                _this3._renderGraph = renderGraph;
                _this3._vertID = vertID;
                _this3._queue = queue;
                _this3._pipeline = pipeline;
                return _this3;
              }
              var _proto3 = WebRenderQueueBuilder.prototype;
              _proto3.update = function update(data, renderGraph, layoutGraph, vertID, queue, pipeline) {
                this._data = data;
                this._lg = layoutGraph;
                this._renderGraph = renderGraph;
                this._vertID = vertID;
                this._queue = queue;
                this._pipeline = pipeline;
              };
              _proto3.setArrayBuffer = function setArrayBuffer(name, arrayBuffer) {
                throw new Error('Method not implemented.');
              };
              _proto3.addSceneOfCamera = function addSceneOfCamera(camera, light, sceneFlags, name) {
                if (sceneFlags === undefined) {
                  sceneFlags = 0;
                }
                var lightTarget = light.light;
                this.addScene(camera, sceneFlags, lightTarget);
              };
              _proto3.addScene = function addScene(camera, sceneFlags, light, scene) {
                if (sceneFlags === undefined) {
                  sceneFlags = 0;
                }
                if (light === undefined) {
                  light = null;
                }
                if (scene === undefined) {
                  scene = undefined;
                }
                var sceneData = renderGraphPool.createSceneData(scene || camera.scene, camera, sceneFlags, light && !(sceneFlags & 8) ? 1 | 4 : 1, light);
                var renderData = renderGraphPool.createRenderData();
                var sceneId = this._renderGraph.addVertex(9, sceneData, 'Scene', '', renderData, false, this._vertID);
                if (!(sceneFlags & 32768)) {
                  this.getParentLayout();
                  setCameraUBOValues(this, camera, this._pipeline, scene || camera.scene);
                  if (light && light.type !== 0) setShadowUBOLightView(this, camera, light, 0);else if (!(sceneFlags & 8)) setShadowUBOView(this, camera);
                }
                var passOrSubpassId = this._renderGraph.getParent(this._vertID);
                if (sceneFlags & 16) {
                  var queueId = this._renderGraph.addVertex(8, this._queue, 'UI Queue', 'default', this._data, false, passOrSubpassId);
                  this._renderGraph.addVertex(10, renderGraphPool.createBlit(emptyMaterial, this._renderGraph.N, 0, camera, 1), 'UI', '', emptyRenderData, false, queueId);
                }
                if (sceneFlags & 1024) {
                  this.addProfiler(camera);
                }
                var sceneBuilder = pipelinePool.sceneBuilder.add();
                sceneBuilder.update(renderData, this._lg, this._renderGraph, sceneId, sceneData);
                return sceneBuilder;
              };
              _proto3.addFullscreenQuad = function addFullscreenQuad(material, passID, sceneFlags, name) {
                if (sceneFlags === undefined) {
                  sceneFlags = 0;
                }
                if (name === undefined) {
                  name = 'Quad';
                }
                this._renderGraph.addVertex(10, renderGraphPool.createBlit(material, passID, sceneFlags, null), name, '', renderGraphPool.createRenderData(), false, this._vertID);
                this.getParentLayout();
                var scene = cclegacy.director.getScene();
                setCameraUBOValues(this, null, this._pipeline, scene ? scene.renderScene : null);
                if (sceneFlags & 8) ; else {
                  setShadowUBOView(this, null);
                }
              };
              _proto3.addCameraQuad = function addCameraQuad(camera, material, passID, sceneFlags) {
                if (sceneFlags === undefined) {
                  sceneFlags = 0;
                }
                this._renderGraph.addVertex(10, renderGraphPool.createBlit(material, passID, sceneFlags, camera), 'CameraQuad', '', renderGraphPool.createRenderData(), false, this._vertID);
                this.getParentLayout();
                var scene = cclegacy.director.getScene();
                setCameraUBOValues(this, camera, this._pipeline, camera.scene || (scene ? scene.renderScene : null));
                if (sceneFlags & 8) ; else {
                  setShadowUBOView(this, camera);
                }
              };
              _proto3.addDraw3D = function addDraw3D(camera, models, sceneFlags) {
                if (sceneFlags === undefined) {
                  sceneFlags = 32768;
                }
                var blit = renderGraphPool.createBlit(emptyMaterial, this._renderGraph.N, 0, camera, 3);
                for (var _iterator = _createForOfIteratorHelperLoose(models), _step; !(_step = _iterator()).done;) {
                  var model = _step.value;
                  blit.models.push(model);
                }
                this._renderGraph.addVertex(10, blit, 'Draw3D', '', renderGraphPool.createRenderData(), false, this._vertID);
                if (!(sceneFlags & 32768)) {
                  this.getParentLayout();
                  setCameraUBOValues(this, camera, this._pipeline, camera.scene);
                  if (!(sceneFlags & 8)) setShadowUBOView(this, camera);
                }
              };
              _proto3.addDraw2D = function addDraw2D(camera) {
                this.getParentLayout();
                setCameraUBOValues(this, camera, this._pipeline, camera.scene);
                this._renderGraph.addVertex(10, renderGraphPool.createBlit(emptyMaterial, this._renderGraph.N, 0, camera, 1), 'Draw2D', '', emptyRenderData, false, this._vertID);
              };
              _proto3.addProfiler = function addProfiler(camera) {
                var passOrSubpassId = this._renderGraph.getParent(this._vertID);
                var queueId = this._renderGraph.addVertex(8, this._queue, 'UI Queue', 'default', this._data, false, passOrSubpassId);
                var blitID = this._renderGraph.addVertex(10, renderGraphPool.createBlit(emptyMaterial, this._renderGraph.N, 0, camera, 2), 'Profiler', '', emptyRenderData, false, queueId);
                var data = this._renderGraph.getData(blitID);
                WebSetter.setMat4(this._lg, data, 'cc_matProj', camera.matProj);
              };
              _proto3.clearRenderTarget = function clearRenderTarget(name, color) {
                if (color === undefined) {
                  color = new Color$1();
                }
                var clearView = renderGraphPool.createClearView(name, 1);
                clearView.clearColor.copy(color);
                this._renderGraph.addVertex(12, [clearView], 'ClearRenderTarget', '', renderGraphPool.createRenderData(), false, this._vertID);
              };
              _proto3.setViewport = function setViewport(viewport) {
                var currViewport = pipelinePool.viewport.add();
                this._queue.viewport = currViewport.copy(viewport);
              };
              _proto3.addCustomCommand = function addCustomCommand(customBehavior) {
                throw new Error('Method not implemented.');
              };
              _createClass(WebRenderQueueBuilder, [{
                key: "name",
                get: function get() {
                  return this._renderGraph.getName(this._vertID);
                },
                set: function set(name) {
                  this._renderGraph.setName(this._vertID, name);
                }
              }]);
              return WebRenderQueueBuilder;
            }(WebSetter);
            var WebRenderSubpassBuilder = function (_WebSetter3) {
              _inheritsLoose(WebRenderSubpassBuilder, _WebSetter3);
              function WebRenderSubpassBuilder(data, renderGraph, layoutGraph, vertID, subpass, pipeline) {
                var _this4;
                _this4 = _WebSetter3.call(this, data, layoutGraph) || this;
                _this4._renderGraph = undefined;
                _this4._layoutID = undefined;
                _this4._subpass = undefined;
                _this4._pipeline = undefined;
                _this4._renderGraph = renderGraph;
                _this4._vertID = vertID;
                _this4._subpass = subpass;
                _this4._pipeline = pipeline;
                var layoutName = _this4._renderGraph.getLayout(_this4._vertID);
                _this4._layoutID = layoutGraph.locateChild(layoutGraph.N, layoutName);
                return _this4;
              }
              var _proto4 = WebRenderSubpassBuilder.prototype;
              _proto4.update = function update(data, renderGraph, layoutGraph, vertID, subpass, pipeline) {
                this._data = data;
                this._lg = layoutGraph;
                this._renderGraph = renderGraph;
                this._vertID = vertID;
                this._subpass = subpass;
                this._pipeline = pipeline;
                var layoutName = this._renderGraph.getLayout(this._vertID);
                this._layoutID = layoutGraph.locateChild(layoutGraph.N, layoutName);
              };
              _proto4.addRenderTarget = function addRenderTarget(name, accessType, slotName, loadOp, storeOp, color) {
                throw new Error('Method not implemented.');
              };
              _proto4.setCustomShaderStages = function setCustomShaderStages(name, stageFlags) {
                throw new Error('Method not implemented.');
              };
              _proto4.setArrayBuffer = function setArrayBuffer(name, arrayBuffer) {
                throw new Error('Method not implemented.');
              };
              _proto4.addDepthStencil = function addDepthStencil(name, accessType, depthSlotName, stencilSlotName, loadOp, storeOp, depth, stencil, clearFlag) {
                throw new Error('Method not implemented.');
              };
              _proto4.addTexture = function addTexture(name, slotName, sampler) {
                throw new Error('Method not implemented.');
              };
              _proto4.addStorageBuffer = function addStorageBuffer(name, accessType, slotName) {
                throw new Error('Method not implemented.');
              };
              _proto4.addStorageImage = function addStorageImage(name, accessType, slotName) {
                throw new Error('Method not implemented.');
              };
              _proto4.setViewport = function setViewport(viewport) {
                throw new Error('Method not implemented.');
              };
              _proto4.addQueue = function addQueue(hint, layoutName, passName) {
                if (hint === undefined) {
                  hint = 1;
                }
                if (layoutName === undefined) {
                  layoutName = 'default';
                }
                var layoutId = this._lg.locateChild(this._layoutID, layoutName);
                var queue = renderGraphPool.createRenderQueue(hint, layoutId);
                var data = renderGraphPool.createRenderData();
                var queueID = this._renderGraph.addVertex(8, queue, '', layoutName, data, false, this._vertID);
                var queueBuilder = pipelinePool.renderQueueBuilder.add();
                queueBuilder.update(data, this._renderGraph, this._lg, queueID, queue, this._pipeline);
                return queueBuilder;
              };
              _createClass(WebRenderSubpassBuilder, [{
                key: "name",
                get: function get() {
                  return this._renderGraph.getName(this._vertID);
                },
                set: function set(name) {
                  this._renderGraph.setName(this._vertID, name);
                }
              }, {
                key: "showStatistics",
                get: function get() {
                  return this._subpass.showStatistics;
                },
                set: function set(enable) {
                  this._subpass.showStatistics = enable;
                }
              }]);
              return WebRenderSubpassBuilder;
            }(WebSetter);
            var WebRenderPassBuilder = function (_WebSetter4) {
              _inheritsLoose(WebRenderPassBuilder, _WebSetter4);
              function WebRenderPassBuilder(data, renderGraph, layoutGraph, resourceGraph, vertID, pass, pipeline) {
                var _this5;
                _this5 = _WebSetter4.call(this, data, layoutGraph) || this;
                _this5._renderGraph = undefined;
                _this5._layoutID = undefined;
                _this5._pass = undefined;
                _this5._pipeline = undefined;
                _this5._resourceGraph = undefined;
                _this5._renderGraph = renderGraph;
                _this5._resourceGraph = resourceGraph;
                _this5._vertID = vertID;
                _this5._pass = pass;
                _this5._pipeline = pipeline;
                var layoutName = _this5._renderGraph.getLayout(_this5._vertID);
                _this5._layoutID = layoutGraph.locateChild(layoutGraph.N, layoutName);
                return _this5;
              }
              var _proto5 = WebRenderPassBuilder.prototype;
              _proto5.update = function update(data, renderGraph, layoutGraph, resourceGraph, vertID, pass, pipeline) {
                this._renderGraph = renderGraph;
                this._lg = layoutGraph;
                this._resourceGraph = resourceGraph;
                this._vertID = vertID;
                this._pass = pass;
                this._pipeline = pipeline;
                this._data = data;
                var layoutName = this._renderGraph.getLayout(this._vertID);
                this._layoutID = layoutGraph.locateChild(layoutGraph.N, layoutName);
              };
              _proto5.setCustomShaderStages = function setCustomShaderStages(name, stageFlags) {
                throw new Error('Method not implemented.');
              };
              _proto5.setArrayBuffer = function setArrayBuffer(name, arrayBuffer) {
                throw new Error('Method not implemented.');
              };
              _proto5.setVersion = function setVersion(name, version) {
                this._pass.versionName = name;
                this._pass.version = version;
              };
              _proto5.addRenderTarget = function addRenderTarget(name, loadOp, storeOp, clearColor) {
                if (loadOp === undefined) {
                  loadOp = 1;
                }
                if (storeOp === undefined) {
                  storeOp = 0;
                }
                if (clearColor === undefined) {
                  clearColor = new Color$1();
                }
                var clearFlag = 1;
                if (loadOp === 0) {
                  clearFlag = 0;
                }
                var view = renderGraphPool.createRasterView('', 2, 0, loadOp, storeOp, clearFlag);
                view.clearColor.copy(clearColor);
                this._pass.rasterViews.set(name, view);
              };
              _proto5.addDepthStencil = function addDepthStencil(name, loadOp, storeOp, depth, stencil, clearFlag) {
                if (loadOp === undefined) {
                  loadOp = 1;
                }
                if (storeOp === undefined) {
                  storeOp = 0;
                }
                if (depth === undefined) {
                  depth = 1;
                }
                if (stencil === undefined) {
                  stencil = 0;
                }
                if (clearFlag === undefined) {
                  clearFlag = 6;
                }
                var view = renderGraphPool.createRasterView('', 2, 1, loadOp, storeOp, clearFlag);
                view.clearColor.set(depth, stencil, 0, 0);
                this._pass.rasterViews.set(name, view);
              };
              _proto5.resolveRenderTarget = function resolveRenderTarget(source, target) {};
              _proto5.resolveDepthStencil = function resolveDepthStencil(source, target, depthMode, stencilMode) {};
              _proto5._addComputeResource = function _addComputeResource(name, accessType, slotName) {
                var view = renderGraphPool.createComputeView(slotName);
                view.accessType = accessType;
                if (this._pass.computeViews.has(name)) {
                  var _this$_pass$computeVi;
                  (_this$_pass$computeVi = this._pass.computeViews.get(name)) == null ? undefined : _this$_pass$computeVi.push(view);
                } else {
                  this._pass.computeViews.set(name, [view]);
                }
              };
              _proto5.addTexture = function addTexture(name, slotName, sampler) {
                if (sampler === undefined) {
                  sampler = null;
                }
                this._addComputeResource(name, 0, slotName);
                if (sampler) {
                  var descriptorID = this._lg.attributeIndex.get(slotName);
                  this._data.samplers.set(descriptorID, sampler);
                }
              };
              _proto5.addStorageBuffer = function addStorageBuffer(name, accessType, slotName) {
                this._addComputeResource(name, accessType, slotName);
              };
              _proto5.addStorageImage = function addStorageImage(name, accessType, slotName) {
                this._addComputeResource(name, accessType, slotName);
              };
              _proto5.addRenderSubpass = function addRenderSubpass(layoutName) {
                if (layoutName === undefined) {
                  layoutName = '';
                }
                var name = 'Raster';
                var subpassID = this._pass.subpassGraph.nv();
                this._pass.subpassGraph.addVertex(name, renderGraphPool.createSubpass());
                var subpass = renderGraphPool.createRasterSubpass(subpassID, 1, 0);
                var data = renderGraphPool.createRenderData();
                var vertID = this._renderGraph.addVertex(1, subpass, name, layoutName, data, false);
                var result = pipelinePool.renderSubpassBuilder.add();
                result.update(data, this._renderGraph, this._lg, vertID, subpass, this._pipeline);
                return result;
              };
              _proto5.addQueue = function addQueue(hint, layoutName, passName) {
                if (hint === undefined) {
                  hint = 1;
                }
                if (layoutName === undefined) {
                  layoutName = 'default';
                }
                var layoutId = this._lg.locateChild(this._layoutID, layoutName);
                var queue = renderGraphPool.createRenderQueue(hint, layoutId);
                var data = renderGraphPool.createRenderData();
                var queueID = this._renderGraph.addVertex(8, queue, '', layoutName, data, false, this._vertID);
                var result = pipelinePool.renderQueueBuilder.add();
                result.update(data, this._renderGraph, this._lg, queueID, queue, this._pipeline);
                return result;
              };
              _proto5.addFullscreenQuad = function addFullscreenQuad(material, passID, sceneFlags, name) {
                if (sceneFlags === undefined) {
                  sceneFlags = 0;
                }
                if (name === undefined) {
                  name = 'FullscreenQuad';
                }
                var queue = renderGraphPool.createRenderQueue(3);
                var queueId = this._renderGraph.addVertex(8, queue, 'Queue', '', renderGraphPool.createRenderData(), false, this._vertID);
                this._renderGraph.addVertex(10, renderGraphPool.createBlit(material, passID, sceneFlags, null), name, '', renderGraphPool.createRenderData(), false, queueId);
              };
              _proto5.addCameraQuad = function addCameraQuad(camera, material, passID, sceneFlags, name) {
                if (name === undefined) {
                  name = 'CameraQuad';
                }
                var queue = renderGraphPool.createRenderQueue(3);
                var queueId = this._renderGraph.addVertex(8, queue, 'Queue', '', renderGraphPool.createRenderData(), false, this._vertID);
                this._renderGraph.addVertex(10, renderGraphPool.createBlit(material, passID, sceneFlags, camera), name, '', renderGraphPool.createRenderData(), false, queueId);
              };
              _proto5.setViewport = function setViewport(viewport) {
                this._pass.viewport.copy(viewport);
              };
              _createClass(WebRenderPassBuilder, [{
                key: "name",
                get: function get() {
                  return this._renderGraph.getName(this._vertID);
                },
                set: function set(name) {
                  this._renderGraph.setName(this._vertID, name);
                }
              }, {
                key: "showStatistics",
                get: function get() {
                  return this._pass.showStatistics;
                },
                set: function set(enable) {
                  this._pass.showStatistics = enable;
                }
              }]);
              return WebRenderPassBuilder;
            }(WebSetter);
            var WebComputeQueueBuilder = function (_WebSetter5) {
              _inheritsLoose(WebComputeQueueBuilder, _WebSetter5);
              function WebComputeQueueBuilder(data, renderGraph, layoutGraph, vertID, queue, pipeline) {
                var _this6;
                _this6 = _WebSetter5.call(this, data, layoutGraph) || this;
                _this6._renderGraph = undefined;
                _this6._queue = undefined;
                _this6._pipeline = undefined;
                _this6._renderGraph = renderGraph;
                _this6._vertID = vertID;
                _this6._queue = queue;
                _this6._pipeline = pipeline;
                return _this6;
              }
              var _proto6 = WebComputeQueueBuilder.prototype;
              _proto6.update = function update(data, renderGraph, layoutGraph, vertID, queue, pipeline) {
                this._data = data;
                this._lg = layoutGraph;
                this._renderGraph = renderGraph;
                this._vertID = vertID;
                this._queue = queue;
                this._pipeline = pipeline;
              };
              _proto6.setArrayBuffer = function setArrayBuffer(name, arrayBuffer) {
                throw new Error('Method not implemented.');
              };
              _proto6.addDispatch = function addDispatch(threadGroupCountX, threadGroupCountY, threadGroupCountZ, material, passID, name) {
                if (material === undefined) {
                  material = null;
                }
                if (passID === undefined) {
                  passID = 0;
                }
                if (name === undefined) {
                  name = 'Dispatch';
                }
                this._renderGraph.addVertex(11, renderGraphPool.createDispatch(material, passID, threadGroupCountX, threadGroupCountY, threadGroupCountZ), name, '', renderGraphPool.createRenderData(), false, this._vertID);
              };
              _createClass(WebComputeQueueBuilder, [{
                key: "name",
                get: function get() {
                  return this._renderGraph.getName(this._vertID);
                },
                set: function set(name) {
                  this._renderGraph.setName(this._vertID, name);
                }
              }]);
              return WebComputeQueueBuilder;
            }(WebSetter);
            var WebComputePassBuilder = function (_WebSetter6) {
              _inheritsLoose(WebComputePassBuilder, _WebSetter6);
              function WebComputePassBuilder(data, renderGraph, layoutGraph, resourceGraph, vertID, pass, pipeline) {
                var _this7;
                _this7 = _WebSetter6.call(this, data, layoutGraph) || this;
                _this7._renderGraph = undefined;
                _this7._resourceGraph = undefined;
                _this7._layoutID = undefined;
                _this7._pass = undefined;
                _this7._pipeline = undefined;
                _this7._renderGraph = renderGraph;
                _this7._resourceGraph = resourceGraph;
                _this7._vertID = vertID;
                _this7._pass = pass;
                _this7._pipeline = pipeline;
                var layoutName = _this7._renderGraph.getLayout(_this7._vertID);
                _this7._layoutID = layoutGraph.locateChild(layoutGraph.N, layoutName);
                return _this7;
              }
              var _proto7 = WebComputePassBuilder.prototype;
              _proto7.update = function update(data, renderGraph, layoutGraph, resourceGraph, vertID, pass, pipeline) {
                this._data = data;
                this._renderGraph = renderGraph;
                this._lg = layoutGraph;
                this._resourceGraph = resourceGraph;
                this._vertID = vertID;
                this._pass = pass;
                this._pipeline = pipeline;
                var layoutName = this._renderGraph.getLayout(this._vertID);
                this._layoutID = layoutGraph.locateChild(layoutGraph.N, layoutName);
              };
              _proto7.setCustomShaderStages = function setCustomShaderStages(name, stageFlags) {
                throw new Error('Method not implemented.');
              };
              _proto7.setArrayBuffer = function setArrayBuffer(name, arrayBuffer) {
                throw new Error('Method not implemented.');
              };
              _proto7.addTexture = function addTexture(name, slotName, sampler) {
                throw new Error('Method not implemented.');
              };
              _proto7.addStorageBuffer = function addStorageBuffer(name, accessType, slotName) {
                this._addComputeResource(name, accessType, slotName);
              };
              _proto7.addStorageImage = function addStorageImage(name, accessType, slotName) {
                this._addComputeResource(name, accessType, slotName);
              };
              _proto7.addMaterialTexture = function addMaterialTexture(resourceName, flags) {
                throw new Error('Method not implemented.');
              };
              _proto7.addQueue = function addQueue(layoutName, passName) {
                if (layoutName === undefined) {
                  layoutName = 'default';
                }
                var layoutId = this._lg.locateChild(this._layoutID, layoutName);
                var queue = renderGraphPool.createRenderQueue(1, layoutId);
                var data = renderGraphPool.createRenderData();
                var queueID = this._renderGraph.addVertex(8, queue, '', layoutName, data, false, this._vertID);
                var computeQueueBuilder = pipelinePool.computeQueueBuilder.add();
                computeQueueBuilder.update(data, this._renderGraph, this._lg, queueID, queue, this._pipeline);
                return computeQueueBuilder;
              };
              _proto7._addComputeResource = function _addComputeResource(name, accessType, slotName) {
                var view = renderGraphPool.createComputeView(slotName);
                view.accessType = accessType;
                if (this._pass.computeViews.has(name)) {
                  var _this$_pass$computeVi2;
                  (_this$_pass$computeVi2 = this._pass.computeViews.get(name)) == null ? undefined : _this$_pass$computeVi2.push(view);
                } else {
                  this._pass.computeViews.set(name, [view]);
                }
              };
              _createClass(WebComputePassBuilder, [{
                key: "name",
                get: function get() {
                  return this._renderGraph.getName(this._vertID);
                },
                set: function set(name) {
                  this._renderGraph.setName(this._vertID, name);
                }
              }]);
              return WebComputePassBuilder;
            }(WebSetter);
            (function () {
              function WebMovePassBuilder(renderGraph, vertID, pass) {
                this._renderGraph = undefined;
                this._vertID = undefined;
                this._pass = undefined;
                this._renderGraph = renderGraph;
                this._vertID = vertID;
                this._pass = pass;
              }
              var _proto8 = WebMovePassBuilder.prototype;
              _proto8.setCustomBehavior = function setCustomBehavior(name) {
                throw new Error('Method not implemented.');
              };
              _proto8.addPair = function addPair(pair) {
                this._pass.movePairs.push(pair);
              };
              _createClass(WebMovePassBuilder, [{
                key: "name",
                get: function get() {
                  return this._renderGraph.getName(this._vertID);
                },
                set: function set(name) {
                  this._renderGraph.setName(this._vertID, name);
                }
              }]);
              return WebMovePassBuilder;
            })();
            (function () {
              function WebCopyPassBuilder(renderGraph, vertID, pass) {
                this._renderGraph = undefined;
                this._vertID = undefined;
                this._pass = undefined;
                this._renderGraph = renderGraph;
                this._vertID = vertID;
                this._pass = pass;
              }
              var _proto9 = WebCopyPassBuilder.prototype;
              _proto9.addPair = function addPair(pair) {
                throw new Error('Method not implemented.');
              };
              _proto9.setCustomBehavior = function setCustomBehavior(name) {
                throw new Error('Method not implemented.');
              };
              _createClass(WebCopyPassBuilder, [{
                key: "name",
                get: function get() {
                  return this._renderGraph.getName(this._vertID);
                },
                set: function set(name) {
                  this._renderGraph.setName(this._vertID, name);
                }
              }]);
              return WebCopyPassBuilder;
            })();
            var WebPipeline = function (_WebSetter7) {
              _inheritsLoose(WebPipeline, _WebSetter7);
              function WebPipeline(layoutGraph) {
                var _this8;
                _this8 = _WebSetter7.call(this, new RenderData$1(), layoutGraph) || this;
                _this8.globalDSManager = undefined;
                _this8.descriptorSetLayout = undefined;
                _this8.descriptorSet = undefined;
                _this8._width = 0;
                _this8._height = 0;
                _this8._usesDeferredPipeline = false;
                _this8._copyPassMat = new Material();
                _this8._device = undefined;
                _this8._defaultSampler = undefined;
                _this8._profilerDescriptorSet = null;
                _this8._macros = {};
                _this8._pipelineSceneData = new PipelineSceneData();
                _this8._constantMacros = '';
                _this8._lightingMode = 1;
                _this8._profiler = null;
                _this8._cameras = [];
                _this8._resourceUses = [];
                _this8._resourceGraph = new ResourceGraph();
                _this8._renderGraph = null;
                _this8._compiler = null;
                _this8._executor = null;
                _this8._customPipelineName = '';
                _this8._globalDescSetData = undefined;
                _this8._combineSignY = 0;
                _this8._renderGraph = new RenderGraph();
                _this8._data = _this8._renderGraph.globalRenderData;
                return _this8;
              }
              var _proto10 = WebPipeline.prototype;
              _proto10.addCustomBuffer = function addCustomBuffer(name, info, type) {
                throw new Error('Method not implemented.');
              };
              _proto10.addCustomTexture = function addCustomTexture(name, info, type) {
                throw new Error('Method not implemented.');
              };
              _proto10.tryAddRenderWindowDepthStencil = function tryAddRenderWindowDepthStencil(width, height, depthStencilName, swapchain) {
                if (!depthStencilName) {
                  return;
                }
                if (swapchain) {
                  this.addDepthStencilImpl(depthStencilName, swapchain.depthStencilTexture.format, width, height, 4, swapchain);
                } else {
                  this.addDepthStencilImpl(depthStencilName, 55, width, height, 0);
                }
              };
              _proto10.addRenderWindow = function addRenderWindow(name, format, width, height, renderWindow, depthStencilName) {
                var resID = this._resourceGraph.find(name);
                if (resID !== 0xFFFFFFFF) {
                  this.updateRenderWindow(name, renderWindow, depthStencilName);
                  return resID;
                }
                this.tryAddRenderWindowDepthStencil(width, height, depthStencilName, renderWindow.swapchain);
                var desc = new ResourceDesc();
                desc.dimension = 2;
                desc.width = width;
                desc.height = height;
                desc.depthOrArraySize = 1;
                desc.mipLevels = 1;
                desc.format = renderWindow.framebuffer.colorTextures[0].format;
                desc.flags = 16;
                if (!renderWindow.swapchain) {
                  desc.sampleCount = renderWindow.framebuffer.colorTextures[0].info.samples;
                  return this._resourceGraph.addVertex(5, renderWindow.framebuffer, name, desc, new ResourceTraits(3), new ResourceStates(), new SamplerInfo());
                } else {
                  return this._resourceGraph.addVertex(6, new RenderSwapchain(renderWindow.swapchain), name, desc, new ResourceTraits(4), new ResourceStates(), new SamplerInfo());
                }
              };
              _proto10.updateRenderWindow = function updateRenderWindow(name, renderWindow, depthStencilName) {
                var resId = this.resourceGraph.vertex(name);
                var desc = this.resourceGraph.getDesc(resId);
                desc.width = renderWindow.width;
                desc.height = renderWindow.height;
                var currFbo = this.resourceGraph.object(resId);
                if (currFbo !== renderWindow.framebuffer) {
                  this.resourceGraph.x[resId].j = renderWindow.framebuffer;
                }
                this.tryAddRenderWindowDepthStencil(renderWindow.width, renderWindow.height, depthStencilName, renderWindow.swapchain);
              };
              _proto10.updateStorageBuffer = function updateStorageBuffer(name, size, format) {
                if (format === undefined) {
                  format = 0;
                }
                var resId = this.resourceGraph.vertex(name);
                var desc = this.resourceGraph.getDesc(resId);
                desc.width = size;
                if (format !== 0) {
                  desc.format = format;
                }
              };
              _proto10.updateRenderTarget = function updateRenderTarget(name, width, height, format) {
                if (format === undefined) {
                  format = 0;
                }
                var resId = this.resourceGraph.vertex(name);
                var desc = this.resourceGraph.getDesc(resId);
                desc.width = width;
                desc.height = height;
                if (format !== 0) desc.format = format;
              };
              _proto10.updateDepthStencil = function updateDepthStencil(name, width, height, format) {
                if (format === undefined) {
                  format = 0;
                }
                var resId = this.resourceGraph.find(name);
                if (resId === 0xFFFFFFFF) {
                  return;
                }
                this.updateDepthStencilImpl(resId, width, height, format);
              };
              _proto10.updateStorageTexture = function updateStorageTexture(name, width, height, format) {
                if (format === undefined) {
                  format = 0;
                }
                var resId = this.resourceGraph.vertex(name);
                var desc = this.resourceGraph.getDesc(resId);
                desc.width = width;
                desc.height = height;
                if (format !== 0) {
                  desc.format = format;
                }
              };
              _proto10.updateShadingRateTexture = function updateShadingRateTexture(name, width, height) {
                var resId = this.resourceGraph.vertex(name);
                var desc = this.resourceGraph.getDesc(resId);
                desc.width = width;
                desc.height = height;
              };
              _proto10.addBuffer = function addBuffer(name, size, flags, residency) {
                var resID = this._resourceGraph.find(name);
                if (resID !== 0xFFFFFFFF) {
                  this.updateBuffer(name, size);
                  return resID;
                }
                var desc = new ResourceDesc();
                desc.dimension = 0;
                desc.width = size;
                desc.flags = flags;
                return this._resourceGraph.addVertex(0, new ManagedResource(), name, desc, new ResourceTraits(residency), new ResourceStates(), new SamplerInfo(2, 2, 0, 2, 2, 2));
              };
              _proto10.updateBuffer = function updateBuffer(name, size) {
                this.updateResource(name, 0, size, 0, 0, 0, 0, 1);
              };
              _proto10.addExternalTexture = function addExternalTexture(name, texture, flags) {
                throw new Error('Method not implemented.');
              };
              _proto10.updateExternalTexture = function updateExternalTexture(name, texture) {
                throw new Error('Method not implemented.');
              };
              _proto10.addTexture = function addTexture(name, textureType, format, width, height, depth, arraySize, mipLevels, sampleCount, flags, residency) {
                var resID = this._resourceGraph.find(name);
                if (resID !== 0xFFFFFFFF) {
                  this.updateTexture(name, format, width, height, depth, arraySize, mipLevels, sampleCount);
                  return resID;
                }
                var desc = new ResourceDesc();
                desc.dimension = getResourceDimension(textureType);
                desc.width = width;
                desc.height = height;
                desc.depthOrArraySize = desc.dimension === 3 ? depth : arraySize;
                desc.mipLevels = mipLevels;
                desc.format = format;
                desc.sampleCount = sampleCount;
                desc.flags = flags;
                desc.viewType = textureType;
                return this._resourceGraph.addVertex(0, new ManagedResource(), name, desc, new ResourceTraits(residency), new ResourceStates(), new SamplerInfo(2, 2, 0, 2, 2, 2));
              };
              _proto10.updateTexture = function updateTexture(name, format, width, height, depth, arraySize, mipLevels, sampleCount) {
                this.updateResource(name, format, width, height, depth, arraySize, mipLevels, sampleCount);
              };
              _proto10.addResource = function addResource(name, dimension, format, width, height, depth, arraySize, mipLevels, sampleCount, flags, residency) {
                var resID = this._resourceGraph.find(name);
                if (resID !== 0xFFFFFFFF) {
                  this.updateResource(name, format, width, height, depth, arraySize, mipLevels, sampleCount);
                  return resID;
                }
                if (dimension === 0) {
                  return this.addBuffer(name, width, flags, residency);
                } else {
                  return this.addTexture(name, getTextureType(dimension, arraySize), format, width, height, depth, arraySize, mipLevels, sampleCount, flags, residency);
                }
              };
              _proto10.updateResource = function updateResource(name, format, width, height, depth, arraySize, mipLevels, sampleCount) {
                var resId = this.resourceGraph.vertex(name);
                var desc = this.resourceGraph.getDesc(resId);
                desc.width = width;
                desc.height = height;
                desc.depthOrArraySize = desc.dimension === 3 ? depth : arraySize;
                desc.mipLevels = mipLevels;
                if (format !== 0) {
                  desc.format = format;
                }
                desc.sampleCount = sampleCount;
              };
              _proto10.containsResource = function containsResource(name) {
                return this._resourceGraph.contains(name);
              };
              _proto10.addResolvePass = function addResolvePass(resolvePairs) {
                throw new Error('Method not implemented.');
              };
              _proto10.addComputePass = function addComputePass(passName) {
                var name = 'Compute';
                var pass = renderGraphPool.createComputePass();
                var data = renderGraphPool.createRenderData();
                var vertID = this._renderGraph.addVertex(3, pass, name, passName, data, false);
                var result = pipelinePool.computePassBuilder.add();
                result.update(data, this._renderGraph, this._lg, this._resourceGraph, vertID, pass, this._pipelineSceneData);
                setComputeConstants();
                return result;
              };
              _proto10.addUploadPass = function addUploadPass(uploadPairs) {
                var name = 'UploadPass';
                var pass = renderGraphPool.createCopyPass();
                for (var _iterator2 = _createForOfIteratorHelperLoose(uploadPairs), _step2; !(_step2 = _iterator2()).done;) {
                  var up = _step2.value;
                  pass.uploadPairs.push(up);
                }
                this._renderGraph.addVertex(5, pass, name, '', renderGraphPool.createRenderData(), false);
              };
              _proto10.addCopyPass = function addCopyPass(copyPairs) {
                for (var _iterator3 = _createForOfIteratorHelperLoose(copyPairs), _step3; !(_step3 = _iterator3()).done;) {
                  var pair = _step3.value;
                  var targetName = pair.target;
                  var tarVerId = this.resourceGraph.find(targetName);
                  var resDesc = this.resourceGraph.getDesc(tarVerId);
                  var currRaster = this.addRenderPass(resDesc.width, resDesc.height, 'copy-pass');
                  currRaster.addRenderTarget(targetName, 1, 0, pipelinePool.createColor());
                  currRaster.setFloat('flip', this.getCombineSignY());
                  currRaster.addTexture(pair.source, 'outputResultMap');
                  currRaster.addQueue(0).addFullscreenQuad(this._copyPassMat, 0, 0);
                }
              };
              _proto10._generateConstantMacros = function _generateConstantMacros(clusterEnabled) {
                var str = '';
                str += "#define CC_DEVICE_SUPPORT_FLOAT_TEXTURE " + (this._device.getFormatFeatures(44) & (1 | 2) ? 1 : 0) + "\n";
                str += "#define CC_DEVICE_MAX_VERTEX_UNIFORM_VECTORS " + this._device.capabilities.maxVertexUniformVectors + "\n";
                str += "#define CC_DEVICE_MAX_FRAGMENT_UNIFORM_VECTORS " + this._device.capabilities.maxFragmentUniformVectors + "\n";
                str += "#define CC_DEVICE_CAN_BENEFIT_FROM_INPUT_ATTACHMENT " + (this._device.hasFeature(5) ? 1 : 0) + "\n";
                str += "#define CC_PLATFORM_ANDROID_AND_WEBGL " + (systemInfo.os === OS.ANDROID && systemInfo.isBrowser ? 1 : 0) + "\n";
                str += "#define CC_ENABLE_WEBGL_HIGHP_STRUCT_VALUES " + (macro.ENABLE_WEBGL_HIGHP_STRUCT_VALUES ? 1 : 0) + "\n";
                var jointUniformCapacity = UBOSkinning.JOINT_UNIFORM_CAPACITY;
                str += "#define CC_JOINT_UNIFORM_CAPACITY " + jointUniformCapacity + "\n";
                this._constantMacros = str;
                this._lg.constantMacros = this._constantMacros;
              };
              _proto10.setCustomPipelineName = function setCustomPipelineName(name) {
                this._customPipelineName = name;
                if (this._customPipelineName === 'Deferred') {
                  this._usesDeferredPipeline = true;
                }
              };
              _proto10.getGlobalDescriptorSetData = function getGlobalDescriptorSetData() {
                var stageId = this.layoutGraph.locateChild(this.layoutGraph.N, 'default');
                var layout = this.layoutGraph.getLayout(stageId);
                var layoutData = layout.getSet(3);
                return layoutData;
              };
              _proto10._initCombineSignY = function _initCombineSignY() {
                var device = this._device;
                this._combineSignY = device.capabilities.screenSpaceSignY * 0.5 + 0.5 << 1 | device.capabilities.clipSpaceSignY * 0.5 + 0.5;
              };
              _proto10.getCombineSignY = function getCombineSignY() {
                return this._combineSignY;
              };
              _proto10._compileMaterial = function _compileMaterial() {
                this._copyPassMat.initialize({
                  effectName: 'pipeline/copy-pass'
                });
                for (var i = 0; i < this._copyPassMat.passes.length; ++i) {
                  this._copyPassMat.passes[i].tryCompile();
                }
              };
              _proto10.activate = function activate(swapchain) {
                this._device = deviceManager.gfxDevice;
                pipelinePool = new PipelinePool();
                renderGraphPool = pipelinePool.renderGraphPool;
                createGfxDescriptorSetsAndPipelines(this._device, this._lg);
                this._compileMaterial();
                this.setMacroBool('CC_USE_HDR', this._pipelineSceneData.isHDR);
                this.setMacroBool('CC_USE_FLOAT_OUTPUT', macro.ENABLE_FLOAT_OUTPUT && supportsRGBA16HalfFloatTexture(this._device));
                this._generateConstantMacros(false);
                this._pipelineSceneData.activate(this._device);
                this._initCombineSignY();
                var isFloat = supportsR32FloatTexture(this._device) ? 0 : 1;
                this.setMacroInt('CC_SHADOWMAP_FORMAT', isFloat);
                var isLinear = this._device.gfxAPI === 6 ? 1 : 0;
                this.setMacroInt('CC_SHADOWMAP_USE_LINEAR_DEPTH', isLinear);
                var director = cclegacy.director;
                var root = director.root;
                this._defaultSampler = root.device.getSampler(_samplerPointInfo);
                this.pipelineSceneData.csmSupported = this.device.capabilities.maxFragmentUniformVectors >= WebPipeline.CSM_UNIFORM_VECTORS + WebPipeline.GLOBAL_UNIFORM_VECTORS;
                this.setMacroBool('CC_SUPPORT_CASCADED_SHADOW_MAP', this.pipelineSceneData.csmSupported);
                this.setMacroInt('CC_SHADOW_TYPE', 0);
                this.setMacroInt('CC_DIR_SHADOW_PCF_TYPE', PCFType.HARD);
                this.setMacroInt('CC_DIR_LIGHT_SHADOW_TYPE', 0);
                this.setMacroBool('CC_CASCADED_LAYERS_TRANSITION', false);
                if (this.usesDeferredPipeline) {
                  this.setMacroInt('CC_PIPELINE_TYPE', 1);
                }
                return true;
              };
              _proto10.destroy = function destroy() {
                var _this$_pipelineSceneD;
                (_this$_pipelineSceneD = this._pipelineSceneData) == null ? undefined : _this$_pipelineSceneD.destroy();
                return true;
              };
              _proto10.getMacroString = function getMacroString(name) {
                var str = this._macros[name];
                if (str === undefined) {
                  return '';
                }
                return str;
              };
              _proto10.getMacroInt = function getMacroInt(name) {
                var value = this._macros[name];
                if (value === undefined) {
                  return 0;
                }
                return value;
              };
              _proto10.getMacroBool = function getMacroBool(name) {
                var value = this._macros[name];
                if (value === undefined) {
                  return false;
                }
                return value;
              };
              _proto10.getSamplerInfo = function getSamplerInfo(name) {
                if (this.containsResource(name)) {
                  var verId = this._resourceGraph.vertex(name);
                  return this._resourceGraph.getSampler(verId);
                }
                return null;
              };
              _proto10.setMacroString = function setMacroString(name, value) {
                this._macros[name] = value;
              };
              _proto10.setMacroInt = function setMacroInt(name, value) {
                this._macros[name] = value;
              };
              _proto10.setMacroBool = function setMacroBool(name, value) {
                this._macros[name] = value;
              };
              _proto10.onGlobalPipelineStateChanged = function onGlobalPipelineStateChanged() {
                var builder = cclegacy.rendering.getCustomPipeline(macro.CUSTOM_PIPELINE_NAME);
                if (builder) {
                  if (typeof builder.onGlobalPipelineStateChanged === 'function') {
                    builder.onGlobalPipelineStateChanged();
                  }
                  cclegacy.rendering.forceResizeAllWindows();
                }
              };
              _proto10.beginSetup = function beginSetup() {
                if (!this._renderGraph) {
                  this._renderGraph = new RenderGraph();
                  this._data = this._renderGraph.globalRenderData;
                }
                pipelinePool.reset();
              };
              _proto10.endSetup = function endSetup() {
                this.compile();
              };
              _proto10.addStorageBuffer = function addStorageBuffer(name, format, size, residency) {
                if (residency === undefined) {
                  residency = 0;
                }
                var resID = this._resourceGraph.find(name);
                if (resID !== 0xFFFFFFFF) {
                  this.updateStorageBuffer(name, size, format);
                  return resID;
                }
                var desc = new ResourceDesc();
                desc.dimension = 0;
                desc.width = size;
                desc.height = 1;
                desc.depthOrArraySize = 1;
                desc.mipLevels = 1;
                desc.format = format;
                desc.flags = 4;
                if (residency === 2) {
                  return this._resourceGraph.addVertex(3, new PersistentBuffer(), name, desc, new ResourceTraits(2), new ResourceStates(), new SamplerInfo());
                }
                return this._resourceGraph.addVertex(1, new ManagedBuffer(), name, desc, new ResourceTraits(residency), new ResourceStates(), new SamplerInfo());
              };
              _proto10.addRenderTarget = function addRenderTarget(name, format, width, height, residency) {
                if (residency === undefined) {
                  residency = 0;
                }
                var resID = this._resourceGraph.find(name);
                if (resID !== 0xFFFFFFFF) {
                  this.updateRenderTarget(name, width, height, format);
                  return resID;
                }
                var desc = new ResourceDesc();
                desc.dimension = 2;
                desc.width = width;
                desc.height = height;
                desc.depthOrArraySize = 1;
                desc.mipLevels = 1;
                desc.format = format;
                desc.sampleCount = 1;
                desc.flags = 16 | 8;
                return this._resourceGraph.addVertex(0, new ManagedResource(), name, desc, new ResourceTraits(residency), new ResourceStates(), new SamplerInfo(2, 2, 0, 2, 2, 2));
              };
              _proto10.updateDepthStencilImpl = function updateDepthStencilImpl(resId, width, height, format, swapchain) {
                var desc = this.resourceGraph.getDesc(resId);
                desc.width = width;
                desc.height = height;
                if (swapchain) {
                  var sc = this.resourceGraph.j(resId);
                  sc.swapchain = swapchain;
                  desc.format = sc.swapchain.depthStencilTexture.format;
                } else if (format !== 0) {
                  desc.format = format;
                }
              };
              _proto10.addDepthStencilImpl = function addDepthStencilImpl(name, format, width, height, residency, swapchain) {
                var resID = this._resourceGraph.find(name);
                if (resID !== 0xFFFFFFFF) {
                  this.updateDepthStencilImpl(resID, width, height, format, swapchain);
                  return resID;
                }
                var desc = new ResourceDesc();
                desc.dimension = 2;
                desc.width = width;
                desc.height = height;
                desc.depthOrArraySize = 1;
                desc.mipLevels = 1;
                desc.format = format;
                desc.sampleCount = 1;
                desc.flags = 32 | 8;
                if (swapchain) {
                  return this._resourceGraph.addVertex(6, new RenderSwapchain(swapchain, true), name, desc, new ResourceTraits(residency), new ResourceStates(), new SamplerInfo(1, 1, 0));
                } else {
                  return this._resourceGraph.addVertex(0, new ManagedResource(), name, desc, new ResourceTraits(residency), new ResourceStates(), new SamplerInfo(1, 1, 0));
                }
              };
              _proto10.addDepthStencil = function addDepthStencil(name, format, width, height, residency) {
                if (residency === undefined) {
                  residency = 0;
                }
                return this.addDepthStencilImpl(name, format, width, height, residency);
              };
              _proto10.addStorageTexture = function addStorageTexture(name, format, width, height, residency) {
                if (residency === undefined) {
                  residency = 0;
                }
                var resID = this._resourceGraph.find(name);
                if (resID !== 0xFFFFFFFF) {
                  this.updateStorageTexture(name, width, height, format);
                  return resID;
                }
                var desc = new ResourceDesc();
                desc.dimension = 2;
                desc.width = width;
                desc.height = height;
                desc.depthOrArraySize = 1;
                desc.mipLevels = 1;
                desc.format = format;
                desc.flags = 4 | 8;
                return this._resourceGraph.addVertex(0, new ManagedResource(), name, desc, new ResourceTraits(residency), new ResourceStates(), new SamplerInfo(1, 1, 0));
              };
              _proto10.addShadingRateTexture = function addShadingRateTexture(name, width, height, residency) {
                if (residency === undefined) {
                  residency = 0;
                }
                var resID = this._resourceGraph.find(name);
                if (resID !== 0xFFFFFFFF) {
                  this.addShadingRateTexture(name, width, height);
                  return resID;
                }
                var desc = new ResourceDesc();
                desc.dimension = 2;
                desc.width = width;
                desc.height = height;
                desc.depthOrArraySize = 1;
                desc.mipLevels = 1;
                desc.format = 6;
                desc.flags = 128 | 4 | 8;
                return this._resourceGraph.addVertex(0, new ManagedResource(), name, desc, new ResourceTraits(residency), new ResourceStates(), new SamplerInfo(2, 2, 0, 2, 2, 2));
              };
              _proto10.beginFrame = function beginFrame() {
                var director = cclegacy.director;
                director.buildRenderPipeline();
              };
              _proto10.update = function update(camera) {};
              _proto10.endFrame = function endFrame() {
                var _this$renderGraph;
                (_this$renderGraph = this.renderGraph) == null ? undefined : _this$renderGraph.clear();
              };
              _proto10.compile = function compile() {
                if (!this._renderGraph) {
                  throw new Error('RenderGraph cannot be built without being created');
                }
                {
                  if (!this._compiler) {
                    this._compiler = new Compiler(this, this._renderGraph, this._resourceGraph, this._lg);
                  }
                  this._compiler.compile(this._renderGraph);
                }
              };
              _proto10.execute = function execute() {
                if (!this._renderGraph) {
                  throw new Error('Cannot run without creating rendergraph');
                }
                if (!this._executor) {
                  this._executor = new Executor(this, this._device, this._resourceGraph, this.layoutGraph, this.width, this.height);
                }
                this._executor.resize(this.width, this.height);
                this._executor.execute(this._renderGraph);
              };
              _proto10._applySize = function _applySize(cameras) {
                var _this9 = this;
                var newWidth = this._width;
                var newHeight = this._height;
                cameras.forEach(function (camera) {
                  var window = camera.window;
                  newWidth = Math.max(window.width, newWidth);
                  newHeight = Math.max(window.height, newHeight);
                  if (!_this9._cameras.includes(camera)) {
                    _this9._cameras.push(camera);
                  }
                });
                if (newWidth !== this._width || newHeight !== this._height) {
                  this._width = newWidth;
                  this._height = newHeight;
                }
              };
              _proto10.render = function render(cameras) {
                if (cameras.length === 0) {
                  return;
                }
                this._applySize(cameras);
                decideProfilerCamera(cameras);
                this.beginFrame();
                this.execute();
                this.endFrame();
              };
              _proto10.addBuiltinReflectionProbePass = function addBuiltinReflectionProbePass(camera) {
                var reflectionProbeManager = cclegacy.internal.reflectionProbeManager;
                if (!reflectionProbeManager) return;
                var probes = reflectionProbeManager.getProbes();
                if (probes.length === 0) return;
                for (var i = 0; i < probes.length; i++) {
                  var probe = probes[i];
                  if (probe.needRender) {
                    if (probes[i].probeType === 1) {
                      buildReflectionProbePass(camera, this, probe, probe.realtimePlanarTexture.window, 0);
                    }
                  }
                }
              };
              _proto10.addRenderPassImpl = function addRenderPassImpl(width, height, layoutName, count, quality) {
                if (count === undefined) {
                  count = 1;
                }
                if (quality === undefined) {
                  quality = 0;
                }
                var name = 'Raster';
                var pass = renderGraphPool.createRasterPass();
                pass.viewport.width = width;
                pass.viewport.height = height;
                pass.count = count;
                pass.quality = quality;
                var data = renderGraphPool.createRenderData();
                var vertID = this._renderGraph.addVertex(0, pass, name, layoutName, data, false);
                var result = pipelinePool.renderPassBuilder.add();
                result.update(data, this._renderGraph, this._lg, this._resourceGraph, vertID, pass, this._pipelineSceneData);
                this._updateRasterPassConstants(result, width, height, layoutName);
                setTextureUBOView(result, this._pipelineSceneData);
                return result;
              };
              _proto10.addRenderPass = function addRenderPass(width, height, layoutName) {
                if (layoutName === undefined) {
                  layoutName = 'default';
                }
                return this.addRenderPassImpl(width, height, layoutName);
              };
              _proto10.addMultisampleRenderPass = function addMultisampleRenderPass(width, height, count, quality, layoutName) {
                if (layoutName === undefined) {
                  layoutName = 'default';
                }
                return this.addRenderPassImpl(width, height, layoutName, count, quality);
              };
              _proto10.getDescriptorSetLayout = function getDescriptorSetLayout(shaderName, freq) {
                var lg = this._lg;
                var phaseID = lg.shaderLayoutIndex.get(shaderName);
                var pplLayout = lg.getLayout(phaseID);
                var setLayout = pplLayout.getSet(freq);
                return setLayout.descriptorSetLayout;
              };
              _proto10._updateRasterPassConstants = function _updateRasterPassConstants(setter, width, height, layoutName) {
                var director = cclegacy.director;
                var root = director.root;
                var shadingWidth = width;
                var shadingHeight = height;
                var pipeline = root.pipeline;
                pipeline.layoutGraph;
                _uboVec.set(root.cumulativeTime, root.frameTime, director.getTotalFrames());
                setter.setVec4('cc_time', _uboVec);
                _uboVec.set(shadingWidth, shadingHeight, 1.0 / shadingWidth, 1.0 / shadingHeight);
                setter.setVec4('cc_screenSize', _uboVec);
                _uboVec.set(shadingWidth, shadingHeight, 1.0 / shadingWidth, 1.0 / shadingHeight);
                setter.setVec4('cc_nativeSize', _uboVec);
                var debugView = root.debugView;
                _uboVec.set(0.0, 0.0, 0.0, 0.0);
                if (debugView) {
                  var debugPackVec = [debugView.singleMode, 0.0, 0.0, 0.0];
                  for (var i = 0; i < 17; i++) {
                    var idx = i >> 3;
                    var bit = i % 8;
                    debugPackVec[idx + 1] += (debugView.isCompositeModeEnabled(i) ? 1.0 : 0.0) * Math.pow(10.0, bit);
                  }
                  debugPackVec[3] += (debugView.lightingWithAlbedo ? 1.0 : 0.0) * Math.pow(10.0, 6.0);
                  debugPackVec[3] += (debugView.csmLayerColoration ? 1.0 : 0.0) * Math.pow(10.0, 7.0);
                  _uboVec.set(debugPackVec[0], debugPackVec[1], debugPackVec[2], debugPackVec[3]);
                }
                setter.setVec4('cc_debug_view_mode', _uboVec);
              };
              _createClass(WebPipeline, [{
                key: "type",
                get: function get() {
                  return 0;
                }
              }, {
                key: "capabilities",
                get: function get() {
                  return new PipelineCapabilities();
                }
              }, {
                key: "enableCpuLightCulling",
                get: function get() {
                  if (!this._executor) {
                    return true;
                  }
                  return this._executor._context.culling.enableLightCulling;
                },
                set: function set(enable) {
                  if (!this._executor) {
                    return;
                  }
                  this._executor._context.culling.enableLightCulling = enable;
                }
              }, {
                key: "name",
                get: function get() {
                  return 'WebPipeline';
                }
              }, {
                key: "globalDescriptorSetData",
                get: function get() {
                  return this._globalDescSetData;
                }
              }, {
                key: "defaultSampler",
                get: function get() {
                  return this._defaultSampler;
                }
              }, {
                key: "defaultShadowTexture",
                get: function get() {
                  return getDefaultShadowTexture(this.device);
                }
              }, {
                key: "device",
                get: function get() {
                  return this._device;
                }
              }, {
                key: "lightingMode",
                get: function get() {
                  return this._lightingMode;
                },
                set: function set(mode) {
                  this._lightingMode = mode;
                }
              }, {
                key: "usesDeferredPipeline",
                get: function get() {
                  return this._usesDeferredPipeline;
                }
              }, {
                key: "macros",
                get: function get() {
                  return this._macros;
                }
              }, {
                key: "profilerDescriptorSet",
                get: function get() {
                  return this._profilerDescriptorSet;
                }
              }, {
                key: "commandBuffers",
                get: function get() {
                  return [this._device.commandBuffer];
                }
              }, {
                key: "pipelineSceneData",
                get: function get() {
                  return this._pipelineSceneData;
                }
              }, {
                key: "constantMacros",
                get: function get() {
                  return this._constantMacros;
                }
              }, {
                key: "profiler",
                get: function get() {
                  return this._profiler;
                },
                set: function set(profiler) {
                  this._profiler = profiler;
                }
              }, {
                key: "geometryRenderer",
                get: function get() {
                  throw new Error('Method not implemented.');
                }
              }, {
                key: "shadingScale",
                get: function get() {
                  return this._pipelineSceneData.shadingScale;
                },
                set: function set(scale) {
                  this._pipelineSceneData.shadingScale = scale;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
              }, {
                key: "renderGraph",
                get: function get() {
                  return this._renderGraph;
                }
              }, {
                key: "resourceGraph",
                get: function get() {
                  return this._resourceGraph;
                }
              }, {
                key: "layoutGraph",
                get: function get() {
                  return this._lg;
                }
              }, {
                key: "resourceUses",
                get: function get() {
                  return this._resourceUses;
                }
              }]);
              return WebPipeline;
            }(WebSetter);
            WebPipeline.MAX_BLOOM_FILTER_PASS_NUM = 6;
            WebPipeline.CSM_UNIFORM_VECTORS = 61;
            WebPipeline.GLOBAL_UNIFORM_VECTORS = 64;

            (function () {
              function BinaryOutputArchive() {
                this.capacity = 0;
                this.size = 0;
                this.buffer = undefined;
                this.dataView = undefined;
                this.capacity = 4096;
                this.buffer = new Uint8Array(this.capacity);
                this.dataView = new DataView(this.buffer.buffer);
              }
              var _proto = BinaryOutputArchive.prototype;
              _proto.b = function b(value) {
                var newSize = this.size + 1;
                if (newSize > this.capacity) {
                  this.reserve(newSize);
                }
                this.dataView.setUint8(this.size, value ? 1 : 0);
                this.size = newSize;
              };
              _proto.n = function n(value) {
                var newSize = this.size + 8;
                if (newSize > this.capacity) {
                  this.reserve(newSize);
                }
                this.dataView.setFloat64(this.size, value, true);
                this.size = newSize;
              };
              _proto.s = function s(value) {
                this.n(value.length);
                var newSize = this.size + value.length;
                if (newSize > this.capacity) {
                  this.reserve(newSize);
                }
                for (var i = 0; i < value.length; i++) {
                  this.dataView.setUint8(this.size + i, value.charCodeAt(i));
                }
                this.size = newSize;
              };
              _proto.reserve = function reserve(requiredSize) {
                var newCapacity = Math.max(requiredSize, this.capacity * 2);
                var prevBuffer = this.buffer;
                this.buffer = new Uint8Array(newCapacity);
                this.buffer.set(prevBuffer);
                this.dataView = new DataView(this.buffer.buffer);
                this.capacity = newCapacity;
              };
              _createClass(BinaryOutputArchive, [{
                key: "data",
                get: function get() {
                  return this.buffer.buffer.slice(0, this.size);
                }
              }]);
              return BinaryOutputArchive;
            })();
            var BinaryInputArchive = function () {
              function BinaryInputArchive(data, byteOffset) {
                this.offset = 0;
                this.dataView = undefined;
                this.dataView = new DataView(data, byteOffset);
              }
              var _proto2 = BinaryInputArchive.prototype;
              _proto2.b = function b() {
                return this.dataView.getUint8(this.offset++) !== 0;
              };
              _proto2.n = function n() {
                var value = this.dataView.getFloat64(this.offset, true);
                this.offset += 8;
                return value;
              };
              _proto2.s = function s() {
                var length = this.n();
                var str = String.fromCharCode.apply(null, Array.from(new Uint8Array(this.dataView.buffer, this.offset, length)));
                this.offset += length;
                return str;
              };
              return BinaryInputArchive;
            }();

            var ProgramInfo = function ProgramInfo(programInfo, shaderInfo, attributes, blockSizes, handleMap) {
              this.programInfo = programInfo;
              this.shaderInfo = shaderInfo;
              this.attributes = attributes;
              this.blockSizes = blockSizes;
              this.handleMap = handleMap;
            };
            var ProgramGroup = function ProgramGroup() {
              this.programInfos = new Map();
              this.programProxies = new Map();
            };

            var _setIndex = [2, 1, 3, 0];
            function makeProgramInfo(effectName, shader) {
              var programInfo = _extends({}, shader);
              programInfo.effectName = effectName;
              populateMacros(programInfo);
              return programInfo;
            }
            function findBinding(shaderInfo, name) {
              for (var _iterator = _createForOfIteratorHelperLoose(shaderInfo.blocks), _step; !(_step = _iterator()).done;) {
                var v = _step.value;
                if (v.name === name) {
                  return {
                    set: v.set,
                    binding: v.binding
                  };
                }
              }
              for (var _iterator2 = _createForOfIteratorHelperLoose(shaderInfo.buffers), _step2; !(_step2 = _iterator2()).done;) {
                var _v = _step2.value;
                if (_v.name === name) {
                  return {
                    set: _v.set,
                    binding: _v.binding
                  };
                }
              }
              for (var _iterator3 = _createForOfIteratorHelperLoose(shaderInfo.samplerTextures), _step3; !(_step3 = _iterator3()).done;) {
                var _v2 = _step3.value;
                if (_v2.name === name) {
                  return {
                    set: _v2.set,
                    binding: _v2.binding
                  };
                }
              }
              for (var _iterator4 = _createForOfIteratorHelperLoose(shaderInfo.samplers), _step4; !(_step4 = _iterator4()).done;) {
                var _v3 = _step4.value;
                if (_v3.name === name) {
                  return {
                    set: _v3.set,
                    binding: _v3.binding
                  };
                }
              }
              for (var _iterator5 = _createForOfIteratorHelperLoose(shaderInfo.textures), _step5; !(_step5 = _iterator5()).done;) {
                var _v4 = _step5.value;
                if (_v4.name === name) {
                  return {
                    set: _v4.set,
                    binding: _v4.binding
                  };
                }
              }
              for (var _iterator6 = _createForOfIteratorHelperLoose(shaderInfo.images), _step6; !(_step6 = _iterator6()).done;) {
                var _v5 = _step6.value;
                if (_v5.name === name) {
                  return {
                    set: _v5.set,
                    binding: _v5.binding
                  };
                }
              }
              for (var _iterator7 = _createForOfIteratorHelperLoose(shaderInfo.subpassInputs), _step7; !(_step7 = _iterator7()).done;) {
                var _v6 = _step7.value;
                if (_v6.name === name) {
                  return {
                    set: _v6.set,
                    binding: _v6.binding
                  };
                }
              }
              throw error('binding not found in shaderInfo!');
            }
            function overwriteShaderSourceBinding(shaderInfo, source) {
              var code = source;
              var samplerExp = /layout\s*\(([^)])+\)\s+uniform\s+(\b\w+\b\s+)?sampler(\w+)\s+(\b\w+\b)/g;
              var samplerIter = samplerExp.exec(code);
              while (samplerIter) {
                var name = samplerIter[4];
                var _findBinding = findBinding(shaderInfo, name),
                  set = _findBinding.set,
                  binding = _findBinding.binding;
                var precStr = samplerIter[2] ? samplerIter[2] : '';
                var replaceStr = "layout(set = " + set + ", binding = " + binding + ") uniform " + precStr + " sampler" + samplerIter[3] + " " + samplerIter[4];
                code = code.replace(samplerIter[0], replaceStr);
                samplerIter = samplerExp.exec(code);
              }
              var blockExp = /layout\s*\(([^)]+)\)\s*(readonly|writeonly)?\s*\b((uniform\s*|buffer\s*|image2D\s*){1,2})\b\s*(\b\w+\b)\s*[{;]/g;
              var blockIter = blockExp.exec(code);
              while (blockIter) {
                var _name = blockIter[5];
                var _findBinding2 = findBinding(shaderInfo, _name),
                  _set = _findBinding2.set,
                  _binding = _findBinding2.binding;
                var accessStr = blockIter[2] ? blockIter[2] : '';
                var endStr = ' {';
                if (blockIter[3].includes('image')) {
                  endStr = ";";
                }
                var desc = blockIter[1];
                desc = desc.replace(/set\s*=\s*\d+/g, "set = " + _set);
                desc = desc.replace(/binding\s*=\s*\d+/g, "binding = " + _binding);
                var _replaceStr = "layout(" + desc + ") " + accessStr + " " + blockIter[3] + " " + blockIter[5] + endStr;
                code = code.replace(blockIter[0], _replaceStr);
                blockIter = blockExp.exec(code);
              }
              return code;
            }
            function overwriteShaderProgramBinding(shaderInfo, programInfo) {
              var version = getDeviceShaderVersion(deviceManager.gfxDevice);
              if (version !== 'glsl4') {
                return;
              }
              if (programInfo.glsl4.vert) {
                programInfo.glsl4.vert = overwriteShaderSourceBinding(shaderInfo, programInfo.glsl4.vert);
              }
              if (programInfo.glsl4.frag) {
                programInfo.glsl4.frag = overwriteShaderSourceBinding(shaderInfo, programInfo.glsl4.frag);
              }
              if (programInfo.glsl4.compute) {
                programInfo.glsl4.compute = overwriteShaderSourceBinding(shaderInfo, programInfo.glsl4.compute);
              }
            }
            function overwriteProgramBlockInfo(shaderInfo, programInfo) {
              overwriteShaderProgramBinding(shaderInfo, programInfo);
              var set = _setIndex[1];
              for (var _iterator8 = _createForOfIteratorHelperLoose(programInfo.blocks), _step8; !(_step8 = _iterator8()).done;) {
                var block = _step8.value;
                var found = false;
                for (var _iterator9 = _createForOfIteratorHelperLoose(shaderInfo.blocks), _step9; !(_step9 = _iterator9()).done;) {
                  var src = _step9.value;
                  if (src.set !== set) {
                    continue;
                  }
                  if (src.name === block.name) {
                    block.binding = src.binding;
                    found = true;
                    break;
                  }
                }
                if (!found) {
                  error("Block " + block.name + " not found in shader " + shaderInfo.name);
                }
              }
            }
            function populateGroupedShaderInfo(layout, descriptorInfo, set, shaderInfo, blockSizes) {
              for (var _iterator10 = _createForOfIteratorHelperLoose(layout.descriptorBlocks), _step10; !(_step10 = _iterator10()).done;) {
                var descriptorBlock = _step10.value;
                var visibility = descriptorBlock.visibility;
                var binding = descriptorBlock.offset;
                switch (descriptorBlock.type) {
                  case 0:
                    for (var _iterator11 = _createForOfIteratorHelperLoose(descriptorInfo.blocks), _step11; !(_step11 = _iterator11()).done;) {
                      var block = _step11.value;
                      if (block.stageFlags !== visibility) {
                        continue;
                      }
                      blockSizes.push(getSize(block.members));
                      shaderInfo.blocks.push(new UniformBlock(set, binding, block.name, block.members.map(function (m) {
                        return new Uniform(m.name, m.type, m.count);
                      }), 1));
                      ++binding;
                    }
                    break;
                  case 1:
                    break;
                  case 2:
                    for (var _iterator12 = _createForOfIteratorHelperLoose(descriptorInfo.samplerTextures), _step12; !(_step12 = _iterator12()).done;) {
                      var tex = _step12.value;
                      if (tex.stageFlags !== visibility) {
                        continue;
                      }
                      shaderInfo.samplerTextures.push(new UniformSamplerTexture(set, binding, tex.name, tex.type, tex.count));
                      ++binding;
                    }
                    break;
                  case 3:
                    for (var _iterator13 = _createForOfIteratorHelperLoose(descriptorInfo.samplers), _step13; !(_step13 = _iterator13()).done;) {
                      var sampler = _step13.value;
                      if (sampler.stageFlags !== visibility) {
                        continue;
                      }
                      shaderInfo.samplers.push(new UniformSampler(set, binding, sampler.name, sampler.count));
                      ++binding;
                    }
                    break;
                  case 4:
                    for (var _iterator14 = _createForOfIteratorHelperLoose(descriptorInfo.textures), _step14; !(_step14 = _iterator14()).done;) {
                      var texture = _step14.value;
                      if (texture.stageFlags !== visibility) {
                        continue;
                      }
                      shaderInfo.textures.push(new UniformTexture(set, binding, texture.name, texture.type, texture.count));
                      ++binding;
                    }
                    break;
                  case 5:
                    for (var _iterator15 = _createForOfIteratorHelperLoose(descriptorInfo.buffers), _step15; !(_step15 = _iterator15()).done;) {
                      var buffer = _step15.value;
                      if (buffer.stageFlags !== visibility) {
                        continue;
                      }
                      shaderInfo.buffers.push(new UniformStorageBuffer(set, binding, buffer.name, 1, buffer.memoryAccess));
                      ++binding;
                    }
                    break;
                  case 6:
                    break;
                  case 7:
                    for (var _iterator16 = _createForOfIteratorHelperLoose(descriptorInfo.images), _step16; !(_step16 = _iterator16()).done;) {
                      var image = _step16.value;
                      if (image.stageFlags !== visibility) {
                        continue;
                      }
                      shaderInfo.images.push(new UniformStorageImage(set, binding, image.name, image.type, image.count, image.memoryAccess));
                      ++binding;
                    }
                    break;
                  case 8:
                    for (var _iterator17 = _createForOfIteratorHelperLoose(descriptorInfo.subpassInputs), _step17; !(_step17 = _iterator17()).done;) {
                      var subpassInput = _step17.value;
                      if (subpassInput.stageFlags !== visibility) {
                        continue;
                      }
                      shaderInfo.subpassInputs.push(new UniformInputAttachment(set, subpassInput.binding, subpassInput.name, subpassInput.count));
                      ++binding;
                    }
                    break;
                }
              }
            }
            function populateMergedShaderInfo(valueNames, layout, set, shaderInfo, blockSizes) {
              for (var _iterator18 = _createForOfIteratorHelperLoose(layout.descriptorBlocks), _step18; !(_step18 = _iterator18()).done;) {
                var descriptorBlock = _step18.value;
                var binding = descriptorBlock.offset;
                switch (descriptorBlock.type) {
                  case 0:
                    for (var _iterator19 = _createForOfIteratorHelperLoose(descriptorBlock.descriptors), _step19; !(_step19 = _iterator19()).done;) {
                      var block = _step19.value;
                      var uniformBlock = layout.uniformBlocks.get(block.descriptorID);
                      if (uniformBlock === undefined) {
                        error("Failed to find uniform block " + block.descriptorID + " in layout");
                        continue;
                      }
                      blockSizes.push(getSize(uniformBlock.members));
                      shaderInfo.blocks.push(new UniformBlock(set, binding, valueNames[block.descriptorID], uniformBlock.members.map(function (m) {
                        return new Uniform(m.name, m.type, m.count);
                      }), 1));
                      ++binding;
                    }
                    if (binding !== descriptorBlock.offset + descriptorBlock.capacity) {
                      error("Uniform buffer binding mismatch for set " + set);
                    }
                    break;
                  case 1:
                    break;
                  case 2:
                    for (var _iterator20 = _createForOfIteratorHelperLoose(descriptorBlock.descriptors), _step20; !(_step20 = _iterator20()).done;) {
                      var tex = _step20.value;
                      shaderInfo.samplerTextures.push(new UniformSamplerTexture(set, binding, valueNames[tex.descriptorID], tex.type, tex.count));
                      ++binding;
                    }
                    break;
                  case 3:
                    for (var _iterator21 = _createForOfIteratorHelperLoose(descriptorBlock.descriptors), _step21; !(_step21 = _iterator21()).done;) {
                      var sampler = _step21.value;
                      shaderInfo.samplers.push(new UniformSampler(set, binding, valueNames[sampler.descriptorID], sampler.count));
                      ++binding;
                    }
                    break;
                  case 4:
                    for (var _iterator22 = _createForOfIteratorHelperLoose(descriptorBlock.descriptors), _step22; !(_step22 = _iterator22()).done;) {
                      var texture = _step22.value;
                      shaderInfo.textures.push(new UniformTexture(set, binding, valueNames[texture.descriptorID], texture.type, texture.count));
                      ++binding;
                    }
                    break;
                  case 5:
                    for (var _iterator23 = _createForOfIteratorHelperLoose(descriptorBlock.descriptors), _step23; !(_step23 = _iterator23()).done;) {
                      var buffer = _step23.value;
                      shaderInfo.buffers.push(new UniformStorageBuffer(set, binding, valueNames[buffer.descriptorID], 1, 3));
                      ++binding;
                    }
                    break;
                  case 6:
                    break;
                  case 7:
                    for (var _iterator24 = _createForOfIteratorHelperLoose(descriptorBlock.descriptors), _step24; !(_step24 = _iterator24()).done;) {
                      var image = _step24.value;
                      shaderInfo.images.push(new UniformStorageImage(set, binding, valueNames[image.descriptorID], image.type, image.count, 3));
                      ++binding;
                    }
                    break;
                  case 8:
                    for (var _iterator25 = _createForOfIteratorHelperLoose(descriptorBlock.descriptors), _step25; !(_step25 = _iterator25()).done;) {
                      var subpassInput = _step25.value;
                      shaderInfo.subpassInputs.push(new UniformInputAttachment(set, binding, valueNames[subpassInput.descriptorID], subpassInput.count));
                      ++binding;
                    }
                    break;
                }
              }
            }
            function populateLocalShaderInfo(target, source, shaderInfo, blockSizes) {
              var set = _setIndex[0];
              var _loop = function _loop() {
                var block = target.blocks[i];
                var info = source.layouts[block.name];
                var binding = info && source.bindings.find(function (bd) {
                  return bd.binding === info.binding;
                });
                if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_BUFFER_TYPE)) {
                  console.warn("builtin UBO '" + block.name + "' not available!");
                  return 1;
                }
                blockSizes.push(getSize(block.members));
                shaderInfo.blocks.push(new UniformBlock(set, binding.binding, block.name, block.members.map(function (m) {
                  return new Uniform(m.name, m.type, m.count);
                }), 1));
              };
              for (var i = 0; i < target.blocks.length; i++) {
                if (_loop()) continue;
              }
              var _loop2 = function _loop2() {
                var samplerTexture = target.samplerTextures[_i7];
                var info = source.layouts[samplerTexture.name];
                var binding = info && source.bindings.find(function (bd) {
                  return bd.binding === info.binding;
                });
                if (!info || !binding || !(binding.descriptorType & DESCRIPTOR_SAMPLER_TYPE)) {
                  console.warn("builtin samplerTexture '" + samplerTexture.name + "' not available!");
                  return 1;
                }
                shaderInfo.samplerTextures.push(new UniformSamplerTexture(set, binding.binding, samplerTexture.name, samplerTexture.type, samplerTexture.count));
              };
              for (var _i7 = 0; _i7 < target.samplerTextures.length; _i7++) {
                if (_loop2()) continue;
              }
            }
            function getIDescriptorSetLayoutInfoUniformBlockCapacity(info) {
              var capacity = 0;
              for (var _iterator26 = _createForOfIteratorHelperLoose(info.bindings), _step26; !(_step26 = _iterator26()).done;) {
                var binding = _step26.value;
                if (binding.descriptorType === 1 || binding.descriptorType === 2) {
                  capacity += binding.count;
                }
              }
              return capacity;
            }
            function getIDescriptorSetLayoutInfoSamplerTextureCapacity(info) {
              var capacity = 0;
              for (var _iterator27 = _createForOfIteratorHelperLoose(info.bindings), _step27; !(_step27 = _iterator27()).done;) {
                var binding = _step27.value;
                if (binding.descriptorType !== 1 && binding.descriptorType !== 2) {
                  capacity += binding.count;
                }
              }
              return capacity;
            }
            function setFlattenedUniformBlockBinding(setOffsets, descriptors) {
              for (var _iterator28 = _createForOfIteratorHelperLoose(descriptors), _step28; !(_step28 = _iterator28()).done;) {
                var d = _step28.value;
                d.flattened = setOffsets[d.set] + d.binding;
              }
            }
            function setFlattenedSamplerTextureBinding(setOffsets, uniformBlockCapacities, descriptors) {
              for (var _iterator29 = _createForOfIteratorHelperLoose(descriptors), _step29; !(_step29 = _iterator29()).done;) {
                var d = _step29.value;
                d.flattened = setOffsets[d.set] + d.binding - uniformBlockCapacities[d.set];
              }
            }
            function calculateFlattenedBinding(descriptorSets, fixedInstanceDescriptorSetLayout, shaderInfo) {
              var uniformBlockCapacities = new Array(4);
              {
                var _descriptorSets$, _descriptorSets$2, _descriptorSets$3, _descriptorSets$4;
                var passCapacity = ((_descriptorSets$ = descriptorSets[3]) == null ? undefined : _descriptorSets$.uniformBlockCapacity) || 0;
                var phaseCapacity = ((_descriptorSets$2 = descriptorSets[2]) == null ? undefined : _descriptorSets$2.uniformBlockCapacity) || 0;
                var batchCapacity = ((_descriptorSets$3 = descriptorSets[1]) == null ? undefined : _descriptorSets$3.uniformBlockCapacity) || 0;
                var instanceCapacity = fixedInstanceDescriptorSetLayout ? getIDescriptorSetLayoutInfoUniformBlockCapacity(fixedInstanceDescriptorSetLayout) : ((_descriptorSets$4 = descriptorSets[0]) == null ? undefined : _descriptorSets$4.uniformBlockCapacity) || 0;
                uniformBlockCapacities[_setIndex[3]] = passCapacity;
                uniformBlockCapacities[_setIndex[2]] = phaseCapacity;
                uniformBlockCapacities[_setIndex[1]] = batchCapacity;
                uniformBlockCapacities[_setIndex[0]] = instanceCapacity;
                var passOffset = 0;
                var phaseOffset = passOffset + passCapacity;
                var instanceOffset = phaseOffset + phaseCapacity;
                var batchOffset = instanceOffset + instanceCapacity;
                var uniformBlockOffsets = new Array(4);
                uniformBlockOffsets[_setIndex[3]] = passOffset;
                uniformBlockOffsets[_setIndex[2]] = phaseOffset;
                uniformBlockOffsets[_setIndex[1]] = batchOffset;
                uniformBlockOffsets[_setIndex[0]] = instanceOffset;
                setFlattenedUniformBlockBinding(uniformBlockOffsets, shaderInfo.blocks);
              }
              {
                var _descriptorSets$5, _descriptorSets$6, _descriptorSets$7;
                var _passCapacity = ((_descriptorSets$5 = descriptorSets[3]) == null ? undefined : _descriptorSets$5.samplerTextureCapacity) || 0;
                var _phaseCapacity = ((_descriptorSets$6 = descriptorSets[2]) == null ? undefined : _descriptorSets$6.samplerTextureCapacity) || 0;
                var _instanceCapacity = fixedInstanceDescriptorSetLayout ? getIDescriptorSetLayoutInfoSamplerTextureCapacity(fixedInstanceDescriptorSetLayout) : ((_descriptorSets$7 = descriptorSets[0]) == null ? undefined : _descriptorSets$7.samplerTextureCapacity) || 0;
                var _passOffset = 0;
                var _phaseOffset = _passOffset + _passCapacity;
                var _instanceOffset = _phaseOffset + _phaseCapacity;
                var _batchOffset = _instanceOffset + _instanceCapacity;
                var samplerTextureOffsets = new Array(4);
                samplerTextureOffsets[_setIndex[3]] = _passOffset;
                samplerTextureOffsets[_setIndex[2]] = _phaseOffset;
                samplerTextureOffsets[_setIndex[1]] = _batchOffset;
                samplerTextureOffsets[_setIndex[0]] = _instanceOffset;
                setFlattenedSamplerTextureBinding(samplerTextureOffsets, uniformBlockCapacities, shaderInfo.samplerTextures);
              }
            }
            function makeShaderInfo(lg, passLayouts, phaseLayouts, srcShaderInfo, programData, fixedLocal) {
              var descriptorSets = [null, null, null, null];
              var fixedInstanceDescriptorSetLayout = null;
              var shaderInfo = new ShaderInfo();
              var blockSizes = [];
              {
                var passLayout = passLayouts.getSet(3);
                if (passLayout) {
                  descriptorSets[3] = passLayout.descriptorSetLayoutData;
                  populateMergedShaderInfo(lg.valueNames, passLayout.descriptorSetLayoutData, _setIndex[3], shaderInfo, blockSizes);
                }
              }
              {
                var phaseLayout = phaseLayouts.getSet(2);
                if (phaseLayout) {
                  descriptorSets[2] = phaseLayout.descriptorSetLayoutData;
                  populateMergedShaderInfo(lg.valueNames, phaseLayout.descriptorSetLayoutData, _setIndex[2], shaderInfo, blockSizes);
                }
              }
              {
                var batchInfo = srcShaderInfo.descriptors[1];
                if (programData) {
                  var perBatch = programData.layout.getSet(1);
                  if (perBatch) {
                    descriptorSets[1] = perBatch.descriptorSetLayoutData;
                    populateMergedShaderInfo(lg.valueNames, perBatch.descriptorSetLayoutData, _setIndex[1], shaderInfo, blockSizes);
                  }
                } else {
                  var batchLayout = phaseLayouts.getSet(1);
                  if (batchLayout) {
                    descriptorSets[1] = batchLayout.descriptorSetLayoutData;
                    populateGroupedShaderInfo(batchLayout.descriptorSetLayoutData, batchInfo, _setIndex[1], shaderInfo, blockSizes);
                  }
                }
              }
              {
                var instanceInfo = srcShaderInfo.descriptors[0];
                if (programData) {
                  if (fixedLocal) {
                    fixedInstanceDescriptorSetLayout = localDescriptorSetLayout;
                    populateLocalShaderInfo(instanceInfo, localDescriptorSetLayout, shaderInfo, blockSizes);
                  } else {
                    var perInstance = programData.layout.getSet(0);
                    if (perInstance) {
                      descriptorSets[0] = perInstance.descriptorSetLayoutData;
                      populateMergedShaderInfo(lg.valueNames, perInstance.descriptorSetLayoutData, _setIndex[0], shaderInfo, blockSizes);
                    }
                  }
                } else {
                  var instanceLayout = phaseLayouts.getSet(0);
                  if (instanceLayout) {
                    descriptorSets[0] = instanceLayout.descriptorSetLayoutData;
                    populateGroupedShaderInfo(instanceLayout.descriptorSetLayoutData, instanceInfo, _setIndex[0], shaderInfo, blockSizes);
                  }
                }
              }
              calculateFlattenedBinding(descriptorSets, fixedInstanceDescriptorSetLayout, shaderInfo);
              shaderInfo.stages.push(new ShaderStage(1, ''));
              shaderInfo.stages.push(new ShaderStage(16, ''));
              return [shaderInfo, blockSizes];
            }
            var WebProgramProxy = function () {
              function WebProgramProxy(shader, pipelineStateIn) {
                if (pipelineStateIn === undefined) {
                  pipelineStateIn = null;
                }
                this.shader = undefined;
                this.pipelineState = null;
                this.shader = shader;
                this.pipelineState = pipelineStateIn;
              }
              _createClass(WebProgramProxy, [{
                key: "name",
                get: function get() {
                  return this.shader.name;
                }
              }]);
              return WebProgramProxy;
            }();
            function getDescriptorNameAndType(source, binding) {
              for (var name in source.layouts) {
                var v = source.layouts[name];
                if (v.binding === binding) {
                  assert(v.name === name);
                  var type = 0;
                  if (v instanceof UniformSamplerTexture) {
                    type = v.type;
                  } else if (v instanceof UniformStorageImage) {
                    type = v.type;
                  }
                  return [v.name, type];
                }
              }
              error('descriptor not found');
              return ['', 0];
            }
            function makeLocalDescriptorSetLayoutData(lg, source) {
              var data = new DescriptorSetLayoutData();
              for (var _iterator30 = _createForOfIteratorHelperLoose(source.bindings), _step30; !(_step30 = _iterator30()).done;) {
                var b = _step30.value;
                var _getDescriptorNameAnd = getDescriptorNameAndType(source, b.binding),
                  name = _getDescriptorNameAnd[0],
                  type = _getDescriptorNameAnd[1];
                var nameID = getOrCreateDescriptorID(lg, name);
                var order = getDescriptorTypeOrder(b.descriptorType);
                var block = new DescriptorBlockData(order, b.stageFlags, b.count, b.access, b.viewDimension, b.sampleType, b.format);
                block.offset = b.binding;
                block.descriptors.push(new DescriptorData(nameID, type, b.count));
                data.descriptorBlocks.push(block);
                var binding = data.bindingMap.get(nameID);
                if (binding !== undefined) {
                  error("duplicate descriptor name '" + name + "'");
                }
                data.bindingMap.set(nameID, b.binding);
                var v = source.layouts[name];
                if (v instanceof UniformBlock) {
                  data.uniformBlocks.set(nameID, v);
                }
              }
              return data;
            }
            function buildProgramData(programName, srcShaderInfo, lg, phase, programData, fixedLocal) {
              var programSets = programData.layout.getSets();
              {
                var perBatch = makeDescriptorSetLayoutData(lg, 1, _setIndex[1], srcShaderInfo.descriptors[1]);
                var setData = new DescriptorSetData(perBatch);
                initializeDescriptorSetLayoutInfo(setData.descriptorSetLayoutData, setData.descriptorSetLayoutInfo);
                programSets.set(1, setData);
              }
              if (fixedLocal) {
                var perInstance = makeLocalDescriptorSetLayoutData(lg, localDescriptorSetLayout);
                var _setData = new DescriptorSetData(perInstance);
                initializeDescriptorSetLayoutInfo(_setData.descriptorSetLayoutData, _setData.descriptorSetLayoutInfo);
                if (localDescriptorSetLayout.bindings.length !== _setData.descriptorSetLayoutInfo.bindings.length) {
                  error('local descriptor set layout inconsistent');
                } else {
                  for (var k = 0; k !== localDescriptorSetLayout.bindings.length; ++k) {
                    var b = localDescriptorSetLayout.bindings[k];
                    var b2 = _setData.descriptorSetLayoutInfo.bindings[k];
                    if (b.binding !== b2.binding || b.descriptorType !== b2.descriptorType || b.count !== b2.count || b.stageFlags !== b2.stageFlags) {
                      error('local descriptor set layout inconsistent');
                    }
                  }
                }
                programSets.set(0, _setData);
              } else {
                var _perInstance = makeDescriptorSetLayoutData(lg, 0, _setIndex[0], srcShaderInfo.descriptors[0]);
                var _setData2 = new DescriptorSetData(_perInstance);
                initializeDescriptorSetLayoutInfo(_setData2.descriptorSetLayoutData, _setData2.descriptorSetLayoutInfo);
                programSets.set(0, _setData2);
              }
              var shaderID = phase.shaderPrograms.length;
              phase.shaderIndex.set(programName, shaderID);
              phase.shaderPrograms.push(programData);
            }
            function getOrCreateProgramDescriptorSetLayout(device, lg, phaseID, programName, rate) {
              assert(rate < 2);
              var phase = lg.j(phaseID);
              var programID = phase.shaderIndex.get(programName);
              if (programID === undefined) {
                return getEmptyDescriptorSetLayout();
              }
              var programData = phase.shaderPrograms[programID];
              var layout = programData.layout.getSet(rate);
              if (layout === undefined) {
                return getEmptyDescriptorSetLayout();
              }
              if (layout.descriptorSetLayout) {
                return layout.descriptorSetLayout;
              }
              layout.descriptorSetLayout = device.createDescriptorSetLayout(layout.descriptorSetLayoutInfo);
              return layout.descriptorSetLayout;
            }
            function getProgramDescriptorSetLayout(device, lg, phaseID, programName, rate) {
              assert(rate < 2);
              var phase = lg.j(phaseID);
              var programID = phase.shaderIndex.get(programName);
              if (programID === undefined) {
                return null;
              }
              var programData = phase.shaderPrograms[programID];
              var layout = programData.layout.getSet(rate);
              if (layout === undefined) {
                return null;
              }
              if (layout.descriptorSetLayout) {
                return layout.descriptorSetLayout;
              }
              layout.descriptorSetLayout = device.createDescriptorSetLayout(layout.descriptorSetLayoutInfo);
              return layout.descriptorSetLayout;
            }
            function getEffectShader(lg, effect, pass) {
              var programName = pass.program;
              var passID = getCustomPassID(lg, pass.pass);
              if (passID === INVALID_ID$1) {
                error("Invalid render pass, program: " + programName);
                return [INVALID_ID$1, INVALID_ID$1, INVALID_ID$1, null, INVALID_ID$1];
              }
              var enableSubpass = pass.subpass && pass.subpass !== '' && ENABLE_SUBPASS;
              var subpassID = enableSubpass ? getCustomSubpassID(lg, passID, pass.subpass) : INVALID_ID$1;
              if (enableSubpass && subpassID === INVALID_ID$1) {
                error("Invalid render subpass, program: " + programName);
                return [INVALID_ID$1, INVALID_ID$1, INVALID_ID$1, null, INVALID_ID$1];
              }
              var phaseID = getCustomPhaseID(lg, subpassID === INVALID_ID$1 ? passID : subpassID, pass.phase);
              if (phaseID === INVALID_ID$1) {
                error("Invalid render phase, program: " + programName);
                return [INVALID_ID$1, INVALID_ID$1, INVALID_ID$1, null, INVALID_ID$1];
              }
              var srcShaderInfo = null;
              var shaderID = INVALID_ID$1;
              for (var i = 0; i < effect.shaders.length; ++i) {
                var shaderInfo = effect.shaders[i];
                if (shaderInfo.name === programName) {
                  srcShaderInfo = shaderInfo;
                  shaderID = i;
                  break;
                }
              }
              return [passID, subpassID, phaseID, srcShaderInfo, shaderID];
            }
            function validateShaderInfo(srcShaderInfo) {
              if (srcShaderInfo.descriptors === undefined) {
                error("No descriptors in shader: " + srcShaderInfo.name + ", please reimport ALL effects");
                return 1;
              }
              return 0;
            }
            var WebProgramLibrary = function () {
              function WebProgramLibrary(lg) {
                this.layoutGraph = undefined;
                this.phases = new Map();
                this.mergeHighFrequency = false;
                this.fixedLocal = true;
                this.localLayoutData = new DescriptorSetLayoutData();
                this.localDescriptorSetLayout = null;
                this.pipeline = null;
                this.device = null;
                this.layoutGraph = lg;
                for (var _iterator31 = _createForOfIteratorHelperLoose(lg.v()), _step31; !(_step31 = _iterator31()).done;) {
                  var v = _step31.value;
                  if (lg.h(1, v)) {
                    this.phases.set(v, new ProgramGroup());
                  }
                }
              }
              var _proto = WebProgramLibrary.prototype;
              _proto.init = function init(deviceIn) {
                if (this.device === deviceIn) {
                  return;
                }
                this.device = deviceIn;
                var maxJoints = Math.floor((this.device.capabilities.maxVertexUniformVectors - 38) / 3);
                maxJoints = maxJoints < 256 ? maxJoints : 256;
                UBOSkinning.initLayout(maxJoints);
                var lg = this.layoutGraph;
                for (var _iterator32 = _createForOfIteratorHelperLoose(lg.v()), _step32; !(_step32 = _iterator32()).done;) {
                  var v = _step32.value;
                  var layout = lg.getLayout(v);
                  var sets = layout.getSets();
                  for (var _iterator36 = _createForOfIteratorHelperLoose(sets), _step36; !(_step36 = _iterator36()).done;) {
                    var _step36$value = _step36.value;
                      _step36$value[0];
                      var set = _step36$value[1];
                    initializeDescriptorSetLayoutInfo(set.descriptorSetLayoutData, set.descriptorSetLayoutInfo);
                    set.descriptorSetLayout = this.device.createDescriptorSetLayout(set.descriptorSetLayoutInfo);
                    assert(!!set.descriptorSetLayout);
                    set.descriptorSet = this.device.createDescriptorSet(new DescriptorSetInfo(set.descriptorSetLayout));
                    assert(!!set.descriptorSet);
                  }
                }
                for (var _iterator33 = _createForOfIteratorHelperLoose(lg.v()), _step33; !(_step33 = _iterator33()).done;) {
                  var _v7 = _step33.value;
                  if (!lg.h(1, _v7)) {
                    continue;
                  }
                  var phaseID = _v7;
                  var subpassOrPassID = lg.getParent(phaseID);
                  var passLayout = lg.getLayout(subpassOrPassID);
                  var phaseLayout = lg.getLayout(phaseID);
                  var _info = new PipelineLayoutInfo();
                  populatePipelineLayoutInfo(passLayout, 3, _info);
                  populatePipelineLayoutInfo(phaseLayout, 2, _info);
                  populatePipelineLayoutInfo(phaseLayout, 1, _info);
                  populatePipelineLayoutInfo(phaseLayout, 0, _info);
                  var phase = lg.j(phaseID);
                  phase.pipelineLayout = this.device.createPipelineLayout(_info);
                }
                {
                  var localSetLayout = localDescriptorSetLayout;
                  this.localLayoutData = makeLocalDescriptorSetLayoutData(lg, localSetLayout);
                  var info = new DescriptorSetLayoutInfo();
                  initializeDescriptorSetLayoutInfo(this.localLayoutData, info);
                  this.localDescriptorSetLayout = this.device.createDescriptorSetLayout(info);
                  assert(!!this.localDescriptorSetLayout);
                  var numUniformBuffers = 0;
                  for (var _iterator34 = _createForOfIteratorHelperLoose(this.localLayoutData.descriptorBlocks), _step34; !(_step34 = _iterator34()).done;) {
                    var block = _step34.value;
                    if (block.type !== 0 && block.type !== 1) {
                      continue;
                    }
                    for (var _iterator35 = _createForOfIteratorHelperLoose(block.descriptors), _step35; !(_step35 = _iterator35()).done;) {
                      var d = _step35.value;
                      numUniformBuffers += d.count;
                    }
                  }
                  assert(numUniformBuffers === 7);
                }
                generateConstantMacros(this.device, this.layoutGraph.constantMacros);
              };
              _proto.addEffect = function addEffect(effect) {
                var _this = this;
                var lg = this.layoutGraph;
                for (var _iterator37 = _createForOfIteratorHelperLoose(effect.techniques), _step37; !(_step37 = _iterator37()).done;) {
                  var tech = _step37.value;
                  var _loop3 = function _loop3() {
                    var pass = _step38.value;
                    var programName = pass.program;
                    var _getEffectShader = getEffectShader(lg, effect, pass),
                      passID = _getEffectShader[0],
                      subpassID = _getEffectShader[1],
                      phaseID = _getEffectShader[2],
                      srcShaderInfo = _getEffectShader[3];
                    if (srcShaderInfo === null || validateShaderInfo(srcShaderInfo)) {
                      error("program: " + programName + " not found");
                      return 1;
                    }
                    assert(passID !== INVALID_ID$1 && phaseID !== INVALID_ID$1);
                    var subpassOrPassID = subpassID === INVALID_ID$1 ? passID : subpassID;
                    var passLayout = lg.getLayout(subpassOrPassID);
                    var phaseLayout = lg.getLayout(phaseID);
                    var group = _this.phases.get(phaseID);
                    if (group === undefined) {
                      group = new ProgramGroup();
                      _this.phases.set(phaseID, group);
                    }
                    var phasePrograms = group.programInfos;
                    var programInfo = makeProgramInfo(effect.name, srcShaderInfo);
                    var programData = null;
                    if (!_this.mergeHighFrequency) {
                      var phase = lg.j(phaseID);
                      programData = new ShaderProgramData();
                      buildProgramData(programName, srcShaderInfo, lg, phase, programData, _this.fixedLocal);
                    }
                    var _makeShaderInfo = makeShaderInfo(lg, passLayout, phaseLayout, srcShaderInfo, programData, _this.fixedLocal),
                      shaderInfo = _makeShaderInfo[0],
                      blockSizes = _makeShaderInfo[1];
                    overwriteProgramBlockInfo(shaderInfo, programInfo);
                    var handleMap = genHandles(shaderInfo);
                    var attributes = [];
                    programInfo.attributes.forEach(function (attr) {
                      attributes.push(new Attribute(attr.name, attr.format, attr.isNormalized, 0, attr.isInstanced, attr.location));
                    });
                    var info = new ProgramInfo(programInfo, shaderInfo, attributes, blockSizes, handleMap);
                    phasePrograms.set(srcShaderInfo.name, info);
                  };
                  for (var _iterator38 = _createForOfIteratorHelperLoose(tech.passes), _step38; !(_step38 = _iterator38()).done;) {
                    if (_loop3()) continue;
                  }
                }
              };
              _proto.precompileEffect = function precompileEffect(device, effect) {
                var _this2 = this;
                var lg = this.layoutGraph;
                for (var _iterator39 = _createForOfIteratorHelperLoose(effect.techniques), _step39; !(_step39 = _iterator39()).done;) {
                  var tech = _step39.value;
                  var _loop4 = function _loop4() {
                      var pass = _step40.value;
                      var programName = pass.program;
                      var _getEffectShader2 = getEffectShader(lg, effect, pass),
                        passID = _getEffectShader2[0];
                        _getEffectShader2[1];
                        var phaseID = _getEffectShader2[2],
                        srcShaderInfo = _getEffectShader2[3],
                        shaderID = _getEffectShader2[4];
                      if (srcShaderInfo === null || validateShaderInfo(srcShaderInfo)) {
                        error("program: " + programName + " not valid");
                        return 0;
                      }
                      assert(passID !== INVALID_ID$1 && phaseID !== INVALID_ID$1 && shaderID !== INVALID_ID$1);
                      var combination = effect.combinations[shaderID];
                      if (!combination) {
                        return 0;
                      }
                      var defines = getCombinationDefines(combination);
                      defines.forEach(function (defines) {
                        return _this2.getProgramVariant(device, phaseID, programName, defines);
                      });
                    },
                    _ret;
                  for (var _iterator40 = _createForOfIteratorHelperLoose(tech.passes), _step40; !(_step40 = _iterator40()).done;) {
                    _ret = _loop4();
                    if (_ret === 0) continue;
                  }
                }
              };
              _proto.getProgramInfo = function getProgramInfo(phaseID, programName) {
                assert(phaseID !== INVALID_ID$1);
                var group = this.phases.get(phaseID);
                var info = group.programInfos.get(programName);
                return info.programInfo;
              };
              _proto.getShaderInfo = function getShaderInfo(phaseID, programName) {
                assert(phaseID !== INVALID_ID$1);
                var group = this.phases.get(phaseID);
                var info = group.programInfos.get(programName);
                return info.shaderInfo;
              };
              _proto.getKey = function getKey(phaseID, programName, defines) {
                assert(phaseID !== INVALID_ID$1);
                var group = this.phases.get(phaseID);
                if (group === undefined) {
                  error("Invalid render phase, program: " + programName);
                  return '';
                }
                var info = group.programInfos.get(programName);
                if (info === undefined) {
                  error("Invalid program, program: " + programName);
                  return '';
                }
                return getVariantKey(info.programInfo, defines);
              };
              _proto.getProgramVariant = function getProgramVariant(device, phaseID, name, defines, key) {
                var _this$pipeline;
                if (key === undefined) {
                  key = null;
                }
                Object.assign(defines, (_this$pipeline = this.pipeline) == null ? undefined : _this$pipeline.macros);
                assert(phaseID !== INVALID_ID$1);
                var group = this.phases.get(phaseID);
                if (group === undefined) {
                  error("Invalid render phase, program: " + name);
                  return null;
                }
                var info = group.programInfos.get(name);
                if (info === undefined) {
                  error("Invalid program, program: " + name);
                  return null;
                }
                var programInfo = info.programInfo;
                if (key === null) {
                  key = getVariantKey(programInfo, defines);
                }
                var programHosts = group.programProxies;
                var programHost = programHosts.get(key);
                if (programHost !== undefined) {
                  return programHost;
                }
                var macroArray = prepareDefines(defines, programInfo.defines);
                var prefix = this.layoutGraph.constantMacros + programInfo.constantMacros + macroArray.reduce(function (acc, cur) {
                  return acc + "#define " + cur.name + " " + cur.value + "\n";
                }, '');
                var src = programInfo.glsl3;
                var deviceShaderVersion = getDeviceShaderVersion(device);
                if (deviceShaderVersion) {
                  src = programInfo[deviceShaderVersion];
                } else {
                  errorID(16346);
                }
                var shaderInfo = info.shaderInfo;
                if (src.compute) {
                  shaderInfo.stages[0].source = prefix + src.compute;
                  shaderInfo.stages[0].stage = 32;
                  shaderInfo.stages.length = 1;
                } else {
                  shaderInfo.stages[0].source = prefix + src.vert;
                  shaderInfo.stages[1].source = prefix + src.frag;
                }
                shaderInfo.attributes = getActiveAttributes(programInfo, info.attributes, defines);
                shaderInfo.name = getShaderInstanceName(name, macroArray);
                var shader = device.createShader(shaderInfo);
                var host = new WebProgramProxy(shader);
                programHosts.set(key, host);
                return host;
              };
              _proto.getMaterialDescriptorSetLayout = function getMaterialDescriptorSetLayout(device, phaseID, programName) {
                if (this.mergeHighFrequency) {
                  assert(phaseID !== INVALID_ID$1);
                  var subpassOrPassID = this.layoutGraph.getParent(phaseID);
                  return getOrCreateDescriptorSetLayout(this.layoutGraph, subpassOrPassID, phaseID, 1);
                }
                return getOrCreateProgramDescriptorSetLayout(device, this.layoutGraph, phaseID, programName, 1);
              };
              _proto.getLocalDescriptorSetLayout = function getLocalDescriptorSetLayout(device, phaseID, programName) {
                if (this.mergeHighFrequency) {
                  assert(phaseID !== INVALID_ID$1);
                  var subpassOrPassID = this.layoutGraph.getParent(phaseID);
                  return getOrCreateDescriptorSetLayout(this.layoutGraph, subpassOrPassID, phaseID, 0);
                }
                return getOrCreateProgramDescriptorSetLayout(device, this.layoutGraph, phaseID, programName, 0);
              };
              _proto.getBlockSizes = function getBlockSizes(phaseID, programName) {
                assert(phaseID !== INVALID_ID$1);
                var group = this.phases.get(phaseID);
                if (!group) {
                  error("Invalid render phase, program: " + programName);
                  return [];
                }
                var info = group.programInfos.get(programName);
                if (!info) {
                  error("Invalid program, program: " + programName);
                  return [];
                }
                return info.blockSizes;
              };
              _proto.getHandleMap = function getHandleMap(phaseID, programName) {
                assert(phaseID !== INVALID_ID$1);
                var group = this.phases.get(phaseID);
                if (!group) {
                  error("Invalid render phase, program: " + programName);
                  return {};
                }
                var info = group.programInfos.get(programName);
                if (!info) {
                  error("Invalid program, program: " + programName);
                  return {};
                }
                return info.handleMap;
              };
              _proto.getPipelineLayout = function getPipelineLayout(device, phaseID, programName) {
                if (this.mergeHighFrequency) {
                  assert(phaseID !== INVALID_ID$1);
                  var layout = this.layoutGraph.j(phaseID);
                  return layout.pipelineLayout;
                }
                var lg = this.layoutGraph;
                var phase = lg.j(phaseID);
                var programID = phase.shaderIndex.get(programName);
                if (programID === undefined) {
                  return getEmptyPipelineLayout();
                }
                var programData = phase.shaderPrograms[programID];
                if (programData.pipelineLayout) {
                  return programData.pipelineLayout;
                }
                var subpassOrPassID = lg.getParent(phaseID);
                if (subpassOrPassID === INVALID_ID$1) {
                  return getEmptyPipelineLayout();
                }
                var info = new PipelineLayoutInfo();
                var passSet = getDescriptorSetLayout(this.layoutGraph, subpassOrPassID, phaseID, 3);
                if (passSet) {
                  info.setLayouts.push(passSet);
                }
                var phaseSet = getDescriptorSetLayout(this.layoutGraph, subpassOrPassID, phaseID, 2);
                if (phaseSet) {
                  info.setLayouts.push(phaseSet);
                }
                var batchSet = getProgramDescriptorSetLayout(device, lg, phaseID, programName, 1);
                if (batchSet) {
                  info.setLayouts.push(batchSet);
                }
                var instanceSet = getProgramDescriptorSetLayout(device, lg, phaseID, programName, 0);
                if (instanceSet) {
                  info.setLayouts.push(instanceSet);
                }
                programData.pipelineLayout = device.createPipelineLayout(info);
                return programData.pipelineLayout;
              };
              _proto.getProgramID = function getProgramID$1(phaseID, programName) {
                return getProgramID(this.layoutGraph, phaseID, programName);
              };
              _proto.getDescriptorNameID = function getDescriptorNameID$1(name) {
                return getDescriptorNameID(this.layoutGraph, name);
              };
              _proto.getDescriptorName = function getDescriptorName$1(nameID) {
                return getDescriptorName(this.layoutGraph, nameID);
              };
              return WebProgramLibrary;
            }();

            var editorPipelineSettings = null;
            var forceResize = false;
            function setEditorPipelineSettings(settings) {
              editorPipelineSettings = settings;
              forceResize = true;
            }
            function getEditorPipelineSettings() {
              return editorPipelineSettings;
            }
            function forceResizeAllWindows() {
              forceResize = true;
            }
            function defaultWindowResize(ppl, window, width, height) {
              ppl.addRenderWindow(window.colorName, 36, width, height, window);
              ppl.addDepthStencil(window.depthStencilName, 55, width, height);
              var id = window.renderWindowId;
              var shadowFormat = supportsR32FloatTexture(ppl.device) ? 11 : 35;
              var shadowSize = ppl.pipelineSceneData.shadows.size;
              ppl.addRenderTarget("ShadowMap" + id, shadowFormat, shadowSize.x, shadowSize.y);
              ppl.addDepthStencil("ShadowDepth" + id, 55, shadowSize.x, shadowSize.y);
            }
            var _resizedWindows = [];
            function dispatchResizeEvents(cameras, builder, ppl) {
              if (!builder.windowResize) {
                return;
              }
              for (var _iterator = _createForOfIteratorHelperLoose(cameras), _step; !(_step = _iterator()).done;) {
                var camera = _step.value;
                if (!camera.window.isRenderWindowResized() && !forceResize) {
                  continue;
                }
                var width = Math.max(Math.floor(camera.window.width), 1);
                var height = Math.max(Math.floor(camera.window.height), 1);
                builder.windowResize(ppl, camera.window, camera, width, height);
                _resizedWindows.push(camera.window);
              }
              for (var _iterator2 = _createForOfIteratorHelperLoose(_resizedWindows), _step2; !(_step2 = _iterator2()).done;) {
                var window = _step2.value;
                window.setRenderWindowResizeHandled();
              }
              _resizedWindows.length = 0;
              forceResize = false;
            }

            var INVALID_ID = 0xFFFFFFFF;
            var defaultLayoutGraph = new LayoutGraphData();
            var LAYOUT_HEADER_SIZE = 8;
            var enableEffectImport = true;
            var programLib = new WebProgramLibrary(defaultLayoutGraph);
            function createCustomPipeline() {
              var layoutGraph = defaultLayoutGraph;
              var ppl = new WebPipeline(layoutGraph);
              var pplName = macro.CUSTOM_PIPELINE_NAME;
              ppl.setCustomPipelineName(pplName);
              programLib.pipeline = ppl;
              return ppl;
            }
            var customPipelineBuilderMap = new Map();
            function setCustomPipeline(name, builder) {
              customPipelineBuilderMap.set(name, builder);
              forceResizeAllWindows();
            }
            function getCustomPipeline(name) {
              var builder = customPipelineBuilderMap.get(name);
              if (!builder) {
                builder = customPipelineBuilderMap.get('Forward');
              }
              return builder;
            }
            function init(device, arrayBuffer) {
              if (arrayBuffer && arrayBuffer.byteLength >= LAYOUT_HEADER_SIZE) {
                var uint8Array = new Uint8Array(arrayBuffer);
                var header = new DataView(uint8Array.buffer, uint8Array.byteOffset, LAYOUT_HEADER_SIZE);
                if (header.getUint32(0) === INVALID_ID) {
                  var inflator = new _p.Inflate(new Uint8Array(uint8Array.buffer, uint8Array.byteOffset + LAYOUT_HEADER_SIZE));
                  var decompressed = inflator.decompress();
                  var readBinaryData = new BinaryInputArchive(decompressed.buffer, decompressed.byteOffset);
                  loadLayoutGraphData(readBinaryData, defaultLayoutGraph);
                } else {
                  var _readBinaryData = new BinaryInputArchive(uint8Array.buffer, uint8Array.byteOffset);
                  loadLayoutGraphData(_readBinaryData, defaultLayoutGraph);
                }
              }
              initializeLayoutGraphData(device, defaultLayoutGraph);
            }
            function destroy() {
              terminateLayoutGraphData(defaultLayoutGraph);
            }
            function getPassID(name) {
              return getCustomPassID(defaultLayoutGraph, name);
            }
            function getSubpassID(passID, name) {
              return getCustomSubpassID(defaultLayoutGraph, passID, name);
            }
            function getPhaseID(passID, name) {
              return getCustomPhaseID(defaultLayoutGraph, passID, name);
            }
            function completePhaseName(name) {
              if (typeof name === 'number') {
                return name.toString();
              } else if (typeof name === 'string') {
                return name;
              } else {
                return 'default';
              }
            }

            var rendering = /*#__PURE__*/Object.freeze({
                __proto__: null,
                AccessType: AccessType,
                AttachmentType: AttachmentType,
                ClearValueType: ClearValueType,
                CopyPair: CopyPair,
                INVALID_ID: INVALID_ID,
                LightInfo: LightInfo,
                LightingMode: LightingMode,
                MovePair: MovePair,
                ParameterType: ParameterType,
                PipelineCapabilities: PipelineCapabilities,
                PipelineStatistics: PipelineStatistics,
                PipelineType: PipelineType,
                QueueHint: QueueHint,
                RenderCommonObjectPool: RenderCommonObjectPool,
                ResolveFlags: ResolveFlags,
                ResolvePair: ResolvePair,
                ResourceDimension: ResourceDimension,
                ResourceFlags: ResourceFlags,
                ResourceResidency: ResourceResidency,
                SceneFlags: SceneFlags,
                SubpassCapabilities: SubpassCapabilities,
                TaskType: TaskType,
                UpdateFrequency: UpdateFrequency,
                UploadPair: UploadPair,
                completePhaseName: completePhaseName,
                createCustomPipeline: createCustomPipeline,
                customPipelineBuilderMap: customPipelineBuilderMap,
                defaultWindowResize: defaultWindowResize,
                destroy: destroy,
                dispatchResizeEvents: dispatchResizeEvents,
                enableEffectImport: enableEffectImport,
                forceResizeAllWindows: forceResizeAllWindows,
                getCustomPipeline: getCustomPipeline,
                getEditorPipelineSettings: getEditorPipelineSettings,
                getPassID: getPassID,
                getPhaseID: getPhaseID,
                getSubpassID: getSubpassID,
                init: init,
                loadCopyPair: loadCopyPair,
                loadLightInfo: loadLightInfo,
                loadMovePair: loadMovePair,
                loadPipelineStatistics: loadPipelineStatistics,
                loadResolvePair: loadResolvePair,
                packRGBE: packRGBE,
                programLib: programLib,
                saveCopyPair: saveCopyPair,
                saveLightInfo: saveLightInfo,
                saveMovePair: saveMovePair,
                savePipelineStatistics: savePipelineStatistics,
                saveResolvePair: saveResolvePair,
                setCustomPipeline: setCustomPipeline,
                setEditorPipelineSettings: setEditorPipelineSettings
            });
            exports("rendering", rendering);

            legacyCC.rendering = rendering;

            var WebGLDescriptorSet = function (_DescriptorSet) {
              _inheritsLoose(WebGLDescriptorSet, _DescriptorSet);
              function WebGLDescriptorSet() {
                var _this;
                _this = _DescriptorSet.call(this) || this;
                _this._gpuDescriptorSet = null;
                return _this;
              }
              var _proto = WebGLDescriptorSet.prototype;
              _proto.initialize = function initialize(info) {
                this._layout = info.layout;
                var _gpuDescriptorSetLayo = info.layout.gpuDescriptorSetLayout,
                  bindings = _gpuDescriptorSetLayo.bindings,
                  descriptorIndices = _gpuDescriptorSetLayo.descriptorIndices,
                  descriptorCount = _gpuDescriptorSetLayo.descriptorCount;
                this._buffers = Array(descriptorCount).fill(null);
                this._textures = Array(descriptorCount).fill(null);
                this._samplers = Array(descriptorCount).fill(null);
                var gpuDescriptors = [];
                this._gpuDescriptorSet = {
                  gpuDescriptors: gpuDescriptors,
                  descriptorIndices: descriptorIndices
                };
                for (var i = 0; i < bindings.length; ++i) {
                  var binding = bindings[i];
                  for (var j = 0; j < binding.count; j++) {
                    var gpuDescriptor = {
                      type: binding.descriptorType,
                      gpuBuffer: null,
                      gpuTexture: null,
                      gpuSampler: null
                    };
                    gpuDescriptors.push(gpuDescriptor);
                  }
                }
              };
              _proto.destroy = function destroy() {
                this._layout = null;
                this._gpuDescriptorSet = null;
              };
              _proto.update = function update() {
                if (this._isDirty && this._gpuDescriptorSet) {
                  var descriptors = this._gpuDescriptorSet.gpuDescriptors;
                  for (var i = 0; i < descriptors.length; ++i) {
                    if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                      var buffer = this._buffers[i];
                      if (buffer) {
                        descriptors[i].gpuBuffer = buffer.gpuBuffer || buffer.gpuBufferView;
                      }
                    } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                      if (this._textures[i]) {
                        descriptors[i].gpuTexture = this._textures[i].gpuTexture;
                      }
                      if (this._samplers[i]) {
                        descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                      }
                    }
                  }
                  this._isDirty = false;
                }
              };
              _createClass(WebGLDescriptorSet, [{
                key: "gpuDescriptorSet",
                get: function get() {
                  return this._gpuDescriptorSet;
                }
              }]);
              return WebGLDescriptorSet;
            }(DescriptorSet);

            var max$1 = Math.max;
            var min$1 = Math.min;
            function GFXFormatToWebGLType$1(format, gl) {
              switch (format) {
                case 4:
                  return 5121;
                case 5:
                  return 5120;
                case 6:
                  return 5121;
                case 7:
                  return 5120;
                case 8:
                  return 36193;
                case 9:
                  return 5123;
                case 10:
                  return 5122;
                case 11:
                  return 5126;
                case 12:
                  return 5125;
                case 13:
                  return 5124;
                case 14:
                  return 5121;
                case 15:
                  return 5120;
                case 16:
                  return 5121;
                case 17:
                  return 5120;
                case 18:
                  return 36193;
                case 19:
                  return 5123;
                case 20:
                  return 5122;
                case 21:
                  return 5126;
                case 22:
                  return 5125;
                case 23:
                  return 5124;
                case 24:
                  return 5121;
                case 25:
                  return 5121;
                case 26:
                  return 5120;
                case 27:
                  return 5121;
                case 28:
                  return 5120;
                case 29:
                  return 36193;
                case 30:
                  return 5123;
                case 31:
                  return 5122;
                case 32:
                  return 5126;
                case 33:
                  return 5125;
                case 34:
                  return 5124;
                case 36:
                  return 5121;
                case 35:
                  return 5121;
                case 37:
                  return 5121;
                case 38:
                  return 5120;
                case 39:
                  return 5121;
                case 40:
                  return 5120;
                case 41:
                  return 36193;
                case 42:
                  return 5123;
                case 43:
                  return 5122;
                case 44:
                  return 5126;
                case 45:
                  return 5125;
                case 46:
                  return 5124;
                case 47:
                  return 33635;
                case 48:
                  return 5126;
                case 49:
                  return 32820;
                case 50:
                  return 32819;
                case 51:
                  return 5121;
                case 52:
                  return 5125;
                case 53:
                  return 5121;
                case 54:
                  return 5125;
                case 55:
                  return 34042;
                case 56:
                  return 5121;
                case 58:
                  return 5121;
                case 60:
                  return 5121;
                case 61:
                  return 5121;
                case 62:
                  return 5121;
                case 63:
                  return 5121;
                case 64:
                  return 5121;
                case 65:
                  return 5120;
                case 66:
                  return 5121;
                case 67:
                  return 5120;
                case 69:
                  return 5126;
                case 68:
                  return 5126;
                case 70:
                  return 5121;
                case 71:
                  return 5121;
                case 72:
                  return 5121;
                case 73:
                  return 5121;
                case 74:
                  return 5121;
                case 75:
                  return 5121;
                case 76:
                  return 5121;
                case 79:
                  return 5121;
                case 80:
                  return 5120;
                case 81:
                  return 5121;
                case 82:
                  return 5120;
                case 83:
                  return 5121;
                case 84:
                  return 5121;
                case 85:
                  return 5121;
                case 86:
                  return 5121;
                case 87:
                  return 5121;
                case 88:
                  return 5121;
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                  return 5121;
                default:
                  {
                    return 5121;
                  }
              }
            }
            function GFXFormatToWebGLInternalFormat$1(format, gl) {
              switch (format) {
                case 47:
                  return 36194;
                case 49:
                  return 32855;
                case 50:
                  return 32854;
                case 41:
                  return 34842;
                case 44:
                  return 34836;
                case 37:
                  return 35907;
                case 54:
                  return 33189;
                case 55:
                  return 34041;
                default:
                  {
                    errorID(16309);
                    return 6408;
                  }
              }
            }
            function GFXFormatToWebGLFormat$1(format, gl) {
              switch (format) {
                case 1:
                  return 6406;
                case 2:
                  return 6409;
                case 3:
                  return 6410;
                case 24:
                  return 6407;
                case 29:
                  return 6407;
                case 32:
                  return 6407;
                case 36:
                  return 6408;
                case 35:
                  return 6408;
                case 37:
                  return 6408;
                case 41:
                  return 6408;
                case 44:
                  return 6408;
                case 47:
                  return 6407;
                case 49:
                  return 6408;
                case 50:
                  return 6408;
                case 54:
                  return 6402;
                case 55:
                  return 34041;
                case 56:
                  return 33776;
                case 57:
                  return 33777;
                case 58:
                  return 35916;
                case 59:
                  return 35917;
                case 60:
                  return 33778;
                case 61:
                  return 35918;
                case 62:
                  return 33779;
                case 63:
                  return 35919;
                case 72:
                  return 36196;
                case 73:
                  return 37492;
                case 74:
                  return 37493;
                case 75:
                  return 37494;
                case 76:
                  return 37495;
                case 77:
                  return 37496;
                case 78:
                  return 37497;
                case 79:
                  return 37488;
                case 80:
                  return 37489;
                case 81:
                  return 37490;
                case 82:
                  return 37491;
                case 83:
                  return 35841;
                case 84:
                  return 35843;
                case 85:
                  return 35840;
                case 86:
                  return 35842;
                case 89:
                  return 37808;
                case 90:
                  return 37809;
                case 91:
                  return 37810;
                case 92:
                  return 37811;
                case 93:
                  return 37812;
                case 94:
                  return 37813;
                case 95:
                  return 37814;
                case 96:
                  return 37815;
                case 97:
                  return 37816;
                case 98:
                  return 37817;
                case 99:
                  return 37818;
                case 100:
                  return 37819;
                case 101:
                  return 37820;
                case 102:
                  return 37821;
                case 103:
                  return 37840;
                case 104:
                  return 37841;
                case 105:
                  return 37842;
                case 106:
                  return 37843;
                case 107:
                  return 37844;
                case 108:
                  return 37845;
                case 109:
                  return 37846;
                case 110:
                  return 37847;
                case 111:
                  return 37848;
                case 112:
                  return 37849;
                case 113:
                  return 37850;
                case 114:
                  return 37851;
                case 115:
                  return 37852;
                case 116:
                  return 37853;
                default:
                  {
                    errorID(16310);
                    return 6408;
                  }
              }
            }
            function GFXTypeToWebGLType$1(type, gl) {
              switch (type) {
                case 1:
                  return 35670;
                case 2:
                  return 35671;
                case 3:
                  return 35672;
                case 4:
                  return 35673;
                case 5:
                  return 5124;
                case 6:
                  return 35667;
                case 7:
                  return 35668;
                case 8:
                  return 35669;
                case 9:
                  return 5125;
                case 13:
                  return 5126;
                case 14:
                  return 35664;
                case 15:
                  return 35665;
                case 16:
                  return 35666;
                case 17:
                  return 35674;
                case 21:
                  return 35675;
                case 25:
                  return 35676;
                case 28:
                  return 35678;
                case 31:
                  return 35680;
                default:
                  {
                    errorID(16311);
                    return 0;
                  }
              }
            }
            function GFXTypeToTypedArrayCtor(type) {
              switch (type) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                  return Int32Array;
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 21:
                case 25:
                  return Float32Array;
                default:
                  {
                    errorID(16312);
                    return Float32Array;
                  }
              }
            }
            function WebGLTypeToGFXType$1(glType, gl) {
              switch (glType) {
                case 35670:
                  return 1;
                case 35671:
                  return 2;
                case 35672:
                  return 3;
                case 35673:
                  return 4;
                case 5124:
                  return 5;
                case 35667:
                  return 6;
                case 35668:
                  return 7;
                case 35669:
                  return 8;
                case 5125:
                  return 9;
                case 5126:
                  return 13;
                case 35664:
                  return 14;
                case 35665:
                  return 15;
                case 35666:
                  return 16;
                case 35674:
                  return 17;
                case 35675:
                  return 21;
                case 35676:
                  return 25;
                case 35678:
                  return 28;
                case 35680:
                  return 31;
                default:
                  {
                    errorID(16313);
                    return 0;
                  }
              }
            }
            function WebGLGetTypeSize$1(glType, gl) {
              switch (glType) {
                case 35670:
                  return 4;
                case 35671:
                  return 8;
                case 35672:
                  return 12;
                case 35673:
                  return 16;
                case 5124:
                  return 4;
                case 35667:
                  return 8;
                case 35668:
                  return 12;
                case 35669:
                  return 16;
                case 5125:
                  return 4;
                case 5126:
                  return 4;
                case 35664:
                  return 8;
                case 35665:
                  return 12;
                case 35666:
                  return 16;
                case 35674:
                  return 16;
                case 35675:
                  return 36;
                case 35676:
                  return 64;
                case 35678:
                  return 4;
                case 35680:
                  return 4;
                default:
                  {
                    errorID(16314);
                    return 0;
                  }
              }
            }
            function WebGLGetComponentCount$1(glType, gl) {
              switch (glType) {
                case 35674:
                  return 2;
                case 35675:
                  return 3;
                case 35676:
                  return 4;
                default:
                  {
                    return 1;
                  }
              }
            }
            var WebGLCmpFuncs$1 = [512, 513, 514, 515, 516, 517, 518, 519];
            var WebGLStencilOps$1 = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
            var WebGLBlendOps$1 = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
            var WebGLBlendFactors$1 = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
            function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
              var gl = device.gl,
                stateCache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & 2 ? 35048 : 35044;
              if (gpuBuffer.usage & 8) {
                gpuBuffer.glTarget = 34962;
                var glBuffer = gl.createBuffer();
                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;
                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (stateCache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        stateCache.glVAO = null;
                      }
                    }
                    gfxStateCache$1.gpuInputAssembler = null;
                    if (stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(34962, gpuBuffer.glBuffer);
                      stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                    }
                    gl.bufferData(34962, gpuBuffer.size, glUsage);
                    gl.bindBuffer(34962, null);
                    stateCache.glArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & 4) {
                gpuBuffer.glTarget = 34963;
                var _glBuffer = gl.createBuffer();
                if (_glBuffer) {
                  gpuBuffer.glBuffer = _glBuffer;
                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (stateCache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        stateCache.glVAO = null;
                      }
                    }
                    gfxStateCache$1.gpuInputAssembler = null;
                    if (stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(34963, gpuBuffer.glBuffer);
                      stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }
                    gl.bufferData(34963, gpuBuffer.size, glUsage);
                    gl.bindBuffer(34963, null);
                    stateCache.glElementArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & 16) {
                gpuBuffer.glTarget = 0;
                if (gpuBuffer.buffer) {
                  gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
                }
              } else if (gpuBuffer.usage & 64) {
                gpuBuffer.glTarget = 0;
              } else if (gpuBuffer.usage & 2) {
                gpuBuffer.glTarget = 0;
              } else if (gpuBuffer.usage & 1) {
                gpuBuffer.glTarget = 0;
              } else {
                errorID(16315);
                gpuBuffer.glTarget = 0;
              }
            }
            function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;
              if (gpuBuffer.glBuffer) {
                switch (gpuBuffer.glTarget) {
                  case 34962:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        cache.glVAO = null;
                      }
                    }
                    gfxStateCache$1.gpuInputAssembler = null;
                    gl.bindBuffer(34962, null);
                    cache.glArrayBuffer = null;
                    break;
                  case 34963:
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                        cache.glVAO = null;
                      }
                    }
                    gfxStateCache$1.gpuInputAssembler = null;
                    gl.bindBuffer(34963, null);
                    cache.glElementArrayBuffer = null;
                    break;
                }
                gl.deleteBuffer(gpuBuffer.glBuffer);
                gpuBuffer.glBuffer = null;
              }
            }
            function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
              var gl = device.gl,
                stateCache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & 2 ? 35048 : 35044;
              if (gpuBuffer.usage & 8) {
                if (device.extensions.useVAO) {
                  if (stateCache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    stateCache.glVAO = null;
                  }
                }
                gfxStateCache$1.gpuInputAssembler = null;
                if (stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(34962, gpuBuffer.glBuffer);
                }
                if (gpuBuffer.buffer) {
                  gl.bufferData(34962, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(34962, gpuBuffer.size, glUsage);
                }
                gl.bindBuffer(34962, null);
                stateCache.glArrayBuffer = null;
              } else if (gpuBuffer.usage & 4) {
                if (device.extensions.useVAO) {
                  if (stateCache.glVAO) {
                    device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                    stateCache.glVAO = null;
                  }
                }
                gfxStateCache$1.gpuInputAssembler = null;
                if (stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(34963, gpuBuffer.glBuffer);
                }
                if (gpuBuffer.buffer) {
                  gl.bufferData(34963, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(34963, gpuBuffer.size, glUsage);
                }
                gl.bindBuffer(34963, null);
                stateCache.glElementArrayBuffer = null;
              } else if (gpuBuffer.usage & 16) {
                if (gpuBuffer.buffer) {
                  gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
                }
              } else if (gpuBuffer.usage & 64 || gpuBuffer.usage & 2 || gpuBuffer.usage & 1) {
                gpuBuffer.glTarget = 0;
              } else {
                errorID(16315);
                gpuBuffer.glTarget = 0;
              }
            }
            function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
              if (gpuBuffer.usage & 16) {
                if (ArrayBuffer.isView(buffer)) {
                  gpuBuffer.vf32.set(buffer, offset / 4);
                } else {
                  gpuBuffer.vf32.set(new Float32Array(buffer), offset / 4);
                }
              } else if (gpuBuffer.usage & 64) {
                gpuBuffer.indirects.clearDraws();
                var drawInfos = buffer.drawInfos;
                for (var i = 0; i < drawInfos.length; ++i) {
                  gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
                }
              } else {
                var buff = buffer;
                var gl = device.gl,
                  stateCache = device.stateCache;
                switch (gpuBuffer.glTarget) {
                  case 34962:
                    {
                      if (device.extensions.useVAO) {
                        if (stateCache.glVAO) {
                          device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                          stateCache.glVAO = null;
                        }
                      }
                      gfxStateCache$1.gpuInputAssembler = null;
                      if (stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(34962, gpuBuffer.glBuffer);
                        stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                      }
                      break;
                    }
                  case 34963:
                    {
                      if (device.extensions.useVAO) {
                        if (stateCache.glVAO) {
                          device.extensions.OES_vertex_array_object.bindVertexArrayOES(null);
                          stateCache.glVAO = null;
                        }
                      }
                      gfxStateCache$1.gpuInputAssembler = null;
                      if (stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(34963, gpuBuffer.glBuffer);
                        stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                      }
                      break;
                    }
                  default:
                    {
                      errorID(16316);
                      return;
                    }
                }
                if (systemInfo.os === OS.IOS && gpuBuffer.memUsage & 2 && offset === 0 && size === buff.byteLength) {
                  gl.bufferData(gpuBuffer.glTarget, buff, gl.DYNAMIC_DRAW);
                } else if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                }
              }
            }
            function WebGLCmdFuncCreateTexture(device, gpuTexture) {
              var gl = device.gl,
                stateCache = device.stateCache;
              gpuTexture.glFormat = gpuTexture.glInternalFmt = GFXFormatToWebGLFormat$1(gpuTexture.format);
              gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format);
              var w = gpuTexture.width;
              var h = gpuTexture.height;
              switch (gpuTexture.type) {
                case 1:
                  {
                    gpuTexture.glTarget = 3553;
                    var maxSize = max$1(w, h);
                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }
                    if (!device.textureExclusive[gpuTexture.format] && (!device.extensions.WEBGL_depth_texture || BYTEDANCE) && FormatInfos[gpuTexture.format].hasDepth) {
                      gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format);
                      gpuTexture.glRenderbuffer = gl.createRenderbuffer();
                      if (gpuTexture.size > 0) {
                        if (stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                          gl.bindRenderbuffer(36161, gpuTexture.glRenderbuffer);
                          stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                        }
                        gl.renderbufferStorage(36161, gpuTexture.glInternalFmt, w, h);
                      }
                    } else {
                      gpuTexture.glTexture = gl.createTexture();
                      if (gpuTexture.size > 0) {
                        var glTexUnit = stateCache.glTexUnits[stateCache.texUnit];
                        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                          gl.bindTexture(3553, gpuTexture.glTexture);
                          glTexUnit.glTexture = gpuTexture.glTexture;
                        }
                        if (FormatInfos[gpuTexture.format].isCompressed) {
                          for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                            var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            var view = new Uint8Array(imgSize);
                            gl.compressedTexImage2D(3553, i, gpuTexture.glInternalFmt, w, h, 0, view);
                            w = max$1(1, w >> 1);
                            h = max$1(1, h >> 1);
                          }
                        } else {
                          for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                            gl.texImage2D(3553, _i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                            w = max$1(1, w >> 1);
                            h = max$1(1, h >> 1);
                          }
                        }
                        if (gpuTexture.isPowerOf2) {
                          gpuTexture.glWrapS = 10497;
                          gpuTexture.glWrapT = 10497;
                        } else {
                          gpuTexture.glWrapS = 33071;
                          gpuTexture.glWrapT = 33071;
                        }
                        gpuTexture.glMinFilter = 9729;
                        gpuTexture.glMagFilter = 9729;
                        gl.texParameteri(gpuTexture.glTarget, 10242, gpuTexture.glWrapS);
                        gl.texParameteri(gpuTexture.glTarget, 10243, gpuTexture.glWrapT);
                        gl.texParameteri(gpuTexture.glTarget, 10241, gpuTexture.glMinFilter);
                        gl.texParameteri(gpuTexture.glTarget, 10240, gpuTexture.glMagFilter);
                      }
                    }
                    break;
                  }
                case 3:
                  {
                    gpuTexture.glTarget = 34067;
                    var _maxSize = max$1(w, h);
                    if (_maxSize > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize, device.capabilities.maxTextureSize);
                    }
                    gpuTexture.glTexture = gl.createTexture();
                    if (gpuTexture.size > 0) {
                      var _glTexUnit = stateCache.glTexUnits[stateCache.texUnit];
                      if (_glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(34067, gpuTexture.glTexture);
                        _glTexUnit.glTexture = gpuTexture.glTexture;
                      }
                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var f = 0; f < 6; ++f) {
                          w = gpuTexture.width;
                          h = gpuTexture.height;
                          for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) {
                            var _imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            var _view = new Uint8Array(_imgSize);
                            gl.compressedTexImage2D(34069 + f, _i2, gpuTexture.glInternalFmt, w, h, 0, _view);
                            w = max$1(1, w >> 1);
                            h = max$1(1, h >> 1);
                          }
                        }
                      } else {
                        for (var _f = 0; _f < 6; ++_f) {
                          w = gpuTexture.width;
                          h = gpuTexture.height;
                          for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                            gl.texImage2D(34069 + _f, _i3, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                            w = max$1(1, w >> 1);
                            h = max$1(1, h >> 1);
                          }
                        }
                      }
                      if (gpuTexture.isPowerOf2) {
                        gpuTexture.glWrapS = 10497;
                        gpuTexture.glWrapT = 10497;
                      } else {
                        gpuTexture.glWrapS = 33071;
                        gpuTexture.glWrapT = 33071;
                      }
                      gpuTexture.glMinFilter = 9729;
                      gpuTexture.glMagFilter = 9729;
                      gl.texParameteri(gpuTexture.glTarget, 10242, gpuTexture.glWrapS);
                      gl.texParameteri(gpuTexture.glTarget, 10243, gpuTexture.glWrapT);
                      gl.texParameteri(gpuTexture.glTarget, 10241, gpuTexture.glMinFilter);
                      gl.texParameteri(gpuTexture.glTarget, 10240, gpuTexture.glMagFilter);
                    }
                    break;
                  }
                default:
                  {
                    errorID(16317);
                    gpuTexture.type = 1;
                    gpuTexture.glTarget = 3553;
                  }
              }
            }
            function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
              var gl = device.gl,
                stateCache = device.stateCache;
              if (gpuTexture.glTexture) {
                var glTexUnits = stateCache.glTexUnits;
                var texUnit = stateCache.texUnit;
                gl.deleteTexture(gpuTexture.glTexture);
                for (var i = 0; i < glTexUnits.length; i++) {
                  if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
                    gl.activeTexture(33984 + i);
                    texUnit = i;
                    gl.bindTexture(gpuTexture.glTarget, null);
                    glTexUnits[i].glTexture = null;
                  }
                }
                stateCache.texUnit = texUnit;
                gpuTexture.glTexture = null;
              }
              if (gpuTexture.glRenderbuffer) {
                var glRenderbuffer = stateCache.glRenderbuffer;
                gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);
                if (glRenderbuffer === gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(36161, null);
                  stateCache.glRenderbuffer = null;
                }
                gpuTexture.glRenderbuffer = null;
              }
            }
            function WebGLCmdFuncResizeTexture(device, gpuTexture) {
              if (!gpuTexture.size) return;
              var gl = device.gl,
                stateCache = device.stateCache;
              var w = gpuTexture.width;
              var h = gpuTexture.height;
              switch (gpuTexture.type) {
                case 1:
                  {
                    gpuTexture.glTarget = 3553;
                    var maxSize = max$1(w, h);
                    if (maxSize > device.capabilities.maxTextureSize) {
                      errorID(9100, maxSize, device.capabilities.maxTextureSize);
                    }
                    if (gpuTexture.glRenderbuffer) {
                      if (stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                        gl.bindRenderbuffer(36161, gpuTexture.glRenderbuffer);
                        stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                      }
                      gl.renderbufferStorage(36161, gpuTexture.glInternalFmt, w, h);
                    } else if (gpuTexture.glTexture) {
                      var glTexUnit = stateCache.glTexUnits[stateCache.texUnit];
                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(3553, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }
                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                          var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          var view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(3553, i, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = max$1(1, w >> 1);
                          h = max$1(1, h >> 1);
                        }
                      } else {
                        for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                          gl.texImage2D(3553, _i4, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = max$1(1, w >> 1);
                          h = max$1(1, h >> 1);
                        }
                      }
                    }
                    break;
                  }
                case 3:
                  {
                    gpuTexture.glTarget = 34067;
                    var _maxSize2 = max$1(w, h);
                    if (_maxSize2 > device.capabilities.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize2, device.capabilities.maxTextureSize);
                    }
                    var _glTexUnit2 = stateCache.glTexUnits[stateCache.texUnit];
                    if (_glTexUnit2.glTexture !== gpuTexture.glTexture) {
                      gl.bindTexture(34067, gpuTexture.glTexture);
                      _glTexUnit2.glTexture = gpuTexture.glTexture;
                    }
                    if (FormatInfos[gpuTexture.format].isCompressed) {
                      for (var f = 0; f < 6; ++f) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;
                        for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) {
                          var _imgSize2 = FormatSize(gpuTexture.format, w, h, 1);
                          var _view2 = new Uint8Array(_imgSize2);
                          gl.compressedTexImage2D(34069 + f, _i5, gpuTexture.glInternalFmt, w, h, 0, _view2);
                          w = max$1(1, w >> 1);
                          h = max$1(1, h >> 1);
                        }
                      }
                    } else {
                      for (var _f2 = 0; _f2 < 6; ++_f2) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;
                        for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                          gl.texImage2D(34069 + _f2, _i6, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = max$1(1, w >> 1);
                          h = max$1(1, h >> 1);
                        }
                      }
                    }
                    break;
                  }
                default:
                  {
                    errorID(16317);
                    gpuTexture.type = 1;
                    gpuTexture.glTarget = 3553;
                  }
              }
            }
            function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
              for (var i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
                var tex = gpuFramebuffer.gpuColorTextures[i];
                if (tex.isSwapchainTexture) {
                  gpuFramebuffer.isOffscreen = false;
                  return;
                }
              }
              var gl = device.gl,
                stateCache = device.stateCache;
              var attachments = [];
              var glFramebuffer = gl.createFramebuffer();
              if (glFramebuffer) {
                gpuFramebuffer.glFramebuffer = glFramebuffer;
                if (stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(36160, gpuFramebuffer.glFramebuffer);
                }
                for (var _i7 = 0; _i7 < gpuFramebuffer.gpuColorTextures.length; ++_i7) {
                  var gpuTexture = gpuFramebuffer.gpuColorTextures[_i7];
                  if (gpuTexture) {
                    if (gpuTexture.glTexture) {
                      gl.framebufferTexture2D(36160, 36064 + _i7, gpuTexture.glTarget, gpuTexture.glTexture, 0);
                    } else {
                      gl.framebufferRenderbuffer(36160, 36064 + _i7, 36161, gpuTexture.glRenderbuffer);
                    }
                    attachments.push(36064 + _i7);
                    gpuFramebuffer.width = min$1(gpuFramebuffer.width, gpuTexture.width);
                    gpuFramebuffer.height = min$1(gpuFramebuffer.height, gpuTexture.height);
                  }
                }
                var dst = gpuFramebuffer.gpuDepthStencilTexture;
                if (dst) {
                  var glAttachment = FormatInfos[dst.format].hasStencil ? 33306 : 36096;
                  if (dst.glTexture) {
                    gl.framebufferTexture2D(36160, glAttachment, dst.glTarget, dst.glTexture, 0);
                  } else {
                    gl.framebufferRenderbuffer(36160, glAttachment, 36161, dst.glRenderbuffer);
                  }
                  gpuFramebuffer.width = min$1(gpuFramebuffer.width, dst.width);
                  gpuFramebuffer.height = min$1(gpuFramebuffer.height, dst.height);
                }
                if (device.extensions.WEBGL_draw_buffers) {
                  device.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
                }
                var status = gl.checkFramebufferStatus(36160);
                if (status !== 36053) {
                  switch (status) {
                    case 36054:
                      {
                        errorID(16318);
                        break;
                      }
                    case 36055:
                      {
                        errorID(16319);
                        break;
                      }
                    case 36057:
                      {
                        errorID(16320);
                        break;
                      }
                    case 36061:
                      {
                        errorID(16321);
                        break;
                      }
                  }
                }
                if (stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(36160, stateCache.glFramebuffer);
                }
              }
            }
            function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
              var gl = device.gl,
                stateCache = device.stateCache;
              if (gpuFramebuffer.glFramebuffer) {
                gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);
                if (stateCache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(36160, null);
                  stateCache.glFramebuffer = null;
                }
                gpuFramebuffer.glFramebuffer = null;
              }
            }
            function WebGLCmdFuncCreateShader(device, gpuShader) {
              var gl = device.gl,
                stateCache = device.stateCache;
              var _loop = function _loop() {
                  var gpuStage = gpuShader.gpuStages[k];
                  var glShaderType = 0;
                  var shaderTypeStr = '';
                  var lineNumber = 1;
                  switch (gpuStage.type) {
                    case 1:
                      {
                        shaderTypeStr = 'VertexShader';
                        glShaderType = 35633;
                        break;
                      }
                    case 16:
                      {
                        shaderTypeStr = 'FragmentShader';
                        glShaderType = 35632;
                        break;
                      }
                    default:
                      {
                        errorID(16322);
                        return {
                          v: undefined
                        };
                      }
                  }
                  var glShader = gl.createShader(glShaderType);
                  if (glShader) {
                    gpuStage.glShader = glShader;
                    gl.shaderSource(gpuStage.glShader, gpuStage.source);
                    gl.compileShader(gpuStage.glShader);
                    if (!gl.getShaderParameter(gpuStage.glShader, 35713)) {
                      errorID(16323, shaderTypeStr, gpuShader.name);
                      errorID(16324, gpuStage.source.replace(/^|\n/g, function () {
                        return "\n" + lineNumber++ + " ";
                      }));
                      error(gl.getShaderInfoLog(gpuStage.glShader));
                      for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                        var stage = gpuShader.gpuStages[k];
                        if (stage.glShader) {
                          gl.deleteShader(stage.glShader);
                          stage.glShader = null;
                        }
                      }
                      return {
                        v: undefined
                      };
                    }
                  }
                },
                _ret;
              for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                _ret = _loop();
                if (_ret) return _ret.v;
              }
              var glProgram = gl.createProgram();
              if (!glProgram) {
                return;
              }
              gpuShader.glProgram = glProgram;
              for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
                var gpuStage = gpuShader.gpuStages[_k];
                gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
              }
              gl.linkProgram(gpuShader.glProgram);
              if (device.extensions.destroyShadersImmediately) {
                for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
                  var _gpuStage = gpuShader.gpuStages[_k2];
                  if (_gpuStage.glShader) {
                    gl.detachShader(gpuShader.glProgram, _gpuStage.glShader);
                    gl.deleteShader(_gpuStage.glShader);
                    _gpuStage.glShader = null;
                  }
                }
              }
              if (gl.getProgramParameter(gpuShader.glProgram, 35714)) {
                debugID(16325, gpuShader.name);
              } else {
                errorID(16326, gpuShader.name);
                error(gl.getProgramInfoLog(gpuShader.glProgram));
                return;
              }
              var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, 35721);
              gpuShader.glInputs = new Array(activeAttribCount);
              for (var i = 0; i < activeAttribCount; ++i) {
                var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                if (attribInfo) {
                  var attribType = attribInfo.type,
                    attribName = attribInfo.name,
                    attribSize = attribInfo.size;
                  var varName = undefined;
                  var nameOffset = attribName.indexOf('[');
                  if (nameOffset !== -1) {
                    varName = attribName.substring(0, nameOffset);
                  } else {
                    varName = attribName;
                  }
                  var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
                  var gfxType = WebGLTypeToGFXType$1(attribType);
                  var stride = WebGLGetTypeSize$1(attribType);
                  gpuShader.glInputs[i] = {
                    binding: glLoc,
                    name: varName,
                    type: gfxType,
                    stride: stride,
                    count: attribSize,
                    size: stride * attribSize,
                    glType: attribType,
                    glLoc: glLoc
                  };
                }
              }
              if (gpuShader.blocks.length > 0) {
                gpuShader.glBlocks = new Array(gpuShader.blocks.length);
                for (var _i8 = 0; _i8 < gpuShader.blocks.length; ++_i8) {
                  var block = gpuShader.blocks[_i8];
                  var glBlock = {
                    set: block.set,
                    binding: block.binding,
                    name: block.name,
                    size: 0,
                    glUniforms: new Array(block.members.length),
                    glActiveUniforms: []
                  };
                  gpuShader.glBlocks[_i8] = glBlock;
                  for (var u = 0; u < block.members.length; ++u) {
                    var uniform = block.members[u];
                    var glType = GFXTypeToWebGLType$1(uniform.type);
                    var _stride = WebGLGetTypeSize$1(glType);
                    var size = _stride * uniform.count;
                    glBlock.glUniforms[u] = {
                      binding: -1,
                      name: uniform.name,
                      type: uniform.type,
                      stride: _stride,
                      count: uniform.count,
                      size: size,
                      offset: 0,
                      glType: glType,
                      glLoc: null,
                      array: null
                    };
                  }
                }
              }
              for (var _i9 = 0; _i9 < gpuShader.subpassInputs.length; ++_i9) {
                var subpassInput = gpuShader.subpassInputs[_i9];
                gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, 28, subpassInput.count));
              }
              if (gpuShader.samplerTextures.length > 0) {
                gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);
                for (var _i10 = 0; _i10 < gpuShader.samplerTextures.length; ++_i10) {
                  var sampler = gpuShader.samplerTextures[_i10];
                  gpuShader.glSamplerTextures[_i10] = {
                    set: sampler.set,
                    binding: sampler.binding,
                    name: sampler.name,
                    type: sampler.type,
                    count: sampler.count,
                    units: [],
                    glUnits: null,
                    glType: GFXTypeToWebGLType$1(sampler.type),
                    glLoc: null
                  };
                }
              }
              var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, 35718);
              for (var _i11 = 0; _i11 < activeUniformCount; ++_i11) {
                var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i11);
                if (uniformInfo) {
                  var isSampler = uniformInfo.type === 35678 || uniformInfo.type === 35680;
                  if (!isSampler) {
                    var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);
                    if (device.extensions.isLocationActive(_glLoc)) {
                      var _varName = undefined;
                      var _nameOffset = uniformInfo.name.indexOf('[');
                      if (_nameOffset !== -1) {
                        _varName = uniformInfo.name.substring(0, _nameOffset);
                      } else {
                        _varName = uniformInfo.name;
                      }
                      for (var j = 0; j < gpuShader.glBlocks.length; j++) {
                        var _glBlock = gpuShader.glBlocks[j];
                        for (var _k3 = 0; _k3 < _glBlock.glUniforms.length; _k3++) {
                          var glUniform = _glBlock.glUniforms[_k3];
                          if (glUniform.name === _varName) {
                            glUniform.glLoc = _glLoc;
                            glUniform.count = uniformInfo.size;
                            glUniform.size = glUniform.stride * glUniform.count;
                            glUniform.array = new (GFXTypeToTypedArrayCtor(glUniform.type))(glUniform.size / 4);
                            _glBlock.glActiveUniforms.push(glUniform);
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
              for (var _j = 0; _j < gpuShader.glBlocks.length; _j++) {
                var _glBlock2 = gpuShader.glBlocks[_j];
                for (var _k4 = 0; _k4 < _glBlock2.glUniforms.length; _k4++) {
                  var _glUniform = _glBlock2.glUniforms[_k4];
                  _glUniform.offset = _glBlock2.size / 4;
                  _glBlock2.size += _glUniform.size;
                }
              }
              var glActiveSamplers = [];
              var glActiveSamplerLocations = [];
              var bindingMappings = device.bindingMappings,
                capabilities = device.capabilities;
              var texUnitCacheMap = device.stateCache.texUnitCacheMap;
              var maxTextureUnits = capabilities.maxTextureUnits;
              if (!(cclegacy.rendering && cclegacy.rendering.enableEffectImport)) {
                var flexibleSetBaseOffset = 0;
                for (var _i12 = 0; _i12 < gpuShader.blocks.length; ++_i12) {
                  if (gpuShader.blocks[_i12].set === bindingMappings.flexibleSet) {
                    flexibleSetBaseOffset++;
                  }
                }
                var arrayOffset = 0;
                for (var _i13 = 0; _i13 < gpuShader.samplerTextures.length; ++_i13) {
                  var _sampler = gpuShader.samplerTextures[_i13];
                  var _glLoc2 = gl.getUniformLocation(gpuShader.glProgram, _sampler.name);
                  if (device.extensions.isLocationActive(_glLoc2)) {
                    glActiveSamplers.push(gpuShader.glSamplerTextures[_i13]);
                    glActiveSamplerLocations.push(_glLoc2);
                  }
                  if (texUnitCacheMap[_sampler.name] === undefined) {
                    var binding = _sampler.binding + bindingMappings.samplerTextureOffsets[_sampler.set] + arrayOffset;
                    if (_sampler.set === bindingMappings.flexibleSet) {
                      binding -= flexibleSetBaseOffset;
                    }
                    texUnitCacheMap[_sampler.name] = binding % maxTextureUnits;
                    arrayOffset += _sampler.count - 1;
                  }
                }
              } else {
                for (var _i14 = 0; _i14 < gpuShader.samplerTextures.length; ++_i14) {
                  var _sampler2 = gpuShader.samplerTextures[_i14];
                  var _glLoc3 = gl.getUniformLocation(gpuShader.glProgram, _sampler2.name);
                  if (device.extensions.isLocationActive(_glLoc3)) {
                    glActiveSamplers.push(gpuShader.glSamplerTextures[_i14]);
                    glActiveSamplerLocations.push(_glLoc3);
                  }
                  if (texUnitCacheMap[_sampler2.name] === undefined) {
                    texUnitCacheMap[_sampler2.name] = _sampler2.flattened % maxTextureUnits;
                  }
                }
              }
              if (glActiveSamplers.length) {
                var usedTexUnits = [];
                for (var _i15 = 0; _i15 < glActiveSamplers.length; ++_i15) {
                  var glSampler = glActiveSamplers[_i15];
                  var cachedUnit = texUnitCacheMap[glSampler.name];
                  if (cachedUnit !== undefined) {
                    glSampler.glLoc = glActiveSamplerLocations[_i15];
                    for (var t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[cachedUnit]) {
                        cachedUnit = (cachedUnit + 1) % maxTextureUnits;
                      }
                      glSampler.units.push(cachedUnit);
                      usedTexUnits[cachedUnit] = true;
                    }
                  }
                }
                var unitIdx = 0;
                for (var _i16 = 0; _i16 < glActiveSamplers.length; ++_i16) {
                  var _glSampler = glActiveSamplers[_i16];
                  if (!device.extensions.isLocationActive(_glSampler.glLoc)) {
                    _glSampler.glLoc = glActiveSamplerLocations[_i16];
                    for (var _t = 0; _t < _glSampler.count; ++_t) {
                      while (usedTexUnits[unitIdx]) {
                        unitIdx = (unitIdx + 1) % maxTextureUnits;
                      }
                      if (texUnitCacheMap[_glSampler.name] === undefined) {
                        texUnitCacheMap[_glSampler.name] = unitIdx;
                      }
                      _glSampler.units.push(unitIdx);
                      usedTexUnits[unitIdx] = true;
                    }
                  }
                }
                if (stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(gpuShader.glProgram);
                }
                for (var _i17 = 0; _i17 < glActiveSamplers.length; _i17++) {
                  var _glSampler2 = glActiveSamplers[_i17];
                  _glSampler2.glUnits = new Int32Array(_glSampler2.units);
                  gl.uniform1iv(_glSampler2.glLoc, _glSampler2.glUnits);
                }
                if (stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(stateCache.glProgram);
                }
              }
              for (var _i18 = 0; _i18 < gpuShader.glBlocks.length;) {
                if (gpuShader.glBlocks[_i18].glActiveUniforms.length) {
                  _i18++;
                } else {
                  gpuShader.glBlocks[_i18] = gpuShader.glBlocks[gpuShader.glBlocks.length - 1];
                  gpuShader.glBlocks.length--;
                }
              }
              gpuShader.glSamplerTextures = glActiveSamplers;
            }
            function WebGLCmdFuncDestroyShader(device, gpuShader) {
              if (gpuShader.glProgram) {
                var gl = device.gl,
                  stateCache = device.stateCache;
                if (!device.extensions.destroyShadersImmediately) {
                  for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                    var gpuStage = gpuShader.gpuStages[k];
                    if (gpuStage.glShader) {
                      gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
                      gl.deleteShader(gpuStage.glShader);
                      gpuStage.glShader = null;
                    }
                  }
                }
                gl.deleteProgram(gpuShader.glProgram);
                if (stateCache.glProgram === gpuShader.glProgram) {
                  gl.useProgram(null);
                  stateCache.glProgram = null;
                }
                gpuShader.glProgram = null;
              }
            }
            function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
              device.gl;
              gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
              var offsets = [0, 0, 0, 0, 0, 0, 0, 0];
              for (var i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                var attrib = gpuInputAssembler.attributes[i];
                var attribFormat = attrib.format,
                  attribIsNormalized = attrib.isNormalized,
                  attribIsInstanced = attrib.isInstanced;
                var stream = attrib.stream !== undefined ? attrib.stream : 0;
                var gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
                var glType = GFXFormatToWebGLType$1(attribFormat);
                var size = FormatInfos[attribFormat].size;
                gpuInputAssembler.glAttribs[i] = {
                  name: attrib.name,
                  glBuffer: gpuBuffer.glBuffer,
                  glType: glType,
                  size: size,
                  count: FormatInfos[attribFormat].count,
                  stride: gpuBuffer.stride,
                  componentCount: WebGLGetComponentCount$1(glType),
                  isNormalized: attribIsNormalized !== undefined ? attribIsNormalized : false,
                  isInstanced: attribIsInstanced !== undefined ? attribIsInstanced : false,
                  offset: offsets[stream]
                };
                offsets[stream] += size;
              }
            }
            function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
              var stateCache = device.stateCache;
              var it = gpuInputAssembler.glVAOs.values();
              var res = it.next();
              var OES_vertex_array_object = device.extensions.OES_vertex_array_object;
              var glVAO = stateCache.glVAO;
              while (!res.done) {
                OES_vertex_array_object.deleteVertexArrayOES(res.value);
                if (glVAO === res.value) {
                  OES_vertex_array_object.bindVertexArrayOES(null);
                  glVAO = null;
                }
                res = it.next();
              }
              stateCache.glVAO = glVAO;
              gpuInputAssembler.glVAOs.clear();
            }
            var gfxStateCache$1 = {
              gpuPipelineState: null,
              gpuInputAssembler: null,
              glPrimitive: 0
            };
            var realRenderArea = new Rect$1();
            function WebGLCmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
              var gl = device.gl;
              var cache = device.stateCache;
              var clears = 0;
              if (gpuFramebuffer) {
                var lodLevel = gpuFramebuffer.lodLevel;
                realRenderArea.x = renderArea.x << lodLevel;
                realRenderArea.y = renderArea.y << lodLevel;
                realRenderArea.width = renderArea.width << lodLevel;
                realRenderArea.height = renderArea.height << lodLevel;
              }
              if (gpuFramebuffer && gpuRenderPass) {
                var curGPUFrameBuffer = gpuFramebuffer.glFramebuffer;
                var realRenderAreaX = realRenderArea.x,
                  realRenderAreaY = realRenderArea.y,
                  realRenderAreaWidth = realRenderArea.width,
                  realRenderAreaHeight = realRenderArea.height;
                if (cache.glFramebuffer !== curGPUFrameBuffer) {
                  gl.bindFramebuffer(36160, curGPUFrameBuffer);
                  cache.glFramebuffer = curGPUFrameBuffer;
                }
                var cacheViewport = cache.viewport;
                if (cacheViewport.left !== realRenderAreaX || cacheViewport.top !== realRenderAreaY || cacheViewport.width !== realRenderAreaWidth || cacheViewport.height !== realRenderAreaHeight) {
                  gl.viewport(realRenderAreaX, realRenderAreaY, realRenderAreaWidth, realRenderAreaHeight);
                  cacheViewport.left = realRenderAreaX;
                  cacheViewport.top = realRenderAreaY;
                  cacheViewport.width = realRenderAreaWidth;
                  cacheViewport.height = realRenderAreaHeight;
                }
                var cacheScissorRect = cache.scissorRect;
                if (cacheScissorRect.x !== realRenderAreaX || cacheScissorRect.y !== realRenderAreaY || cacheScissorRect.width !== realRenderAreaWidth || cacheScissorRect.height !== realRenderAreaHeight) {
                  gl.scissor(realRenderAreaX, realRenderAreaY, realRenderAreaWidth, realRenderAreaHeight);
                  cacheScissorRect.x = realRenderAreaX;
                  cacheScissorRect.y = realRenderAreaY;
                  cacheScissorRect.width = realRenderAreaWidth;
                  cacheScissorRect.height = realRenderAreaHeight;
                }
                var clearCount = clearColors.length;
                if (!device.extensions.WEBGL_draw_buffers) {
                  clearCount = 1;
                }
                var cacheDSS = cache.dss;
                for (var j = 0; j < clearCount; ++j) {
                  var colorAttachment = gpuRenderPass.colorAttachments[j];
                  if (colorAttachment.format !== 0) {
                    switch (colorAttachment.loadOp) {
                      case 0:
                        break;
                      case 1:
                        {
                          if (cache.bs.targets[0].blendColorMask !== 15) {
                            gl.colorMask(true, true, true, true);
                          }
                          var clearColor = clearColors[0];
                          gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                          clears |= 16384;
                          break;
                        }
                    }
                  }
                }
                if (gpuRenderPass.depthStencilAttachment) {
                  if (gpuRenderPass.depthStencilAttachment.format !== 0) {
                    switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                      case 0:
                        break;
                      case 1:
                        {
                          if (!cacheDSS.depthWrite) {
                            gl.depthMask(true);
                          }
                          gl.clearDepth(clearDepth);
                          clears |= 256;
                          break;
                        }
                    }
                    if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                      switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                        case 0:
                          break;
                        case 1:
                          {
                            if (!cacheDSS.stencilWriteMaskFront) {
                              gl.stencilMaskSeparate(1028, 0xffff);
                            }
                            if (!cacheDSS.stencilWriteMaskBack) {
                              gl.stencilMaskSeparate(1029, 0xffff);
                            }
                            gl.clearStencil(clearStencil);
                            clears |= 1024;
                            break;
                          }
                      }
                    }
                  }
                }
                if (clears) {
                  gl.clear(clears);
                }
                if (clears & 16384) {
                  var colorMask = cache.bs.targets[0].blendColorMask;
                  if (colorMask !== 15) {
                    var r = (colorMask & 1) !== 0;
                    var g = (colorMask & 2) !== 0;
                    var b = (colorMask & 4) !== 0;
                    var a = (colorMask & 8) !== 0;
                    gl.colorMask(r, g, b, a);
                  }
                }
                if (clears & 256 && !cacheDSS.depthWrite) {
                  gl.depthMask(false);
                }
                if (clears & 1024) {
                  if (!cacheDSS.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(1028, 0);
                  }
                  if (!cacheDSS.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(1029, 0);
                  }
                }
              }
            }
            function WebGLCmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
              var gl = device.gl;
              var cache = device.stateCache;
              var cacheDSS = cache.dss;
              var cacheBS = cache.bs;
              var gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
              var isShaderChanged = false;
              var glWrapS;
              var glWrapT;
              var glMinFilter;
              if (gpuPipelineState && gfxStateCache$1.gpuPipelineState !== gpuPipelineState) {
                gfxStateCache$1.gpuPipelineState = gpuPipelineState;
                gfxStateCache$1.glPrimitive = gpuPipelineState.glPrimitive;
                if (gpuPipelineState.gpuShader) {
                  var glProgram = gpuPipelineState.gpuShader.glProgram;
                  if (cache.glProgram !== glProgram) {
                    gl.useProgram(glProgram);
                    cache.glProgram = glProgram;
                    isShaderChanged = true;
                  }
                }
                var rs = gpuPipelineState.rs;
                var cacheRS = cache.rs;
                if (rs) {
                  if (cacheRS.cullMode !== rs.cullMode) {
                    switch (rs.cullMode) {
                      case 0:
                        {
                          gl.disable(2884);
                          break;
                        }
                      case 1:
                        {
                          gl.enable(2884);
                          gl.cullFace(1028);
                          break;
                        }
                      case 2:
                        {
                          gl.enable(2884);
                          gl.cullFace(1029);
                          break;
                        }
                    }
                    cacheRS.cullMode = rs.cullMode;
                  }
                  var isFrontFaceCCW = rs.isFrontFaceCCW;
                  if (cacheRS.isFrontFaceCCW !== isFrontFaceCCW) {
                    gl.frontFace(isFrontFaceCCW ? 2305 : 2304);
                    cacheRS.isFrontFaceCCW = isFrontFaceCCW;
                  }
                  if (cacheRS.depthBias !== rs.depthBias || cacheRS.depthBiasSlop !== rs.depthBiasSlop) {
                    gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
                    cacheRS.depthBias = rs.depthBias;
                    cacheRS.depthBiasSlop = rs.depthBiasSlop;
                  }
                  if (cacheRS.lineWidth !== rs.lineWidth) {
                    gl.lineWidth(rs.lineWidth);
                    cacheRS.lineWidth = rs.lineWidth;
                  }
                }
                var dss = gpuPipelineState.dss;
                if (dss) {
                  if (cacheDSS.depthTest !== dss.depthTest) {
                    if (dss.depthTest) {
                      gl.enable(2929);
                    } else {
                      gl.disable(2929);
                    }
                    cacheDSS.depthTest = dss.depthTest;
                  }
                  if (cacheDSS.depthWrite !== dss.depthWrite) {
                    gl.depthMask(dss.depthWrite);
                    cacheDSS.depthWrite = dss.depthWrite;
                  }
                  if (cacheDSS.depthFunc !== dss.depthFunc) {
                    gl.depthFunc(WebGLCmpFuncs$1[dss.depthFunc]);
                    cacheDSS.depthFunc = dss.depthFunc;
                  }
                  if (cacheDSS.stencilTestFront !== dss.stencilTestFront || cacheDSS.stencilTestBack !== dss.stencilTestBack) {
                    if (dss.stencilTestFront || dss.stencilTestBack) {
                      gl.enable(2960);
                    } else {
                      gl.disable(2960);
                    }
                    cacheDSS.stencilTestFront = dss.stencilTestFront;
                    cacheDSS.stencilTestBack = dss.stencilTestBack;
                  }
                  if (cacheDSS.stencilFuncFront !== dss.stencilFuncFront || cacheDSS.stencilRefFront !== dss.stencilRefFront || cacheDSS.stencilReadMaskFront !== dss.stencilReadMaskFront) {
                    gl.stencilFuncSeparate(1028, WebGLCmpFuncs$1[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
                    cacheDSS.stencilFuncFront = dss.stencilFuncFront;
                    cacheDSS.stencilRefFront = dss.stencilRefFront;
                    cacheDSS.stencilReadMaskFront = dss.stencilReadMaskFront;
                  }
                  if (cacheDSS.stencilFailOpFront !== dss.stencilFailOpFront || cacheDSS.stencilZFailOpFront !== dss.stencilZFailOpFront || cacheDSS.stencilPassOpFront !== dss.stencilPassOpFront) {
                    gl.stencilOpSeparate(1028, WebGLStencilOps$1[dss.stencilFailOpFront], WebGLStencilOps$1[dss.stencilZFailOpFront], WebGLStencilOps$1[dss.stencilPassOpFront]);
                    cacheDSS.stencilFailOpFront = dss.stencilFailOpFront;
                    cacheDSS.stencilZFailOpFront = dss.stencilZFailOpFront;
                    cacheDSS.stencilPassOpFront = dss.stencilPassOpFront;
                  }
                  if (cacheDSS.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(1028, dss.stencilWriteMaskFront);
                    cacheDSS.stencilWriteMaskFront = dss.stencilWriteMaskFront;
                  }
                  if (cacheDSS.stencilFuncBack !== dss.stencilFuncBack || cacheDSS.stencilRefBack !== dss.stencilRefBack || cacheDSS.stencilReadMaskBack !== dss.stencilReadMaskBack) {
                    gl.stencilFuncSeparate(1029, WebGLCmpFuncs$1[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
                    cacheDSS.stencilFuncBack = dss.stencilFuncBack;
                    cacheDSS.stencilRefBack = dss.stencilRefBack;
                    cacheDSS.stencilReadMaskBack = dss.stencilReadMaskBack;
                  }
                  if (cacheDSS.stencilFailOpBack !== dss.stencilFailOpBack || cacheDSS.stencilZFailOpBack !== dss.stencilZFailOpBack || cacheDSS.stencilPassOpBack !== dss.stencilPassOpBack) {
                    gl.stencilOpSeparate(1029, WebGLStencilOps$1[dss.stencilFailOpBack], WebGLStencilOps$1[dss.stencilZFailOpBack], WebGLStencilOps$1[dss.stencilPassOpBack]);
                    cacheDSS.stencilFailOpBack = dss.stencilFailOpBack;
                    cacheDSS.stencilZFailOpBack = dss.stencilZFailOpBack;
                    cacheDSS.stencilPassOpBack = dss.stencilPassOpBack;
                  }
                  if (cacheDSS.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(1029, dss.stencilWriteMaskBack);
                    cacheDSS.stencilWriteMaskBack = dss.stencilWriteMaskBack;
                  }
                }
                var bs = gpuPipelineState.bs;
                if (bs) {
                  if (cacheBS.isA2C !== bs.isA2C) {
                    if (bs.isA2C) {
                      gl.enable(32926);
                    } else {
                      gl.disable(32926);
                    }
                    cacheBS.isA2C = bs.isA2C;
                  }
                  if (cacheBS.blendColor.x !== bs.blendColor.x || cacheBS.blendColor.y !== bs.blendColor.y || cacheBS.blendColor.z !== bs.blendColor.z || cacheBS.blendColor.w !== bs.blendColor.w) {
                    gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
                    cacheBS.blendColor.x = bs.blendColor.x;
                    cacheBS.blendColor.y = bs.blendColor.y;
                    cacheBS.blendColor.z = bs.blendColor.z;
                    cacheBS.blendColor.w = bs.blendColor.w;
                  }
                  var target0 = bs.targets[0];
                  var target0Cache = cacheBS.targets[0];
                  if (target0Cache.blend !== target0.blend) {
                    if (target0.blend) {
                      gl.enable(3042);
                    } else {
                      gl.disable(3042);
                    }
                    target0Cache.blend = target0.blend;
                  }
                  if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
                    gl.blendEquationSeparate(WebGLBlendOps$1[target0.blendEq], WebGLBlendOps$1[target0.blendAlphaEq]);
                    target0Cache.blendEq = target0.blendEq;
                    target0Cache.blendAlphaEq = target0.blendAlphaEq;
                  }
                  if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
                    gl.blendFuncSeparate(WebGLBlendFactors$1[target0.blendSrc], WebGLBlendFactors$1[target0.blendDst], WebGLBlendFactors$1[target0.blendSrcAlpha], WebGLBlendFactors$1[target0.blendDstAlpha]);
                    target0Cache.blendSrc = target0.blendSrc;
                    target0Cache.blendDst = target0.blendDst;
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
                    target0Cache.blendDstAlpha = target0.blendDstAlpha;
                  }
                  if (target0Cache.blendColorMask !== target0.blendColorMask) {
                    gl.colorMask((target0.blendColorMask & 1) !== 0, (target0.blendColorMask & 2) !== 0, (target0.blendColorMask & 4) !== 0, (target0.blendColorMask & 8) !== 0);
                    target0Cache.blendColorMask = target0.blendColorMask;
                  }
                }
              }
              if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
                var blockLen = gpuShader.glBlocks.length;
                var dynamicOffsetIndices = gpuPipelineState.gpuPipelineLayout.dynamicOffsetIndices;
                for (var j = 0; j < blockLen; j++) {
                  var glBlock = gpuShader.glBlocks[j];
                  var gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
                  var descriptorIdx = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
                  var gpuDescriptor = descriptorIdx >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIdx];
                  var vf32 = null;
                  var offset = 0;
                  if (gpuDescriptor && gpuDescriptor.gpuBuffer) {
                    var gpuBuffer = gpuDescriptor.gpuBuffer;
                    var dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
                    var dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];
                    if (dynamicOffsetIndex >= 0) {
                      offset = dynamicOffsets[dynamicOffsetIndex];
                    }
                    if ('vf32' in gpuBuffer) {
                      vf32 = gpuBuffer.vf32;
                    } else {
                      offset += gpuBuffer.offset;
                      vf32 = gpuBuffer.gpuBuffer.vf32;
                    }
                    offset >>= 2;
                  }
                  if (!vf32) {
                    continue;
                  }
                  var uniformLen = glBlock.glActiveUniforms.length;
                  for (var l = 0; l < uniformLen; l++) {
                    var glUniform = glBlock.glActiveUniforms[l];
                    switch (glUniform.glType) {
                      case 35670:
                      case 5124:
                        {
                          for (var u = 0; u < glUniform.array.length; ++u) {
                            var idx = glUniform.offset + offset + u;
                            if (vf32[idx] !== glUniform.array[u]) {
                              for (var n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }
                              gl.uniform1iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 35671:
                      case 35667:
                        {
                          for (var _u = 0; _u < glUniform.array.length; ++_u) {
                            var _idx = glUniform.offset + offset + _u;
                            if (vf32[_idx] !== glUniform.array[_u]) {
                              for (var _n = _u, _m = _idx; _n < glUniform.array.length; ++_n, ++_m) {
                                glUniform.array[_n] = vf32[_m];
                              }
                              gl.uniform2iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 35672:
                      case 35668:
                        {
                          for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                            var _idx2 = glUniform.offset + offset + _u2;
                            if (vf32[_idx2] !== glUniform.array[_u2]) {
                              for (var _n2 = _u2, _m2 = _idx2; _n2 < glUniform.array.length; ++_n2, ++_m2) {
                                glUniform.array[_n2] = vf32[_m2];
                              }
                              gl.uniform3iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 35673:
                      case 35669:
                        {
                          for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                            var _idx3 = glUniform.offset + offset + _u3;
                            if (vf32[_idx3] !== glUniform.array[_u3]) {
                              for (var _n3 = _u3, _m3 = _idx3; _n3 < glUniform.array.length; ++_n3, ++_m3) {
                                glUniform.array[_n3] = vf32[_m3];
                              }
                              gl.uniform4iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 5126:
                        {
                          for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                            var _idx4 = glUniform.offset + offset + _u4;
                            if (vf32[_idx4] !== glUniform.array[_u4]) {
                              for (var _n4 = _u4, _m4 = _idx4; _n4 < glUniform.array.length; ++_n4, ++_m4) {
                                glUniform.array[_n4] = vf32[_m4];
                              }
                              gl.uniform1fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 35664:
                        {
                          for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                            var _idx5 = glUniform.offset + offset + _u5;
                            if (vf32[_idx5] !== glUniform.array[_u5]) {
                              for (var _n5 = _u5, _m5 = _idx5; _n5 < glUniform.array.length; ++_n5, ++_m5) {
                                glUniform.array[_n5] = vf32[_m5];
                              }
                              gl.uniform2fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 35665:
                        {
                          for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                            var _idx6 = glUniform.offset + offset + _u6;
                            if (vf32[_idx6] !== glUniform.array[_u6]) {
                              for (var _n6 = _u6, _m6 = _idx6; _n6 < glUniform.array.length; ++_n6, ++_m6) {
                                glUniform.array[_n6] = vf32[_m6];
                              }
                              gl.uniform3fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 35666:
                        {
                          for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                            var _idx7 = glUniform.offset + offset + _u7;
                            if (vf32[_idx7] !== glUniform.array[_u7]) {
                              for (var _n7 = _u7, _m7 = _idx7; _n7 < glUniform.array.length; ++_n7, ++_m7) {
                                glUniform.array[_n7] = vf32[_m7];
                              }
                              gl.uniform4fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 35674:
                        {
                          for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                            var _idx8 = glUniform.offset + offset + _u8;
                            if (vf32[_idx8] !== glUniform.array[_u8]) {
                              for (var _n8 = _u8, _m8 = _idx8; _n8 < glUniform.array.length; ++_n8, ++_m8) {
                                glUniform.array[_n8] = vf32[_m8];
                              }
                              gl.uniformMatrix2fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 35675:
                        {
                          for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                            var _idx9 = glUniform.offset + offset + _u9;
                            if (vf32[_idx9] !== glUniform.array[_u9]) {
                              for (var _n9 = _u9, _m9 = _idx9; _n9 < glUniform.array.length; ++_n9, ++_m9) {
                                glUniform.array[_n9] = vf32[_m9];
                              }
                              gl.uniformMatrix3fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                      case 35676:
                        {
                          for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                            var _idx10 = glUniform.offset + offset + _u10;
                            if (vf32[_idx10] !== glUniform.array[_u10]) {
                              for (var _n10 = _u10, _m10 = _idx10; _n10 < glUniform.array.length; ++_n10, ++_m10) {
                                glUniform.array[_n10] = vf32[_m10];
                              }
                              gl.uniformMatrix4fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }
                          break;
                        }
                    }
                  }
                  continue;
                }
                var samplerLen = gpuShader.glSamplerTextures.length;
                for (var i = 0; i < samplerLen; i++) {
                  var glSampler = gpuShader.glSamplerTextures[i];
                  var _gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
                  var descriptorIndex = _gpuDescriptorSet && _gpuDescriptorSet.descriptorIndices[glSampler.binding];
                  var _gpuDescriptor = descriptorIndex >= 0 && _gpuDescriptorSet.gpuDescriptors[descriptorIndex];
                  var texUnitLen = glSampler.units.length;
                  for (var _l = 0; _l < texUnitLen; _l++) {
                    var texUnit = glSampler.units[_l];
                    if (!_gpuDescriptor || !_gpuDescriptor.gpuSampler) {
                      continue;
                    }
                    if (_gpuDescriptor.gpuTexture && _gpuDescriptor.gpuTexture.size > 0) {
                      var _gpuDescriptor2 = _gpuDescriptor,
                        gpuTexture = _gpuDescriptor2.gpuTexture;
                      var glTexUnit = cache.glTexUnits[texUnit];
                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(33984 + texUnit);
                          cache.texUnit = texUnit;
                        }
                        if (gpuTexture.glTexture) {
                          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                        } else {
                          gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                        }
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }
                      var _gpuDescriptor3 = _gpuDescriptor,
                        gpuSampler = _gpuDescriptor3.gpuSampler;
                      if (gpuTexture.isPowerOf2) {
                        glWrapS = gpuSampler.glWrapS;
                        glWrapT = gpuSampler.glWrapT;
                      } else {
                        glWrapS = 33071;
                        glWrapT = 33071;
                      }
                      if (gpuTexture.isPowerOf2) {
                        if (gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === 9985 || gpuSampler.glMinFilter === 9987)) {
                          glMinFilter = 9729;
                        } else {
                          glMinFilter = gpuSampler.glMinFilter;
                        }
                      } else if (gpuSampler.glMinFilter === 9729 || gpuSampler.glMinFilter === 9985 || gpuSampler.glMinFilter === 9987) {
                        glMinFilter = 9729;
                      } else {
                        glMinFilter = 9728;
                      }
                      if (gpuTexture.glWrapS !== glWrapS) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(33984 + texUnit);
                          cache.texUnit = texUnit;
                        }
                        gl.texParameteri(gpuTexture.glTarget, 10242, glWrapS);
                        gpuTexture.glWrapS = glWrapS;
                      }
                      if (gpuTexture.glWrapT !== glWrapT) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(33984 + texUnit);
                          cache.texUnit = texUnit;
                        }
                        gl.texParameteri(gpuTexture.glTarget, 10243, glWrapT);
                        gpuTexture.glWrapT = glWrapT;
                      }
                      if (gpuTexture.glMinFilter !== glMinFilter) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(33984 + texUnit);
                          cache.texUnit = texUnit;
                        }
                        gl.texParameteri(gpuTexture.glTarget, 10241, glMinFilter);
                        gpuTexture.glMinFilter = glMinFilter;
                      }
                      if (gpuTexture.glMagFilter !== gpuSampler.glMagFilter) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(33984 + texUnit);
                          cache.texUnit = texUnit;
                        }
                        gl.texParameteri(gpuTexture.glTarget, 10240, gpuSampler.glMagFilter);
                        gpuTexture.glMagFilter = gpuSampler.glMagFilter;
                      }
                    }
                    _gpuDescriptor = _gpuDescriptorSet.gpuDescriptors[++descriptorIndex];
                  }
                }
              }
              if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache$1.gpuInputAssembler !== gpuInputAssembler)) {
                gfxStateCache$1.gpuInputAssembler = gpuInputAssembler;
                var ia = device.extensions.ANGLE_instanced_arrays;
                if (device.extensions.useVAO) {
                  var vao = device.extensions.OES_vertex_array_object;
                  var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
                  if (!glVAO) {
                    glVAO = vao.createVertexArrayOES();
                    gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
                    vao.bindVertexArrayOES(glVAO);
                    gl.bindBuffer(34962, null);
                    gl.bindBuffer(34963, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                    var glAttrib;
                    var inputLen = gpuShader.glInputs.length;
                    for (var _j2 = 0; _j2 < inputLen; _j2++) {
                      var glInput = gpuShader.glInputs[_j2];
                      glAttrib = null;
                      var attribLen = gpuInputAssembler.glAttribs.length;
                      for (var k = 0; k < attribLen; k++) {
                        var attrib = gpuInputAssembler.glAttribs[k];
                        if (attrib.name === glInput.name) {
                          glAttrib = attrib;
                          break;
                        }
                      }
                      if (glAttrib) {
                        if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                          gl.bindBuffer(34962, glAttrib.glBuffer);
                          cache.glArrayBuffer = glAttrib.glBuffer;
                        }
                        for (var c = 0; c < glAttrib.componentCount; ++c) {
                          var glLoc = glInput.glLoc + c;
                          var attribOffset = glAttrib.offset + glAttrib.size * c;
                          gl.enableVertexAttribArray(glLoc);
                          cache.glCurrentAttribLocs[glLoc] = true;
                          gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                          if (ia) {
                            ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                          }
                        }
                      }
                    }
                    var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                    if (_gpuBuffer) {
                      gl.bindBuffer(34963, _gpuBuffer.glBuffer);
                    }
                    vao.bindVertexArrayOES(null);
                    gl.bindBuffer(34962, null);
                    gl.bindBuffer(34963, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                  }
                  if (cache.glVAO !== glVAO) {
                    vao.bindVertexArrayOES(glVAO);
                    cache.glVAO = glVAO;
                  }
                } else {
                  for (var a = 0; a < device.capabilities.maxVertexAttributes; ++a) {
                    cache.glCurrentAttribLocs[a] = false;
                  }
                  var _inputLen = gpuShader.glInputs.length;
                  for (var _j3 = 0; _j3 < _inputLen; _j3++) {
                    var _glInput = gpuShader.glInputs[_j3];
                    var _glAttrib = null;
                    var _attribLen = gpuInputAssembler.glAttribs.length;
                    for (var _k5 = 0; _k5 < _attribLen; _k5++) {
                      var _attrib = gpuInputAssembler.glAttribs[_k5];
                      if (_attrib.name === _glInput.name) {
                        _glAttrib = _attrib;
                        break;
                      }
                    }
                    if (_glAttrib) {
                      if (cache.glArrayBuffer !== _glAttrib.glBuffer) {
                        gl.bindBuffer(34962, _glAttrib.glBuffer);
                        cache.glArrayBuffer = _glAttrib.glBuffer;
                      }
                      for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                        var _glLoc4 = _glInput.glLoc + _c;
                        var _attribOffset = _glAttrib.offset + _glAttrib.size * _c;
                        if (!cache.glEnabledAttribLocs[_glLoc4] && _glLoc4 >= 0) {
                          gl.enableVertexAttribArray(_glLoc4);
                          cache.glEnabledAttribLocs[_glLoc4] = true;
                        }
                        cache.glCurrentAttribLocs[_glLoc4] = true;
                        gl.vertexAttribPointer(_glLoc4, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                        if (ia) {
                          ia.vertexAttribDivisorANGLE(_glLoc4, _glAttrib.isInstanced ? 1 : 0);
                        }
                      }
                    }
                  }
                  var _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;
                  if (_gpuBuffer2) {
                    if (cache.glElementArrayBuffer !== _gpuBuffer2.glBuffer) {
                      gl.bindBuffer(34963, _gpuBuffer2.glBuffer);
                      cache.glElementArrayBuffer = _gpuBuffer2.glBuffer;
                    }
                  }
                  for (var _a = 0; _a < device.capabilities.maxVertexAttributes; ++_a) {
                    if (cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a]) {
                      gl.disableVertexAttribArray(_a);
                      cache.glEnabledAttribLocs[_a] = false;
                    }
                  }
                }
              }
              if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
                var dsLen = gpuPipelineState.dynamicStates.length;
                for (var _j4 = 0; _j4 < dsLen; _j4++) {
                  var dynamicState = gpuPipelineState.dynamicStates[_j4];
                  switch (dynamicState) {
                    case 1:
                      {
                        if (cache.rs.lineWidth !== dynamicStates.lineWidth) {
                          gl.lineWidth(dynamicStates.lineWidth);
                          cache.rs.lineWidth = dynamicStates.lineWidth;
                        }
                        break;
                      }
                    case 2:
                      {
                        if (cache.rs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                          gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                          cache.rs.depthBias = dynamicStates.depthBiasConstant;
                          cache.rs.depthBiasSlop = dynamicStates.depthBiasSlope;
                        }
                        break;
                      }
                    case 4:
                      {
                        var blendConstant = dynamicStates.blendConstant;
                        if (cacheBS.blendColor.x !== blendConstant.x || cacheBS.blendColor.y !== blendConstant.y || cacheBS.blendColor.z !== blendConstant.z || cacheBS.blendColor.w !== blendConstant.w) {
                          gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                          cacheBS.blendColor.copy(blendConstant);
                        }
                        break;
                      }
                    case 16:
                      {
                        var front = dynamicStates.stencilStatesFront;
                        var back = dynamicStates.stencilStatesBack;
                        if (cacheDSS.stencilWriteMaskFront !== front.writeMask) {
                          gl.stencilMaskSeparate(1028, front.writeMask);
                          cacheDSS.stencilWriteMaskFront = front.writeMask;
                        }
                        if (cacheDSS.stencilWriteMaskBack !== back.writeMask) {
                          gl.stencilMaskSeparate(1029, back.writeMask);
                          cacheDSS.stencilWriteMaskBack = back.writeMask;
                        }
                        break;
                      }
                    case 32:
                      {
                        var _front = dynamicStates.stencilStatesFront;
                        var _back = dynamicStates.stencilStatesBack;
                        if (cacheDSS.stencilRefFront !== _front.reference || cacheDSS.stencilReadMaskFront !== _front.compareMask) {
                          gl.stencilFuncSeparate(1028, WebGLCmpFuncs$1[cacheDSS.stencilFuncFront], _front.reference, _front.compareMask);
                          cacheDSS.stencilRefFront = _front.reference;
                          cacheDSS.stencilReadMaskFront = _front.compareMask;
                        }
                        if (cacheDSS.stencilRefBack !== _back.reference || cacheDSS.stencilReadMaskBack !== _back.compareMask) {
                          gl.stencilFuncSeparate(1029, WebGLCmpFuncs$1[cacheDSS.stencilFuncBack], _back.reference, _back.compareMask);
                          cacheDSS.stencilRefBack = _back.reference;
                          cacheDSS.stencilReadMaskBack = _back.compareMask;
                        }
                        break;
                      }
                  }
                }
              }
            }
            function WebGLCmdFuncDraw(device, drawInfo) {
              var gl = device.gl;
              var _device$extensions = device.extensions,
                ia = _device$extensions.ANGLE_instanced_arrays,
                md = _device$extensions.WEBGL_multi_draw;
              var gpuInputAssembler = gfxStateCache$1.gpuInputAssembler,
                glPrimitive = gfxStateCache$1.glPrimitive;
              if (gpuInputAssembler) {
                var indexBuffer = gpuInputAssembler.gpuIndexBuffer;
                if (gpuInputAssembler.gpuIndirectBuffer) {
                  var indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;
                  if (indirects.drawByIndex) {
                    for (var j = 0; j < indirects.drawCount; j++) {
                      indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
                    }
                    if (md) {
                      if (indirects.instancedDraw) {
                        md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                      } else {
                        md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                      }
                    } else {
                      for (var _j5 = 0; _j5 < indirects.drawCount; _j5++) {
                        if (indirects.instances[_j5] && ia) {
                          ia.drawElementsInstancedANGLE(glPrimitive, indirects.counts[_j5], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j5], indirects.instances[_j5]);
                        } else {
                          gl.drawElements(glPrimitive, indirects.counts[_j5], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j5]);
                        }
                      }
                    }
                  } else if (md) {
                    if (indirects.instancedDraw) {
                      md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
                    } else {
                      md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
                    }
                  } else {
                    for (var _j6 = 0; _j6 < indirects.drawCount; _j6++) {
                      if (indirects.instances[_j6] && ia) {
                        ia.drawArraysInstancedANGLE(glPrimitive, indirects.offsets[_j6], indirects.counts[_j6], indirects.instances[_j6]);
                      } else {
                        gl.drawArrays(glPrimitive, indirects.offsets[_j6], indirects.counts[_j6]);
                      }
                    }
                  }
                } else if (drawInfo.instanceCount && ia) {
                  if (indexBuffer) {
                    if (drawInfo.indexCount > 0) {
                      var offset = drawInfo.firstIndex * indexBuffer.stride;
                      ia.drawElementsInstancedANGLE(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
                    }
                  } else if (drawInfo.vertexCount > 0) {
                    ia.drawArraysInstancedANGLE(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
                  }
                } else if (indexBuffer) {
                  if (drawInfo.indexCount > 0) {
                    var _offset = drawInfo.firstIndex * indexBuffer.stride;
                    gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                  }
                } else if (drawInfo.vertexCount > 0) {
                  gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                }
              }
            }
            function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
              var gl = device.gl,
                stateCache = device.stateCache;
              var glTexUnit = stateCache.glTexUnits[stateCache.texUnit];
              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }
              var n = 0;
              var f = 0;
              switch (gpuTexture.glTarget) {
                case 3553:
                  {
                    for (var i = 0; i < regions.length; i++) {
                      var region = regions[i];
                      gl.texSubImage2D(3553, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                    }
                    break;
                  }
                case 34067:
                  {
                    for (var _i19 = 0; _i19 < regions.length; _i19++) {
                      var _region = regions[_i19];
                      var regionTexOffset = _region.texOffset;
                      var regionTexSubres = _region.texSubres;
                      var fcount = regionTexSubres.baseArrayLayer + regionTexSubres.layerCount;
                      for (f = regionTexSubres.baseArrayLayer; f < fcount; ++f) {
                        gl.texSubImage2D(34069 + f, regionTexSubres.mipLevel, regionTexOffset.x, regionTexOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }
                    break;
                  }
                default:
                  {
                    errorID(16327);
                  }
              }
              if (gpuTexture.flags & 1 && gpuTexture.isPowerOf2) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            var stagingBuffer$1 = new Uint8Array(1);
            function pixelBufferPick$1(buffer, format, offset, stride, extent) {
              var blockHeight = formatAlignment(format).height;
              var bufferSize = FormatSize(format, extent.width, extent.height, extent.depth);
              var rowStride = FormatSize(format, stride.width, 1, 1);
              var sliceStride = FormatSize(format, stride.width, stride.height, 1);
              var chunkSize = FormatSize(format, extent.width, 1, 1);
              var ArrayBufferCtor = getTypedArrayConstructor(FormatInfos[format]);
              if (stagingBuffer$1.byteLength < bufferSize) {
                stagingBuffer$1 = new Uint8Array(bufferSize);
              }
              var destOffset = 0;
              var bufferOffset = offset;
              for (var i = 0; i < extent.depth; i++) {
                bufferOffset = offset + sliceStride * i;
                for (var j = 0; j < extent.height; j += blockHeight) {
                  stagingBuffer$1.subarray(destOffset, destOffset + chunkSize).set(new Uint8Array(buffer.buffer, buffer.byteOffset + bufferOffset, chunkSize));
                  destOffset += chunkSize;
                  bufferOffset += rowStride;
                }
              }
              var length = bufferSize / ArrayBufferCtor.BYTES_PER_ELEMENT;
              assertID(Number.isInteger(length), 9101);
              return new ArrayBufferCtor(stagingBuffer$1.buffer, 0, length);
            }
            function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
              var gl = device.gl,
                stateCache = device.stateCache;
              var glTexUnit = stateCache.glTexUnits[stateCache.texUnit];
              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }
              var n = 0;
              var f = 0;
              var fmtInfo = FormatInfos[gpuTexture.format];
              var ArrayBufferCtor = getTypedArrayConstructor(fmtInfo);
              var isCompressed = fmtInfo.isCompressed;
              var blockSize = formatAlignment(gpuTexture.format);
              var extent = new Extent();
              var offset = new Offset();
              var stride = new Extent();
              switch (gpuTexture.glTarget) {
                case 3553:
                  {
                    for (var i = 0; i < regions.length; i++) {
                      var region = regions[i];
                      var mipLevel = region.texSubres.mipLevel;
                      var regionTexOffset = region.texOffset;
                      var regionTexExtent = region.texExtent;
                      var regionTexExtentWidth = regionTexExtent.width;
                      var regionTexExtentHeight = regionTexExtent.height;
                      var blockSizeWidth = blockSize.width;
                      var blockSizeHeight = blockSize.height;
                      var regionBuffStride = region.buffStride;
                      offset.x = regionTexOffset.x === 0 ? 0 : alignTo(regionTexOffset.x, blockSizeWidth);
                      offset.y = regionTexOffset.y === 0 ? 0 : alignTo(regionTexOffset.y, blockSizeHeight);
                      extent.width = regionTexExtentWidth < blockSizeWidth ? regionTexExtentWidth : alignTo(regionTexExtentWidth, blockSizeWidth);
                      extent.height = regionTexExtentHeight < blockSizeHeight ? regionTexExtentWidth : alignTo(regionTexExtentHeight, blockSizeHeight);
                      stride.width = regionBuffStride > 0 ? regionBuffStride : extent.width;
                      stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                      var destWidth = regionTexExtentWidth + offset.x === gpuTexture.width >> mipLevel ? regionTexExtentWidth : extent.width;
                      var destHeight = regionTexExtentHeight + offset.y === gpuTexture.height >> mipLevel ? regionTexExtentHeight : extent.height;
                      var pixels = undefined;
                      var buffer = buffers[n++];
                      if (stride.width === extent.width && stride.height === extent.height) {
                        var length = FormatSize(gpuTexture.format, destWidth, destHeight, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                        assertID(Number.isInteger(length), 9101);
                        pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset, length);
                      } else {
                        pixels = pixelBufferPick$1(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                      }
                      if (!isCompressed) {
                        gl.texSubImage2D(3553, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                      } else if (gpuTexture.glInternalFmt !== 36196 && !device.extensions.noCompressedTexSubImage2D) {
                        gl.compressedTexSubImage2D(3553, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                      } else {
                        gl.compressedTexImage2D(3553, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                      }
                    }
                    break;
                  }
                case 34067:
                  {
                    for (var _i20 = 0; _i20 < regions.length; _i20++) {
                      var _region2 = regions[_i20];
                      var _mipLevel = _region2.texSubres.mipLevel;
                      var _regionTexOffset = _region2.texOffset;
                      var _regionTexExtent = _region2.texExtent;
                      var regionTexSubres = _region2.texSubres;
                      var _regionTexExtentWidth = _regionTexExtent.width;
                      var _regionTexExtentHeight = _regionTexExtent.height;
                      var _blockSizeWidth = blockSize.width;
                      var _blockSizeHeight = blockSize.height;
                      offset.x = _regionTexOffset.x === 0 ? 0 : alignTo(_regionTexOffset.x, _blockSizeWidth);
                      offset.y = _regionTexOffset.y === 0 ? 0 : alignTo(_regionTexOffset.y, _blockSizeHeight);
                      extent.width = _regionTexExtentWidth < _blockSizeWidth ? _regionTexExtentWidth : alignTo(_regionTexExtentWidth, _blockSizeWidth);
                      extent.height = _regionTexExtentHeight < _blockSizeHeight ? _regionTexExtentWidth : alignTo(_regionTexExtentHeight, _blockSizeHeight);
                      stride.width = _region2.buffStride > 0 ? _region2.buffStride : extent.width;
                      stride.height = _region2.buffTexHeight > 0 ? _region2.buffTexHeight : extent.height;
                      var _destWidth = _regionTexExtentWidth + offset.x === gpuTexture.width >> _mipLevel ? _regionTexExtentWidth : extent.width;
                      var _destHeight = _regionTexExtentHeight + offset.y === gpuTexture.height >> _mipLevel ? _regionTexExtentHeight : extent.height;
                      var fcount = regionTexSubres.baseArrayLayer + regionTexSubres.layerCount;
                      for (f = regionTexSubres.baseArrayLayer; f < fcount; ++f) {
                        var _pixels = undefined;
                        var _buffer = buffers[n++];
                        if (stride.width === extent.width && stride.height === extent.height) {
                          var _length = FormatSize(gpuTexture.format, _destWidth, _destHeight, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                          assertID(Number.isInteger(_length), 9101);
                          _pixels = new ArrayBufferCtor(_buffer.buffer, _buffer.byteOffset + _region2.buffOffset, _length);
                        } else {
                          _pixels = pixelBufferPick$1(_buffer, gpuTexture.format, _region2.buffOffset, stride, extent);
                        }
                        if (!isCompressed) {
                          gl.texSubImage2D(34069 + f, _mipLevel, offset.x, offset.y, _destWidth, _destHeight, gpuTexture.glFormat, gpuTexture.glType, _pixels);
                        } else if (gpuTexture.glInternalFmt !== 36196 && !device.extensions.noCompressedTexSubImage2D) {
                          gl.compressedTexSubImage2D(34069 + f, _mipLevel, offset.x, offset.y, _destWidth, _destHeight, gpuTexture.glFormat, _pixels);
                        } else {
                          gl.compressedTexImage2D(34069 + f, _mipLevel, gpuTexture.glInternalFmt, _destWidth, _destHeight, 0, _pixels);
                        }
                      }
                    }
                    break;
                  }
                default:
                  {
                    errorID(16327);
                  }
              }
              if (gpuTexture.flags & 1) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGLCmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
              var gl = device.gl;
              var cache = device.stateCache;
              var framebuffer = gl.createFramebuffer();
              gl.bindFramebuffer(36160, framebuffer);
              var x = 0;
              var y = 0;
              var w = 1;
              var h = 1;
              switch (gpuTexture.glTarget) {
                case 3553:
                  {
                    for (var k = 0; k < regions.length; k++) {
                      var region = regions[k];
                      gl.framebufferTexture2D(36160, 36064, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                      x = region.texOffset.x;
                      y = region.texOffset.y;
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
                    }
                    break;
                  }
                default:
                  {
                    errorID(16399);
                  }
              }
              gl.bindFramebuffer(36160, null);
              cache.glFramebuffer = null;
              gl.deleteFramebuffer(framebuffer);
            }
            function WebGLCmdFuncBlitTexture(device, srcTexture, dstTexture, regions, filter) {
              device.blitManager.draw(srcTexture, dstTexture, regions, filter);
            }

            var WebGLDeviceManager = function () {
              function WebGLDeviceManager() {}
              WebGLDeviceManager.setInstance = function setInstance(instance) {
                WebGLDeviceManager._instance = instance;
              };
              _createClass(WebGLDeviceManager, null, [{
                key: "instance",
                get: function get() {
                  return WebGLDeviceManager._instance;
                }
              }]);
              return WebGLDeviceManager;
            }();
            WebGLDeviceManager._instance = null;

            function createInt32Array(capacity) {
              return new Int32Array(capacity);
            }
            var WebGLIndirectDrawInfos = function () {
              function WebGLIndirectDrawInfos() {
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
                this._capacity = 4;
                this.counts = createInt32Array(this._capacity);
                this.offsets = createInt32Array(this._capacity);
                this.instances = createInt32Array(this._capacity);
                this.byteOffsets = createInt32Array(this._capacity);
              }
              var _proto = WebGLIndirectDrawInfos.prototype;
              _proto.clearDraws = function clearDraws() {
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
              };
              _proto.setDrawInfo = function setDrawInfo(idx, info) {
                this._ensureCapacity(idx);
                this.drawByIndex = info.indexCount > 0;
                this.instancedDraw = !!info.instanceCount;
                this.drawCount = Math.max(idx + 1, this.drawCount);
                if (this.drawByIndex) {
                  this.counts[idx] = info.indexCount;
                  this.offsets[idx] = info.firstIndex;
                } else {
                  this.counts[idx] = info.vertexCount;
                  this.offsets[idx] = info.firstVertex;
                }
                this.instances[idx] = Math.max(1, info.instanceCount);
              };
              _proto._ensureCapacity = function _ensureCapacity(target) {
                if (this._capacity > target) return;
                this._capacity = nextPow2$1(target);
                var counts = createInt32Array(this._capacity);
                var offsets = createInt32Array(this._capacity);
                var instances = createInt32Array(this._capacity);
                this.byteOffsets = createInt32Array(this._capacity);
                counts.set(this.counts);
                offsets.set(this.offsets);
                instances.set(this.instances);
                this.counts = counts;
                this.offsets = offsets;
                this.instances = instances;
              };
              return WebGLIndirectDrawInfos;
            }();
            var IWebGLBlitManager = function () {
              function IWebGLBlitManager() {
                this._gpuShader = null;
                this._gpuDescriptorSetLayout = null;
                this._gpuPipelineLayout = null;
                this._gpuPipelineState = null;
                this._gpuVertexBuffer = null;
                this._gpuInputAssembler = null;
                this._gpuPointSampler = null;
                this._gpuLinearSampler = null;
                this._gpuDescriptorSet = null;
                this._gpuUniformBuffer = null;
                this._drawInfo = null;
                this._glFramebuffer = null;
                this._uniformBuffer = null;
                var device = WebGLDeviceManager.instance;
                var samplerOffset = device.bindingMappingInfo.maxBlockCounts[0];
                this._gpuShader = {
                  name: 'Blit Pass',
                  blocks: [new UniformBlock(0, 0, "BlitParams", [new Uniform("tilingOffsetSrc", 16, 1), new Uniform("tilingOffsetDst", 16, 1)], 1)],
                  samplerTextures: [new UniformSamplerTexture(0, samplerOffset, 'textureSrc', 28, 1)],
                  subpassInputs: [],
                  gpuStages: [{
                    type: 1,
                    source: "\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform vec4 tilingOffsetSrc;\nuniform vec4 tilingOffsetDst;\nvarying vec2 v_texCoord;\nvoid main() {\n    v_texCoord = a_texCoord * tilingOffsetSrc.xy + tilingOffsetSrc.zw;\n    gl_Position = vec4((a_position + 1.0) * tilingOffsetDst.xy - 1.0 + tilingOffsetDst.zw * 2.0, 0, 1);\n}",
                    glShader: null
                  }, {
                    type: 16,
                    source: "\nprecision mediump float;\nuniform sampler2D textureSrc;\nvarying vec2 v_texCoord;\nvoid main() {\n    gl_FragColor = texture2D(textureSrc, v_texCoord);\n}",
                    glShader: null
                  }],
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplerTextures: []
                };
                WebGLCmdFuncCreateShader(WebGLDeviceManager.instance, this._gpuShader);
                this._gpuDescriptorSetLayout = {
                  bindings: [new DescriptorSetLayoutBinding(0, 1, 1, 1), new DescriptorSetLayoutBinding(samplerOffset, 16, 1, 16)],
                  dynamicBindings: [],
                  descriptorIndices: [],
                  descriptorCount: samplerOffset + 1
                };
                for (var i = 0; i < samplerOffset; i++) {
                  this._gpuDescriptorSetLayout.descriptorIndices[i] = 0;
                }
                this._gpuDescriptorSetLayout.descriptorIndices.push(1);
                this._gpuPipelineLayout = {
                  gpuSetLayouts: [this._gpuDescriptorSetLayout],
                  dynamicOffsetCount: 0,
                  dynamicOffsetOffsets: [0],
                  dynamicOffsetIndices: [[]]
                };
                this._gpuPipelineState = {
                  glPrimitive: 5,
                  gpuShader: this._gpuShader,
                  gpuPipelineLayout: this._gpuPipelineLayout,
                  rs: null,
                  dss: new DepthStencilState(false, false),
                  bs: null,
                  dynamicStates: [],
                  gpuRenderPass: null
                };
                this._gpuVertexBuffer = {
                  usage: 8,
                  memUsage: 1,
                  size: 16 * 4,
                  stride: 4 * 4,
                  buffer: null,
                  vf32: null,
                  indirects: new WebGLIndirectDrawInfos(),
                  glTarget: 0,
                  glBuffer: null
                };
                WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuVertexBuffer);
                WebGLDeviceManager.instance.memoryStatus.bufferSize += this._gpuVertexBuffer.size;
                var data = new Float32Array([-1, -1, 0.0, 0.0, 1.0, -1, 1.0, 0.0, -1, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0]);
                WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, this._gpuVertexBuffer, data, 0, data.length);
                this._gpuInputAssembler = {
                  attributes: [new Attribute("a_position", 21), new Attribute("a_texCoord", 21)],
                  gpuVertexBuffers: [this._gpuVertexBuffer],
                  gpuIndexBuffer: null,
                  gpuIndirectBuffer: null,
                  glAttribs: [],
                  glIndexType: 0,
                  glVAOs: new Map()
                };
                WebGLCmdFuncCreateInputAssember(WebGLDeviceManager.instance, this._gpuInputAssembler);
                this._gpuPointSampler = {
                  glMinFilter: 0x2600,
                  glMagFilter: 0x2600,
                  glWrapS: 0x2901,
                  glWrapT: 0x2901,
                  glWrapR: 0x2901
                };
                this._gpuLinearSampler = {
                  glMinFilter: 0x2601,
                  glMagFilter: 0x2601,
                  glWrapS: 0x2901,
                  glWrapT: 0x2901,
                  glWrapR: 0x2901
                };
                this._uniformBuffer = new Float32Array(8);
                this._gpuUniformBuffer = {
                  usage: 16,
                  memUsage: 1,
                  size: 8 * 4,
                  stride: 8 * 4,
                  buffer: this._uniformBuffer,
                  vf32: null,
                  indirects: new WebGLIndirectDrawInfos(),
                  glTarget: 0,
                  glBuffer: null
                };
                WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuUniformBuffer);
                WebGLDeviceManager.instance.memoryStatus.bufferSize += this._gpuUniformBuffer.size;
                this._gpuDescriptorSet = {
                  gpuDescriptors: [{
                    type: 1,
                    gpuBuffer: this._gpuUniformBuffer,
                    gpuTexture: null,
                    gpuSampler: null
                  }, {
                    type: 16,
                    gpuBuffer: null,
                    gpuTexture: null,
                    gpuSampler: null
                  }],
                  descriptorIndices: this._gpuDescriptorSetLayout.descriptorIndices
                };
                this._drawInfo = new DrawInfo(4, 0, 0, 0, 0, 0, 0);
                this._glFramebuffer = WebGLDeviceManager.instance.gl.createFramebuffer();
              }
              var _proto2 = IWebGLBlitManager.prototype;
              _proto2.destroy = function destroy() {
                if (this._glFramebuffer) {
                  WebGLDeviceManager.instance.gl.deleteFramebuffer(this._glFramebuffer);
                  this._glFramebuffer = null;
                }
                if (this._gpuVertexBuffer) {
                  WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._gpuVertexBuffer.size;
                  WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuVertexBuffer);
                }
                if (this._gpuUniformBuffer) {
                  WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._gpuUniformBuffer.size;
                  WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuUniformBuffer);
                }
                if (this._gpuShader) {
                  WebGLCmdFuncDestroyShader(WebGLDeviceManager.instance, this._gpuShader);
                }
                if (this._gpuInputAssembler) {
                  WebGLCmdFuncDestroyInputAssembler(WebGLDeviceManager.instance, this._gpuInputAssembler);
                }
              };
              _proto2.draw = function draw(gpuTextureSrc, gpuTextureDst, regions, filter) {
                var device = WebGLDeviceManager.instance;
                var gl = device.gl;
                var stateCache = device.stateCache;
                var origFramebuffer = stateCache.glFramebuffer;
                gl.viewport(0, 0, gpuTextureDst.width, gpuTextureDst.height);
                gl.scissor(0, 0, gpuTextureDst.width, gpuTextureDst.height);
                if (!this._uniformBuffer || !this._gpuUniformBuffer || !this._gpuPipelineState || !this._gpuInputAssembler || !this._gpuDescriptorSet || !this._drawInfo) {
                  return;
                }
                var descriptor = this._gpuDescriptorSet.gpuDescriptors[1];
                descriptor.gpuTexture = gpuTextureSrc;
                descriptor.gpuSampler = filter === 1 ? this._gpuPointSampler : this._gpuLinearSampler;
                var formatInfo = FormatInfos[gpuTextureDst.format];
                var attachment = 36064;
                if (formatInfo.hasStencil) {
                  attachment = 33306;
                } else if (formatInfo.hasDepth) {
                  attachment = 36096;
                }
                var regionIndices = regions.map(function (_, i) {
                  return i;
                });
                regionIndices.sort(function (a, b) {
                  return regions[a].srcSubres.mipLevel - regions[b].srcSubres.mipLevel;
                });
                if (stateCache.glFramebuffer !== this._glFramebuffer) {
                  gl.bindFramebuffer(36160, this._glFramebuffer);
                  stateCache.glFramebuffer = this._glFramebuffer;
                }
                var mipLevel = regions[0].dstSubres.mipLevel;
                if (gpuTextureDst.glTexture) {
                  gl.framebufferTexture2D(36160, attachment, gpuTextureDst.glTarget, gpuTextureDst.glTexture, mipLevel);
                } else {
                  gl.framebufferRenderbuffer(36160, attachment, 36161, gpuTextureDst.glRenderbuffer);
                }
                for (var i = 0; i < regionIndices.length; ++i) {
                  var region = regions[regionIndices[i]];
                  if (gpuTextureSrc.glTexture && mipLevel !== region.srcSubres.mipLevel) {
                    mipLevel = region.srcSubres.mipLevel;
                    gl.framebufferTexture2D(36160, attachment, gpuTextureDst.glTarget, gpuTextureDst.glTexture, mipLevel);
                  }
                  var srcWidth = gpuTextureSrc.width;
                  var srcHeight = gpuTextureSrc.height;
                  var dstWidth = gpuTextureDst.width;
                  var dstHeight = gpuTextureDst.height;
                  this._uniformBuffer[0] = region.srcExtent.width / srcWidth;
                  this._uniformBuffer[1] = region.srcExtent.height / srcHeight;
                  this._uniformBuffer[2] = region.srcOffset.x / srcWidth;
                  this._uniformBuffer[3] = region.srcOffset.y / srcHeight;
                  this._uniformBuffer[4] = region.dstExtent.width / dstWidth;
                  this._uniformBuffer[5] = region.dstExtent.height / dstHeight;
                  this._uniformBuffer[6] = region.dstOffset.x / dstWidth;
                  this._uniformBuffer[7] = region.dstOffset.y / dstHeight;
                  WebGLCmdFuncUpdateBuffer(device, this._gpuUniformBuffer, this._uniformBuffer, 0, this._uniformBuffer.length * 4);
                  WebGLCmdFuncBindStates(device, this._gpuPipelineState, this._gpuInputAssembler, [this._gpuDescriptorSet], [], null);
                  WebGLCmdFuncDraw(device, this._drawInfo);
                }
                if (stateCache.glFramebuffer !== origFramebuffer) {
                  gl.bindFramebuffer(36160, origFramebuffer);
                  stateCache.glFramebuffer = origFramebuffer;
                }
                var origViewport = stateCache.viewport;
                gl.viewport(origViewport.left, origViewport.top, origViewport.width, origViewport.height);
                var origScissor = stateCache.scissorRect;
                gl.scissor(origScissor.x, origScissor.y, origScissor.width, origScissor.height);
              };
              return IWebGLBlitManager;
            }();

            var WebGLBuffer = function (_Buffer) {
              _inheritsLoose(WebGLBuffer, _Buffer);
              function WebGLBuffer() {
                var _this;
                _this = _Buffer.call(this) || this;
                _this._gpuBuffer = null;
                _this._gpuBufferView = null;
                _this._uniformBuffer = null;
                return _this;
              }
              var _proto = WebGLBuffer.prototype;
              _proto.initialize = function initialize(info) {
                if ('buffer' in info) {
                  this._isBufferView = true;
                  var buffer = info.buffer;
                  this._usage = buffer.usage;
                  this._memUsage = buffer.memUsage;
                  this._size = this._stride = info.range;
                  this._count = 1;
                  this._flags = buffer.flags;
                  this._gpuBufferView = {
                    gpuBuffer: buffer.gpuBuffer,
                    offset: info.offset,
                    range: info.range
                  };
                } else {
                  this._usage = info.usage;
                  this._memUsage = info.memUsage;
                  this._size = info.size;
                  this._stride = Math.max(info.stride || this._size, 1);
                  this._count = this._size / this._stride;
                  this._flags = info.flags;
                  if (this._usage & 16 && this._size > 0) {
                    this._uniformBuffer = new Uint8Array(this._size);
                  }
                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: null,
                    vf32: null,
                    indirects: new WebGLIndirectDrawInfos(),
                    glTarget: 0,
                    glBuffer: null
                  };
                  if (this._usage & 16) {
                    this._gpuBuffer.buffer = this._uniformBuffer;
                  }
                  WebGLCmdFuncCreateBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
                  WebGLDeviceManager.instance.memoryStatus.bufferSize += this._size;
                }
              };
              _proto.destroy = function destroy() {
                if (this._gpuBuffer) {
                  WebGLCmdFuncDestroyBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
                  WebGLDeviceManager.instance.memoryStatus.bufferSize -= this._size;
                  this._gpuBuffer = null;
                }
                if (this._gpuBufferView) {
                  this._gpuBufferView = null;
                }
              };
              _proto.resize = function resize(size) {
                if (this._isBufferView) {
                  warnID(16379);
                  return;
                }
                var oldSize = this._size;
                if (oldSize === size) {
                  return;
                }
                this._size = size;
                this._count = this._size / this._stride;
                if (this._uniformBuffer) {
                  this._uniformBuffer = new Uint8Array(size);
                }
                if (this._gpuBuffer) {
                  if (this._uniformBuffer) {
                    this._gpuBuffer.buffer = this._uniformBuffer;
                  }
                  this._gpuBuffer.size = size;
                  if (size > 0) {
                    WebGLCmdFuncResizeBuffer(WebGLDeviceManager.instance, this._gpuBuffer);
                    WebGLDeviceManager.instance.memoryStatus.bufferSize -= oldSize;
                    WebGLDeviceManager.instance.memoryStatus.bufferSize += size;
                  }
                }
              };
              _proto.update = function update(buffer, size) {
                if (this._isBufferView) {
                  warnID(16380);
                  return;
                }
                var buffSize;
                if (size !== undefined) {
                  buffSize = size;
                } else if (this._usage & 64) {
                  buffSize = 0;
                } else {
                  buffSize = buffer.byteLength;
                }
                WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
              };
              _createClass(WebGLBuffer, [{
                key: "gpuBuffer",
                get: function get() {
                  return this._gpuBuffer;
                }
              }, {
                key: "gpuBufferView",
                get: function get() {
                  return this._gpuBufferView;
                }
              }]);
              return WebGLBuffer;
            }(Buffer);

            var WebGLCommandBuffer = function (_CommandBuffer) {
              _inheritsLoose(WebGLCommandBuffer, _CommandBuffer);
              function WebGLCommandBuffer() {
                var _this;
                _this = _CommandBuffer.call(this) || this;
                _this._isInRenderPass = false;
                _this._curGPUPipelineState = null;
                _this._curGPUInputAssembler = null;
                _this._curGPUDescriptorSets = [];
                _this._curDynamicOffsets = Array(8).fill(0);
                _this._curDynamicStates = new DynamicStates();
                _this._isStateInvalied = false;
                return _this;
              }
              var _proto = WebGLCommandBuffer.prototype;
              _proto.initialize = function initialize(info) {
                this._type = info.type;
                this._queue = info.queue;
                var setCount = WebGLDeviceManager.instance.bindingMappings.blockOffsets.length;
                for (var i = 0; i < setCount; i++) {
                  this._curGPUDescriptorSets.push(null);
                }
              };
              _proto.destroy = function destroy() {};
              _proto.begin = function begin(renderPass, subpass, frameBuffer) {
                this._curGPUPipelineState = null;
                this._curGPUInputAssembler = null;
                this._curGPUDescriptorSets.length = 0;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
              };
              _proto.end = function end() {
                if (this._isStateInvalied) {
                  this.bindStates();
                }
                this._isInRenderPass = false;
              };
              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                errorID(16401);
                this._isInRenderPass = true;
              };
              _proto.endRenderPass = function endRenderPass() {
                this._isInRenderPass = false;
              };
              _proto.bindPipelineState = function bindPipelineState(pipelineState) {
                var gpuPipelineState = pipelineState.gpuPipelineState;
                if (gpuPipelineState !== this._curGPUPipelineState) {
                  this._curGPUPipelineState = gpuPipelineState;
                  this._isStateInvalied = true;
                }
              };
              _proto.bindDescriptorSet = function bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
                var gpuDescriptorSet = descriptorSet.gpuDescriptorSet;
                if (gpuDescriptorSet !== this._curGPUDescriptorSets[set]) {
                  this._curGPUDescriptorSets[set] = gpuDescriptorSet;
                  this._isStateInvalied = true;
                }
                if (dynamicOffsets) {
                  var _this$_curGPUPipeline;
                  var gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) == null ? undefined : _this$_curGPUPipeline.gpuPipelineLayout;
                  if (gpuPipelineLayout) {
                    var offsets = this._curDynamicOffsets;
                    var idx = gpuPipelineLayout.dynamicOffsetOffsets[set];
                    for (var i = 0; i < dynamicOffsets.length; i++) offsets[idx + i] = dynamicOffsets[i];
                    this._isStateInvalied = true;
                  }
                }
              };
              _proto.bindInputAssembler = function bindInputAssembler(inputAssembler) {
                var gpuInputAssembler = inputAssembler.getGpuInputAssembler();
                this._curGPUInputAssembler = gpuInputAssembler;
                this._isStateInvalied = true;
              };
              _proto.setViewport = function setViewport(viewport) {
                var cache = this._curDynamicStates.viewport;
                if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
                  cache.left = viewport.left;
                  cache.top = viewport.top;
                  cache.width = viewport.width;
                  cache.height = viewport.height;
                  cache.minDepth = viewport.minDepth;
                  cache.maxDepth = viewport.maxDepth;
                  this._isStateInvalied = true;
                }
              };
              _proto.setScissor = function setScissor(scissor) {
                var cache = this._curDynamicStates.scissor;
                if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
                  cache.x = scissor.x;
                  cache.y = scissor.y;
                  cache.width = scissor.width;
                  cache.height = scissor.height;
                  this._isStateInvalied = true;
                }
              };
              _proto.setLineWidth = function setLineWidth(lineWidth) {
                if (this._curDynamicStates.lineWidth !== lineWidth) {
                  this._curDynamicStates.lineWidth = lineWidth;
                  this._isStateInvalied = true;
                }
              };
              _proto.setDepthBias = function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
                var cache = this._curDynamicStates;
                if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
                  cache.depthBiasConstant = depthBiasConstantFactor;
                  cache.depthBiasClamp = depthBiasClamp;
                  cache.depthBiasSlope = depthBiasSlopeFactor;
                  this._isStateInvalied = true;
                }
              };
              _proto.setBlendConstants = function setBlendConstants(blendConstants) {
                var cache = this._curDynamicStates.blendConstant;
                if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
                  cache.copy(blendConstants);
                  this._isStateInvalied = true;
                }
              };
              _proto.setDepthBound = function setDepthBound(minDepthBounds, maxDepthBounds) {
                var cache = this._curDynamicStates;
                if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
                  cache.depthMinBounds = minDepthBounds;
                  cache.depthMaxBounds = maxDepthBounds;
                  this._isStateInvalied = true;
                }
              };
              _proto.setStencilWriteMask = function setStencilWriteMask(face, writeMask) {
                var front = this._curDynamicStates.stencilStatesFront;
                var back = this._curDynamicStates.stencilStatesBack;
                if (face & 1) {
                  if (front.writeMask !== writeMask) {
                    front.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }
                if (face & 2) {
                  if (back.writeMask !== writeMask) {
                    back.writeMask = writeMask;
                    this._isStateInvalied = true;
                  }
                }
              };
              _proto.setStencilCompareMask = function setStencilCompareMask(face, reference, compareMask) {
                var front = this._curDynamicStates.stencilStatesFront;
                var back = this._curDynamicStates.stencilStatesBack;
                if (face & 1) {
                  if (front.compareMask !== compareMask || front.reference !== reference) {
                    front.reference = reference;
                    front.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }
                if (face & 2) {
                  if (back.compareMask !== compareMask || back.reference !== reference) {
                    back.reference = reference;
                    back.compareMask = compareMask;
                    this._isStateInvalied = true;
                  }
                }
              };
              _proto.draw = function draw(infoOrAssembler) {
                errorID(16328);
              };
              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                errorID(16329);
              };
              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                errorID(16330);
              };
              _proto.execute = function execute(cmdBuffs, count) {
                errorID(16402);
              };
              _proto.pipelineBarrier = function pipelineBarrier(GeneralBarrier, bufferBarriers, buffers, textureBarriers, textures) {};
              _proto.bindStates = function bindStates() {
                errorID(16401);
              };
              _proto.blitTexture = function blitTexture(srcTexture, dstTexture, regions, filter) {
                errorID(16401);
              };
              return WebGLCommandBuffer;
            }(CommandBuffer);

            var WebGLFramebuffer = function (_Framebuffer) {
              _inheritsLoose(WebGLFramebuffer, _Framebuffer);
              var _proto = WebGLFramebuffer.prototype;
              _proto.getGpuFramebuffer = function getGpuFramebuffer() {
                return this._gpuFramebuffer;
              };
              function WebGLFramebuffer() {
                var _this;
                _this = _Framebuffer.call(this) || this;
                _this._gpuFramebuffer = null;
                _this._gpuColorTextures = [];
                _this._gpuDepthStencilTexture = undefined;
                return _this;
              }
              _proto.initialize = function initialize(info) {
                var _this2 = this,
                  _this$_gpuFramebuffer;
                this._renderPass = info.renderPass;
                this._colorTextures = info.colorTextures || [];
                var depthStencilTexture = this._depthStencilTexture = info.depthStencilTexture || null;
                var lodLevel = 0;
                var gpuColorTextures = [];
                for (var i = 0; i < info.colorTextures.length; ++i) {
                  var colorTexture = info.colorTextures[i];
                  if (colorTexture) {
                    gpuColorTextures.push(colorTexture.gpuTexture);
                    lodLevel = colorTexture.lodLevel;
                  }
                }
                var gpuDepthStencilTexture = null;
                if (depthStencilTexture) {
                  gpuDepthStencilTexture = depthStencilTexture.gpuTexture;
                  lodLevel = depthStencilTexture.lodLevel;
                }
                var width = Number.MAX_SAFE_INTEGER;
                var height = Number.MAX_SAFE_INTEGER;
                this._gpuFramebuffer = {
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  gpuColorTextures: gpuColorTextures,
                  gpuDepthStencilTexture: gpuDepthStencilTexture,
                  glFramebuffer: null,
                  isOffscreen: true,
                  get width() {
                    if (this.gpuColorTextures.length > 0) {
                      return this.gpuColorTextures[0].width;
                    } else if (this.gpuDepthStencilTexture) {
                      return this.gpuDepthStencilTexture.width;
                    }
                    return width;
                  },
                  set width(val) {
                    width = val;
                  },
                  get height() {
                    if (this.gpuColorTextures.length > 0) {
                      return this.gpuColorTextures[0].height;
                    } else if (this.gpuDepthStencilTexture) {
                      return this.gpuDepthStencilTexture.height;
                    }
                    return height;
                  },
                  set height(val) {
                    height = val;
                  },
                  lodLevel: lodLevel
                };
                WebGLCmdFuncCreateFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
                this._gpuFramebuffer.gpuColorTextures.forEach(function (tex) {
                  return _this2._gpuColorTextures.push(tex.glTexture);
                });
                this._gpuDepthStencilTexture = (_this$_gpuFramebuffer = this._gpuFramebuffer.gpuDepthStencilTexture) == null ? undefined : _this$_gpuFramebuffer.glTexture;
                this._width = this._gpuFramebuffer.width;
                this._height = this._gpuFramebuffer.height;
              };
              _proto.destroy = function destroy() {
                if (this._gpuFramebuffer) {
                  WebGLCmdFuncDestroyFramebuffer(WebGLDeviceManager.instance, this._gpuFramebuffer);
                  this._gpuFramebuffer = null;
                  this._gpuColorTextures.length = 0;
                  this._gpuDepthStencilTexture = null;
                }
              };
              _createClass(WebGLFramebuffer, [{
                key: "needRebuild",
                get: function get() {
                  var gpuFramebuffer = this._gpuFramebuffer;
                  if (gpuFramebuffer) {
                    var _gpuFramebuffer$gpuDe;
                    for (var i = 0; i < gpuFramebuffer.gpuColorTextures.length; i++) {
                      if (gpuFramebuffer.gpuColorTextures[i].glTexture !== this._gpuColorTextures[i]) {
                        return true;
                      }
                    }
                    if (((_gpuFramebuffer$gpuDe = gpuFramebuffer.gpuDepthStencilTexture) == null ? undefined : _gpuFramebuffer$gpuDe.glTexture) !== this._gpuDepthStencilTexture) {
                      return true;
                    }
                  }
                  return false;
                }
              }]);
              return WebGLFramebuffer;
            }(Framebuffer);

            var WebGLInputAssembler = function (_InputAssembler) {
              _inheritsLoose(WebGLInputAssembler, _InputAssembler);
              var _proto = WebGLInputAssembler.prototype;
              _proto.getGpuInputAssembler = function getGpuInputAssembler() {
                return this._gpuInputAssembler;
              };
              function WebGLInputAssembler() {
                var _this;
                _this = _InputAssembler.call(this) || this;
                _this._gpuInputAssembler = null;
                return _this;
              }
              _proto.initialize = function initialize(info) {
                if (info.vertexBuffers.length === 0) {
                  errorID(16331);
                  return;
                }
                this._attributes = info.attributes;
                this._attributesHash = this.computeAttributesHash();
                this._vertexBuffers = info.vertexBuffers;
                if (info.indexBuffer) {
                  this._indexBuffer = info.indexBuffer;
                  this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
                  this._drawInfo.firstIndex = 0;
                } else {
                  var vertBuff = this._vertexBuffers[0];
                  this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
                  this._drawInfo.firstVertex = 0;
                  this._drawInfo.vertexOffset = 0;
                }
                this._drawInfo.instanceCount = 0;
                this._drawInfo.firstInstance = 0;
                this._indirectBuffer = info.indirectBuffer || null;
                var gpuVertexBuffers = new Array(info.vertexBuffers.length);
                for (var i = 0; i < info.vertexBuffers.length; ++i) {
                  var vb = info.vertexBuffers[i];
                  if (vb.gpuBuffer) {
                    gpuVertexBuffers[i] = vb.gpuBuffer;
                  }
                }
                var gpuIndexBuffer = null;
                var glIndexType = 0;
                if (info.indexBuffer) {
                  gpuIndexBuffer = info.indexBuffer.gpuBuffer;
                  if (gpuIndexBuffer) {
                    switch (gpuIndexBuffer.stride) {
                      case 1:
                        glIndexType = 0x1401;
                        break;
                      case 2:
                        glIndexType = 0x1403;
                        break;
                      case 4:
                        glIndexType = 0x1405;
                        break;
                      default:
                        {
                          errorID(16332);
                        }
                    }
                  }
                }
                var gpuIndirectBuffer = null;
                if (info.indirectBuffer) {
                  gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
                }
                this._gpuInputAssembler = {
                  attributes: info.attributes,
                  gpuVertexBuffers: gpuVertexBuffers,
                  gpuIndexBuffer: gpuIndexBuffer,
                  gpuIndirectBuffer: gpuIndirectBuffer,
                  glAttribs: [],
                  glIndexType: glIndexType,
                  glVAOs: new Map()
                };
                WebGLCmdFuncCreateInputAssember(WebGLDeviceManager.instance, this._gpuInputAssembler);
              };
              _proto.destroy = function destroy() {
                var device = WebGLDeviceManager.instance;
                if (this._gpuInputAssembler && device.extensions.useVAO) {
                  WebGLCmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
                }
                this._gpuInputAssembler = null;
              };
              return WebGLInputAssembler;
            }(InputAssembler);

            var WebGLDescriptorSetLayout = function (_DescriptorSetLayout) {
              _inheritsLoose(WebGLDescriptorSetLayout, _DescriptorSetLayout);
              function WebGLDescriptorSetLayout() {
                var _this;
                _this = _DescriptorSetLayout.call(this) || this;
                _this._gpuDescriptorSetLayout = null;
                return _this;
              }
              var _proto = WebGLDescriptorSetLayout.prototype;
              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._bindings, info.bindings);
                var descriptorCount = 0;
                var maxBinding = -1;
                var flattenedIndices = [];
                for (var i = 0; i < this._bindings.length; i++) {
                  var binding = this._bindings[i];
                  flattenedIndices.push(descriptorCount);
                  descriptorCount += binding.count;
                  if (binding.binding > maxBinding) maxBinding = binding.binding;
                }
                this._bindingIndices = Array(maxBinding + 1).fill(-1);
                var descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);
                for (var _i = 0; _i < this._bindings.length; _i++) {
                  var _binding = this._bindings[_i];
                  this._bindingIndices[_binding.binding] = _i;
                  descriptorIndices[_binding.binding] = flattenedIndices[_i];
                }
                var dynamicBindings = [];
                for (var _i2 = 0; _i2 < this._bindings.length; _i2++) {
                  var _binding2 = this._bindings[_i2];
                  if (_binding2.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
                    for (var j = 0; j < _binding2.count; j++) {
                      dynamicBindings.push(_binding2.binding);
                    }
                  }
                }
                this._gpuDescriptorSetLayout = {
                  bindings: this._bindings,
                  dynamicBindings: dynamicBindings,
                  descriptorIndices: descriptorIndices,
                  descriptorCount: descriptorCount
                };
              };
              _proto.destroy = function destroy() {
                this._bindings.length = 0;
              };
              _createClass(WebGLDescriptorSetLayout, [{
                key: "gpuDescriptorSetLayout",
                get: function get() {
                  return this._gpuDescriptorSetLayout;
                }
              }]);
              return WebGLDescriptorSetLayout;
            }(DescriptorSetLayout);

            var WebGLPipelineLayout = function (_PipelineLayout) {
              _inheritsLoose(WebGLPipelineLayout, _PipelineLayout);
              function WebGLPipelineLayout() {
                var _this;
                _this = _PipelineLayout.call(this) || this;
                _this._gpuPipelineLayout = null;
                return _this;
              }
              var _proto = WebGLPipelineLayout.prototype;
              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._setLayouts, info.setLayouts);
                var dynamicOffsetIndices = [];
                var gpuSetLayouts = [];
                var dynamicOffsetCount = 0;
                var dynamicOffsetOffsets = [];
                for (var i = 0; i < this._setLayouts.length; i++) {
                  var setLayout = this._setLayouts[i];
                  var dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
                  var indices = Array(setLayout.bindingIndices.length).fill(-1);
                  for (var j = 0; j < dynamicBindings.length; j++) {
                    var binding = dynamicBindings[j];
                    if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
                  }
                  gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
                  dynamicOffsetIndices.push(indices);
                  dynamicOffsetOffsets.push(dynamicOffsetCount);
                  dynamicOffsetCount += dynamicBindings.length;
                }
                this._gpuPipelineLayout = {
                  gpuSetLayouts: gpuSetLayouts,
                  dynamicOffsetIndices: dynamicOffsetIndices,
                  dynamicOffsetCount: dynamicOffsetCount,
                  dynamicOffsetOffsets: dynamicOffsetOffsets
                };
              };
              _proto.destroy = function destroy() {
                this._setLayouts.length = 0;
              };
              _createClass(WebGLPipelineLayout, [{
                key: "gpuPipelineLayout",
                get: function get() {
                  return this._gpuPipelineLayout;
                }
              }]);
              return WebGLPipelineLayout;
            }(PipelineLayout);

            var WebGLPrimitives$1 = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
            var WebGLPipelineState = function (_PipelineState) {
              _inheritsLoose(WebGLPipelineState, _PipelineState);
              function WebGLPipelineState() {
                var _this;
                _this = _PipelineState.call(this) || this;
                _this._gpuPipelineState = null;
                return _this;
              }
              var _proto = WebGLPipelineState.prototype;
              _proto.initialize = function initialize(info) {
                this._primitive = info.primitive;
                this._shader = info.shader;
                this._pipelineLayout = info.pipelineLayout;
                var bs = this._bs;
                if (info.blendState) {
                  var bsInfo = info.blendState;
                  var targets = bsInfo.targets;
                  if (targets) {
                    targets.forEach(function (t, i) {
                      bs.setTarget(i, t);
                    });
                  }
                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }
                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }
                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }
                Object.assign(this._rs, info.rasterizerState);
                Object.assign(this._dss, info.depthStencilState);
                this._is = info.inputState;
                this._renderPass = info.renderPass;
                this._dynamicStates = info.dynamicStates;
                var dynamicStates = [];
                for (var i = 0; i < 31; i++) {
                  if (this._dynamicStates & 1 << i) {
                    dynamicStates.push(1 << i);
                  }
                }
                this._gpuPipelineState = {
                  glPrimitive: WebGLPrimitives$1[info.primitive],
                  gpuShader: info.shader.gpuShader,
                  gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
                  rs: info.rasterizerState,
                  dss: info.depthStencilState,
                  bs: info.blendState,
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  dynamicStates: dynamicStates
                };
              };
              _proto.destroy = function destroy() {
                this._gpuPipelineState = null;
              };
              _createClass(WebGLPipelineState, [{
                key: "gpuPipelineState",
                get: function get() {
                  return this._gpuPipelineState;
                }
              }]);
              return WebGLPipelineState;
            }(PipelineState);

            var WebGLPrimaryCommandBuffer = function (_WebGLCommandBuffer) {
              _inheritsLoose(WebGLPrimaryCommandBuffer, _WebGLCommandBuffer);
              function WebGLPrimaryCommandBuffer() {
                return _WebGLCommandBuffer.apply(this, arguments) || this;
              }
              var _proto = WebGLPrimaryCommandBuffer.prototype;
              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                WebGLCmdFuncBeginRenderPass(WebGLDeviceManager.instance, renderPass.gpuRenderPass, framebuffer.getGpuFramebuffer(), renderArea, clearColors, clearDepth, clearStencil);
                this._isInRenderPass = true;
              };
              _proto.draw = function draw(infoOrAssembler) {
                if (this._isInRenderPass) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }
                  var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
                  WebGLCmdFuncDraw(WebGLDeviceManager.instance, info);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  var indexCount = info.indexCount || info.vertexCount;
                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;
                    switch (glPrimitive) {
                      case 4:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }
                      case 5:
                      case 6:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  errorID(16328);
                }
              };
              _proto.setViewport = function setViewport(viewport) {
                var _WebGLDeviceManager$i = WebGLDeviceManager.instance,
                  cache = _WebGLDeviceManager$i.stateCache,
                  gl = _WebGLDeviceManager$i.gl;
                if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
                  gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
                  cache.viewport.left = viewport.left;
                  cache.viewport.top = viewport.top;
                  cache.viewport.width = viewport.width;
                  cache.viewport.height = viewport.height;
                }
              };
              _proto.setScissor = function setScissor(scissor) {
                var _WebGLDeviceManager$i2 = WebGLDeviceManager.instance,
                  cache = _WebGLDeviceManager$i2.stateCache,
                  gl = _WebGLDeviceManager$i2.gl;
                if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
                  gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
                  cache.scissorRect.x = scissor.x;
                  cache.scissorRect.y = scissor.y;
                  cache.scissorRect.width = scissor.width;
                  cache.scissorRect.height = scissor.height;
                }
              };
              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (!this._isInRenderPass) {
                  var gpuBuffer = buffer.gpuBuffer;
                  if (gpuBuffer) {
                    var buffSize;
                    if (size !== undefined) {
                      buffSize = size;
                    } else if (buffer.usage & 64) {
                      buffSize = 0;
                    } else {
                      buffSize = data.byteLength;
                    }
                    WebGLCmdFuncUpdateBuffer(WebGLDeviceManager.instance, gpuBuffer, data, 0, buffSize);
                  }
                } else {
                  errorID(16329);
                }
              };
              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (!this._isInRenderPass) {
                  var gpuTexture = texture.gpuTexture;
                  if (gpuTexture) {
                    WebGLCmdFuncCopyBuffersToTexture(WebGLDeviceManager.instance, buffers, gpuTexture, regions);
                  }
                } else {
                  errorID(16330);
                }
              };
              _proto.execute = function execute(cmdBuffs, count) {
                errorID(16402);
              };
              _proto.bindStates = function bindStates() {
                WebGLCmdFuncBindStates(WebGLDeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
                this._isStateInvalied = false;
              };
              _proto.blitTexture = function blitTexture(srcTexture, dstTexture, regions, filter) {
                var gpuTextureSrc = srcTexture.gpuTexture;
                var gpuTextureDst = dstTexture.gpuTexture;
                WebGLCmdFuncBlitTexture(WebGLDeviceManager.instance, gpuTextureSrc, gpuTextureDst, regions, filter);
              };
              return WebGLPrimaryCommandBuffer;
            }(WebGLCommandBuffer);

            var WebGLQueue = function (_Queue) {
              _inheritsLoose(WebGLQueue, _Queue);
              function WebGLQueue() {
                var _this;
                _this = _Queue.call(this) || this;
                _this.numDrawCalls = 0;
                _this.numInstances = 0;
                _this.numTris = 0;
                return _this;
              }
              var _proto = WebGLQueue.prototype;
              _proto.initialize = function initialize(info) {
                this._type = info.type;
              };
              _proto.destroy = function destroy() {};
              _proto.submit = function submit(cmdBuffs) {
                var len = cmdBuffs.length;
                for (var i = 0; i < len; i++) {
                  var cmdBuff = cmdBuffs[i];
                  this.numDrawCalls += cmdBuff.numDrawCalls;
                  this.numInstances += cmdBuff.numInstances;
                  this.numTris += cmdBuff.numTris;
                }
              };
              _proto.clear = function clear() {
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              };
              return WebGLQueue;
            }(Queue);

            var WebGLRenderPass = function (_RenderPass) {
              _inheritsLoose(WebGLRenderPass, _RenderPass);
              function WebGLRenderPass() {
                var _this;
                _this = _RenderPass.call(this) || this;
                _this._gpuRenderPass = null;
                return _this;
              }
              var _proto = WebGLRenderPass.prototype;
              _proto.initialize = function initialize(info) {
                this._colorInfos = info.colorAttachments;
                this._depthStencilInfo = info.depthStencilAttachment;
                this._subpasses = info.subpasses;
                this._gpuRenderPass = {
                  colorAttachments: this._colorInfos,
                  depthStencilAttachment: this._depthStencilInfo
                };
                this._hash = this.computeHash();
              };
              _proto.destroy = function destroy() {
                this._gpuRenderPass = null;
              };
              _createClass(WebGLRenderPass, [{
                key: "gpuRenderPass",
                get: function get() {
                  return this._gpuRenderPass;
                }
              }]);
              return WebGLRenderPass;
            }(RenderPass);

            var WebGLWraps$1 = [0x2901, 0x8370, 0x812F, 0x812F];
            var WebGLSampler = function (_Sampler) {
              _inheritsLoose(WebGLSampler, _Sampler);
              function WebGLSampler(info, hash) {
                var _this;
                _this = _Sampler.call(this, info, hash) || this;
                _this._gpuSampler = null;
                var glMinFilter = 0;
                var glMagFilter = 0;
                var minFilter = _this._info.minFilter;
                var magFilter = _this._info.magFilter;
                var mipFilter = _this._info.mipFilter;
                if (minFilter === 2 || minFilter === 3) {
                  if (mipFilter === 2 || mipFilter === 3) {
                    glMinFilter = 9987;
                  } else if (mipFilter === 1) {
                    glMinFilter = 9985;
                  } else {
                    glMinFilter = 9729;
                  }
                } else if (mipFilter === 2 || mipFilter === 3) {
                  glMinFilter = 9986;
                } else if (mipFilter === 1) {
                  glMinFilter = 9984;
                } else {
                  glMinFilter = 9728;
                }
                if (magFilter === 2 || magFilter === 3) {
                  glMagFilter = 9729;
                } else {
                  glMagFilter = 9728;
                }
                var glWrapS = WebGLWraps$1[_this._info.addressU];
                var glWrapT = WebGLWraps$1[_this._info.addressV];
                var glWrapR = WebGLWraps$1[_this._info.addressW];
                _this._gpuSampler = {
                  glMinFilter: glMinFilter,
                  glMagFilter: glMagFilter,
                  glWrapS: glWrapS,
                  glWrapT: glWrapT,
                  glWrapR: glWrapR
                };
                return _this;
              }
              _createClass(WebGLSampler, [{
                key: "gpuSampler",
                get: function get() {
                  return this._gpuSampler;
                }
              }]);
              return WebGLSampler;
            }(Sampler);

            var WebGLShader = function (_Shader) {
              _inheritsLoose(WebGLShader, _Shader);
              function WebGLShader() {
                var _this;
                _this = _Shader.call(this) || this;
                _this._gpuShader = null;
                return _this;
              }
              var _proto = WebGLShader.prototype;
              _proto.initialize = function initialize(info) {
                this._name = info.name;
                this._stages = info.stages;
                this._attributes = info.attributes;
                this._blocks = info.blocks;
                this._samplers = info.samplers;
                this._gpuShader = {
                  name: info.name,
                  blocks: info.blocks.slice(),
                  samplerTextures: info.samplerTextures.slice(),
                  subpassInputs: info.subpassInputs.slice(),
                  gpuStages: new Array(info.stages.length),
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplerTextures: []
                };
                for (var i = 0; i < info.stages.length; ++i) {
                  var stage = info.stages[i];
                  this._gpuShader.gpuStages[i] = {
                    type: stage.stage,
                    source: stage.source,
                    glShader: null
                  };
                }
              };
              _proto.destroy = function destroy() {
                if (this._gpuShader) {
                  WebGLCmdFuncDestroyShader(WebGLDeviceManager.instance, this._gpuShader);
                  this._gpuShader = null;
                }
              };
              _createClass(WebGLShader, [{
                key: "gpuShader",
                get: function get() {
                  if (this._gpuShader.glProgram === null) {
                    WebGLCmdFuncCreateShader(WebGLDeviceManager.instance, this._gpuShader);
                  }
                  return this._gpuShader;
                }
              }]);
              return WebGLShader;
            }(Shader);

            var WebGLStateCache = function () {
              function WebGLStateCache() {
                this.glArrayBuffer = null;
                this.glElementArrayBuffer = null;
                this.glVAO = null;
                this.texUnit = 0;
                this.glTexUnits = [];
                this.glRenderbuffer = null;
                this.glFramebuffer = null;
                this.viewport = new Viewport();
                this.scissorRect = new Rect$1(0, 0, 0, 0);
                this.rs = new RasterizerState();
                this.dss = new DepthStencilState();
                this.bs = new BlendState();
                this.glProgram = null;
                this.glEnabledAttribLocs = [];
                this.glCurrentAttribLocs = [];
                this.texUnitCacheMap = {};
              }
              var _proto = WebGLStateCache.prototype;
              _proto.initialize = function initialize(texUnit, vertexAttributes) {
                for (var i = 0; i < texUnit; ++i) {
                  var glTexUnit = {
                    glTexture: null
                  };
                  this.glTexUnits.push(glTexUnit);
                }
                this.glEnabledAttribLocs.length = vertexAttributes;
                this.glEnabledAttribLocs.fill(false);
                this.glCurrentAttribLocs.length = vertexAttributes;
                this.glCurrentAttribLocs.fill(false);
              };
              return WebGLStateCache;
            }();

            var WebGLTexture = function (_Texture) {
              _inheritsLoose(WebGLTexture, _Texture);
              function WebGLTexture() {
                var _this;
                _this = _Texture.call(this) || this;
                _this._gpuTexture = null;
                _this._lodLevel = 0;
                return _this;
              }
              var _proto = WebGLTexture.prototype;
              _proto.initialize = function initialize(info, isSwapchainTexture) {
                var self = this;
                var instance = WebGLDeviceManager.instance;
                var texInfo = info;
                var viewInfo = info;
                if ('texture' in info) {
                  texInfo = viewInfo.texture.info;
                  self._isTextureView = true;
                }
                var thisTextureInfo = self._info;
                thisTextureInfo.copy(texInfo);
                var thisViewInfo = self._viewInfo;
                self._isPowerOf2 = IsPowerOf2(thisTextureInfo.width) && IsPowerOf2(thisTextureInfo.height);
                self._size = FormatSurfaceSize(thisTextureInfo.format, self.width, self.height, self.depth, thisTextureInfo.levelCount) * thisTextureInfo.layerCount;
                if (!self._isTextureView) {
                  self._gpuTexture = {
                    type: texInfo.type,
                    format: texInfo.format,
                    usage: texInfo.usage,
                    width: texInfo.width,
                    height: texInfo.height,
                    depth: texInfo.depth,
                    size: self._size,
                    arrayLayer: texInfo.layerCount,
                    mipLevel: texInfo.levelCount,
                    samples: texInfo.samples,
                    flags: texInfo.flags,
                    isPowerOf2: self._isPowerOf2,
                    glTarget: 0,
                    glInternalFmt: 0,
                    glFormat: 0,
                    glType: 0,
                    glUsage: 0,
                    glTexture: null,
                    glRenderbuffer: null,
                    glWrapS: 0,
                    glWrapT: 0,
                    glMinFilter: 0,
                    glMagFilter: 0,
                    isSwapchainTexture: isSwapchainTexture || false
                  };
                  if (!self._gpuTexture.isSwapchainTexture) {
                    WebGLCmdFuncCreateTexture(instance, self._gpuTexture);
                    instance.memoryStatus.textureSize += self._size;
                  }
                  thisViewInfo.texture = self;
                  thisViewInfo.type = info.type;
                  thisViewInfo.format = info.format;
                  thisViewInfo.baseLevel = 0;
                  thisViewInfo.levelCount = info.levelCount;
                  thisViewInfo.baseLayer = 0;
                  thisViewInfo.layerCount = info.layerCount;
                } else {
                  thisViewInfo.copy(viewInfo);
                  self._lodLevel = viewInfo.baseLevel;
                  self._gpuTexture = viewInfo.texture._gpuTexture;
                }
              };
              _proto.destroy = function destroy() {
                var self = this;
                var instance = WebGLDeviceManager.instance;
                if (!self._isTextureView && self._gpuTexture) {
                  WebGLCmdFuncDestroyTexture(instance, self._gpuTexture);
                  instance.memoryStatus.textureSize -= self._size;
                  self._gpuTexture = null;
                }
              };
              _proto.getTextureHandle = function getTextureHandle() {
                var gpuTexture = this._gpuTexture;
                if (!gpuTexture) {
                  return 0;
                }
                if (gpuTexture.glTexture) {
                  return gpuTexture.glTexture;
                } else if (gpuTexture.glRenderbuffer) {
                  return gpuTexture.glRenderbuffer;
                }
                return 0;
              };
              _proto.resize = function resize(width, height) {
                var self = this;
                var instance = WebGLDeviceManager.instance;
                var thisTextureInfo = self._info;
                if (thisTextureInfo.width === width && thisTextureInfo.height === height) {
                  return;
                }
                if (thisTextureInfo.levelCount === WebGLTexture.getLevelCount(thisTextureInfo.width, thisTextureInfo.height)) {
                  thisTextureInfo.levelCount = WebGLTexture.getLevelCount(width, height);
                } else if (thisTextureInfo.levelCount > 1) {
                  thisTextureInfo.levelCount = Math.min(thisTextureInfo.levelCount, WebGLTexture.getLevelCount(width, height));
                }
                var oldSize = self._size;
                thisTextureInfo.width = width;
                thisTextureInfo.height = height;
                self._size = FormatSurfaceSize(thisTextureInfo.format, self.width, self.height, self.depth, thisTextureInfo.levelCount) * thisTextureInfo.layerCount;
                var thisGpuTexture = self._gpuTexture;
                if (!self._isTextureView && thisGpuTexture) {
                  thisGpuTexture.width = width;
                  thisGpuTexture.height = height;
                  thisGpuTexture.size = self._size;
                  if (!thisGpuTexture.isSwapchainTexture) {
                    WebGLCmdFuncResizeTexture(instance, thisGpuTexture);
                    instance.memoryStatus.textureSize -= oldSize;
                    instance.memoryStatus.textureSize += self._size;
                  }
                }
              };
              _proto.initAsSwapchainTexture = function initAsSwapchainTexture(info) {
                var texInfo = new TextureInfo();
                texInfo.format = info.format;
                texInfo.usage = FormatInfos[info.format].hasDepth ? 32 : 16;
                texInfo.width = info.width;
                texInfo.height = info.height;
                this.initialize(texInfo, true);
              };
              _createClass(WebGLTexture, [{
                key: "gpuTexture",
                get: function get() {
                  return this._gpuTexture;
                }
              }, {
                key: "lodLevel",
                get: function get() {
                  return this._lodLevel;
                }
              }]);
              return WebGLTexture;
            }(Texture);

            var eventWebGLContextLost$1 = 'webglcontextlost';
            function initStates$1(gl) {
              gl.activeTexture(33984);
              gl.pixelStorei(3333, 1);
              gl.pixelStorei(3317, 1);
              gl.pixelStorei(37440, false);
              gl.bindFramebuffer(36160, null);
              gl.enable(3089);
              gl.enable(2884);
              gl.cullFace(1029);
              gl.frontFace(2305);
              gl.disable(32823);
              gl.polygonOffset(0.0, 0.0);
              gl.enable(2929);
              gl.depthMask(true);
              gl.depthFunc(513);
              gl.depthRange(0.0, 1.0);
              gl.stencilFuncSeparate(1028, 519, 1, 0xffff);
              gl.stencilOpSeparate(1028, 7680, 7680, 7680);
              gl.stencilMaskSeparate(1028, 0xffff);
              gl.stencilFuncSeparate(1029, 519, 1, 0xffff);
              gl.stencilOpSeparate(1029, 7680, 7680, 7680);
              gl.stencilMaskSeparate(1029, 0xffff);
              gl.disable(2960);
              gl.disable(32926);
              gl.disable(3042);
              gl.blendEquationSeparate(32774, 32774);
              gl.blendFuncSeparate(1, 0, 1, 0);
              gl.colorMask(true, true, true, true);
              gl.blendColor(0.0, 0.0, 0.0, 0.0);
            }
            function getExtension$1(gl, ext) {
              var prefixes = ['', 'WEBKIT_', 'MOZ_'];
              for (var i = 0; i < prefixes.length; ++i) {
                var _ext = gl.getExtension(prefixes[i] + ext);
                if (_ext) {
                  return _ext;
                }
              }
              return null;
            }
            function getExtensions$1(gl) {
              var res = {
                EXT_texture_filter_anisotropic: getExtension$1(gl, 'EXT_texture_filter_anisotropic'),
                EXT_blend_minmax: getExtension$1(gl, 'EXT_blend_minmax'),
                EXT_frag_depth: getExtension$1(gl, 'EXT_frag_depth'),
                EXT_shader_texture_lod: getExtension$1(gl, 'EXT_shader_texture_lod'),
                EXT_sRGB: getExtension$1(gl, 'EXT_sRGB'),
                OES_vertex_array_object: getExtension$1(gl, 'OES_vertex_array_object'),
                EXT_color_buffer_half_float: getExtension$1(gl, 'EXT_color_buffer_half_float'),
                WEBGL_color_buffer_float: getExtension$1(gl, 'WEBGL_color_buffer_float'),
                WEBGL_compressed_texture_etc1: getExtension$1(gl, 'WEBGL_compressed_texture_etc1'),
                WEBGL_compressed_texture_etc: getExtension$1(gl, 'WEBGL_compressed_texture_etc'),
                WEBGL_compressed_texture_pvrtc: getExtension$1(gl, 'WEBGL_compressed_texture_pvrtc'),
                WEBGL_compressed_texture_s3tc: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc'),
                WEBGL_compressed_texture_s3tc_srgb: getExtension$1(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
                WEBGL_debug_shaders: getExtension$1(gl, 'WEBGL_debug_shaders'),
                WEBGL_draw_buffers: getExtension$1(gl, 'WEBGL_draw_buffers'),
                WEBGL_lose_context: getExtension$1(gl, 'WEBGL_lose_context'),
                WEBGL_depth_texture: getExtension$1(gl, 'WEBGL_depth_texture'),
                OES_texture_half_float: getExtension$1(gl, 'OES_texture_half_float'),
                OES_texture_half_float_linear: getExtension$1(gl, 'OES_texture_half_float_linear'),
                OES_texture_float: getExtension$1(gl, 'OES_texture_float'),
                OES_texture_float_linear: getExtension$1(gl, 'OES_texture_float_linear'),
                OES_standard_derivatives: getExtension$1(gl, 'OES_standard_derivatives'),
                OES_element_index_uint: getExtension$1(gl, 'OES_element_index_uint'),
                ANGLE_instanced_arrays: getExtension$1(gl, 'ANGLE_instanced_arrays'),
                WEBGL_debug_renderer_info: getExtension$1(gl, 'WEBGL_debug_renderer_info'),
                WEBGL_multi_draw: null,
                WEBGL_compressed_texture_astc: null,
                destroyShadersImmediately: true,
                noCompressedTexSubImage2D: false,
                isLocationActive: function isLocationActive(glLoc) {
                  return !!glLoc;
                },
                useVAO: false
              };
              {
                if (systemInfo.os !== OS.IOS || systemInfo.osMainVersion !== 14 || !systemInfo.isBrowser) {
                  res.WEBGL_compressed_texture_astc = getExtension$1(gl, 'WEBGL_compressed_texture_astc');
                }
                if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
                  res.WEBGL_multi_draw = getExtension$1(gl, 'WEBGL_multi_draw');
                }
                if (systemInfo.browserType === BrowserType.UC) {
                  res.ANGLE_instanced_arrays = null;
                }
                if (systemInfo.os === OS.IOS && systemInfo.osMainVersion <= 10 || (WECHAT_MINI_PROGRAM)) {
                  res.destroyShadersImmediately = false;
                }
              }
              if (res.OES_vertex_array_object) {
                res.useVAO = true;
              }
              return res;
            }
            function getContext$1(canvas) {
              var context = null;
              try {
                var webGLCtxAttribs = {
                  alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                  antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
                  depth: true,
                  stencil: true,
                  premultipliedAlpha: false,
                  preserveDrawingBuffer: false,
                  powerPreference: 'default',
                  failIfMajorPerformanceCaveat: false
                };
                context = canvas.getContext('webgl', webGLCtxAttribs);
              } catch (err) {
                return null;
              }
              return context;
            }
            var WebGLSwapchain = function (_Swapchain) {
              _inheritsLoose(WebGLSwapchain, _Swapchain);
              function WebGLSwapchain() {
                var _this;
                _this = _Swapchain.call(this) || this;
                _this.stateCache = new WebGLStateCache();
                _this.nullTex2D = null;
                _this.nullTexCube = null;
                _this._canvas = null;
                _this._webGLContextLostHandler = null;
                _this._extensions = null;
                _this._blitManager = null;
                return _this;
              }
              var _proto = WebGLSwapchain.prototype;
              _proto.initialize = function initialize(info) {
                var self = this;
                self._canvas = info.windowHandle;
                self._webGLContextLostHandler = self._onWebGLContextLost.bind(self);
                self._canvas.addEventListener(eventWebGLContextLost$1, self._webGLContextLostHandler);
                var instance = WebGLDeviceManager.instance;
                var gl = instance.gl,
                  capabilities = instance.capabilities;
                self.stateCache.initialize(capabilities.maxTextureUnits, capabilities.maxVertexAttributes);
                self._extensions = getExtensions$1(gl);
                initStates$1(gl);
                var colorFmt = 35;
                var depthStencilFmt = 55;
                var depthBits = gl.getParameter(3414);
                var stencilBits = gl.getParameter(3415);
                if (depthBits && stencilBits) depthStencilFmt = 55;else if (depthBits) depthStencilFmt = 54;
                self._colorTexture = new WebGLTexture();
                self._colorTexture.initAsSwapchainTexture({
                  swapchain: self,
                  format: colorFmt,
                  width: info.width,
                  height: info.height
                });
                self._depthStencilTexture = new WebGLTexture();
                self._depthStencilTexture.initAsSwapchainTexture({
                  swapchain: self,
                  format: depthStencilFmt,
                  width: info.width,
                  height: info.height
                });
                self.nullTex2D = instance.createTexture(new TextureInfo(1, 4, 35, 2, 2, 1));
                self.nullTexCube = instance.createTexture(new TextureInfo(3, 4, 35, 2, 2, 1, 6));
                var nullTexRegion = new BufferTextureCopy();
                nullTexRegion.texExtent.width = 2;
                nullTexRegion.texExtent.height = 2;
                var nullTexBuff = new Uint8Array(self.nullTex2D.size);
                nullTexBuff.fill(0);
                instance.copyBuffersToTexture([nullTexBuff], self.nullTex2D, [nullTexRegion]);
                nullTexRegion.texSubres.layerCount = 6;
                instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], self.nullTexCube, [nullTexRegion]);
                self._blitManager = new IWebGLBlitManager();
              };
              _proto.destroy = function destroy() {
                var self = this;
                if (self._canvas && self._webGLContextLostHandler) {
                  self._canvas.removeEventListener(eventWebGLContextLost$1, self._webGLContextLostHandler);
                  self._webGLContextLostHandler = null;
                }
                if (self.nullTex2D) {
                  self.nullTex2D.destroy();
                  self.nullTex2D = null;
                }
                if (self.nullTexCube) {
                  self.nullTexCube.destroy();
                  self.nullTexCube = null;
                }
                if (self._blitManager) {
                  self._blitManager.destroy();
                  self._blitManager = null;
                }
                self._extensions = null;
                self._canvas = null;
              };
              _proto.resize = function resize(width, height, surfaceTransform) {
                var self = this;
                if (self._colorTexture.width !== width || self._colorTexture.height !== height) {
                  debug("Resizing swapchain: " + width + "x" + height);
                  self._canvas.width = width;
                  self._canvas.height = height;
                  self._colorTexture.resize(width, height);
                  self._depthStencilTexture.resize(width, height);
                }
              };
              _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
                warnID(11000);
                warn(event);
              };
              _createClass(WebGLSwapchain, [{
                key: "extensions",
                get: function get() {
                  return this._extensions;
                }
              }, {
                key: "blitManager",
                get: function get() {
                  return this._blitManager;
                }
              }]);
              return WebGLSwapchain;
            }(Swapchain);

            function setFormatFeature$1(formatFeatures, indexArray, feature) {
              for (var i = 0; i < indexArray.length; ++i) {
                formatFeatures[indexArray[i]] = feature;
              }
            }
            function setFormatFeatureBitwiseOr(formatFeatures, indexArray, feature) {
              for (var i = 0; i < indexArray.length; ++i) {
                formatFeatures[indexArray[i]] |= feature;
              }
            }
            function setTextureExclusive$1(textureExclusive, indexArray, isExclusive) {
              for (var i = 0; i < indexArray.length; ++i) {
                textureExclusive[indexArray[i]] = isExclusive;
              }
            }
            var WebGLDevice = exports("WebGLDevice", function (_Device) {
              _inheritsLoose(WebGLDevice, _Device);
              function WebGLDevice() {
                var _this;
                _this = _Device.call(this) || this;
                _this._swapchain = null;
                _this._context = null;
                _this._bindingMappings = null;
                _this._textureExclusive = new Array(117);
                return _this;
              }
              var _proto = WebGLDevice.prototype;
              _proto.initialize = function initialize(info) {
                WebGLDeviceManager.setInstance(this);
                this._gfxAPI = 6;
                var mapping = this._bindingMappingInfo = info.bindingMappingInfo;
                var blockOffsets = [];
                var samplerTextureOffsets = [];
                var firstSet = mapping.setIndices[0];
                blockOffsets[firstSet] = 0;
                samplerTextureOffsets[firstSet] = 0;
                for (var i = 1; i < mapping.setIndices.length; ++i) {
                  var curSet = mapping.setIndices[i];
                  var prevSet = mapping.setIndices[i - 1];
                  blockOffsets[curSet] = mapping.maxBlockCounts[prevSet] + blockOffsets[prevSet];
                  samplerTextureOffsets[curSet] = mapping.maxSamplerTextureCounts[prevSet] + samplerTextureOffsets[prevSet];
                }
                for (var _i = 0; _i < mapping.setIndices.length; ++_i) {
                  var _curSet = mapping.setIndices[_i];
                  samplerTextureOffsets[_curSet] -= mapping.maxBlockCounts[_curSet];
                }
                this._bindingMappings = {
                  blockOffsets: blockOffsets,
                  samplerTextureOffsets: samplerTextureOffsets,
                  flexibleSet: mapping.setIndices[mapping.setIndices.length - 1]
                };
                var gl = this._context = getContext$1(Device.canvas);
                if (!gl) {
                  errorID(16333);
                  return false;
                }
                this._queue = this.createQueue(new QueueInfo(0));
                this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
                var glGetParameter = gl.getParameter.bind(gl);
                var caps = this._caps;
                caps.maxVertexAttributes = glGetParameter(34921);
                caps.maxVertexUniformVectors = glGetParameter(36347);
                caps.maxFragmentUniformVectors = glGetParameter(36349);
                caps.maxTextureUnits = glGetParameter(34930);
                caps.maxVertexTextureUnits = glGetParameter(35660);
                caps.maxTextureSize = glGetParameter(3379);
                caps.maxCubeMapTextureSize = glGetParameter(34076);
                caps.maxArrayTextureLayers = 0;
                caps.max3DTextureSize = 0;
                caps.maxUniformBufferBindings = 16;
                var extensions = gl.getSupportedExtensions();
                var extStr = '';
                if (extensions) {
                  extensions.forEach(function (ext) {
                    extStr += ext + " ";
                  });
                }
                var exts = getExtensions$1(gl);
                if (exts.WEBGL_debug_renderer_info) {
                  this._renderer = glGetParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
                  this._vendor = glGetParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
                } else {
                  this._renderer = glGetParameter(7937);
                  this._vendor = glGetParameter(7936);
                }
                var version = glGetParameter(7938);
                var features = this._features;
                features.fill(false);
                this.initFormatFeatures(exts);
                if (exts.EXT_blend_minmax) {
                  features[3] = true;
                }
                if (exts.OES_element_index_uint) {
                  features[0] = true;
                }
                if (exts.ANGLE_instanced_arrays) {
                  features[1] = true;
                }
                if (exts.WEBGL_draw_buffers) {
                  features[2] = true;
                }
                var compressedFormat = '';
                if (this.getFormatFeatures(72)) {
                  compressedFormat += 'etc1 ';
                }
                if (this.getFormatFeatures(73)) {
                  compressedFormat += 'etc2 ';
                }
                if (this.getFormatFeatures(56)) {
                  compressedFormat += 'dxt ';
                }
                if (this.getFormatFeatures(83)) {
                  compressedFormat += 'pvrtc ';
                }
                if (this.getFormatFeatures(89)) {
                  compressedFormat += 'astc ';
                }
                debug('WebGL device initialized.');
                debug("RENDERER: " + this._renderer);
                debug("VENDOR: " + this._vendor);
                debug("VERSION: " + version);
                debug("COMPRESSED_FORMAT: " + compressedFormat);
                debug("EXTENSIONS: " + extStr);
                return true;
              };
              _proto.destroy = function destroy() {
                if (this._queue) {
                  this._queue.destroy();
                  this._queue = null;
                }
                if (this._cmdBuff) {
                  this._cmdBuff.destroy();
                  this._cmdBuff = null;
                }
                this._swapchain = null;
              };
              _proto.flushCommands = function flushCommands(cmdBuffs) {};
              _proto.acquire = function acquire(swapchains) {};
              _proto.present = function present() {
                var queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls;
                this._numInstances = queue.numInstances;
                this._numTris = queue.numTris;
                queue.clear();
              };
              _proto.initFormatFeatures = function initFormatFeatures(exts) {
                var formatFeatures = this._formatFeatures;
                formatFeatures.fill(0);
                var textureExclusive = this._textureExclusive;
                textureExclusive.fill(true);
                var tempFeature = 1 | 2 | 4;
                setFormatFeature$1(formatFeatures, [24, 47, 35, 50, 49], tempFeature);
                setFormatFeature$1(formatFeatures, [54, 55], 1);
                setTextureExclusive$1(textureExclusive, [47, 50, 49, 54, 55], false);
                setFormatFeatureBitwiseOr(formatFeatures, [7, 17, 28, 40, 6, 16, 27, 39, 7, 17, 28, 40, 6, 16, 27, 39, 11, 21, 32, 44], 16);
                if (exts.EXT_sRGB) {
                  formatFeatures[25] = tempFeature;
                  formatFeatures[37] = tempFeature;
                  textureExclusive[37] = false;
                }
                if (exts.WEBGL_depth_texture) {
                  formatFeatures[54] |= tempFeature;
                  formatFeatures[55] |= tempFeature;
                }
                if (exts.WEBGL_color_buffer_float) {
                  formatFeatures[32] |= 1;
                  formatFeatures[44] |= 1;
                  textureExclusive[32] = false;
                  textureExclusive[44] = false;
                }
                if (exts.EXT_color_buffer_half_float) {
                  formatFeatures[29] |= 1;
                  formatFeatures[41] |= 1;
                  textureExclusive[29] = false;
                  textureExclusive[41] = false;
                }
                if (exts.OES_texture_float) {
                  formatFeatures[32] |= 1 | 2;
                  formatFeatures[44] |= 1 | 2;
                }
                if (exts.OES_texture_half_float) {
                  formatFeatures[29] |= 1 | 2;
                  formatFeatures[41] |= 1 | 2;
                }
                if (exts.OES_texture_float_linear) {
                  formatFeatures[32] |= 4;
                  formatFeatures[44] |= 4;
                }
                if (exts.OES_texture_half_float_linear) {
                  formatFeatures[29] |= 4;
                  formatFeatures[41] |= 4;
                }
                var compressedFeature = 2 | 4;
                if (exts.WEBGL_compressed_texture_etc1) {
                  formatFeatures[72] = compressedFeature;
                }
                if (exts.WEBGL_compressed_texture_etc) {
                  setFormatFeature$1(formatFeatures, [73, 77, 74, 78, 75, 76], compressedFeature);
                }
                if (exts.WEBGL_compressed_texture_s3tc) {
                  setFormatFeature$1(formatFeatures, [56, 57, 58, 59, 60, 61, 62, 63], compressedFeature);
                }
                if (exts.WEBGL_compressed_texture_pvrtc) {
                  setFormatFeatureBitwiseOr(formatFeatures, [83, 84, 85, 86], compressedFeature);
                }
                if (exts.WEBGL_compressed_texture_astc) {
                  setFormatFeatureBitwiseOr(formatFeatures, [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116], compressedFeature);
                }
              };
              _proto.createCommandBuffer = function createCommandBuffer(info) {
                var Ctor = info.type === 0 ? WebGLPrimaryCommandBuffer : WebGLCommandBuffer;
                var cmdBuff = new Ctor();
                cmdBuff.initialize(info);
                return cmdBuff;
              };
              _proto.createSwapchain = function createSwapchain(info) {
                var swapchain = new WebGLSwapchain();
                this._swapchain = swapchain;
                swapchain.initialize(info);
                return swapchain;
              };
              _proto.createBuffer = function createBuffer(info) {
                var buffer = new WebGLBuffer();
                buffer.initialize(info);
                return buffer;
              };
              _proto.createTexture = function createTexture(info) {
                var texture = new WebGLTexture();
                texture.initialize(info);
                return texture;
              };
              _proto.createDescriptorSet = function createDescriptorSet(info) {
                var descriptorSet = new WebGLDescriptorSet();
                descriptorSet.initialize(info);
                return descriptorSet;
              };
              _proto.createShader = function createShader(info) {
                var shader = new WebGLShader();
                shader.initialize(info);
                return shader;
              };
              _proto.createInputAssembler = function createInputAssembler(info) {
                var inputAssembler = new WebGLInputAssembler();
                inputAssembler.initialize(info);
                return inputAssembler;
              };
              _proto.createRenderPass = function createRenderPass(info) {
                var renderPass = new WebGLRenderPass();
                renderPass.initialize(info);
                return renderPass;
              };
              _proto.createFramebuffer = function createFramebuffer(info) {
                var framebuffer = new WebGLFramebuffer();
                framebuffer.initialize(info);
                return framebuffer;
              };
              _proto.createDescriptorSetLayout = function createDescriptorSetLayout(info) {
                var descriptorSetLayout = new WebGLDescriptorSetLayout();
                descriptorSetLayout.initialize(info);
                return descriptorSetLayout;
              };
              _proto.createPipelineLayout = function createPipelineLayout(info) {
                var pipelineLayout = new WebGLPipelineLayout();
                pipelineLayout.initialize(info);
                return pipelineLayout;
              };
              _proto.createPipelineState = function createPipelineState(info) {
                var pipelineState = new WebGLPipelineState();
                pipelineState.initialize(info);
                return pipelineState;
              };
              _proto.createQueue = function createQueue(info) {
                var queue = new WebGLQueue();
                queue.initialize(info);
                return queue;
              };
              _proto.getSampler = function getSampler(info) {
                var hash = Sampler.computeHash(info);
                if (!this._samplers.has(hash)) {
                  this._samplers.set(hash, new WebGLSampler(info, hash));
                }
                return this._samplers.get(hash);
              };
              _proto.getSwapchains = function getSwapchains() {
                return [this._swapchain];
              };
              _proto.getGeneralBarrier = function getGeneralBarrier(info) {
                var hash = GeneralBarrier.computeHash(info);
                if (!this._generalBarrierss.has(hash)) {
                  this._generalBarrierss.set(hash, new GeneralBarrier(info, hash));
                }
                return this._generalBarrierss.get(hash);
              };
              _proto.getTextureBarrier = function getTextureBarrier(info) {
                var hash = TextureBarrier.computeHash(info);
                if (!this._textureBarriers.has(hash)) {
                  this._textureBarriers.set(hash, new TextureBarrier(info, hash));
                }
                return this._textureBarriers.get(hash);
              };
              _proto.getBufferBarrier = function getBufferBarrier(info) {
                var hash = BufferBarrier.computeHash(info);
                if (!this._bufferBarriers.has(hash)) {
                  this._bufferBarriers.set(hash, new BufferBarrier(info, hash));
                }
                return this._bufferBarriers.get(hash);
              };
              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
              };
              _proto.copyTextureToBuffers = function copyTextureToBuffers(texture, buffers, regions) {
                WebGLCmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
              };
              _proto.copyTexImagesToTexture = function copyTexImagesToTexture(texImages, texture, regions) {
                WebGLCmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
              };
              _createClass(WebGLDevice, [{
                key: "gl",
                get: function get() {
                  return this._context;
                }
              }, {
                key: "extensions",
                get: function get() {
                  return this._swapchain.extensions;
                }
              }, {
                key: "stateCache",
                get: function get() {
                  return this._swapchain.stateCache;
                }
              }, {
                key: "nullTex2D",
                get: function get() {
                  return this._swapchain.nullTex2D;
                }
              }, {
                key: "nullTexCube",
                get: function get() {
                  return this._swapchain.nullTexCube;
                }
              }, {
                key: "textureExclusive",
                get: function get() {
                  return this._textureExclusive;
                }
              }, {
                key: "bindingMappings",
                get: function get() {
                  return this._bindingMappings;
                }
              }, {
                key: "blitManager",
                get: function get() {
                  return this._swapchain.blitManager;
                }
              }]);
              return WebGLDevice;
            }(Device));

            legacyCC.WebGLDevice = WebGLDevice;

            var WebGL2DescriptorSet = function (_DescriptorSet) {
              _inheritsLoose(WebGL2DescriptorSet, _DescriptorSet);
              function WebGL2DescriptorSet() {
                var _this;
                _this = _DescriptorSet.call(this) || this;
                _this._gpuDescriptorSet = null;
                return _this;
              }
              var _proto = WebGL2DescriptorSet.prototype;
              _proto.initialize = function initialize(info) {
                this._layout = info.layout;
                var _getGpuDescriptorSetL = info.layout.getGpuDescriptorSetLayout(),
                  bindings = _getGpuDescriptorSetL.bindings,
                  descriptorIndices = _getGpuDescriptorSetL.descriptorIndices,
                  descriptorCount = _getGpuDescriptorSetL.descriptorCount;
                this._buffers = Array(descriptorCount).fill(null);
                this._textures = Array(descriptorCount).fill(null);
                this._samplers = Array(descriptorCount).fill(null);
                var gpuDescriptors = [];
                this._gpuDescriptorSet = {
                  gpuDescriptors: gpuDescriptors,
                  descriptorIndices: descriptorIndices
                };
                for (var i = 0; i < bindings.length; ++i) {
                  var binding = bindings[i];
                  for (var j = 0; j < binding.count; j++) {
                    var gpuDescriptor = {
                      type: binding.descriptorType,
                      gpuBuffer: null,
                      gpuTextureView: null,
                      gpuSampler: null
                    };
                    gpuDescriptors.push(gpuDescriptor);
                  }
                }
              };
              _proto.destroy = function destroy() {
                this._layout = null;
                this._gpuDescriptorSet = null;
              };
              _proto.update = function update() {
                if (this._isDirty && this._gpuDescriptorSet) {
                  var descriptors = this._gpuDescriptorSet.gpuDescriptors;
                  for (var i = 0; i < descriptors.length; ++i) {
                    if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                      if (this._buffers[i]) {
                        descriptors[i].gpuBuffer = this._buffers[i].getGpuBuffer();
                      }
                    } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                      if (this._textures[i]) {
                        descriptors[i].gpuTextureView = this._textures[i].gpuTextureView;
                      }
                      if (this._samplers[i]) {
                        descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                      }
                    }
                  }
                  this._isDirty = false;
                }
              };
              _createClass(WebGL2DescriptorSet, [{
                key: "gpuDescriptorSet",
                get: function get() {
                  return this._gpuDescriptorSet;
                }
              }]);
              return WebGL2DescriptorSet;
            }(DescriptorSet);

            var WebGLWraps = [10497, 33648, 33071, 33071];
            var _f32v4 = new Float32Array(4);
            var max = Math.max;
            var min = Math.min;
            function GFXFormatToWebGLType(format, gl) {
              switch (format) {
                case 4:
                  return 5121;
                case 5:
                  return 5120;
                case 6:
                  return 5121;
                case 7:
                  return 5120;
                case 8:
                  return 5131;
                case 9:
                  return 5123;
                case 10:
                  return 5122;
                case 11:
                  return 5126;
                case 12:
                  return 5125;
                case 13:
                  return 5124;
                case 14:
                  return 5121;
                case 15:
                  return 5120;
                case 16:
                  return 5121;
                case 17:
                  return 5120;
                case 18:
                  return 5131;
                case 19:
                  return 5123;
                case 20:
                  return 5122;
                case 21:
                  return 5126;
                case 22:
                  return 5125;
                case 23:
                  return 5124;
                case 24:
                  return 5121;
                case 25:
                  return 5121;
                case 26:
                  return 5120;
                case 27:
                  return 5121;
                case 28:
                  return 5120;
                case 29:
                  return 5131;
                case 30:
                  return 5123;
                case 31:
                  return 5122;
                case 32:
                  return 5126;
                case 33:
                  return 5125;
                case 34:
                  return 5124;
                case 36:
                  return 5121;
                case 35:
                  return 5121;
                case 37:
                  return 5121;
                case 38:
                  return 5120;
                case 39:
                  return 5121;
                case 40:
                  return 5120;
                case 41:
                  return 5131;
                case 42:
                  return 5123;
                case 43:
                  return 5122;
                case 44:
                  return 5126;
                case 45:
                  return 5125;
                case 46:
                  return 5124;
                case 47:
                  return 33635;
                case 48:
                  return 35899;
                case 49:
                  return 32820;
                case 50:
                  return 32819;
                case 51:
                  return 33640;
                case 52:
                  return 33640;
                case 53:
                  return 5126;
                case 54:
                  return 5126;
                case 55:
                  return 34042;
                case 56:
                  return 5121;
                case 58:
                  return 5121;
                case 60:
                  return 5121;
                case 61:
                  return 5121;
                case 62:
                  return 5121;
                case 63:
                  return 5121;
                case 64:
                  return 5121;
                case 65:
                  return 5120;
                case 66:
                  return 5121;
                case 67:
                  return 5120;
                case 69:
                  return 5126;
                case 68:
                  return 5126;
                case 70:
                  return 5121;
                case 71:
                  return 5121;
                case 72:
                  return 5121;
                case 73:
                  return 5121;
                case 74:
                  return 5121;
                case 75:
                  return 5121;
                case 76:
                  return 5121;
                case 79:
                  return 5121;
                case 80:
                  return 5120;
                case 81:
                  return 5121;
                case 82:
                  return 5120;
                case 83:
                  return 5121;
                case 84:
                  return 5121;
                case 85:
                  return 5121;
                case 86:
                  return 5121;
                case 87:
                  return 5121;
                case 88:
                  return 5121;
                case 89:
                case 90:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 97:
                case 98:
                case 99:
                case 100:
                case 101:
                case 102:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111:
                case 112:
                case 113:
                case 114:
                case 115:
                case 116:
                  return 5121;
                default:
                  {
                    return 5121;
                  }
              }
            }
            function GFXFormatToWebGLInternalFormat(format, gl) {
              switch (format) {
                case 1:
                  return 6406;
                case 2:
                  return 6409;
                case 3:
                  return 6410;
                case 4:
                  return 33321;
                case 5:
                  return 36756;
                case 6:
                  return 33330;
                case 7:
                  return 33329;
                case 14:
                  return 33323;
                case 15:
                  return 36757;
                case 16:
                  return 33336;
                case 17:
                  return 33335;
                case 24:
                  return 32849;
                case 26:
                  return 36758;
                case 27:
                  return 36221;
                case 28:
                  return 36239;
                case 36:
                  return 32856;
                case 35:
                  return 32856;
                case 38:
                  return 36759;
                case 39:
                  return 36220;
                case 40:
                  return 36238;
                case 10:
                  return 33331;
                case 9:
                  return 33332;
                case 8:
                  return 33325;
                case 20:
                  return 33337;
                case 19:
                  return 33338;
                case 18:
                  return 33327;
                case 31:
                  return 36233;
                case 30:
                  return 36215;
                case 29:
                  return 34843;
                case 43:
                  return 36232;
                case 42:
                  return 36214;
                case 41:
                  return 34842;
                case 13:
                  return 33333;
                case 12:
                  return 33334;
                case 11:
                  return 33326;
                case 23:
                  return 33339;
                case 22:
                  return 33340;
                case 21:
                  return 33328;
                case 34:
                  return 36227;
                case 33:
                  return 36209;
                case 32:
                  return 34837;
                case 46:
                  return 36226;
                case 45:
                  return 36208;
                case 44:
                  return 34836;
                case 47:
                  return 36194;
                case 49:
                  return 32855;
                case 50:
                  return 32854;
                case 25:
                  return 35905;
                case 37:
                  return 35907;
                case 51:
                  return 32857;
                case 52:
                  return 36975;
                case 48:
                  return 35898;
                case 54:
                  return 36012;
                case 55:
                  return 35056;
                case 56:
                  return 33776;
                case 57:
                  return 33777;
                case 58:
                  return 35916;
                case 59:
                  return 35917;
                case 60:
                  return 33778;
                case 61:
                  return 35918;
                case 62:
                  return 33779;
                case 63:
                  return 35919;
                case 72:
                  return 36196;
                case 73:
                  return 37492;
                case 74:
                  return 37493;
                case 75:
                  return 37494;
                case 76:
                  return 37495;
                case 77:
                  return 37496;
                case 78:
                  return 37497;
                case 79:
                  return 37488;
                case 80:
                  return 37489;
                case 81:
                  return 37490;
                case 82:
                  return 37491;
                case 83:
                  return 35841;
                case 84:
                  return 35843;
                case 85:
                  return 35840;
                case 86:
                  return 35842;
                case 89:
                  return 37808;
                case 90:
                  return 37809;
                case 91:
                  return 37810;
                case 92:
                  return 37811;
                case 93:
                  return 37812;
                case 94:
                  return 37813;
                case 95:
                  return 37814;
                case 96:
                  return 37815;
                case 97:
                  return 37816;
                case 98:
                  return 37817;
                case 99:
                  return 37818;
                case 100:
                  return 37819;
                case 101:
                  return 37820;
                case 102:
                  return 37821;
                case 103:
                  return 37840;
                case 104:
                  return 37841;
                case 105:
                  return 37842;
                case 106:
                  return 37843;
                case 107:
                  return 37844;
                case 108:
                  return 37845;
                case 109:
                  return 37846;
                case 110:
                  return 37847;
                case 111:
                  return 37848;
                case 112:
                  return 37849;
                case 113:
                  return 37850;
                case 114:
                  return 37851;
                case 115:
                  return 37852;
                case 116:
                  return 37853;
                default:
                  {
                    errorID(16309);
                    return 6408;
                  }
              }
            }
            function GFXFormatToWebGLFormat(format, gl) {
              switch (format) {
                case 1:
                  return 6406;
                case 2:
                  return 6409;
                case 3:
                  return 6410;
                case 4:
                case 5:
                  return 6403;
                case 6:
                case 7:
                  return 6403;
                case 14:
                case 15:
                case 16:
                case 17:
                  return 33319;
                case 24:
                case 26:
                case 27:
                case 28:
                  return 6407;
                case 36:
                case 35:
                case 38:
                case 39:
                case 40:
                  return 6408;
                case 9:
                case 10:
                case 8:
                  return 6403;
                case 19:
                case 20:
                case 18:
                  return 33319;
                case 30:
                case 31:
                case 29:
                  return 6407;
                case 42:
                case 43:
                case 41:
                  return 6408;
                case 12:
                case 13:
                case 11:
                  return 6403;
                case 22:
                case 23:
                case 21:
                  return 33319;
                case 33:
                case 34:
                case 32:
                  return 6407;
                case 45:
                case 46:
                case 44:
                  return 6408;
                case 51:
                  return 6408;
                case 48:
                  return 6407;
                case 47:
                  return 6407;
                case 49:
                  return 6408;
                case 50:
                  return 6408;
                case 25:
                  return 6407;
                case 37:
                  return 6408;
                case 54:
                  return 6402;
                case 55:
                  return 34041;
                case 56:
                  return 33776;
                case 57:
                  return 33777;
                case 58:
                  return 35916;
                case 59:
                  return 35917;
                case 60:
                  return 33778;
                case 61:
                  return 35918;
                case 62:
                  return 33779;
                case 63:
                  return 35919;
                case 72:
                  return 36196;
                case 73:
                  return 37492;
                case 74:
                  return 37493;
                case 75:
                  return 37494;
                case 76:
                  return 37495;
                case 77:
                  return 37496;
                case 78:
                  return 37497;
                case 79:
                  return 37488;
                case 80:
                  return 37489;
                case 81:
                  return 37490;
                case 82:
                  return 37491;
                case 83:
                  return 35841;
                case 84:
                  return 35843;
                case 85:
                  return 35840;
                case 86:
                  return 35842;
                case 89:
                  return 37808;
                case 90:
                  return 37809;
                case 91:
                  return 37810;
                case 92:
                  return 37811;
                case 93:
                  return 37812;
                case 94:
                  return 37813;
                case 95:
                  return 37814;
                case 96:
                  return 37815;
                case 97:
                  return 37816;
                case 98:
                  return 37817;
                case 99:
                  return 37818;
                case 100:
                  return 37819;
                case 101:
                  return 37820;
                case 102:
                  return 37821;
                case 103:
                  return 37840;
                case 104:
                  return 37841;
                case 105:
                  return 37842;
                case 106:
                  return 37843;
                case 107:
                  return 37844;
                case 108:
                  return 37845;
                case 109:
                  return 37846;
                case 110:
                  return 37847;
                case 111:
                  return 37848;
                case 112:
                  return 37849;
                case 113:
                  return 37850;
                case 114:
                  return 37851;
                case 115:
                  return 37852;
                case 116:
                  return 37853;
                default:
                  {
                    errorID(16310);
                    return 6408;
                  }
              }
            }
            function GFXTypeToWebGLType(type, gl) {
              switch (type) {
                case 1:
                  return 35670;
                case 2:
                  return 35671;
                case 3:
                  return 35672;
                case 4:
                  return 35673;
                case 5:
                  return 5124;
                case 6:
                  return 35667;
                case 7:
                  return 35668;
                case 8:
                  return 35669;
                case 9:
                  return 5125;
                case 13:
                  return 5126;
                case 14:
                  return 35664;
                case 15:
                  return 35665;
                case 16:
                  return 35666;
                case 17:
                  return 35674;
                case 18:
                  return 35685;
                case 19:
                  return 35686;
                case 20:
                  return 35687;
                case 21:
                  return 35675;
                case 22:
                  return 35688;
                case 23:
                  return 35689;
                case 24:
                  return 35690;
                case 25:
                  return 35676;
                case 28:
                  return 35678;
                case 29:
                  return 36289;
                case 30:
                  return 35679;
                case 31:
                  return 35680;
                default:
                  {
                    errorID(16311);
                    return 0;
                  }
              }
            }
            function WebGLTypeToGFXType(glType, gl) {
              switch (glType) {
                case 35670:
                  return 1;
                case 35671:
                  return 2;
                case 35672:
                  return 3;
                case 35673:
                  return 4;
                case 5124:
                  return 5;
                case 35667:
                  return 6;
                case 35668:
                  return 7;
                case 35669:
                  return 8;
                case 5125:
                  return 9;
                case 36294:
                  return 10;
                case 36295:
                  return 11;
                case 36296:
                  return 12;
                case 5126:
                  return 13;
                case 35664:
                  return 14;
                case 35665:
                  return 15;
                case 35666:
                  return 16;
                case 35674:
                  return 17;
                case 35685:
                  return 18;
                case 35686:
                  return 19;
                case 35687:
                  return 20;
                case 35675:
                  return 21;
                case 35688:
                  return 22;
                case 35689:
                  return 23;
                case 35690:
                  return 24;
                case 35676:
                  return 25;
                case 35678:
                  return 28;
                case 36289:
                  return 29;
                case 35679:
                  return 30;
                case 35680:
                  return 31;
                default:
                  {
                    errorID(16313);
                    return 0;
                  }
              }
            }
            function WebGLGetTypeSize(glType, gl) {
              switch (glType) {
                case 35670:
                  return 4;
                case 35671:
                  return 8;
                case 35672:
                  return 12;
                case 35673:
                  return 16;
                case 5124:
                  return 4;
                case 35667:
                  return 8;
                case 35668:
                  return 12;
                case 35669:
                  return 16;
                case 5125:
                  return 4;
                case 36294:
                  return 8;
                case 36295:
                  return 12;
                case 36296:
                  return 16;
                case 5126:
                  return 4;
                case 35664:
                  return 8;
                case 35665:
                  return 12;
                case 35666:
                  return 16;
                case 35674:
                  return 16;
                case 35685:
                  return 24;
                case 35686:
                  return 32;
                case 35687:
                  return 24;
                case 35675:
                  return 36;
                case 35688:
                  return 48;
                case 35689:
                  return 32;
                case 35690:
                  return 48;
                case 35676:
                  return 64;
                case 35678:
                  return 4;
                case 36289:
                  return 4;
                case 36292:
                  return 4;
                case 35679:
                  return 4;
                case 35680:
                  return 4;
                case 36298:
                  return 4;
                case 36303:
                  return 4;
                case 36299:
                  return 4;
                case 36300:
                  return 4;
                case 36306:
                  return 4;
                case 36311:
                  return 4;
                case 36307:
                  return 4;
                case 36308:
                  return 4;
                default:
                  {
                    errorID(16314);
                    return 0;
                  }
              }
            }
            function WebGLGetComponentCount(glType, gl) {
              switch (glType) {
                case 35674:
                  return 2;
                case 35685:
                  return 2;
                case 35686:
                  return 2;
                case 35687:
                  return 3;
                case 35675:
                  return 3;
                case 35688:
                  return 3;
                case 35689:
                  return 4;
                case 35690:
                  return 4;
                case 35676:
                  return 4;
                default:
                  {
                    return 1;
                  }
              }
            }
            var WebGLCmpFuncs = [512, 513, 514, 515, 516, 517, 518, 519];
            var WebGLStencilOps = [0, 7680, 7681, 7682, 7683, 5386, 34055, 34056];
            var WebGLBlendOps = [32774, 32778, 32779, 32775, 32776];
            var WebGLBlendFactors = [0, 1, 770, 772, 771, 773, 768, 774, 769, 775, 776, 32769, 32770, 32771, 32772];
            function WebGL2CmdFuncCreateBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var glUsage = gpuBuffer.memUsage & 2 ? 35048 : 35044;
              if (gpuBuffer.usage & 8) {
                gpuBuffer.glTarget = 34962;
                var glBuffer = gl.createBuffer();
                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;
                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = null;
                      }
                    }
                    gfxStateCache.gpuInputAssembler = null;
                    if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(34962, gpuBuffer.glBuffer);
                      cache.glArrayBuffer = gpuBuffer.glBuffer;
                    }
                    gl.bufferData(34962, gpuBuffer.size, glUsage);
                    gl.bindBuffer(34962, null);
                    cache.glArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & 4) {
                gpuBuffer.glTarget = 34963;
                var _glBuffer = gl.createBuffer();
                if (_glBuffer) {
                  gpuBuffer.glBuffer = _glBuffer;
                  if (gpuBuffer.size > 0) {
                    if (device.extensions.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = null;
                      }
                    }
                    gfxStateCache.gpuInputAssembler = null;
                    if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(34963, gpuBuffer.glBuffer);
                      cache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }
                    gl.bufferData(34963, gpuBuffer.size, glUsage);
                    gl.bindBuffer(34963, null);
                    cache.glElementArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & 16) {
                gpuBuffer.glTarget = 35345;
                var _glBuffer2 = gl.createBuffer();
                if (_glBuffer2 && gpuBuffer.size > 0) {
                  gpuBuffer.glBuffer = _glBuffer2;
                  if (cache.glUniformBuffer !== gpuBuffer.glBuffer) {
                    gl.bindBuffer(35345, gpuBuffer.glBuffer);
                    cache.glUniformBuffer = gpuBuffer.glBuffer;
                  }
                  gl.bufferData(35345, gpuBuffer.size, glUsage);
                  gl.bindBuffer(35345, null);
                  cache.glUniformBuffer = null;
                }
              } else if (gpuBuffer.usage & 64) {
                gpuBuffer.glTarget = 0;
              } else if (gpuBuffer.usage & 2) {
                gpuBuffer.glTarget = 0;
              } else if (gpuBuffer.usage & 1) {
                gpuBuffer.glTarget = 0;
              } else {
                errorID(16315);
                gpuBuffer.glTarget = 0;
              }
            }
            function WebGL2CmdFuncDestroyBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var useVAO = device.extensions.useVAO;
              if (gpuBuffer.glBuffer) {
                switch (gpuBuffer.glTarget) {
                  case 34962:
                    if (useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = null;
                      }
                    }
                    gfxStateCache.gpuInputAssembler = null;
                    gl.bindBuffer(34962, null);
                    cache.glArrayBuffer = null;
                    break;
                  case 34963:
                    if (useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = null;
                      }
                    }
                    gfxStateCache.gpuInputAssembler = null;
                    gl.bindBuffer(34963, null);
                    cache.glElementArrayBuffer = null;
                    break;
                  case 35345:
                    gl.bindBuffer(35345, null);
                    cache.glUniformBuffer = null;
                    break;
                }
                gl.deleteBuffer(gpuBuffer.glBuffer);
                gpuBuffer.glBuffer = null;
              }
            }
            function WebGL2CmdFuncResizeBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var glUsage = gpuBuffer.memUsage & 2 ? 35048 : 35044;
              if (gpuBuffer.usage & 8) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }
                gfxStateCache.gpuInputAssembler = null;
                if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(34962, gpuBuffer.glBuffer);
                }
                if (gpuBuffer.buffer) {
                  gl.bufferData(34962, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(34962, gpuBuffer.size, glUsage);
                }
                gl.bindBuffer(34962, null);
                cache.glArrayBuffer = null;
              } else if (gpuBuffer.usage & 4) {
                if (device.extensions.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = null;
                  }
                }
                gfxStateCache.gpuInputAssembler = null;
                if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(34963, gpuBuffer.glBuffer);
                }
                if (gpuBuffer.buffer) {
                  gl.bufferData(34963, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(34963, gpuBuffer.size, glUsage);
                }
                gl.bindBuffer(34963, null);
                cache.glElementArrayBuffer = null;
              } else if (gpuBuffer.usage & 16) {
                if (cache.glUniformBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(35345, gpuBuffer.glBuffer);
                }
                gl.bufferData(35345, gpuBuffer.size, glUsage);
                gl.bindBuffer(35345, null);
                cache.glUniformBuffer = null;
              } else if (gpuBuffer.usage & 64 || gpuBuffer.usage & 2 || gpuBuffer.usage & 1) {
                gpuBuffer.glTarget = 0;
              } else {
                errorID(16315);
                gpuBuffer.glTarget = 0;
              }
            }
            function WebGL2CmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
              if (gpuBuffer.usage & 64) {
                gpuBuffer.indirects.clearDraws();
                var drawInfos = buffer.drawInfos;
                for (var i = 0; i < drawInfos.length; ++i) {
                  gpuBuffer.indirects.setDrawInfo(offset + i, drawInfos[i]);
                }
              } else {
                var buff = buffer;
                var gl = device.gl;
                var cache = device.getStateCache();
                switch (gpuBuffer.glTarget) {
                  case 34962:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          gl.bindVertexArray(null);
                          cache.glVAO = null;
                        }
                      }
                      gfxStateCache.gpuInputAssembler = null;
                      if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(34962, gpuBuffer.glBuffer);
                        cache.glArrayBuffer = gpuBuffer.glBuffer;
                      }
                      if (systemInfo.os === OS.IOS && gpuBuffer.memUsage & 2 && offset === 0 && size === buff.byteLength) {
                        gl.bufferData(gpuBuffer.glTarget, buff, gl.DYNAMIC_DRAW);
                      } else if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                      }
                      break;
                    }
                  case 34963:
                    {
                      if (device.extensions.useVAO) {
                        if (cache.glVAO) {
                          gl.bindVertexArray(null);
                          cache.glVAO = null;
                        }
                      }
                      gfxStateCache.gpuInputAssembler = null;
                      if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(34963, gpuBuffer.glBuffer);
                        cache.glElementArrayBuffer = gpuBuffer.glBuffer;
                      }
                      if (systemInfo.os === OS.IOS && gpuBuffer.memUsage & 2 && offset === 0 && size === buff.byteLength) {
                        gl.bufferData(gpuBuffer.glTarget, buff, gl.DYNAMIC_DRAW);
                      } else if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                      }
                      break;
                    }
                  case 35345:
                    {
                      if (cache.glUniformBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(35345, gpuBuffer.glBuffer);
                        cache.glUniformBuffer = gpuBuffer.glBuffer;
                      }
                      if (systemInfo.os === OS.IOS && gpuBuffer.memUsage & 2 && offset === 0 && size === buff.byteLength) {
                        gl.bufferData(gpuBuffer.glTarget, buff, gl.DYNAMIC_DRAW);
                      } else if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, new Float32Array(buff, 0, size / 4));
                      }
                      break;
                    }
                  default:
                    {
                      errorID(16316);
                    }
                }
              }
            }
            function WebGL2CmdFuncCreateTexture(device, gpuTexture) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var capabilities = device.capabilities;
              gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format);
              gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format);
              gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format);
              var w = gpuTexture.width;
              var h = gpuTexture.height;
              var d = gpuTexture.depth;
              var l = gpuTexture.arrayLayer;
              switch (gpuTexture.type) {
                case 1:
                  {
                    gpuTexture.glTarget = 3553;
                    var maxSize = max(w, h);
                    if (maxSize > capabilities.maxTextureSize) {
                      errorID(9100, maxSize, capabilities.maxTextureSize);
                    }
                    if (gpuTexture.samples === 1) {
                      gpuTexture.glTexture = gl.createTexture();
                      if (gpuTexture.size > 0) {
                        var glTexUnit = cache.glTexUnits[cache.texUnit];
                        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                          gl.bindTexture(3553, gpuTexture.glTexture);
                          glTexUnit.glTexture = gpuTexture.glTexture;
                        }
                        if (FormatInfos[gpuTexture.format].isCompressed) {
                          for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                            var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            var view = new Uint8Array(imgSize);
                            gl.compressedTexImage2D(3553, i, gpuTexture.glInternalFmt, w, h, 0, view);
                            w = max(1, w >> 1);
                            h = max(1, h >> 1);
                          }
                        } else if (gpuTexture.flags & 128) {
                          gl.texImage2D(3553, 0, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                        } else {
                          gl.texStorage2D(3553, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                        }
                      }
                    } else {
                      gpuTexture.glRenderbuffer = gl.createRenderbuffer();
                      if (gpuTexture.size > 0) {
                        if (cache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                          gl.bindRenderbuffer(36161, gpuTexture.glRenderbuffer);
                          cache.glRenderbuffer = gpuTexture.glRenderbuffer;
                        }
                        gl.renderbufferStorageMultisample(36161, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                      }
                    }
                    break;
                  }
                case 5:
                  {
                    gpuTexture.glTarget = 35866;
                    var _maxSize = max(w, h);
                    if (_maxSize > capabilities.maxTextureSize) {
                      errorID(9100, _maxSize, capabilities.maxTextureSize);
                    }
                    if (l > capabilities.maxArrayTextureLayers) {
                      errorID(9100, l, capabilities.maxArrayTextureLayers);
                    }
                    gpuTexture.glTexture = gl.createTexture();
                    if (gpuTexture.size > 0) {
                      var _glTexUnit = cache.glTexUnits[cache.texUnit];
                      if (_glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(35866, gpuTexture.glTexture);
                        _glTexUnit.glTexture = gpuTexture.glTexture;
                      }
                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                          var _imgSize = FormatSize(gpuTexture.format, w, h, l);
                          var _view = new Uint8Array(_imgSize);
                          gl.compressedTexImage3D(35866, _i, gpuTexture.glInternalFmt, w, h, l, 0, _view);
                          w = max(1, w >> 1);
                          h = max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage3D(35866, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, l);
                      }
                    }
                    break;
                  }
                case 2:
                  {
                    gpuTexture.glTarget = 32879;
                    var _maxSize2 = max(max(w, h), d);
                    if (_maxSize2 > capabilities.max3DTextureSize) {
                      errorID(9100, _maxSize2, capabilities.max3DTextureSize);
                    }
                    gpuTexture.glTexture = gl.createTexture();
                    if (gpuTexture.size > 0) {
                      var _glTexUnit2 = cache.glTexUnits[cache.texUnit];
                      if (_glTexUnit2.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(32879, gpuTexture.glTexture);
                        _glTexUnit2.glTexture = gpuTexture.glTexture;
                      }
                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) {
                          var _imgSize2 = FormatSize(gpuTexture.format, w, h, d);
                          var _view2 = new Uint8Array(_imgSize2);
                          gl.compressedTexImage3D(32879, _i2, gpuTexture.glInternalFmt, w, h, d, 0, _view2);
                          w = max(1, w >> 1);
                          h = max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage3D(32879, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, d);
                      }
                    }
                    break;
                  }
                case 3:
                  {
                    gpuTexture.glTarget = 34067;
                    var _maxSize3 = max(w, h);
                    if (_maxSize3 > capabilities.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize3, capabilities.maxTextureSize);
                    }
                    gpuTexture.glTexture = gl.createTexture();
                    if (gpuTexture.size > 0) {
                      var _glTexUnit3 = cache.glTexUnits[cache.texUnit];
                      if (_glTexUnit3.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(34067, gpuTexture.glTexture);
                        _glTexUnit3.glTexture = gpuTexture.glTexture;
                      }
                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                          var _imgSize3 = FormatSize(gpuTexture.format, w, h, 1);
                          var _view3 = new Uint8Array(_imgSize3);
                          for (var f = 0; f < 6; ++f) {
                            gl.compressedTexImage2D(34069 + f, _i3, gpuTexture.glInternalFmt, w, h, 0, _view3);
                          }
                          w = max(1, w >> 1);
                          h = max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage2D(34067, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                      }
                    }
                    break;
                  }
                default:
                  {
                    errorID(16317);
                    gpuTexture.type = 1;
                    gpuTexture.glTarget = 3553;
                  }
              }
            }
            function WebGL2CmdFuncDestroyTexture(device, gpuTexture) {
              var gl = device.gl;
              var cache = device.getStateCache();
              if (gpuTexture.glTexture) {
                var glTexUnits = cache.glTexUnits;
                var texUnit = cache.texUnit;
                gl.deleteTexture(gpuTexture.glTexture);
                for (var i = 0; i < glTexUnits.length; ++i) {
                  if (glTexUnits[i].glTexture === gpuTexture.glTexture) {
                    gl.activeTexture(33984 + i);
                    texUnit = i;
                    gl.bindTexture(gpuTexture.glTarget, null);
                    glTexUnits[i].glTexture = null;
                  }
                }
                cache.texUnit = texUnit;
                gpuTexture.glTexture = null;
              }
              if (gpuTexture.glRenderbuffer) {
                var glRenderbuffer = cache.glRenderbuffer;
                gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);
                if (glRenderbuffer === gpuTexture.glRenderbuffer) {
                  gl.bindRenderbuffer(36161, null);
                  cache.glRenderbuffer = null;
                }
                gpuTexture.glRenderbuffer = null;
              }
            }
            function WebGL2CmdFuncResizeTexture(device, gpuTexture) {
              if (!gpuTexture.size) return;
              var gl = device.gl;
              var cache = device.getStateCache();
              var capabilities = device.capabilities;
              var w = gpuTexture.width;
              var h = gpuTexture.height;
              var d = gpuTexture.depth;
              var l = gpuTexture.arrayLayer;
              switch (gpuTexture.type) {
                case 1:
                  {
                    gpuTexture.glTarget = 3553;
                    var maxSize = max(w, h);
                    if (maxSize > capabilities.maxTextureSize) {
                      errorID(9100, maxSize, capabilities.maxTextureSize);
                    }
                    if (gpuTexture.samples === 1) {
                      var glTexUnit = cache.glTexUnits[cache.texUnit];
                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(3553, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }
                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                          var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          var view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(3553, i, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = max(1, w >> 1);
                          h = max(1, h >> 1);
                        }
                      } else {
                        WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                        WebGL2CmdFuncCreateTexture(device, gpuTexture);
                      }
                    } else if (gpuTexture.glRenderbuffer) {
                      if (cache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                        gl.bindRenderbuffer(36161, gpuTexture.glRenderbuffer);
                        cache.glRenderbuffer = gpuTexture.glRenderbuffer;
                      }
                      gl.renderbufferStorageMultisample(36161, gpuTexture.samples, gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                    }
                    break;
                  }
                case 5:
                  {
                    gpuTexture.glTarget = 35866;
                    var _maxSize4 = max(w, h);
                    if (_maxSize4 > capabilities.maxTextureSize) {
                      errorID(9100, _maxSize4, capabilities.maxTextureSize);
                    }
                    if (l > capabilities.maxArrayTextureLayers) {
                      errorID(9100, l, capabilities.maxArrayTextureLayers);
                    }
                    gpuTexture.glTexture = gl.createTexture();
                    if (gpuTexture.size > 0) {
                      var _glTexUnit4 = cache.glTexUnits[cache.texUnit];
                      if (_glTexUnit4.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(35866, gpuTexture.glTexture);
                        _glTexUnit4.glTexture = gpuTexture.glTexture;
                      }
                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                          var _imgSize4 = FormatSize(gpuTexture.format, w, h, l);
                          var _view4 = new Uint8Array(_imgSize4);
                          gl.compressedTexImage3D(35866, _i4, gpuTexture.glInternalFmt, w, h, l, 0, _view4);
                          w = max(1, w >> 1);
                          h = max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage3D(35866, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, l);
                      }
                    }
                    break;
                  }
                case 2:
                  {
                    gpuTexture.glTarget = 32879;
                    var _maxSize5 = max(max(w, h), d);
                    if (_maxSize5 > capabilities.max3DTextureSize) {
                      errorID(9100, _maxSize5, capabilities.max3DTextureSize);
                    }
                    gpuTexture.glTexture = gl.createTexture();
                    if (gpuTexture.size > 0) {
                      var _glTexUnit5 = cache.glTexUnits[cache.texUnit];
                      if (_glTexUnit5.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(32879, gpuTexture.glTexture);
                        _glTexUnit5.glTexture = gpuTexture.glTexture;
                      }
                      if (FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) {
                          var _imgSize5 = FormatSize(gpuTexture.format, w, h, d);
                          var _view5 = new Uint8Array(_imgSize5);
                          gl.compressedTexImage3D(32879, _i5, gpuTexture.glInternalFmt, w, h, d, 0, _view5);
                          w = max(1, w >> 1);
                          h = max(1, h >> 1);
                        }
                      } else {
                        gl.texStorage3D(32879, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h, d);
                      }
                    }
                    break;
                  }
                case 3:
                  {
                    gpuTexture.type = 3;
                    gpuTexture.glTarget = 34067;
                    var _maxSize6 = max(w, h);
                    if (_maxSize6 > capabilities.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize6, capabilities.maxTextureSize);
                    }
                    var _glTexUnit6 = cache.glTexUnits[cache.texUnit];
                    if (_glTexUnit6.glTexture !== gpuTexture.glTexture) {
                      gl.bindTexture(34067, gpuTexture.glTexture);
                      _glTexUnit6.glTexture = gpuTexture.glTexture;
                    }
                    if (FormatInfos[gpuTexture.format].isCompressed) {
                      for (var f = 0; f < 6; ++f) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;
                        for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                          var _imgSize6 = FormatSize(gpuTexture.format, w, h, 1);
                          var _view6 = new Uint8Array(_imgSize6);
                          gl.compressedTexImage2D(34069 + f, _i6, gpuTexture.glInternalFmt, w, h, 0, _view6);
                          w = max(1, w >> 1);
                          h = max(1, h >> 1);
                        }
                      }
                    } else {
                      WebGL2CmdFuncDestroyTexture(device, gpuTexture);
                      WebGL2CmdFuncCreateTexture(device, gpuTexture);
                    }
                    break;
                  }
                default:
                  {
                    errorID(16317);
                    gpuTexture.type = 1;
                    gpuTexture.glTarget = 3553;
                  }
              }
            }
            function WebGL2CmdFuncPrepareSamplerInfo(device, gpuSampler) {
              device.gl;
              if (gpuSampler.minFilter === 2 || gpuSampler.minFilter === 3) {
                if (gpuSampler.mipFilter === 2 || gpuSampler.mipFilter === 3) {
                  gpuSampler.glMinFilter = 9987;
                } else if (gpuSampler.mipFilter === 1) {
                  gpuSampler.glMinFilter = 9985;
                } else {
                  gpuSampler.glMinFilter = 9729;
                }
              } else if (gpuSampler.mipFilter === 2 || gpuSampler.mipFilter === 3) {
                gpuSampler.glMinFilter = 9986;
              } else if (gpuSampler.mipFilter === 1) {
                gpuSampler.glMinFilter = 9984;
              } else {
                gpuSampler.glMinFilter = 9728;
              }
              if (gpuSampler.magFilter === 2 || gpuSampler.magFilter === 3) {
                gpuSampler.glMagFilter = 9729;
              } else {
                gpuSampler.glMagFilter = 9728;
              }
              gpuSampler.glWrapS = WebGLWraps[gpuSampler.addressU];
              gpuSampler.glWrapT = WebGLWraps[gpuSampler.addressV];
              gpuSampler.glWrapR = WebGLWraps[gpuSampler.addressW];
            }
            function WebGL2CmdFuncDestroySampler(device, gpuSampler) {
              var gl = device.gl;
              var it = gpuSampler.glSamplers.values();
              var res = it.next();
              while (!res.done) {
                gl.deleteSampler(res.value);
                var glSamplerUnits = device.getStateCache().glSamplerUnits;
                for (var i = 0; i < glSamplerUnits.length; ++i) {
                  if (glSamplerUnits[i] === res.value) {
                    gl.bindSampler(i, null);
                    glSamplerUnits[i] = null;
                  }
                }
              }
              gpuSampler.glSamplers.clear();
            }
            function WebGL2CmdFuncCreateFramebuffer(device, gpuFramebuffer) {
              var cache = device.getStateCache();
              for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; ++i) {
                var tex = gpuFramebuffer.gpuColorViews[i].gpuTexture;
                if (tex.isSwapchainTexture) {
                  gpuFramebuffer.isOffscreen = false;
                  return;
                }
              }
              var gl = device.gl;
              var attachments = [];
              var glFramebuffer = gl.createFramebuffer();
              if (glFramebuffer) {
                gpuFramebuffer.glFramebuffer = glFramebuffer;
                if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(36160, gpuFramebuffer.glFramebuffer);
                }
                for (var _i7 = 0; _i7 < gpuFramebuffer.gpuColorViews.length; ++_i7) {
                  var colorTextureView = gpuFramebuffer.gpuColorViews[_i7];
                  var colorTexture = colorTextureView.gpuTexture;
                  if (colorTexture) {
                    if (colorTexture.glTexture) {
                      gl.framebufferTexture2D(36160, 36064 + _i7, colorTexture.glTarget, colorTexture.glTexture, colorTextureView.baseLevel);
                    } else {
                      gl.framebufferRenderbuffer(36160, 36064 + _i7, 36161, colorTexture.glRenderbuffer);
                    }
                    attachments.push(36064 + _i7);
                    gpuFramebuffer.width = min(gpuFramebuffer.width, colorTexture.width >> colorTextureView.baseLevel);
                    gpuFramebuffer.height = min(gpuFramebuffer.height, colorTexture.height >> colorTextureView.baseLevel);
                  }
                }
                var dstView = gpuFramebuffer.gpuDepthStencilView;
                if (dstView) {
                  var dst = dstView.gpuTexture;
                  var glAttachment = FormatInfos[dst.format].hasStencil ? 33306 : 36096;
                  if (dst.glTexture) {
                    gl.framebufferTexture2D(36160, glAttachment, dst.glTarget, dst.glTexture, gpuFramebuffer.gpuDepthStencilView.baseLevel);
                  } else {
                    gl.framebufferRenderbuffer(36160, glAttachment, 36161, dst.glRenderbuffer);
                  }
                  gpuFramebuffer.width = min(gpuFramebuffer.width, dst.width >> dstView.baseLevel);
                  gpuFramebuffer.height = min(gpuFramebuffer.height, dst.height >> dstView.baseLevel);
                }
                gl.drawBuffers(attachments);
                var status = gl.checkFramebufferStatus(36160);
                if (status !== 36053) {
                  switch (status) {
                    case 36054:
                      {
                        errorID(16318);
                        break;
                      }
                    case 36055:
                      {
                        errorID(16319);
                        break;
                      }
                    case 36057:
                      {
                        errorID(16320);
                        break;
                      }
                    case 36061:
                      {
                        errorID(16321);
                        break;
                      }
                  }
                }
                if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(36160, cache.glFramebuffer);
                }
              }
            }
            function WebGL2CmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
              var gl = device.gl;
              var cache = device.getStateCache();
              if (gpuFramebuffer.glFramebuffer) {
                gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);
                if (cache.glFramebuffer === gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(36160, null);
                  cache.glFramebuffer = null;
                }
                gpuFramebuffer.glFramebuffer = null;
              }
            }
            function WebGL2CmdFuncCreateShader(device, gpuShader) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var capabilities = device.capabilities;
              var _loop = function _loop() {
                  var gpuStage = gpuShader.gpuStages[k];
                  var glShaderType = 0;
                  var shaderTypeStr = '';
                  var lineNumber = 1;
                  switch (gpuStage.type) {
                    case 1:
                      {
                        shaderTypeStr = 'VertexShader';
                        glShaderType = 35633;
                        break;
                      }
                    case 16:
                      {
                        shaderTypeStr = 'FragmentShader';
                        glShaderType = 35632;
                        break;
                      }
                    default:
                      {
                        errorID(16322);
                        return {
                          v: undefined
                        };
                      }
                  }
                  var glShader = gl.createShader(glShaderType);
                  if (glShader) {
                    gpuStage.glShader = glShader;
                    gl.shaderSource(gpuStage.glShader, "#version 300 es\n" + gpuStage.source);
                    gl.compileShader(gpuStage.glShader);
                    if (!gl.getShaderParameter(gpuStage.glShader, 35713)) {
                      errorID(16323, shaderTypeStr, gpuShader.name);
                      errorID(16324, gpuStage.source.replace(/^|\n/g, function () {
                        return "\n" + lineNumber++ + " ";
                      }));
                      error(gl.getShaderInfoLog(gpuStage.glShader));
                      for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                        var stage = gpuShader.gpuStages[k];
                        if (stage.glShader) {
                          gl.deleteShader(stage.glShader);
                          stage.glShader = null;
                        }
                      }
                      return {
                        v: undefined
                      };
                    }
                  }
                },
                _ret;
              for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                _ret = _loop();
                if (_ret) return _ret.v;
              }
              var glProgram = gl.createProgram();
              if (!glProgram) {
                return;
              }
              gpuShader.glProgram = glProgram;
              var enableEffectImport = !!(cclegacy.rendering && cclegacy.rendering.enableEffectImport);
              for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
                var gpuStage = gpuShader.gpuStages[_k];
                gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
              }
              gl.linkProgram(gpuShader.glProgram);
              for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
                var _gpuStage = gpuShader.gpuStages[_k2];
                if (_gpuStage.glShader) {
                  gl.detachShader(gpuShader.glProgram, _gpuStage.glShader);
                  gl.deleteShader(_gpuStage.glShader);
                  _gpuStage.glShader = null;
                }
              }
              if (gl.getProgramParameter(gpuShader.glProgram, 35714)) {
                debugID(16325, gpuShader.name);
              } else {
                errorID(16326, gpuShader.name);
                error(gl.getProgramInfoLog(gpuShader.glProgram));
                return;
              }
              var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, 35721);
              gpuShader.glInputs = new Array(activeAttribCount);
              for (var i = 0; i < activeAttribCount; ++i) {
                var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);
                if (attribInfo) {
                  var varName = undefined;
                  var nameOffset = attribInfo.name.indexOf('[');
                  if (nameOffset !== -1) {
                    varName = attribInfo.name.substring(0, nameOffset);
                  } else {
                    varName = attribInfo.name;
                  }
                  var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
                  var type = WebGLTypeToGFXType(attribInfo.type);
                  var stride = WebGLGetTypeSize(attribInfo.type);
                  gpuShader.glInputs[i] = {
                    name: varName,
                    type: type,
                    stride: stride,
                    count: attribInfo.size,
                    size: stride * attribInfo.size,
                    glType: attribInfo.type,
                    glLoc: glLoc
                  };
                }
              }
              var activeBlockCount = gl.getProgramParameter(gpuShader.glProgram, 35382);
              var blockName;
              var blockIdx;
              var blockSize;
              var block;
              if (activeBlockCount) {
                gpuShader.glBlocks = new Array(activeBlockCount);
                for (var b = 0; b < activeBlockCount; ++b) {
                  blockName = gl.getActiveUniformBlockName(gpuShader.glProgram, b);
                  var _nameOffset = blockName.indexOf('[');
                  if (_nameOffset !== -1) {
                    blockName = blockName.substring(0, _nameOffset);
                  }
                  block = null;
                  for (var _k3 = 0; _k3 < gpuShader.blocks.length; _k3++) {
                    if (gpuShader.blocks[_k3].name === blockName) {
                      block = gpuShader.blocks[_k3];
                      break;
                    }
                  }
                  if (!block) {
                    errorID(16404, blockName);
                  } else {
                    blockIdx = b;
                    blockSize = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, 35392);
                    var glBinding = enableEffectImport ? block.flattened : block.binding + (device.bindingMappings.blockOffsets[block.set] || 0);
                    gl.uniformBlockBinding(gpuShader.glProgram, blockIdx, glBinding);
                    gpuShader.glBlocks[b] = {
                      set: block.set,
                      binding: block.binding,
                      idx: blockIdx,
                      name: blockName,
                      size: blockSize,
                      glBinding: glBinding
                    };
                  }
                }
              }
              for (var _i8 = 0; _i8 < gpuShader.subpassInputs.length; ++_i8) {
                var subpassInput = gpuShader.subpassInputs[_i8];
                gpuShader.samplerTextures.push(new UniformSamplerTexture(subpassInput.set, subpassInput.binding, subpassInput.name, 28, subpassInput.count));
              }
              if (gpuShader.samplerTextures.length > 0) {
                gpuShader.glSamplerTextures = new Array(gpuShader.samplerTextures.length);
                for (var _i9 = 0; _i9 < gpuShader.samplerTextures.length; ++_i9) {
                  var sampler = gpuShader.samplerTextures[_i9];
                  gpuShader.glSamplerTextures[_i9] = {
                    set: sampler.set,
                    binding: sampler.binding,
                    name: sampler.name,
                    type: sampler.type,
                    count: sampler.count,
                    units: [],
                    glUnits: null,
                    glType: GFXTypeToWebGLType(sampler.type),
                    glLoc: null
                  };
                }
              }
              var glActiveSamplers = [];
              var glActiveSamplerLocations = [];
              var texUnitCacheMap = cache.texUnitCacheMap;
              if (!enableEffectImport) {
                var flexibleSetBaseOffset = 0;
                for (var _i10 = 0; _i10 < gpuShader.blocks.length; ++_i10) {
                  if (gpuShader.blocks[_i10].set === device.bindingMappings.flexibleSet) {
                    flexibleSetBaseOffset++;
                  }
                }
                var arrayOffset = 0;
                for (var _i11 = 0; _i11 < gpuShader.samplerTextures.length; ++_i11) {
                  var _sampler = gpuShader.samplerTextures[_i11];
                  var _glLoc = gl.getUniformLocation(gpuShader.glProgram, _sampler.name);
                  if (_glLoc && _glLoc.id !== -1) {
                    glActiveSamplers.push(gpuShader.glSamplerTextures[_i11]);
                    glActiveSamplerLocations.push(_glLoc);
                  }
                  if (texUnitCacheMap[_sampler.name] === undefined) {
                    var binding = _sampler.binding + device.bindingMappings.samplerTextureOffsets[_sampler.set] + arrayOffset;
                    if (_sampler.set === device.bindingMappings.flexibleSet) {
                      binding -= flexibleSetBaseOffset;
                    }
                    texUnitCacheMap[_sampler.name] = binding % capabilities.maxTextureUnits;
                    arrayOffset += _sampler.count - 1;
                  }
                }
              } else {
                for (var _i12 = 0; _i12 < gpuShader.samplerTextures.length; ++_i12) {
                  var _sampler2 = gpuShader.samplerTextures[_i12];
                  var _glLoc2 = gl.getUniformLocation(gpuShader.glProgram, _sampler2.name);
                  if (_glLoc2 && _glLoc2.id !== -1) {
                    glActiveSamplers.push(gpuShader.glSamplerTextures[_i12]);
                    glActiveSamplerLocations.push(_glLoc2);
                  }
                  if (texUnitCacheMap[_sampler2.name] === undefined) {
                    texUnitCacheMap[_sampler2.name] = _sampler2.flattened % capabilities.maxTextureUnits;
                  }
                }
              }
              if (glActiveSamplers.length) {
                var usedTexUnits = [];
                for (var _i13 = 0; _i13 < glActiveSamplers.length; ++_i13) {
                  var glSampler = glActiveSamplers[_i13];
                  var cachedUnit = texUnitCacheMap[glSampler.name];
                  if (cachedUnit !== undefined) {
                    glSampler.glLoc = glActiveSamplerLocations[_i13];
                    for (var t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[cachedUnit]) {
                        cachedUnit = (cachedUnit + 1) % capabilities.maxTextureUnits;
                      }
                      glSampler.units.push(cachedUnit);
                      usedTexUnits[cachedUnit] = true;
                    }
                  }
                }
                var unitIdx = 0;
                for (var _i14 = 0; _i14 < glActiveSamplers.length; ++_i14) {
                  var _glSampler = glActiveSamplers[_i14];
                  if (!_glSampler.glLoc) {
                    _glSampler.glLoc = glActiveSamplerLocations[_i14];
                    while (usedTexUnits[unitIdx]) {
                      unitIdx++;
                    }
                    for (var _t = 0; _t < _glSampler.count; ++_t) {
                      while (usedTexUnits[unitIdx]) {
                        unitIdx = (unitIdx + 1) % capabilities.maxTextureUnits;
                      }
                      if (texUnitCacheMap[_glSampler.name] === undefined) {
                        texUnitCacheMap[_glSampler.name] = unitIdx;
                      }
                      _glSampler.units.push(unitIdx);
                      usedTexUnits[unitIdx] = true;
                    }
                  }
                }
                if (cache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(gpuShader.glProgram);
                }
                for (var _k4 = 0; _k4 < glActiveSamplers.length; _k4++) {
                  var _glSampler2 = glActiveSamplers[_k4];
                  _glSampler2.glUnits = new Int32Array(_glSampler2.units);
                  gl.uniform1iv(_glSampler2.glLoc, _glSampler2.glUnits);
                }
                if (cache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(cache.glProgram);
                }
              }
              gpuShader.glSamplerTextures = glActiveSamplers;
            }
            function WebGL2CmdFuncDestroyShader(device, gpuShader) {
              var gl = device.gl;
              var cache = device.getStateCache();
              if (gpuShader.glProgram) {
                gl.deleteProgram(gpuShader.glProgram);
                if (cache.glProgram === gpuShader.glProgram) {
                  gl.useProgram(null);
                  cache.glProgram = null;
                }
                gpuShader.glProgram = null;
              }
            }
            function WebGL2CmdFuncCreateInputAssember(device, gpuInputAssembler) {
              device.gl;
              gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
              var offsets = [0, 0, 0, 0, 0, 0, 0, 0];
              for (var i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                var attrib = gpuInputAssembler.attributes[i];
                var stream = attrib.stream !== undefined ? attrib.stream : 0;
                var gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
                var glType = GFXFormatToWebGLType(attrib.format);
                var size = FormatInfos[attrib.format].size;
                gpuInputAssembler.glAttribs[i] = {
                  name: attrib.name,
                  glBuffer: gpuBuffer.glBuffer,
                  glType: glType,
                  size: size,
                  count: FormatInfos[attrib.format].count,
                  stride: gpuBuffer.stride,
                  componentCount: WebGLGetComponentCount(glType),
                  isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
                  isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
                  offset: offsets[stream]
                };
                offsets[stream] += size;
              }
            }
            function WebGL2CmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var it = gpuInputAssembler.glVAOs.values();
              var res = it.next();
              var glVAO = cache.glVAO;
              while (!res.done) {
                gl.deleteVertexArray(res.value);
                if (glVAO === res.value) {
                  gl.bindVertexArray(null);
                  glVAO = null;
                }
                res = it.next();
              }
              cache.glVAO = glVAO;
              gpuInputAssembler.glVAOs.clear();
            }
            var gfxStateCache = {
              gpuPipelineState: null,
              gpuInputAssembler: null,
              glPrimitive: 0,
              invalidateAttachments: []
            };
            function WebGL2CmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var clears = 0;
              if (gpuFramebuffer && gpuRenderPass) {
                if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(36160, gpuFramebuffer.glFramebuffer);
                  cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
                }
                if (cache.viewport.left !== renderArea.x || cache.viewport.top !== renderArea.y || cache.viewport.width !== renderArea.width || cache.viewport.height !== renderArea.height) {
                  gl.viewport(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.viewport.left = renderArea.x;
                  cache.viewport.top = renderArea.y;
                  cache.viewport.width = renderArea.width;
                  cache.viewport.height = renderArea.height;
                }
                if (cache.scissorRect.x !== renderArea.x || cache.scissorRect.y !== renderArea.y || cache.scissorRect.width !== renderArea.width || cache.scissorRect.height !== renderArea.height) {
                  gl.scissor(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.scissorRect.x = renderArea.x;
                  cache.scissorRect.y = renderArea.y;
                  cache.scissorRect.width = renderArea.width;
                  cache.scissorRect.height = renderArea.height;
                }
                gfxStateCache.invalidateAttachments.length = 0;
                for (var j = 0; j < clearColors.length; ++j) {
                  var colorAttachment = gpuRenderPass.colorAttachments[j];
                  if (colorAttachment.format !== 0) {
                    switch (colorAttachment.loadOp) {
                      case 0:
                        break;
                      case 1:
                        {
                          if (cache.bs.targets[0].blendColorMask !== 15) {
                            gl.colorMask(true, true, true, true);
                          }
                          if (gpuRenderPass.colorAttachments.length === 1) {
                            var clearColor = clearColors[0];
                            gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                            clears |= 16384;
                          } else {
                            _f32v4[0] = clearColors[j].x;
                            _f32v4[1] = clearColors[j].y;
                            _f32v4[2] = clearColors[j].z;
                            _f32v4[3] = clearColors[j].w;
                            gl.clearBufferfv(6144, j, _f32v4);
                          }
                          break;
                        }
                      case 2:
                        {
                          gfxStateCache.invalidateAttachments.push(36064 + j);
                          break;
                        }
                    }
                  }
                }
                if (gpuRenderPass.depthStencilAttachment) {
                  if (gpuRenderPass.depthStencilAttachment.format !== 0) {
                    switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                      case 0:
                        break;
                      case 1:
                        {
                          if (!cache.dss.depthWrite) {
                            gl.depthMask(true);
                          }
                          gl.clearDepth(clearDepth);
                          clears |= 256;
                          break;
                        }
                      case 2:
                        {
                          gfxStateCache.invalidateAttachments.push(36096);
                          break;
                        }
                    }
                    if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                      switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                        case 0:
                          break;
                        case 1:
                          {
                            if (!cache.dss.stencilWriteMaskFront) {
                              gl.stencilMaskSeparate(1028, 0xffff);
                            }
                            if (!cache.dss.stencilWriteMaskBack) {
                              gl.stencilMaskSeparate(1029, 0xffff);
                            }
                            gl.clearStencil(clearStencil);
                            clears |= 1024;
                            break;
                          }
                        case 2:
                          {
                            gfxStateCache.invalidateAttachments.push(36128);
                            break;
                          }
                      }
                    }
                  }
                }
                if (gpuFramebuffer.glFramebuffer && gfxStateCache.invalidateAttachments.length) {
                  gl.invalidateFramebuffer(36160, gfxStateCache.invalidateAttachments);
                }
                if (clears) {
                  gl.clear(clears);
                }
                if (clears & 16384) {
                  var colorMask = cache.bs.targets[0].blendColorMask;
                  if (colorMask !== 15) {
                    var r = (colorMask & 1) !== 0;
                    var g = (colorMask & 2) !== 0;
                    var b = (colorMask & 4) !== 0;
                    var a = (colorMask & 8) !== 0;
                    gl.colorMask(r, g, b, a);
                  }
                }
                if (clears & 256 && !cache.dss.depthWrite) {
                  gl.depthMask(false);
                }
                if (clears & 1024) {
                  if (!cache.dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(1028, 0);
                  }
                  if (!cache.dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(1029, 0);
                  }
                }
              }
            }
            function WebGL2CmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, dynamicStates) {
              var gl = device.gl;
              var capabilities = device.capabilities;
              var cache = device.getStateCache();
              var cacheRs = cache.rs;
              var cacheDss = cache.dss;
              var cacheBs = cache.bs;
              var cacheBlendColor = cacheBs.blendColor;
              var gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
              var isShaderChanged = false;
              if (gpuPipelineState && gfxStateCache.gpuPipelineState !== gpuPipelineState) {
                gfxStateCache.gpuPipelineState = gpuPipelineState;
                gfxStateCache.glPrimitive = gpuPipelineState.glPrimitive;
                if (gpuShader) {
                  var glProgram = gpuShader.glProgram;
                  if (cache.glProgram !== glProgram) {
                    gl.useProgram(glProgram);
                    cache.glProgram = glProgram;
                    isShaderChanged = true;
                  }
                }
                var rs = gpuPipelineState.rs;
                if (rs) {
                  if (cacheRs.cullMode !== rs.cullMode) {
                    switch (rs.cullMode) {
                      case 0:
                        {
                          gl.disable(2884);
                          break;
                        }
                      case 1:
                        {
                          gl.enable(2884);
                          gl.cullFace(1028);
                          break;
                        }
                      case 2:
                        {
                          gl.enable(2884);
                          gl.cullFace(1029);
                          break;
                        }
                    }
                    cacheRs.cullMode = rs.cullMode;
                  }
                  var isFrontFaceCCW = rs.isFrontFaceCCW;
                  if (cacheRs.isFrontFaceCCW !== isFrontFaceCCW) {
                    gl.frontFace(isFrontFaceCCW ? 2305 : 2304);
                    cacheRs.isFrontFaceCCW = isFrontFaceCCW;
                  }
                  if (cacheRs.depthBias !== rs.depthBias || cacheRs.depthBiasSlop !== rs.depthBiasSlop) {
                    gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
                    cacheRs.depthBias = rs.depthBias;
                    cacheRs.depthBiasSlop = rs.depthBiasSlop;
                  }
                  if (cacheRs.lineWidth !== rs.lineWidth) {
                    gl.lineWidth(rs.lineWidth);
                    cacheRs.lineWidth = rs.lineWidth;
                  }
                }
                var dss = gpuPipelineState.dss;
                if (dss) {
                  if (cacheDss.depthTest !== dss.depthTest) {
                    if (dss.depthTest) {
                      gl.enable(2929);
                    } else {
                      gl.disable(2929);
                    }
                    cacheDss.depthTest = dss.depthTest;
                  }
                  if (cacheDss.depthWrite !== dss.depthWrite) {
                    gl.depthMask(dss.depthWrite);
                    cacheDss.depthWrite = dss.depthWrite;
                  }
                  if (cacheDss.depthFunc !== dss.depthFunc) {
                    gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]);
                    cacheDss.depthFunc = dss.depthFunc;
                  }
                  if (cacheDss.stencilTestFront !== dss.stencilTestFront || cacheDss.stencilTestBack !== dss.stencilTestBack) {
                    if (dss.stencilTestFront || dss.stencilTestBack) {
                      gl.enable(2960);
                    } else {
                      gl.disable(2960);
                    }
                    cacheDss.stencilTestFront = dss.stencilTestFront;
                    cacheDss.stencilTestBack = dss.stencilTestBack;
                  }
                  if (cacheDss.stencilFuncFront !== dss.stencilFuncFront || cacheDss.stencilRefFront !== dss.stencilRefFront || cacheDss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
                    gl.stencilFuncSeparate(1028, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
                    cacheDss.stencilFuncFront = dss.stencilFuncFront;
                    cacheDss.stencilRefFront = dss.stencilRefFront;
                    cacheDss.stencilReadMaskFront = dss.stencilReadMaskFront;
                  }
                  if (cacheDss.stencilFailOpFront !== dss.stencilFailOpFront || cacheDss.stencilZFailOpFront !== dss.stencilZFailOpFront || cacheDss.stencilPassOpFront !== dss.stencilPassOpFront) {
                    gl.stencilOpSeparate(1028, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]);
                    cacheDss.stencilFailOpFront = dss.stencilFailOpFront;
                    cacheDss.stencilZFailOpFront = dss.stencilZFailOpFront;
                    cacheDss.stencilPassOpFront = dss.stencilPassOpFront;
                  }
                  if (cacheDss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(1028, dss.stencilWriteMaskFront);
                    cacheDss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
                  }
                  if (cacheDss.stencilFuncBack !== dss.stencilFuncBack || cacheDss.stencilRefBack !== dss.stencilRefBack || cacheDss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
                    gl.stencilFuncSeparate(1029, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
                    cacheDss.stencilFuncBack = dss.stencilFuncBack;
                    cacheDss.stencilRefBack = dss.stencilRefBack;
                    cacheDss.stencilReadMaskBack = dss.stencilReadMaskBack;
                  }
                  if (cacheDss.stencilFailOpBack !== dss.stencilFailOpBack || cacheDss.stencilZFailOpBack !== dss.stencilZFailOpBack || cacheDss.stencilPassOpBack !== dss.stencilPassOpBack) {
                    gl.stencilOpSeparate(1029, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]);
                    cacheDss.stencilFailOpBack = dss.stencilFailOpBack;
                    cacheDss.stencilZFailOpBack = dss.stencilZFailOpBack;
                    cacheDss.stencilPassOpBack = dss.stencilPassOpBack;
                  }
                  if (cacheDss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(1029, dss.stencilWriteMaskBack);
                    cacheDss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
                  }
                }
                var bs = gpuPipelineState.bs;
                if (bs) {
                  if (cacheBs.isA2C !== bs.isA2C) {
                    if (bs.isA2C) {
                      gl.enable(32926);
                    } else {
                      gl.disable(32926);
                    }
                    cacheBs.isA2C = bs.isA2C;
                  }
                  var blendColor = bs.blendColor;
                  if (cacheBlendColor.x !== blendColor.x || cacheBlendColor.y !== blendColor.y || cacheBlendColor.z !== blendColor.z || cacheBlendColor.w !== blendColor.w) {
                    gl.blendColor(blendColor.x, blendColor.y, blendColor.z, blendColor.w);
                    cacheBlendColor.x = blendColor.x;
                    cacheBlendColor.y = blendColor.y;
                    cacheBlendColor.z = blendColor.z;
                    cacheBlendColor.w = blendColor.w;
                  }
                  var target0 = bs.targets[0];
                  var target0Cache = cache.bs.targets[0];
                  if (target0Cache.blend !== target0.blend) {
                    if (target0.blend) {
                      gl.enable(3042);
                    } else {
                      gl.disable(3042);
                    }
                    target0Cache.blend = target0.blend;
                  }
                  if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
                    gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]);
                    target0Cache.blendEq = target0.blendEq;
                    target0Cache.blendAlphaEq = target0.blendAlphaEq;
                  }
                  if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
                    gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]);
                    target0Cache.blendSrc = target0.blendSrc;
                    target0Cache.blendDst = target0.blendDst;
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
                    target0Cache.blendDstAlpha = target0.blendDstAlpha;
                  }
                  if (target0Cache.blendColorMask !== target0.blendColorMask) {
                    gl.colorMask((target0.blendColorMask & 1) !== 0, (target0.blendColorMask & 2) !== 0, (target0.blendColorMask & 4) !== 0, (target0.blendColorMask & 8) !== 0);
                    target0Cache.blendColorMask = target0.blendColorMask;
                  }
                }
              }
              if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
                var blockLen = gpuShader.glBlocks.length;
                var dynamicOffsetIndices = gpuPipelineState.gpuPipelineLayout.dynamicOffsetIndices;
                for (var j = 0; j < blockLen; j++) {
                  var glBlock = gpuShader.glBlocks[j];
                  var gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
                  var descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
                  var gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];
                  if (!gpuDescriptor || !gpuDescriptor.gpuBuffer) {
                    continue;
                  }
                  var dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
                  var dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];
                  var offset = gpuDescriptor.gpuBuffer.glOffset;
                  if (dynamicOffsetIndex >= 0) {
                    offset += dynamicOffsets[dynamicOffsetIndex];
                  }
                  if (cache.glBindUBOs[glBlock.glBinding] !== gpuDescriptor.gpuBuffer.glBuffer || cache.glBindUBOOffsets[glBlock.glBinding] !== offset) {
                    if (offset) {
                      gl.bindBufferRange(35345, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer, offset, gpuDescriptor.gpuBuffer.size);
                    } else {
                      gl.bindBufferBase(35345, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer);
                    }
                    cache.glUniformBuffer = cache.glBindUBOs[glBlock.glBinding] = gpuDescriptor.gpuBuffer.glBuffer;
                    cache.glBindUBOOffsets[glBlock.glBinding] = offset;
                  }
                }
                var samplerLen = gpuShader.glSamplerTextures.length;
                for (var i = 0; i < samplerLen; i++) {
                  var glSampler = gpuShader.glSamplerTextures[i];
                  var _gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
                  var _descriptorIndex = _gpuDescriptorSet && _gpuDescriptorSet.descriptorIndices[glSampler.binding];
                  var _gpuDescriptor = _descriptorIndex >= 0 && _gpuDescriptorSet.gpuDescriptors[_descriptorIndex];
                  for (var l = 0; l < glSampler.units.length; l++) {
                    var texUnit = glSampler.units[l];
                    var glTexUnit = cache.glTexUnits[texUnit];
                    if (!_gpuDescriptor || !_gpuDescriptor.gpuTextureView || !_gpuDescriptor.gpuTextureView.gpuTexture || !_gpuDescriptor.gpuSampler) {
                      continue;
                    }
                    var gpuTextureView = _gpuDescriptor.gpuTextureView;
                    var gpuTexture = gpuTextureView.gpuTexture;
                    var minLod = gpuTextureView.baseLevel;
                    var maxLod = minLod + gpuTextureView.levelCount;
                    if (gpuTexture.size > 0) {
                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(33984 + texUnit);
                          cache.texUnit = texUnit;
                        }
                        if (gpuTexture.glTexture) {
                          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                        } else {
                          gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                        }
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }
                      var _gpuDescriptor2 = _gpuDescriptor,
                        gpuSampler = _gpuDescriptor2.gpuSampler;
                      var _glSampler3 = gpuSampler.getGLSampler(device, minLod, maxLod);
                      if (cache.glSamplerUnits[texUnit] !== _glSampler3) {
                        gl.bindSampler(texUnit, _glSampler3);
                        cache.glSamplerUnits[texUnit] = _glSampler3;
                      }
                    }
                    _gpuDescriptor = _gpuDescriptorSet.gpuDescriptors[++_descriptorIndex];
                  }
                }
              }
              if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache.gpuInputAssembler !== gpuInputAssembler)) {
                gfxStateCache.gpuInputAssembler = gpuInputAssembler;
                if (device.extensions.useVAO) {
                  var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);
                  if (!glVAO) {
                    glVAO = gl.createVertexArray();
                    gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
                    gl.bindVertexArray(glVAO);
                    gl.bindBuffer(34962, null);
                    gl.bindBuffer(34963, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                    var glAttrib;
                    for (var _j = 0; _j < gpuShader.glInputs.length; _j++) {
                      var glInput = gpuShader.glInputs[_j];
                      glAttrib = null;
                      for (var k = 0; k < gpuInputAssembler.glAttribs.length; k++) {
                        var attrib = gpuInputAssembler.glAttribs[k];
                        if (attrib.name === glInput.name) {
                          glAttrib = attrib;
                          break;
                        }
                      }
                      if (glAttrib) {
                        if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                          gl.bindBuffer(34962, glAttrib.glBuffer);
                          cache.glArrayBuffer = glAttrib.glBuffer;
                        }
                        for (var c = 0; c < glAttrib.componentCount; ++c) {
                          var glLoc = glInput.glLoc + c;
                          var attribOffset = glAttrib.offset + glAttrib.size * c;
                          gl.enableVertexAttribArray(glLoc);
                          cache.glCurrentAttribLocs[glLoc] = true;
                          gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                          gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                        }
                      }
                    }
                    var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                    if (gpuBuffer) {
                      gl.bindBuffer(34963, gpuBuffer.glBuffer);
                    }
                    gl.bindVertexArray(null);
                    gl.bindBuffer(34962, null);
                    gl.bindBuffer(34963, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                  }
                  if (cache.glVAO !== glVAO) {
                    gl.bindVertexArray(glVAO);
                    cache.glVAO = glVAO;
                  }
                } else {
                  for (var a = 0; a < capabilities.maxVertexAttributes; ++a) {
                    cache.glCurrentAttribLocs[a] = false;
                  }
                  for (var _j2 = 0; _j2 < gpuShader.glInputs.length; _j2++) {
                    var _glInput = gpuShader.glInputs[_j2];
                    var _glAttrib = null;
                    for (var _k5 = 0; _k5 < gpuInputAssembler.glAttribs.length; _k5++) {
                      var _attrib = gpuInputAssembler.glAttribs[_k5];
                      if (_attrib.name === _glInput.name) {
                        _glAttrib = _attrib;
                        break;
                      }
                    }
                    if (_glAttrib) {
                      if (cache.glArrayBuffer !== _glAttrib.glBuffer) {
                        gl.bindBuffer(34962, _glAttrib.glBuffer);
                        cache.glArrayBuffer = _glAttrib.glBuffer;
                      }
                      for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                        var _glLoc3 = _glInput.glLoc + _c;
                        var _attribOffset = _glAttrib.offset + _glAttrib.size * _c;
                        if (!cache.glEnabledAttribLocs[_glLoc3] && _glLoc3 >= 0) {
                          gl.enableVertexAttribArray(_glLoc3);
                          cache.glEnabledAttribLocs[_glLoc3] = true;
                        }
                        cache.glCurrentAttribLocs[_glLoc3] = true;
                        gl.vertexAttribPointer(_glLoc3, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                        gl.vertexAttribDivisor(_glLoc3, _glAttrib.isInstanced ? 1 : 0);
                      }
                    }
                  }
                  var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;
                  if (_gpuBuffer) {
                    if (cache.glElementArrayBuffer !== _gpuBuffer.glBuffer) {
                      gl.bindBuffer(34963, _gpuBuffer.glBuffer);
                      cache.glElementArrayBuffer = _gpuBuffer.glBuffer;
                    }
                  }
                  for (var _a = 0; _a < capabilities.maxVertexAttributes; ++_a) {
                    if (cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a]) {
                      gl.disableVertexAttribArray(_a);
                      cache.glEnabledAttribLocs[_a] = false;
                    }
                  }
                }
              }
              if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
                var dsLen = gpuPipelineState.dynamicStates.length;
                for (var _k6 = 0; _k6 < dsLen; _k6++) {
                  var dynamicState = gpuPipelineState.dynamicStates[_k6];
                  switch (dynamicState) {
                    case 1:
                      {
                        if (cacheRs.lineWidth !== dynamicStates.lineWidth) {
                          gl.lineWidth(dynamicStates.lineWidth);
                          cacheRs.lineWidth = dynamicStates.lineWidth;
                        }
                        break;
                      }
                    case 2:
                      {
                        if (cacheRs.depthBias !== dynamicStates.depthBiasConstant || cache.rs.depthBiasSlop !== dynamicStates.depthBiasSlope) {
                          gl.polygonOffset(dynamicStates.depthBiasConstant, dynamicStates.depthBiasSlope);
                          cacheRs.depthBias = dynamicStates.depthBiasConstant;
                          cacheRs.depthBiasSlop = dynamicStates.depthBiasSlope;
                        }
                        break;
                      }
                    case 4:
                      {
                        var blendConstant = dynamicStates.blendConstant;
                        if (cacheBlendColor.x !== blendConstant.x || cacheBlendColor.y !== blendConstant.y || cacheBlendColor.z !== blendConstant.z || cacheBlendColor.w !== blendConstant.w) {
                          gl.blendColor(blendConstant.x, blendConstant.y, blendConstant.z, blendConstant.w);
                          cacheBlendColor.copy(blendConstant);
                        }
                        break;
                      }
                    case 16:
                      {
                        var front = dynamicStates.stencilStatesFront;
                        var back = dynamicStates.stencilStatesBack;
                        if (cacheDss.stencilWriteMaskFront !== front.writeMask) {
                          gl.stencilMaskSeparate(1028, front.writeMask);
                          cacheDss.stencilWriteMaskFront = front.writeMask;
                        }
                        if (cacheDss.stencilWriteMaskBack !== back.writeMask) {
                          gl.stencilMaskSeparate(1029, back.writeMask);
                          cacheDss.stencilWriteMaskBack = back.writeMask;
                        }
                        break;
                      }
                    case 32:
                      {
                        var _front = dynamicStates.stencilStatesFront;
                        var _back = dynamicStates.stencilStatesBack;
                        if (cacheDss.stencilRefFront !== _front.reference || cacheDss.stencilReadMaskFront !== _front.compareMask) {
                          gl.stencilFuncSeparate(1028, WebGLCmpFuncs[cacheDss.stencilFuncFront], _front.reference, _front.compareMask);
                          cacheDss.stencilRefFront = _front.reference;
                          cacheDss.stencilReadMaskFront = _front.compareMask;
                        }
                        if (cacheDss.stencilRefBack !== _back.reference || cacheDss.stencilReadMaskBack !== _back.compareMask) {
                          gl.stencilFuncSeparate(1029, WebGLCmpFuncs[cacheDss.stencilFuncBack], _back.reference, _back.compareMask);
                          cacheDss.stencilRefBack = _back.reference;
                          cacheDss.stencilReadMaskBack = _back.compareMask;
                        }
                        break;
                      }
                  }
                }
              }
            }
            function WebGL2CmdFuncDraw(device, drawInfo) {
              var gl = device.gl;
              var gpuInputAssembler = gfxStateCache.gpuInputAssembler,
                glPrimitive = gfxStateCache.glPrimitive;
              var md = device.extensions.WEBGL_multi_draw;
              if (gpuInputAssembler) {
                var indexBuffer = gpuInputAssembler.gpuIndexBuffer;
                if (gpuInputAssembler.gpuIndirectBuffer) {
                  var indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;
                  if (indirects.drawByIndex) {
                    for (var j = 0; j < indirects.drawCount; j++) {
                      indirects.byteOffsets[j] = indirects.offsets[j] * indexBuffer.stride;
                    }
                    if (md) {
                      if (indirects.instancedDraw) {
                        md.multiDrawElementsInstancedWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.instances, 0, indirects.drawCount);
                      } else {
                        md.multiDrawElementsWEBGL(glPrimitive, indirects.counts, 0, gpuInputAssembler.glIndexType, indirects.byteOffsets, 0, indirects.drawCount);
                      }
                    } else {
                      for (var _j3 = 0; _j3 < indirects.drawCount; _j3++) {
                        if (indirects.instances[_j3]) {
                          gl.drawElementsInstanced(glPrimitive, indirects.counts[_j3], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j3], indirects.instances[_j3]);
                        } else {
                          gl.drawElements(glPrimitive, indirects.counts[_j3], gpuInputAssembler.glIndexType, indirects.byteOffsets[_j3]);
                        }
                      }
                    }
                  } else if (md) {
                    if (indirects.instancedDraw) {
                      md.multiDrawArraysInstancedWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.instances, 0, indirects.drawCount);
                    } else {
                      md.multiDrawArraysWEBGL(glPrimitive, indirects.offsets, 0, indirects.counts, 0, indirects.drawCount);
                    }
                  } else {
                    for (var _j4 = 0; _j4 < indirects.drawCount; _j4++) {
                      if (indirects.instances[_j4]) {
                        gl.drawArraysInstanced(glPrimitive, indirects.offsets[_j4], indirects.counts[_j4], indirects.instances[_j4]);
                      } else {
                        gl.drawArrays(glPrimitive, indirects.offsets[_j4], indirects.counts[_j4]);
                      }
                    }
                  }
                } else if (drawInfo.instanceCount) {
                  if (indexBuffer) {
                    if (drawInfo.indexCount > 0) {
                      var offset = drawInfo.firstIndex * indexBuffer.stride;
                      gl.drawElementsInstanced(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, offset, drawInfo.instanceCount);
                    }
                  } else if (drawInfo.vertexCount > 0) {
                    gl.drawArraysInstanced(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
                  }
                } else if (indexBuffer) {
                  if (drawInfo.indexCount > 0) {
                    var _offset = drawInfo.firstIndex * indexBuffer.stride;
                    gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                  }
                } else if (drawInfo.vertexCount > 0) {
                  gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                }
              }
            }
            function toUseTexImage2D(texImages, regions) {
              if (texImages.length > 1 || regions.length > 1) return false;
              var isVideoElement = texImages[0] instanceof HTMLVideoElement;
              if (isVideoElement) {
                var videoElement = texImages[0];
                var isSameSize = regions[0].texOffset.x === 0 && regions[0].texOffset.y === 0 && regions[0].texExtent.width === videoElement.videoWidth && regions[0].texExtent.height === videoElement.videoHeight;
                return isSameSize;
              }
              return false;
            }
            function WebGL2CmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var glTexUnit = cache.glTexUnits[cache.texUnit];
              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }
              var n = 0;
              var f = 0;
              switch (gpuTexture.glTarget) {
                case 3553:
                  {
                    if (gpuTexture.flags & 128 || toUseTexImage2D(texImages, regions)) {
                      gl.texImage2D(3553, regions[0].texSubres.mipLevel, gpuTexture.glInternalFmt, regions[0].texExtent.width, regions[0].texExtent.height, 0, gpuTexture.glFormat, gpuTexture.glType, texImages[0]);
                    } else {
                      for (var k = 0; k < regions.length; k++) {
                        var region = regions[k];
                        gl.texSubImage2D(3553, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }
                    break;
                  }
                case 34067:
                  {
                    for (var _k7 = 0; _k7 < regions.length; _k7++) {
                      var _region = regions[_k7];
                      var regionTexSubres = _region.texSubres;
                      var regionTexOffset = _region.texOffset;
                      var fcount = regionTexSubres.baseArrayLayer + regionTexSubres.layerCount;
                      for (f = regionTexSubres.baseArrayLayer; f < fcount; ++f) {
                        gl.texSubImage2D(34069 + f, regionTexSubres.mipLevel, regionTexOffset.x, regionTexOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }
                    break;
                  }
                default:
                  {
                    errorID(16327);
                  }
              }
              if (gpuTexture.flags & 1) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            var stagingBuffer = new Uint8Array(1);
            function pixelBufferPick(buffer, format, offset, stride, extent) {
              var blockHeight = formatAlignment(format).height;
              var bufferSize = FormatSize(format, extent.width, extent.height, extent.depth);
              var rowStrideSize = FormatSize(format, stride.width, 1, 1);
              var sliceStrideSize = FormatSize(format, stride.width, stride.height, 1);
              var destRowSize = FormatSize(format, extent.width, 1, 1);
              var ArrayBufferCtor = getTypedArrayConstructor(FormatInfos[format]);
              if (stagingBuffer.byteLength < bufferSize) {
                stagingBuffer = new Uint8Array(bufferSize);
              }
              var destOffset = 0;
              var bufferOffset = offset;
              for (var i = 0; i < extent.depth; i++) {
                bufferOffset = offset + sliceStrideSize * i;
                for (var j = 0; j < extent.height; j += blockHeight) {
                  stagingBuffer.subarray(destOffset, destOffset + destRowSize).set(new Uint8Array(buffer.buffer, buffer.byteOffset + bufferOffset, destRowSize));
                  destOffset += destRowSize;
                  bufferOffset += rowStrideSize;
                }
              }
              var length = bufferSize / ArrayBufferCtor.BYTES_PER_ELEMENT;
              assertID(Number.isInteger(length), 9101);
              return new ArrayBufferCtor(stagingBuffer.buffer, 0, length);
            }
            function WebGL2CmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var glTexUnit = cache.glTexUnits[cache.texUnit];
              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }
              var n = 0;
              var f = 0;
              var fmtInfo = FormatInfos[gpuTexture.format];
              var ArrayBufferCtor = getTypedArrayConstructor(fmtInfo);
              var isCompressed = fmtInfo.isCompressed;
              var blockSize = formatAlignment(gpuTexture.format);
              var extent = new Extent();
              var offset = new Offset();
              var stride = new Extent();
              switch (gpuTexture.glTarget) {
                case 3553:
                  {
                    for (var k = 0; k < regions.length; k++) {
                      var region = regions[k];
                      var mipLevel = region.texSubres.mipLevel;
                      var regionTexOffset = region.texOffset;
                      var regionTexExtent = region.texExtent;
                      var regionTexExtentWidth = regionTexExtent.width;
                      var regionTexExtentHeight = regionTexExtent.height;
                      var blockSizeWidth = blockSize.width;
                      var blockSizeHeight = blockSize.height;
                      var regionBuffStride = region.buffStride;
                      offset.x = regionTexOffset.x === 0 ? 0 : alignTo(regionTexOffset.x, blockSizeWidth);
                      offset.y = regionTexOffset.y === 0 ? 0 : alignTo(regionTexOffset.y, blockSizeHeight);
                      extent.width = regionTexExtentWidth < blockSizeWidth ? regionTexExtentWidth : alignTo(regionTexExtentWidth, blockSizeWidth);
                      extent.height = regionTexExtentHeight < blockSizeHeight ? regionTexExtentWidth : alignTo(regionTexExtentHeight, blockSizeHeight);
                      stride.width = regionBuffStride > 0 ? regionBuffStride : extent.width;
                      stride.height = region.buffTexHeight > 0 ? region.buffTexHeight : extent.height;
                      var destWidth = regionTexExtentWidth + offset.x === gpuTexture.width >> mipLevel ? regionTexExtentWidth : extent.width;
                      var destHeight = regionTexExtentHeight + offset.y === gpuTexture.height >> mipLevel ? regionTexExtentHeight : extent.height;
                      var pixels = undefined;
                      var buffer = buffers[n++];
                      if (stride.width === extent.width && stride.height === extent.height) {
                        var length = FormatSize(gpuTexture.format, destWidth, destHeight, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                        assertID(Number.isInteger(length), 9101);
                        pixels = new ArrayBufferCtor(buffer.buffer, buffer.byteOffset + region.buffOffset, length);
                      } else {
                        pixels = pixelBufferPick(buffer, gpuTexture.format, region.buffOffset, stride, extent);
                      }
                      if (!isCompressed) {
                        gl.texSubImage2D(3553, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, gpuTexture.glType, pixels);
                      } else if (gpuTexture.glInternalFmt !== 36196) {
                        gl.compressedTexSubImage2D(3553, mipLevel, offset.x, offset.y, destWidth, destHeight, gpuTexture.glFormat, pixels);
                      } else {
                        gl.compressedTexImage2D(3553, mipLevel, gpuTexture.glInternalFmt, destWidth, destHeight, 0, pixels);
                      }
                    }
                    break;
                  }
                case 35866:
                  {
                    for (var _k8 = 0; _k8 < regions.length; _k8++) {
                      var _region2 = regions[_k8];
                      var _mipLevel = _region2.texSubres.mipLevel;
                      var _regionTexOffset = _region2.texOffset;
                      var _regionTexExtent = _region2.texExtent;
                      var _regionTexExtentWidth = _regionTexExtent.width;
                      var _regionTexExtentHeight = _regionTexExtent.height;
                      var _blockSizeWidth = blockSize.width;
                      var _blockSizeHeight = blockSize.height;
                      var _regionBuffStride = _region2.buffStride;
                      var regionTexSubres = _region2.texSubres;
                      offset.x = _regionTexOffset.x === 0 ? 0 : alignTo(_regionTexOffset.x, _blockSizeWidth);
                      offset.y = _regionTexOffset.y === 0 ? 0 : alignTo(_regionTexOffset.y, _blockSizeHeight);
                      extent.width = _regionTexExtentWidth < _blockSizeWidth ? _regionTexExtentWidth : alignTo(_regionTexExtentWidth, _blockSizeWidth);
                      extent.height = _regionTexExtentHeight < _blockSizeHeight ? _regionTexExtentWidth : alignTo(_regionTexExtentHeight, _blockSizeHeight);
                      extent.depth = 1;
                      stride.width = _regionBuffStride > 0 ? _regionBuffStride : extent.width;
                      stride.height = _region2.buffTexHeight > 0 ? _region2.buffTexHeight : extent.height;
                      var _destWidth = _regionTexExtentWidth + offset.x === gpuTexture.width >> _mipLevel ? _regionTexExtentWidth : extent.width;
                      var _destHeight = _regionTexExtentHeight + offset.y === gpuTexture.height >> _mipLevel ? _regionTexExtentHeight : extent.height;
                      var fcount = regionTexSubres.baseArrayLayer + regionTexSubres.layerCount;
                      for (f = regionTexSubres.baseArrayLayer; f < fcount; ++f) {
                        offset.z = f;
                        var _pixels = undefined;
                        var _buffer = buffers[n++];
                        if (stride.width === extent.width && stride.height === extent.height) {
                          var _length = FormatSize(gpuTexture.format, _destWidth, _destHeight, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                          assertID(Number.isInteger(_length), 9101);
                          _pixels = new ArrayBufferCtor(_buffer.buffer, _buffer.byteOffset + _region2.buffOffset, _length);
                        } else {
                          _pixels = pixelBufferPick(_buffer, gpuTexture.format, _region2.buffOffset, stride, extent);
                        }
                        if (!isCompressed) {
                          gl.texSubImage3D(35866, _mipLevel, offset.x, offset.y, offset.z, _destWidth, _destHeight, extent.depth, gpuTexture.glFormat, gpuTexture.glType, _pixels);
                        } else if (gpuTexture.glInternalFmt !== 36196) {
                          gl.compressedTexSubImage3D(35866, _mipLevel, offset.x, offset.y, offset.z, _destWidth, _destHeight, extent.depth, gpuTexture.glFormat, _pixels);
                        } else {
                          gl.compressedTexImage3D(35866, _mipLevel, gpuTexture.glInternalFmt, _destWidth, _destHeight, extent.depth, 0, _pixels);
                        }
                      }
                    }
                    break;
                  }
                case 32879:
                  {
                    for (var _k9 = 0; _k9 < regions.length; _k9++) {
                      var _region3 = regions[_k9];
                      var _mipLevel2 = _region3.texSubres.mipLevel;
                      var _regionTexOffset2 = _region3.texOffset;
                      var _regionTexExtent2 = _region3.texExtent;
                      var _regionTexExtentWidth2 = _regionTexExtent2.width;
                      var _regionTexExtentHeight2 = _regionTexExtent2.height;
                      var _blockSizeWidth2 = blockSize.width;
                      var _blockSizeHeight2 = blockSize.height;
                      var _regionBuffStride2 = _region3.buffStride;
                      offset.x = _regionTexOffset2.x === 0 ? 0 : alignTo(_regionTexOffset2.x, _blockSizeWidth2);
                      offset.y = _regionTexOffset2.y === 0 ? 0 : alignTo(_regionTexOffset2.y, _blockSizeHeight2);
                      offset.z = _regionTexOffset2.z;
                      extent.width = _regionTexExtentWidth2 < _blockSizeWidth2 ? _regionTexExtentWidth2 : alignTo(_regionTexExtentWidth2, _blockSizeWidth2);
                      extent.height = _regionTexExtentHeight2 < _blockSizeHeight2 ? _regionTexExtentWidth2 : alignTo(_regionTexExtentHeight2, _blockSizeHeight2);
                      extent.depth = _regionTexExtent2.depth;
                      stride.width = _regionBuffStride2 > 0 ? _regionBuffStride2 : extent.width;
                      stride.height = _region3.buffTexHeight > 0 ? _region3.buffTexHeight : extent.height;
                      var _destWidth2 = _regionTexExtentWidth2 + offset.x === gpuTexture.width >> _mipLevel2 ? _regionTexExtentWidth2 : extent.width;
                      var _destHeight2 = _regionTexExtentHeight2 + offset.y === gpuTexture.height >> _mipLevel2 ? _regionTexExtentHeight2 : extent.height;
                      var _pixels2 = undefined;
                      var _buffer2 = buffers[n++];
                      if (stride.width === extent.width && stride.height === extent.height) {
                        var _length2 = FormatSize(gpuTexture.format, _destWidth2, _destHeight2, extent.depth) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                        assertID(Number.isInteger(_length2), 9101);
                        _pixels2 = new ArrayBufferCtor(_buffer2.buffer, _buffer2.byteOffset + _region3.buffOffset, _length2);
                      } else {
                        _pixels2 = pixelBufferPick(_buffer2, gpuTexture.format, _region3.buffOffset, stride, extent);
                      }
                      if (!isCompressed) {
                        gl.texSubImage3D(35866, _mipLevel2, offset.x, offset.y, offset.z, _destWidth2, _destHeight2, extent.depth, gpuTexture.glFormat, gpuTexture.glType, _pixels2);
                      } else if (gpuTexture.glInternalFmt !== 36196) {
                        gl.compressedTexSubImage3D(35866, _mipLevel2, offset.x, offset.y, offset.z, _destWidth2, _destHeight2, extent.depth, gpuTexture.glFormat, _pixels2);
                      } else {
                        gl.compressedTexImage3D(35866, _mipLevel2, gpuTexture.glInternalFmt, _destWidth2, _destHeight2, extent.depth, 0, _pixels2);
                      }
                    }
                    break;
                  }
                case 34067:
                  {
                    for (var _k10 = 0; _k10 < regions.length; _k10++) {
                      var _region4 = regions[_k10];
                      var _mipLevel3 = _region4.texSubres.mipLevel;
                      var _regionTexOffset3 = _region4.texOffset;
                      var _regionTexExtent3 = _region4.texExtent;
                      var _regionTexExtentWidth3 = _regionTexExtent3.width;
                      var _regionTexExtentHeight3 = _regionTexExtent3.height;
                      var _blockSizeWidth3 = blockSize.width;
                      var _blockSizeHeight3 = blockSize.height;
                      var _regionBuffStride3 = _region4.buffStride;
                      var _regionTexSubres = _region4.texSubres;
                      offset.x = _regionTexOffset3.x === 0 ? 0 : alignTo(_regionTexOffset3.x, _blockSizeWidth3);
                      offset.y = _regionTexOffset3.y === 0 ? 0 : alignTo(_regionTexOffset3.y, _blockSizeHeight3);
                      extent.width = _regionTexExtentWidth3 < _blockSizeWidth3 ? _regionTexExtentWidth3 : alignTo(_regionTexExtentWidth3, _blockSizeWidth3);
                      extent.height = _regionTexExtentHeight3 < _blockSizeHeight3 ? _regionTexExtentWidth3 : alignTo(_regionTexExtentHeight3, _blockSizeHeight3);
                      stride.width = _regionBuffStride3 > 0 ? _regionBuffStride3 : extent.width;
                      stride.height = _region4.buffTexHeight > 0 ? _region4.buffTexHeight : extent.height;
                      var _destWidth3 = _regionTexExtentWidth3 + offset.x === gpuTexture.width >> _mipLevel3 ? _regionTexExtentWidth3 : extent.width;
                      var _destHeight3 = _regionTexExtentHeight3 + offset.y === gpuTexture.height >> _mipLevel3 ? _regionTexExtentHeight3 : extent.height;
                      var _fcount = _regionTexSubres.baseArrayLayer + _regionTexSubres.layerCount;
                      for (f = _regionTexSubres.baseArrayLayer; f < _fcount; ++f) {
                        var _pixels3 = undefined;
                        var _buffer3 = buffers[n++];
                        if (stride.width === extent.width && stride.height === extent.height) {
                          var _length3 = FormatSize(gpuTexture.format, _destWidth3, _destHeight3, 1) / ArrayBufferCtor.BYTES_PER_ELEMENT;
                          assertID(Number.isInteger(_length3), 9101);
                          _pixels3 = new ArrayBufferCtor(_buffer3.buffer, _buffer3.byteOffset + _region4.buffOffset, _length3);
                        } else {
                          _pixels3 = pixelBufferPick(_buffer3, gpuTexture.format, _region4.buffOffset, stride, extent);
                        }
                        if (!isCompressed) {
                          gl.texSubImage2D(34069 + f, _mipLevel3, offset.x, offset.y, _destWidth3, _destHeight3, gpuTexture.glFormat, gpuTexture.glType, _pixels3);
                        } else if (gpuTexture.glInternalFmt !== 36196) {
                          gl.compressedTexSubImage2D(34069 + f, _mipLevel3, offset.x, offset.y, _destWidth3, _destHeight3, gpuTexture.glFormat, _pixels3);
                        } else {
                          gl.compressedTexImage2D(34069 + f, _mipLevel3, gpuTexture.glInternalFmt, _destWidth3, _destHeight3, 0, _pixels3);
                        }
                      }
                    }
                    break;
                  }
                default:
                  {
                    errorID(16327);
                  }
              }
              if (gpuTexture.flags & 1) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGL2CmdFuncCopyTextureToBuffers(device, gpuTexture, buffers, regions) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var framebuffer = gl.createFramebuffer();
              gl.bindFramebuffer(36160, framebuffer);
              var x = 0;
              var y = 0;
              var w = 1;
              var h = 1;
              switch (gpuTexture.glTarget) {
                case 3553:
                  {
                    for (var k = 0; k < regions.length; k++) {
                      var region = regions[k];
                      gl.framebufferTexture2D(36160, 36064, gpuTexture.glTarget, gpuTexture.glTexture, region.texSubres.mipLevel);
                      x = region.texOffset.x;
                      y = region.texOffset.y;
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      gl.readPixels(x, y, w, h, gpuTexture.glFormat, gpuTexture.glType, buffers[k]);
                    }
                    break;
                  }
                default:
                  {
                    errorID(16399);
                  }
              }
              gl.bindFramebuffer(36160, null);
              cache.glFramebuffer = null;
              gl.deleteFramebuffer(framebuffer);
            }
            function WebGL2CmdFuncBlitTexture(device, src, dst, regions, filter) {
              var gl = device.gl;
              var cache = device.getStateCache();
              var blitManager = device.blitManager;
              if (!blitManager) {
                return;
              }
              var glFilter = filter === 2 || filter === 3 ? 9729 : 9728;
              var srcFramebuffer = blitManager.srcFramebuffer;
              var dstFramebuffer = blitManager.dstFramebuffer;
              var origReadFBO = cache.glReadFramebuffer;
              var origDrawFBO = cache.glFramebuffer;
              var srcMip = regions[0].srcSubres.mipLevel;
              var dstMip = regions[0].dstSubres.mipLevel;
              var blitInfo = function blitInfo(formatInfo) {
                var mask = 0;
                var attachment = 36064;
                if (formatInfo.hasStencil) {
                  attachment = 33306;
                } else if (formatInfo.hasDepth) {
                  attachment = 36096;
                }
                if (formatInfo.hasDepth || formatInfo.hasStencil) {
                  if (formatInfo.hasDepth) {
                    mask |= 256;
                  }
                  if (formatInfo.hasStencil) {
                    mask |= 1024;
                  }
                } else {
                  mask |= 16384;
                }
                return {
                  mask: mask,
                  attachment: attachment
                };
              };
              var regionIndices = regions.map(function (_, i) {
                return i;
              });
              regionIndices.sort(function (a, b) {
                return regions[a].srcSubres.mipLevel - regions[b].srcSubres.mipLevel;
              });
              var _blitInfo = blitInfo(FormatInfos[src.format]),
                srcMask = _blitInfo.mask,
                srcAttachment = _blitInfo.attachment;
              var _blitInfo2 = blitInfo(FormatInfos[dst.format]),
                dstAttachment = _blitInfo2.attachment;
              if (cache.glReadFramebuffer !== srcFramebuffer) {
                gl.bindFramebuffer(36008, srcFramebuffer);
                cache.glReadFramebuffer = srcFramebuffer;
              }
              if (cache.glFramebuffer !== dstFramebuffer) {
                gl.bindFramebuffer(36009, dstFramebuffer);
                cache.glFramebuffer = dstFramebuffer;
              }
              if (src.glTexture) {
                gl.framebufferTexture2D(36008, srcAttachment, src.glTarget, src.glTexture, srcMip);
              } else {
                gl.framebufferRenderbuffer(36008, srcAttachment, 36161, src.glRenderbuffer);
              }
              if (dst.glTexture) {
                gl.framebufferTexture2D(36009, dstAttachment, dst.glTarget, dst.glTexture, dstMip);
              } else {
                gl.framebufferRenderbuffer(36009, dstAttachment, 36161, dst.glRenderbuffer);
              }
              for (var i = 0; i < regionIndices.length; i++) {
                var region = regions[regionIndices[i]];
                if (src.glTexture && srcMip !== region.srcSubres.mipLevel) {
                  srcMip = region.srcSubres.mipLevel;
                  gl.framebufferTexture2D(36008, srcAttachment, src.glTarget, src.glTexture, srcMip);
                }
                if (dst.glTexture && dstMip !== region.dstSubres.mipLevel) {
                  dstMip = region.dstSubres.mipLevel;
                  gl.framebufferTexture2D(36009, dstAttachment, dst.glTarget, dst.glTexture, dstMip);
                }
                gl.blitFramebuffer(region.srcOffset.x, region.srcOffset.y, region.srcOffset.x + region.srcExtent.width, region.srcOffset.y + region.srcExtent.height, region.dstOffset.x, region.dstOffset.y, region.dstOffset.x + region.dstExtent.width, region.dstOffset.y + region.dstExtent.height, srcMask, glFilter);
              }
              if (cache.glReadFramebuffer !== origReadFBO) {
                gl.bindFramebuffer(36008, origReadFBO);
                cache.glReadFramebuffer = origReadFBO;
              }
              if (cache.glFramebuffer !== origDrawFBO) {
                gl.bindFramebuffer(36009, origDrawFBO);
                cache.glFramebuffer = origDrawFBO;
              }
            }

            var WebGL2DeviceManager = function () {
              function WebGL2DeviceManager() {}
              WebGL2DeviceManager.setInstance = function setInstance(instance) {
                WebGL2DeviceManager._instance = instance;
              };
              _createClass(WebGL2DeviceManager, null, [{
                key: "instance",
                get: function get() {
                  return WebGL2DeviceManager._instance;
                }
              }]);
              return WebGL2DeviceManager;
            }();
            WebGL2DeviceManager._instance = null;

            var WebGL2IndirectDrawInfos = function () {
              function WebGL2IndirectDrawInfos() {
                this.counts = undefined;
                this.offsets = undefined;
                this.instances = undefined;
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
                this.byteOffsets = undefined;
                this._capacity = 4;
                this.counts = new Int32Array(4);
                this.offsets = new Int32Array(4);
                this.instances = new Int32Array(4);
                this.byteOffsets = new Int32Array(4);
              }
              var _proto = WebGL2IndirectDrawInfos.prototype;
              _proto.clearDraws = function clearDraws() {
                this.drawCount = 0;
                this.drawByIndex = false;
                this.instancedDraw = false;
              };
              _proto.setDrawInfo = function setDrawInfo(idx, info) {
                this._ensureCapacity(idx);
                this.drawByIndex = info.indexCount > 0;
                this.instancedDraw = !!info.instanceCount;
                this.drawCount = Math.max(idx + 1, this.drawCount);
                if (this.drawByIndex) {
                  this.counts[idx] = info.indexCount;
                  this.offsets[idx] = info.firstIndex;
                } else {
                  this.counts[idx] = info.vertexCount;
                  this.offsets[idx] = info.firstVertex;
                }
                this.instances[idx] = Math.max(1, info.instanceCount);
              };
              _proto._ensureCapacity = function _ensureCapacity(target) {
                if (this._capacity > target) return;
                this._capacity = nextPow2(target);
                var counts = new Int32Array(this._capacity);
                var offsets = new Int32Array(this._capacity);
                var instances = new Int32Array(this._capacity);
                this.byteOffsets = new Int32Array(this._capacity);
                counts.set(this.counts);
                offsets.set(this.offsets);
                instances.set(this.instances);
                this.counts = counts;
                this.offsets = offsets;
                this.instances = instances;
              };
              return WebGL2IndirectDrawInfos;
            }();
            var IWebGL2BlitManager = function () {
              function IWebGL2BlitManager() {
                this._srcFramebuffer = undefined;
                this._dstFramebuffer = undefined;
                var gl = WebGL2DeviceManager.instance.gl;
                this._srcFramebuffer = gl.createFramebuffer();
                this._dstFramebuffer = gl.createFramebuffer();
              }
              var _proto2 = IWebGL2BlitManager.prototype;
              _proto2.destroy = function destroy() {
                var gl = WebGL2DeviceManager.instance.gl;
                gl.deleteFramebuffer(this._srcFramebuffer);
                gl.deleteFramebuffer(this._dstFramebuffer);
              };
              _createClass(IWebGL2BlitManager, [{
                key: "srcFramebuffer",
                get: function get() {
                  return this._srcFramebuffer;
                }
              }, {
                key: "dstFramebuffer",
                get: function get() {
                  return this._dstFramebuffer;
                }
              }]);
              return IWebGL2BlitManager;
            }();

            var WebGL2Buffer = function (_Buffer) {
              _inheritsLoose(WebGL2Buffer, _Buffer);
              function WebGL2Buffer() {
                var _this;
                _this = _Buffer.call(this) || this;
                _this._gpuBuffer = null;
                return _this;
              }
              var _proto = WebGL2Buffer.prototype;
              _proto.getGpuBuffer = function getGpuBuffer() {
                return this._gpuBuffer;
              };
              _proto.initialize = function initialize(info) {
                if ('buffer' in info) {
                  this._isBufferView = true;
                  var buffer = info.buffer;
                  this._usage = buffer.usage;
                  this._memUsage = buffer.memUsage;
                  this._size = this._stride = info.range;
                  this._count = 1;
                  this._flags = buffer.flags;
                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: null,
                    indirects: buffer.getGpuBuffer().indirects,
                    glTarget: buffer.getGpuBuffer().glTarget,
                    glBuffer: buffer.getGpuBuffer().glBuffer,
                    glOffset: info.offset
                  };
                } else {
                  this._usage = info.usage;
                  this._memUsage = info.memUsage;
                  this._size = info.size;
                  this._stride = Math.max(info.stride || this._size, 1);
                  this._count = this._size / this._stride;
                  this._flags = info.flags;
                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: null,
                    indirects: new WebGL2IndirectDrawInfos(),
                    glTarget: 0,
                    glBuffer: null,
                    glOffset: 0
                  };
                  WebGL2CmdFuncCreateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
                  WebGL2DeviceManager.instance.memoryStatus.bufferSize += this._size;
                }
              };
              _proto.destroy = function destroy() {
                if (this._gpuBuffer) {
                  if (!this._isBufferView) {
                    WebGL2CmdFuncDestroyBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
                    WebGL2DeviceManager.instance.memoryStatus.bufferSize -= this._size;
                  }
                  this._gpuBuffer = null;
                }
              };
              _proto.resize = function resize(size) {
                if (this._isBufferView) {
                  warnID(16379);
                  return;
                }
                var oldSize = this._size;
                if (oldSize === size) {
                  return;
                }
                this._size = size;
                this._count = this._size / this._stride;
                if (this._gpuBuffer) {
                  this._gpuBuffer.size = size;
                  if (size > 0) {
                    WebGL2CmdFuncResizeBuffer(WebGL2DeviceManager.instance, this._gpuBuffer);
                    WebGL2DeviceManager.instance.memoryStatus.bufferSize -= oldSize;
                    WebGL2DeviceManager.instance.memoryStatus.bufferSize += size;
                  }
                }
              };
              _proto.update = function update(buffer, size) {
                if (this._isBufferView) {
                  warnID(16380);
                  return;
                }
                var buffSize;
                if (size !== undefined) {
                  buffSize = size;
                } else if (this._usage & 64) {
                  buffSize = 0;
                } else {
                  buffSize = buffer.byteLength;
                }
                WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, this._gpuBuffer, buffer, 0, buffSize);
              };
              return WebGL2Buffer;
            }(Buffer);

            var WebGL2CommandBuffer = function (_CommandBuffer) {
              _inheritsLoose(WebGL2CommandBuffer, _CommandBuffer);
              function WebGL2CommandBuffer() {
                var _this;
                _this = _CommandBuffer.call(this) || this;
                _this._isInRenderPass = false;
                _this._curGPUPipelineState = null;
                _this._curGPUDescriptorSets = [];
                _this._curGPUInputAssembler = null;
                _this._curDynamicOffsets = Array(8).fill(0);
                _this._curDynamicStates = new DynamicStates();
                _this._isStateInvalid = false;
                return _this;
              }
              var _proto = WebGL2CommandBuffer.prototype;
              _proto.initialize = function initialize(info) {
                this._type = info.type;
                this._queue = info.queue;
                var setCount = WebGL2DeviceManager.instance.bindingMappings.blockOffsets.length;
                for (var i = 0; i < setCount; i++) {
                  this._curGPUDescriptorSets.push(null);
                }
              };
              _proto.destroy = function destroy() {};
              _proto.begin = function begin(renderPass, subpass, frameBuffer) {
                this._curGPUPipelineState = null;
                this._curGPUInputAssembler = null;
                this._curGPUDescriptorSets.length = 0;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
              };
              _proto.end = function end() {
                if (this._isStateInvalid) {
                  this.bindStates();
                }
                this._isInRenderPass = false;
              };
              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                errorID(16401);
                this._isInRenderPass = true;
              };
              _proto.endRenderPass = function endRenderPass() {
                this._isInRenderPass = false;
              };
              _proto.bindPipelineState = function bindPipelineState(pipelineState) {
                var gpuPipelineState = pipelineState.gpuPipelineState;
                if (gpuPipelineState !== this._curGPUPipelineState) {
                  this._curGPUPipelineState = gpuPipelineState;
                  this._isStateInvalid = true;
                }
              };
              _proto.bindDescriptorSet = function bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
                var gpuDescriptorSets = descriptorSet.gpuDescriptorSet;
                if (gpuDescriptorSets !== this._curGPUDescriptorSets[set]) {
                  this._curGPUDescriptorSets[set] = gpuDescriptorSets;
                  this._isStateInvalid = true;
                }
                if (dynamicOffsets) {
                  var _this$_curGPUPipeline;
                  var gpuPipelineLayout = (_this$_curGPUPipeline = this._curGPUPipelineState) == null ? undefined : _this$_curGPUPipeline.gpuPipelineLayout;
                  if (gpuPipelineLayout) {
                    var offsets = this._curDynamicOffsets;
                    var idx = gpuPipelineLayout.dynamicOffsetOffsets[set];
                    for (var i = 0; i < dynamicOffsets.length; i++) offsets[idx + i] = dynamicOffsets[i];
                    this._isStateInvalid = true;
                  }
                }
              };
              _proto.bindInputAssembler = function bindInputAssembler(inputAssembler) {
                var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler;
                this._isStateInvalid = true;
              };
              _proto.setViewport = function setViewport(viewport) {
                var cache = this._curDynamicStates.viewport;
                if (cache.left !== viewport.left || cache.top !== viewport.top || cache.width !== viewport.width || cache.height !== viewport.height || cache.minDepth !== viewport.minDepth || cache.maxDepth !== viewport.maxDepth) {
                  cache.left = viewport.left;
                  cache.top = viewport.top;
                  cache.width = viewport.width;
                  cache.height = viewport.height;
                  cache.minDepth = viewport.minDepth;
                  cache.maxDepth = viewport.maxDepth;
                  this._isStateInvalid = true;
                }
              };
              _proto.setScissor = function setScissor(scissor) {
                var cache = this._curDynamicStates.scissor;
                if (cache.x !== scissor.x || cache.y !== scissor.y || cache.width !== scissor.width || cache.height !== scissor.height) {
                  cache.x = scissor.x;
                  cache.y = scissor.y;
                  cache.width = scissor.width;
                  cache.height = scissor.height;
                  this._isStateInvalid = true;
                }
              };
              _proto.setLineWidth = function setLineWidth(lineWidth) {
                if (this._curDynamicStates.lineWidth !== lineWidth) {
                  this._curDynamicStates.lineWidth = lineWidth;
                  this._isStateInvalid = true;
                }
              };
              _proto.setDepthBias = function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
                var cache = this._curDynamicStates;
                if (cache.depthBiasConstant !== depthBiasConstantFactor || cache.depthBiasClamp !== depthBiasClamp || cache.depthBiasSlope !== depthBiasSlopeFactor) {
                  cache.depthBiasConstant = depthBiasConstantFactor;
                  cache.depthBiasClamp = depthBiasClamp;
                  cache.depthBiasSlope = depthBiasSlopeFactor;
                  this._isStateInvalid = true;
                }
              };
              _proto.setBlendConstants = function setBlendConstants(blendConstants) {
                var cache = this._curDynamicStates.blendConstant;
                if (cache.x !== blendConstants.x || cache.y !== blendConstants.y || cache.z !== blendConstants.z || cache.w !== blendConstants.w) {
                  cache.copy(blendConstants);
                  this._isStateInvalid = true;
                }
              };
              _proto.setDepthBound = function setDepthBound(minDepthBounds, maxDepthBounds) {
                var cache = this._curDynamicStates;
                if (cache.depthMinBounds !== minDepthBounds || cache.depthMaxBounds !== maxDepthBounds) {
                  cache.depthMinBounds = minDepthBounds;
                  cache.depthMaxBounds = maxDepthBounds;
                  this._isStateInvalid = true;
                }
              };
              _proto.setStencilWriteMask = function setStencilWriteMask(face, writeMask) {
                var front = this._curDynamicStates.stencilStatesFront;
                var back = this._curDynamicStates.stencilStatesBack;
                if (face & 1) {
                  if (front.writeMask !== writeMask) {
                    front.writeMask = writeMask;
                    this._isStateInvalid = true;
                  }
                }
                if (face & 2) {
                  if (back.writeMask !== writeMask) {
                    back.writeMask = writeMask;
                    this._isStateInvalid = true;
                  }
                }
              };
              _proto.setStencilCompareMask = function setStencilCompareMask(face, reference, compareMask) {
                var front = this._curDynamicStates.stencilStatesFront;
                var back = this._curDynamicStates.stencilStatesBack;
                if (face & 1) {
                  if (front.compareMask !== compareMask || front.reference !== reference) {
                    front.reference = reference;
                    front.compareMask = compareMask;
                    this._isStateInvalid = true;
                  }
                }
                if (face & 2) {
                  if (back.compareMask !== compareMask || back.reference !== reference) {
                    back.reference = reference;
                    back.compareMask = compareMask;
                    this._isStateInvalid = true;
                  }
                }
              };
              _proto.draw = function draw(infoOrAssembler) {
                errorID(16328);
              };
              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                errorID(16329);
              };
              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                errorID(16330);
              };
              _proto.execute = function execute(cmdBuffs, count) {
                errorID(16402);
              };
              _proto.pipelineBarrier = function pipelineBarrier(GeneralBarrier, bufferBarriers, buffers, textureBarriers, textures) {};
              _proto.bindStates = function bindStates() {
                errorID(16401);
                this._isStateInvalid = false;
              };
              _proto.blitTexture = function blitTexture(srcTexture, dstTexture, regions, filter) {
                errorID(16401);
              };
              return WebGL2CommandBuffer;
            }(CommandBuffer);

            var WebGL2Framebuffer = function (_Framebuffer) {
              _inheritsLoose(WebGL2Framebuffer, _Framebuffer);
              function WebGL2Framebuffer() {
                var _this;
                _this = _Framebuffer.call(this) || this;
                _this._gpuFramebuffer = null;
                _this._gpuColorViews = [];
                _this._gpuDepthStencilView = undefined;
                return _this;
              }
              var _proto = WebGL2Framebuffer.prototype;
              _proto.getGpuFramebuffer = function getGpuFramebuffer() {
                return this._gpuFramebuffer;
              };
              _proto.initialize = function initialize(info) {
                var _this2 = this,
                  _this$_gpuFramebuffer;
                this._renderPass = info.renderPass;
                this._colorTextures = info.colorTextures || [];
                this._depthStencilTexture = info.depthStencilTexture || null;
                var gpuColorViews = [];
                for (var i = 0; i < info.colorTextures.length; i++) {
                  var colorTexture = info.colorTextures[i];
                  if (colorTexture) {
                    gpuColorViews.push(colorTexture.gpuTextureView);
                  }
                }
                var gpuDepthStencilView = null;
                if (info.depthStencilTexture) {
                  gpuDepthStencilView = info.depthStencilTexture.gpuTextureView;
                }
                var width = Number.MAX_SAFE_INTEGER;
                var height = Number.MAX_SAFE_INTEGER;
                this._gpuFramebuffer = {
                  gpuRenderPass: info.renderPass.getGpuRenderPass(),
                  gpuColorViews: gpuColorViews,
                  gpuDepthStencilView: gpuDepthStencilView,
                  glFramebuffer: null,
                  isOffscreen: true,
                  get width() {
                    if (this.gpuColorViews.length > 0) {
                      return this.gpuColorViews[0].gpuTexture.width;
                    } else if (this.gpuDepthStencilView) {
                      return this.gpuDepthStencilView.gpuTexture.width;
                    }
                    return width;
                  },
                  set width(val) {
                    width = val;
                  },
                  get height() {
                    if (this.gpuColorViews.length > 0) {
                      return this.gpuColorViews[0].gpuTexture.height;
                    } else if (this.gpuDepthStencilView) {
                      return this.gpuDepthStencilView.gpuTexture.height;
                    }
                    return height;
                  },
                  set height(val) {
                    height = val;
                  }
                };
                WebGL2CmdFuncCreateFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
                this._gpuFramebuffer.gpuColorViews.forEach(function (tex) {
                  return _this2._gpuColorViews.push(tex.gpuTexture.glTexture);
                });
                this._gpuDepthStencilView = (_this$_gpuFramebuffer = this._gpuFramebuffer.gpuDepthStencilView) == null ? undefined : _this$_gpuFramebuffer.gpuTexture.glTexture;
                this._width = this._gpuFramebuffer.width;
                this._height = this._gpuFramebuffer.height;
              };
              _proto.destroy = function destroy() {
                if (this._gpuFramebuffer) {
                  WebGL2CmdFuncDestroyFramebuffer(WebGL2DeviceManager.instance, this._gpuFramebuffer);
                  this._gpuFramebuffer = null;
                  this._gpuColorViews.length = 0;
                  this._gpuDepthStencilView = null;
                }
              };
              _createClass(WebGL2Framebuffer, [{
                key: "needRebuild",
                get: function get() {
                  var gpuFramebuffer = this.getGpuFramebuffer();
                  if (gpuFramebuffer) {
                    var _gpuFramebuffer$gpuDe;
                    for (var i = 0; i < gpuFramebuffer.gpuColorViews.length; i++) {
                      if (gpuFramebuffer.gpuColorViews[i].gpuTexture.glTexture !== this._gpuColorViews[i]) {
                        return true;
                      }
                    }
                    if (((_gpuFramebuffer$gpuDe = gpuFramebuffer.gpuDepthStencilView) == null ? undefined : _gpuFramebuffer$gpuDe.gpuTexture.glTexture) !== this._gpuDepthStencilView) {
                      return true;
                    }
                  }
                  return false;
                }
              }]);
              return WebGL2Framebuffer;
            }(Framebuffer);

            var WebGL2InputAssembler = function (_InputAssembler) {
              _inheritsLoose(WebGL2InputAssembler, _InputAssembler);
              function WebGL2InputAssembler() {
                var _this;
                _this = _InputAssembler.call(this) || this;
                _this._gpuInputAssembler = null;
                return _this;
              }
              var _proto = WebGL2InputAssembler.prototype;
              _proto.initialize = function initialize(info) {
                if (info.vertexBuffers.length === 0) {
                  errorID(16331);
                  return;
                }
                this._attributes = info.attributes;
                this._attributesHash = this.computeAttributesHash();
                this._vertexBuffers = info.vertexBuffers;
                if (info.indexBuffer) {
                  this._indexBuffer = info.indexBuffer;
                  this._drawInfo.indexCount = this._indexBuffer.size / this._indexBuffer.stride;
                  this._drawInfo.firstIndex = 0;
                } else {
                  var vertBuff = this._vertexBuffers[0];
                  this._drawInfo.vertexCount = vertBuff.size / vertBuff.stride;
                  this._drawInfo.firstVertex = 0;
                  this._drawInfo.vertexOffset = 0;
                }
                this._drawInfo.instanceCount = 0;
                this._drawInfo.firstInstance = 0;
                this._indirectBuffer = info.indirectBuffer || null;
                var gpuVertexBuffers = new Array(info.vertexBuffers.length);
                for (var i = 0; i < info.vertexBuffers.length; ++i) {
                  var vb = info.vertexBuffers[i];
                  if (vb.getGpuBuffer()) {
                    gpuVertexBuffers[i] = vb.getGpuBuffer();
                  }
                }
                var gpuIndexBuffer = null;
                var glIndexType = 0;
                if (info.indexBuffer) {
                  gpuIndexBuffer = info.indexBuffer.getGpuBuffer();
                  if (gpuIndexBuffer) {
                    switch (gpuIndexBuffer.stride) {
                      case 1:
                        glIndexType = 5121;
                        break;
                      case 2:
                        glIndexType = 5123;
                        break;
                      case 4:
                        glIndexType = 5125;
                        break;
                      default:
                        {
                          errorID(16332);
                        }
                    }
                  }
                }
                var gpuIndirectBuffer = null;
                if (info.indirectBuffer) {
                  gpuIndirectBuffer = info.indirectBuffer.getGpuBuffer();
                }
                this._gpuInputAssembler = {
                  attributes: info.attributes,
                  gpuVertexBuffers: gpuVertexBuffers,
                  gpuIndexBuffer: gpuIndexBuffer,
                  gpuIndirectBuffer: gpuIndirectBuffer,
                  glAttribs: [],
                  glIndexType: glIndexType,
                  glVAOs: new Map()
                };
                WebGL2CmdFuncCreateInputAssember(WebGL2DeviceManager.instance, this._gpuInputAssembler);
              };
              _proto.destroy = function destroy() {
                var device = WebGL2DeviceManager.instance;
                if (this._gpuInputAssembler && device.extensions.useVAO) {
                  WebGL2CmdFuncDestroyInputAssembler(device, this._gpuInputAssembler);
                }
                this._gpuInputAssembler = null;
              };
              _createClass(WebGL2InputAssembler, [{
                key: "gpuInputAssembler",
                get: function get() {
                  return this._gpuInputAssembler;
                }
              }]);
              return WebGL2InputAssembler;
            }(InputAssembler);

            var WebGL2DescriptorSetLayout = function (_DescriptorSetLayout) {
              _inheritsLoose(WebGL2DescriptorSetLayout, _DescriptorSetLayout);
              var _proto = WebGL2DescriptorSetLayout.prototype;
              _proto.getGpuDescriptorSetLayout = function getGpuDescriptorSetLayout() {
                return this._gpuDescriptorSetLayout;
              };
              function WebGL2DescriptorSetLayout() {
                var _this;
                _this = _DescriptorSetLayout.call(this) || this;
                _this._gpuDescriptorSetLayout = null;
                return _this;
              }
              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._bindings, info.bindings);
                var descriptorCount = 0;
                var maxBinding = -1;
                var flattenedIndices = [];
                for (var i = 0; i < this._bindings.length; i++) {
                  var binding = this._bindings[i];
                  flattenedIndices.push(descriptorCount);
                  descriptorCount += binding.count;
                  if (binding.binding > maxBinding) maxBinding = binding.binding;
                }
                this._bindingIndices = Array(maxBinding + 1).fill(-1);
                var descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);
                for (var _i = 0; _i < this._bindings.length; _i++) {
                  var _binding = this._bindings[_i];
                  this._bindingIndices[_binding.binding] = _i;
                  descriptorIndices[_binding.binding] = flattenedIndices[_i];
                }
                var dynamicBindings = [];
                for (var _i2 = 0; _i2 < this._bindings.length; _i2++) {
                  var _binding2 = this._bindings[_i2];
                  if (_binding2.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
                    for (var j = 0; j < _binding2.count; j++) {
                      dynamicBindings.push(_binding2.binding);
                    }
                  }
                }
                this._gpuDescriptorSetLayout = {
                  bindings: this._bindings,
                  dynamicBindings: dynamicBindings,
                  descriptorIndices: descriptorIndices,
                  descriptorCount: descriptorCount
                };
              };
              _proto.destroy = function destroy() {
                this._bindings.length = 0;
              };
              return WebGL2DescriptorSetLayout;
            }(DescriptorSetLayout);

            var WebGL2PipelineLayout = function (_PipelineLayout) {
              _inheritsLoose(WebGL2PipelineLayout, _PipelineLayout);
              function WebGL2PipelineLayout() {
                var _this;
                _this = _PipelineLayout.call(this) || this;
                _this._gpuPipelineLayout = null;
                return _this;
              }
              var _proto = WebGL2PipelineLayout.prototype;
              _proto.getGpuPipelineLayout = function getGpuPipelineLayout() {
                return this._gpuPipelineLayout;
              };
              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._setLayouts, info.setLayouts);
                var dynamicOffsetIndices = [];
                var gpuSetLayouts = [];
                var dynamicOffsetCount = 0;
                var dynamicOffsetOffsets = [];
                for (var i = 0; i < this._setLayouts.length; i++) {
                  var setLayout = this._setLayouts[i];
                  var gpuDescriptorSetLayout = setLayout.getGpuDescriptorSetLayout();
                  var dynamicBindings = gpuDescriptorSetLayout.dynamicBindings;
                  var indices = Array(setLayout.bindingIndices.length).fill(-1);
                  for (var j = 0; j < dynamicBindings.length; j++) {
                    var binding = dynamicBindings[j];
                    if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
                  }
                  gpuSetLayouts.push(gpuDescriptorSetLayout);
                  dynamicOffsetIndices.push(indices);
                  dynamicOffsetOffsets.push(dynamicOffsetCount);
                  dynamicOffsetCount += dynamicBindings.length;
                }
                this._gpuPipelineLayout = {
                  gpuSetLayouts: gpuSetLayouts,
                  dynamicOffsetIndices: dynamicOffsetIndices,
                  dynamicOffsetCount: dynamicOffsetCount,
                  dynamicOffsetOffsets: dynamicOffsetOffsets
                };
              };
              _proto.destroy = function destroy() {
                this._setLayouts.length = 0;
              };
              return WebGL2PipelineLayout;
            }(PipelineLayout);

            var WebGLPrimitives = [0, 1, 3, 2, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0];
            var WebGL2PipelineState = function (_PipelineState) {
              _inheritsLoose(WebGL2PipelineState, _PipelineState);
              function WebGL2PipelineState() {
                var _this;
                _this = _PipelineState.call(this) || this;
                _this._gpuPipelineState = null;
                return _this;
              }
              var _proto = WebGL2PipelineState.prototype;
              _proto.initialize = function initialize(info) {
                this._primitive = info.primitive;
                this._shader = info.shader;
                this._pipelineLayout = info.pipelineLayout;
                var bs = this._bs;
                if (info.blendState) {
                  var bsInfo = info.blendState;
                  var targets = bsInfo.targets;
                  if (targets) {
                    targets.forEach(function (t, i) {
                      bs.setTarget(i, t);
                    });
                  }
                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }
                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }
                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }
                Object.assign(this._rs, info.rasterizerState);
                Object.assign(this._dss, info.depthStencilState);
                this._is = info.inputState;
                this._renderPass = info.renderPass;
                this._dynamicStates = info.dynamicStates;
                var dynamicStates = [];
                for (var i = 0; i < 31; i++) {
                  if (this._dynamicStates & 1 << i) {
                    dynamicStates.push(1 << i);
                  }
                }
                this._gpuPipelineState = {
                  glPrimitive: WebGLPrimitives[info.primitive],
                  gpuShader: info.shader.gpuShader,
                  gpuPipelineLayout: info.pipelineLayout.getGpuPipelineLayout(),
                  rs: info.rasterizerState,
                  dss: info.depthStencilState,
                  bs: info.blendState,
                  gpuRenderPass: info.renderPass.getGpuRenderPass(),
                  dynamicStates: dynamicStates
                };
              };
              _proto.destroy = function destroy() {
                this._gpuPipelineState = null;
              };
              _createClass(WebGL2PipelineState, [{
                key: "gpuPipelineState",
                get: function get() {
                  return this._gpuPipelineState;
                }
              }]);
              return WebGL2PipelineState;
            }(PipelineState);

            var WebGL2PrimaryCommandBuffer = function (_WebGL2CommandBuffer) {
              _inheritsLoose(WebGL2PrimaryCommandBuffer, _WebGL2CommandBuffer);
              function WebGL2PrimaryCommandBuffer() {
                return _WebGL2CommandBuffer.call(this) || this;
              }
              var _proto = WebGL2PrimaryCommandBuffer.prototype;
              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                WebGL2CmdFuncBeginRenderPass(WebGL2DeviceManager.instance, renderPass.getGpuRenderPass(), framebuffer.getGpuFramebuffer(), renderArea, clearColors, clearDepth, clearStencil);
                this._isInRenderPass = true;
              };
              _proto.draw = function draw(infoOrAssembler) {
                if (this._isInRenderPass) {
                  if (this._isStateInvalid) {
                    this.bindStates();
                  }
                  var info = 'drawInfo' in infoOrAssembler ? infoOrAssembler.drawInfo : infoOrAssembler;
                  WebGL2CmdFuncDraw(WebGL2DeviceManager.instance, info);
                  ++this._numDrawCalls;
                  this._numInstances += info.instanceCount;
                  var indexCount = info.indexCount || info.vertexCount;
                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;
                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(info.instanceCount, 1);
                          break;
                        }
                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(info.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  errorID(16328);
                }
              };
              _proto.setViewport = function setViewport(viewport) {
                var gl = WebGL2DeviceManager.instance.gl;
                var cache = WebGL2DeviceManager.instance.getStateCache();
                if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
                  gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
                  cache.viewport.left = viewport.left;
                  cache.viewport.top = viewport.top;
                  cache.viewport.width = viewport.width;
                  cache.viewport.height = viewport.height;
                }
              };
              _proto.setScissor = function setScissor(scissor) {
                var gl = WebGL2DeviceManager.instance.gl;
                var cache = WebGL2DeviceManager.instance.getStateCache();
                if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
                  gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
                  cache.scissorRect.x = scissor.x;
                  cache.scissorRect.y = scissor.y;
                  cache.scissorRect.width = scissor.width;
                  cache.scissorRect.height = scissor.height;
                }
              };
              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (!this._isInRenderPass) {
                  var gpuBuffer = buffer.getGpuBuffer();
                  if (gpuBuffer) {
                    var buffSize;
                    if (size !== undefined) {
                      buffSize = size;
                    } else if (buffer.usage & 64) {
                      buffSize = 0;
                    } else {
                      buffSize = data.byteLength;
                    }
                    WebGL2CmdFuncUpdateBuffer(WebGL2DeviceManager.instance, gpuBuffer, data, 0, buffSize);
                  }
                } else {
                  errorID(16329);
                }
              };
              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (!this._isInRenderPass) {
                  var gpuTexture = texture.gpuTexture;
                  if (gpuTexture) {
                    WebGL2CmdFuncCopyBuffersToTexture(WebGL2DeviceManager.instance, buffers, gpuTexture, regions);
                  }
                } else {
                  errorID(16330);
                }
              };
              _proto.execute = function execute(cmdBuffs, count) {
                errorID(16402);
              };
              _proto.bindStates = function bindStates() {
                WebGL2CmdFuncBindStates(WebGL2DeviceManager.instance, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, this._curDynamicOffsets, this._curDynamicStates);
                this._isStateInvalid = false;
              };
              _proto.blitTexture = function blitTexture(srcTexture, dstTexture, regions, filter) {
                var gpuTextureSrc = srcTexture.gpuTexture;
                var gpuTextureDst = dstTexture.gpuTexture;
                WebGL2CmdFuncBlitTexture(WebGL2DeviceManager.instance, gpuTextureSrc, gpuTextureDst, regions, filter);
              };
              return WebGL2PrimaryCommandBuffer;
            }(WebGL2CommandBuffer);

            var WebGL2Queue = function (_Queue) {
              _inheritsLoose(WebGL2Queue, _Queue);
              function WebGL2Queue() {
                var _this;
                _this = _Queue.call(this) || this;
                _this.numDrawCalls = 0;
                _this.numInstances = 0;
                _this.numTris = 0;
                return _this;
              }
              var _proto = WebGL2Queue.prototype;
              _proto.initialize = function initialize(info) {
                this._type = info.type;
              };
              _proto.destroy = function destroy() {};
              _proto.submit = function submit(cmdBuffs) {
                for (var i = 0; i < cmdBuffs.length; i++) {
                  var cmdBuff = cmdBuffs[i];
                  this.numDrawCalls += cmdBuff.numDrawCalls;
                  this.numInstances += cmdBuff.numInstances;
                  this.numTris += cmdBuff.numTris;
                }
              };
              _proto.clear = function clear() {
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              };
              return WebGL2Queue;
            }(Queue);

            var WebGL2RenderPass = function (_RenderPass) {
              _inheritsLoose(WebGL2RenderPass, _RenderPass);
              function WebGL2RenderPass() {
                var _this;
                _this = _RenderPass.call(this) || this;
                _this._gpuRenderPass = null;
                return _this;
              }
              var _proto = WebGL2RenderPass.prototype;
              _proto.getGpuRenderPass = function getGpuRenderPass() {
                return this._gpuRenderPass;
              };
              _proto.initialize = function initialize(info) {
                this._colorInfos = info.colorAttachments;
                this._depthStencilInfo = info.depthStencilAttachment;
                this._subpasses = info.subpasses;
                this._gpuRenderPass = {
                  colorAttachments: this._colorInfos,
                  depthStencilAttachment: this._depthStencilInfo
                };
                this._hash = this.computeHash();
              };
              _proto.destroy = function destroy() {
                this._gpuRenderPass = null;
              };
              return WebGL2RenderPass;
            }(RenderPass);

            var WebGL2Sampler = function (_Sampler) {
              _inheritsLoose(WebGL2Sampler, _Sampler);
              function WebGL2Sampler(info, hash) {
                var _this;
                _this = _Sampler.call(this, info, hash) || this;
                _this._gpuSampler = null;
                _this._gpuSampler = {
                  glSamplers: new Map(),
                  minFilter: _this._info.minFilter,
                  magFilter: _this._info.magFilter,
                  mipFilter: _this._info.mipFilter,
                  addressU: _this._info.addressU,
                  addressV: _this._info.addressV,
                  addressW: _this._info.addressW,
                  glMinFilter: 0,
                  glMagFilter: 0,
                  glWrapS: 0,
                  glWrapT: 0,
                  glWrapR: 0,
                  getGLSampler: function getGLSampler(device, minLod, maxLod) {
                    var gl = device.gl;
                    var samplerHash = minLod << 16 | maxLod;
                    if (!this.glSamplers.has(samplerHash)) {
                      var glSampler = gl.createSampler();
                      if (glSampler) {
                        this.glSamplers.set(samplerHash, glSampler);
                        var glSamplerParameteri = gl.samplerParameteri.bind(gl);
                        var glSamplerParameterf = gl.samplerParameterf.bind(gl);
                        glSamplerParameteri(glSampler, 10241, this.glMinFilter);
                        glSamplerParameteri(glSampler, 10240, this.glMagFilter);
                        glSamplerParameteri(glSampler, 10242, this.glWrapS);
                        glSamplerParameteri(glSampler, 10243, this.glWrapT);
                        glSamplerParameteri(glSampler, 32882, this.glWrapR);
                        glSamplerParameterf(glSampler, 33082, minLod);
                        glSamplerParameterf(glSampler, 33083, maxLod);
                      }
                    }
                    var sampler = this.glSamplers.get(samplerHash);
                    return sampler;
                  }
                };
                WebGL2CmdFuncPrepareSamplerInfo(WebGL2DeviceManager.instance, _this._gpuSampler);
                return _this;
              }
              var _proto = WebGL2Sampler.prototype;
              _proto.destroy = function destroy() {
                if (this._gpuSampler) {
                  WebGL2CmdFuncDestroySampler(WebGL2DeviceManager.instance, this._gpuSampler);
                  this._gpuSampler = null;
                }
              };
              _createClass(WebGL2Sampler, [{
                key: "gpuSampler",
                get: function get() {
                  return this._gpuSampler;
                }
              }]);
              return WebGL2Sampler;
            }(Sampler);

            var WebGL2Shader = function (_Shader) {
              _inheritsLoose(WebGL2Shader, _Shader);
              function WebGL2Shader() {
                var _this;
                _this = _Shader.call(this) || this;
                _this._gpuShader = null;
                return _this;
              }
              var _proto = WebGL2Shader.prototype;
              _proto.initialize = function initialize(info) {
                this._name = info.name;
                this._stages = info.stages;
                this._attributes = info.attributes;
                this._blocks = info.blocks;
                this._samplers = info.samplers;
                this._gpuShader = {
                  name: info.name,
                  blocks: info.blocks.slice(),
                  samplerTextures: info.samplerTextures.slice(),
                  subpassInputs: info.subpassInputs.slice(),
                  gpuStages: new Array(info.stages.length),
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplerTextures: []
                };
                for (var i = 0; i < info.stages.length; ++i) {
                  var stage = info.stages[i];
                  this._gpuShader.gpuStages[i] = {
                    type: stage.stage,
                    source: stage.source,
                    glShader: null
                  };
                }
              };
              _proto.destroy = function destroy() {
                if (this._gpuShader) {
                  WebGL2CmdFuncDestroyShader(WebGL2DeviceManager.instance, this._gpuShader);
                  this._gpuShader = null;
                }
              };
              _createClass(WebGL2Shader, [{
                key: "gpuShader",
                get: function get() {
                  if (this._gpuShader.glProgram === null) {
                    WebGL2CmdFuncCreateShader(WebGL2DeviceManager.instance, this._gpuShader);
                  }
                  return this._gpuShader;
                }
              }]);
              return WebGL2Shader;
            }(Shader);

            var WebGL2StateCache = function () {
              function WebGL2StateCache() {
                this.glArrayBuffer = null;
                this.glElementArrayBuffer = null;
                this.glUniformBuffer = null;
                this.glBindUBOs = [];
                this.glBindUBOOffsets = [];
                this.glVAO = null;
                this.texUnit = 0;
                this.glTexUnits = [];
                this.glSamplerUnits = [];
                this.glRenderbuffer = null;
                this.glFramebuffer = null;
                this.glReadFramebuffer = null;
                this.viewport = new Viewport();
                this.scissorRect = new Rect$1(0, 0, 0, 0);
                this.rs = new RasterizerState();
                this.dss = new DepthStencilState();
                this.bs = new BlendState();
                this.glProgram = null;
                this.glEnabledAttribLocs = [];
                this.glCurrentAttribLocs = [];
                this.texUnitCacheMap = {};
              }
              var _proto = WebGL2StateCache.prototype;
              _proto.initialize = function initialize(texUnit, bufferBindings, vertexAttributes) {
                for (var i = 0; i < texUnit; ++i) {
                  var glTexUnit = {
                    glTexture: null
                  };
                  this.glTexUnits.push(glTexUnit);
                }
                this.glSamplerUnits.length = texUnit;
                this.glSamplerUnits.fill(null);
                this.glBindUBOs.length = bufferBindings;
                this.glBindUBOs.fill(null);
                this.glBindUBOOffsets.length = bufferBindings;
                this.glBindUBOOffsets.fill(0);
                this.glEnabledAttribLocs.length = vertexAttributes;
                this.glEnabledAttribLocs.fill(false);
                this.glCurrentAttribLocs.length = vertexAttributes;
                this.glCurrentAttribLocs.fill(false);
              };
              return WebGL2StateCache;
            }();

            var WebGL2Texture = function (_Texture) {
              _inheritsLoose(WebGL2Texture, _Texture);
              function WebGL2Texture() {
                var _this;
                _this = _Texture.call(this) || this;
                _this._gpuTexture = null;
                _this._gpuTextureView = null;
                return _this;
              }
              var _proto = WebGL2Texture.prototype;
              _proto.initialize = function initialize(info, isSwapchainTexture) {
                var self = this;
                var instance = WebGL2DeviceManager.instance;
                var thisTextureInfo = self._info;
                var thisViewInfo = self._viewInfo;
                var texInfo = info;
                var viewInfo = info;
                if ('texture' in info) {
                  texInfo = viewInfo.texture.info;
                  self._isTextureView = true;
                }
                thisTextureInfo.copy(texInfo);
                self._isPowerOf2 = IsPowerOf2(thisTextureInfo.width) && IsPowerOf2(thisTextureInfo.height);
                self._size = FormatSurfaceSize(thisTextureInfo.format, self.width, self.height, self.depth, thisTextureInfo.levelCount) * thisTextureInfo.layerCount;
                if (!self._isTextureView) {
                  self._gpuTexture = {
                    type: texInfo.type,
                    format: texInfo.format,
                    usage: texInfo.usage,
                    width: texInfo.width,
                    height: texInfo.height,
                    depth: texInfo.depth,
                    size: self._size,
                    arrayLayer: texInfo.layerCount,
                    mipLevel: texInfo.levelCount,
                    samples: texInfo.samples,
                    flags: texInfo.flags,
                    isPowerOf2: self._isPowerOf2,
                    glTarget: 0,
                    glInternalFmt: 0,
                    glFormat: 0,
                    glType: 0,
                    glUsage: 0,
                    glTexture: null,
                    glRenderbuffer: null,
                    glWrapS: 0,
                    glWrapT: 0,
                    glMinFilter: 0,
                    glMagFilter: 0,
                    isSwapchainTexture: isSwapchainTexture || false
                  };
                  if (!self._gpuTexture.isSwapchainTexture) {
                    WebGL2CmdFuncCreateTexture(instance, self._gpuTexture);
                    instance.memoryStatus.textureSize += self._size;
                  }
                  thisViewInfo.texture = self;
                  thisViewInfo.type = info.type;
                  thisViewInfo.format = info.format;
                  thisViewInfo.baseLevel = 0;
                  thisViewInfo.levelCount = info.levelCount;
                  thisViewInfo.baseLayer = 0;
                  thisViewInfo.layerCount = info.layerCount;
                  self._gpuTextureView = {
                    gpuTexture: self._gpuTexture,
                    type: thisViewInfo.type,
                    format: thisViewInfo.format,
                    baseLevel: thisViewInfo.baseLevel,
                    levelCount: thisViewInfo.levelCount
                  };
                } else {
                  var _self$_gpuTexture;
                  thisViewInfo.copy(viewInfo);
                  self._gpuTexture = viewInfo.texture._gpuTexture;
                  if (((_self$_gpuTexture = self._gpuTexture) == null ? undefined : _self$_gpuTexture.format) !== texInfo.format) {
                    logID(16403);
                    return;
                  }
                  self._gpuTextureView = {
                    gpuTexture: self._gpuTexture,
                    type: viewInfo.type,
                    format: viewInfo.format,
                    baseLevel: viewInfo.baseLevel,
                    levelCount: viewInfo.levelCount
                  };
                }
              };
              _proto.destroy = function destroy() {
                var self = this;
                var instance = WebGL2DeviceManager.instance;
                if (!self._isTextureView && self._gpuTexture) {
                  WebGL2CmdFuncDestroyTexture(instance, self._gpuTexture);
                  instance.memoryStatus.textureSize -= self._size;
                  self._gpuTexture = null;
                }
              };
              _proto.getTextureHandle = function getTextureHandle() {
                var gpuTexture = this._gpuTexture;
                if (!gpuTexture) {
                  return 0;
                }
                if (gpuTexture.glTexture) {
                  return gpuTexture.glTexture;
                } else if (gpuTexture.glRenderbuffer) {
                  return gpuTexture.glRenderbuffer;
                }
                return 0;
              };
              _proto.resize = function resize(width, height) {
                var self = this;
                var instance = WebGL2DeviceManager.instance;
                var thisTextureInfo = self._info;
                if (thisTextureInfo.width === width && thisTextureInfo.height === height) {
                  return;
                }
                if (thisTextureInfo.levelCount === WebGL2Texture.getLevelCount(thisTextureInfo.width, thisTextureInfo.height)) {
                  thisTextureInfo.levelCount = WebGL2Texture.getLevelCount(width, height);
                } else if (thisTextureInfo.levelCount > 1) {
                  thisTextureInfo.levelCount = Math.min(thisTextureInfo.levelCount, WebGL2Texture.getLevelCount(width, height));
                }
                var oldSize = self._size;
                thisTextureInfo.width = width;
                thisTextureInfo.height = height;
                self._size = FormatSurfaceSize(thisTextureInfo.format, self.width, self.height, self.depth, thisTextureInfo.levelCount) * thisTextureInfo.layerCount;
                var thisGpuTexture = self._gpuTexture;
                if (!self._isTextureView && thisGpuTexture) {
                  thisGpuTexture.width = width;
                  thisGpuTexture.height = height;
                  thisGpuTexture.size = self._size;
                  if (!thisGpuTexture.isSwapchainTexture) {
                    WebGL2CmdFuncResizeTexture(instance, thisGpuTexture);
                    instance.memoryStatus.textureSize -= oldSize;
                    instance.memoryStatus.textureSize += self._size;
                  }
                }
              };
              _proto.initAsSwapchainTexture = function initAsSwapchainTexture(info) {
                var texInfo = new TextureInfo();
                texInfo.format = info.format;
                texInfo.usage = FormatInfos[info.format].hasDepth ? 32 : 16;
                texInfo.width = info.width;
                texInfo.height = info.height;
                this.initialize(texInfo, true);
              };
              _createClass(WebGL2Texture, [{
                key: "gpuTexture",
                get: function get() {
                  return this._gpuTexture;
                }
              }, {
                key: "gpuTextureView",
                get: function get() {
                  return this._gpuTextureView;
                }
              }]);
              return WebGL2Texture;
            }(Texture);

            var eventWebGLContextLost = 'webglcontextlost';
            function initStates(gl) {
              gl.activeTexture(33984);
              gl.pixelStorei(3333, 1);
              gl.pixelStorei(3317, 1);
              gl.pixelStorei(37440, false);
              gl.bindFramebuffer(36160, null);
              gl.enable(3089);
              gl.enable(2884);
              gl.cullFace(1029);
              gl.frontFace(2305);
              gl.polygonOffset(0.0, 0.0);
              gl.enable(2929);
              gl.depthMask(true);
              gl.depthFunc(513);
              gl.stencilFuncSeparate(1028, 519, 1, 0xffff);
              gl.stencilOpSeparate(1028, 7680, 7680, 7680);
              gl.stencilMaskSeparate(1028, 0xffff);
              gl.stencilFuncSeparate(1029, 519, 1, 0xffff);
              gl.stencilOpSeparate(1029, 7680, 7680, 7680);
              gl.stencilMaskSeparate(1029, 0xffff);
              gl.disable(2960);
              gl.disable(32926);
              gl.disable(3042);
              gl.blendEquationSeparate(32774, 32774);
              gl.blendFuncSeparate(1, 0, 1, 0);
              gl.colorMask(true, true, true, true);
              gl.blendColor(0.0, 0.0, 0.0, 0.0);
            }
            function getExtension(gl, ext) {
              var prefixes = ['', 'WEBKIT_', 'MOZ_'];
              for (var i = 0; i < prefixes.length; ++i) {
                var _ext = gl.getExtension(prefixes[i] + ext);
                if (_ext) {
                  return _ext;
                }
              }
              return null;
            }
            function getExtensions(gl) {
              var res = {
                EXT_texture_filter_anisotropic: getExtension(gl, 'EXT_texture_filter_anisotropic'),
                EXT_color_buffer_half_float: getExtension(gl, 'EXT_color_buffer_half_float'),
                EXT_color_buffer_float: getExtension(gl, 'EXT_color_buffer_float'),
                WEBGL_compressed_texture_etc1: getExtension(gl, 'WEBGL_compressed_texture_etc1'),
                WEBGL_compressed_texture_etc: getExtension(gl, 'WEBGL_compressed_texture_etc'),
                WEBGL_compressed_texture_pvrtc: getExtension(gl, 'WEBGL_compressed_texture_pvrtc'),
                WEBGL_compressed_texture_astc: getExtension(gl, 'WEBGL_compressed_texture_astc'),
                WEBGL_compressed_texture_s3tc: getExtension(gl, 'WEBGL_compressed_texture_s3tc'),
                WEBGL_compressed_texture_s3tc_srgb: getExtension(gl, 'WEBGL_compressed_texture_s3tc_srgb'),
                WEBGL_debug_shaders: getExtension(gl, 'WEBGL_debug_shaders'),
                WEBGL_lose_context: getExtension(gl, 'WEBGL_lose_context'),
                WEBGL_debug_renderer_info: getExtension(gl, 'WEBGL_debug_renderer_info'),
                OES_texture_half_float_linear: getExtension(gl, 'OES_texture_half_float_linear'),
                OES_texture_float_linear: getExtension(gl, 'OES_texture_float_linear'),
                WEBGL_multi_draw: null,
                useVAO: true
              };
              {
                if (systemInfo.os !== OS.ANDROID && systemInfo.os !== OS.IOS) {
                  res.WEBGL_multi_draw = getExtension(gl, 'WEBGL_multi_draw');
                }
              }
              return res;
            }
            function getContext(canvas) {
              var context = null;
              try {
                var _globalThis$__globalX;
                var glAttribs; if (USE_XR && (_globalThis$__globalX = globalThis.__globalXR) != null && _globalThis$__globalX.webxrCompatible) ;
                var webGLCtxAttribs = {
                  alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                  antialias: EDITOR || macro.ENABLE_WEBGL_ANTIALIAS,
                  depth: true,
                  stencil: true,
                  premultipliedAlpha: false,
                  preserveDrawingBuffer: false,
                  powerPreference: 'default',
                  failIfMajorPerformanceCaveat: false
                };
                context = canvas.getContext('webgl2', webGLCtxAttribs);
              } catch (err) {
                return null;
              }
              return context;
            }
            var WebGL2Swapchain = function (_Swapchain) {
              _inheritsLoose(WebGL2Swapchain, _Swapchain);
              function WebGL2Swapchain() {
                var _this;
                _this = _Swapchain.call(this) || this;
                _this.stateCache = new WebGL2StateCache();
                _this.nullTex2D = null;
                _this.nullTexCube = null;
                _this._canvas = null;
                _this._webGL2ContextLostHandler = null;
                _this._extensions = null;
                _this._blitManager = null;
                return _this;
              }
              var _proto = WebGL2Swapchain.prototype;
              _proto.initialize = function initialize(info) {
                var self = this;
                self._canvas = info.windowHandle;
                self._webGL2ContextLostHandler = self._onWebGLContextLost.bind(self);
                self._canvas.addEventListener(eventWebGLContextLost, self._onWebGLContextLost);
                var instance = WebGL2DeviceManager.instance;
                var gl = instance.gl,
                  capabilities = instance.capabilities;
                self.stateCache.initialize(capabilities.maxTextureUnits, capabilities.maxUniformBufferBindings, capabilities.maxVertexAttributes);
                self._extensions = getExtensions(gl);
                initStates(gl);
                var colorFmt = 35;
                var depthStencilFmt = 55;
                var depthBits = gl.getParameter(3414);
                var stencilBits = gl.getParameter(3415);
                if (depthBits && stencilBits) depthStencilFmt = 55;else if (depthBits) depthStencilFmt = 54;
                self._colorTexture = new WebGL2Texture();
                self._colorTexture.initAsSwapchainTexture({
                  swapchain: self,
                  format: colorFmt,
                  width: info.width,
                  height: info.height
                });
                self._depthStencilTexture = new WebGL2Texture();
                self._depthStencilTexture.initAsSwapchainTexture({
                  swapchain: self,
                  format: depthStencilFmt,
                  width: info.width,
                  height: info.height
                });
                self.nullTex2D = instance.createTexture(new TextureInfo(1, 4, 35, 2, 2, 0));
                self.nullTexCube = instance.createTexture(new TextureInfo(3, 4, 35, 2, 2, 0, 6));
                var nullTexRegion = new BufferTextureCopy();
                nullTexRegion.texExtent.width = 2;
                nullTexRegion.texExtent.height = 2;
                var nullTexBuff = new Uint8Array(self.nullTex2D.size);
                nullTexBuff.fill(0);
                instance.copyBuffersToTexture([nullTexBuff], self.nullTex2D, [nullTexRegion]);
                nullTexRegion.texSubres.layerCount = 6;
                instance.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], self.nullTexCube, [nullTexRegion]);
                self._blitManager = new IWebGL2BlitManager();
              };
              _proto.destroy = function destroy() {
                var self = this;
                if (self._canvas && self._webGL2ContextLostHandler) {
                  self._canvas.removeEventListener(eventWebGLContextLost, self._webGL2ContextLostHandler);
                  self._webGL2ContextLostHandler = null;
                }
                if (self.nullTex2D) {
                  self.nullTex2D.destroy();
                  self.nullTex2D = null;
                }
                if (self.nullTexCube) {
                  self.nullTexCube.destroy();
                  self.nullTexCube = null;
                }
                if (self._blitManager) {
                  self._blitManager.destroy();
                  self._blitManager = null;
                }
                self._extensions = null;
                self._canvas = null;
              };
              _proto.resize = function resize(width, height, surfaceTransform) {
                var self = this;
                if (self._colorTexture.width !== width || self._colorTexture.height !== height) {
                  debug("Resizing swapchain: " + width + "x" + height);
                  self._canvas.width = width;
                  self._canvas.height = height;
                  self._colorTexture.resize(width, height);
                  self._depthStencilTexture.resize(width, height);
                }
              };
              _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
                warnID(11000);
                warn(event);
              };
              _createClass(WebGL2Swapchain, [{
                key: "extensions",
                get: function get() {
                  return this._extensions;
                }
              }, {
                key: "blitManager",
                get: function get() {
                  return this._blitManager;
                }
              }]);
              return WebGL2Swapchain;
            }(Swapchain);

            function setFormatFeature(formatFeatures, indexArray, feature) {
              for (var i = 0; i < indexArray.length; ++i) {
                formatFeatures[indexArray[i]] = feature;
              }
            }
            function setTextureExclusive(textureExclusive, indexArray, isExclusive) {
              for (var i = 0; i < indexArray.length; ++i) {
                textureExclusive[indexArray[i]] = isExclusive;
              }
            }
            var WebGL2Device = exports("WebGL2Device", function (_Device) {
              _inheritsLoose(WebGL2Device, _Device);
              function WebGL2Device() {
                var _this;
                _this = _Device.call(this) || this;
                _this._swapchain = null;
                _this._context = null;
                _this._bindingMappings = null;
                _this._textureExclusive = new Array(117);
                return _this;
              }
              var _proto = WebGL2Device.prototype;
              _proto.getStateCache = function getStateCache() {
                return this._swapchain.stateCache;
              };
              _proto.initialize = function initialize(info) {
                WebGL2DeviceManager.setInstance(this);
                this._gfxAPI = 7;
                var mapping = this._bindingMappingInfo = info.bindingMappingInfo;
                var blockOffsets = [];
                var samplerTextureOffsets = [];
                var firstSet = mapping.setIndices[0];
                blockOffsets[firstSet] = 0;
                samplerTextureOffsets[firstSet] = 0;
                for (var i = 1; i < mapping.setIndices.length; ++i) {
                  var curSet = mapping.setIndices[i];
                  var prevSet = mapping.setIndices[i - 1];
                  blockOffsets[curSet] = mapping.maxBlockCounts[prevSet] + blockOffsets[prevSet];
                  samplerTextureOffsets[curSet] = mapping.maxSamplerTextureCounts[prevSet] + samplerTextureOffsets[prevSet];
                }
                for (var _i = 0; _i < mapping.setIndices.length; ++_i) {
                  var _curSet = mapping.setIndices[_i];
                  samplerTextureOffsets[_curSet] -= mapping.maxBlockCounts[_curSet];
                }
                this._bindingMappings = {
                  blockOffsets: blockOffsets,
                  samplerTextureOffsets: samplerTextureOffsets,
                  flexibleSet: mapping.setIndices[mapping.setIndices.length - 1]
                };
                var gl = this._context = getContext(Device.canvas);
                if (!gl) {
                  errorID(16405);
                  return false;
                }
                this._queue = this.createQueue(new QueueInfo(0));
                this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
                var glGetParameter = gl.getParameter.bind(gl);
                var caps = this._caps;
                caps.maxVertexAttributes = glGetParameter(34921);
                caps.maxVertexUniformVectors = glGetParameter(36347);
                if (systemInfo.os === OS.IOS) {
                  var maxVertexUniformVectors = caps.maxVertexUniformVectors;
                  if (sys.browserType === BrowserType.WECHAT) {
                    caps.maxVertexUniformVectors = maxVertexUniformVectors < 256 ? maxVertexUniformVectors : 256;
                  } else if (sys.browserType === BrowserType.SAFARI) {
                    caps.maxVertexUniformVectors = maxVertexUniformVectors < 512 ? maxVertexUniformVectors : 512;
                  }
                }
                caps.maxFragmentUniformVectors = glGetParameter(36349);
                caps.maxTextureUnits = glGetParameter(34930);
                caps.maxVertexTextureUnits = glGetParameter(35660);
                caps.maxUniformBufferBindings = glGetParameter(35375);
                caps.maxUniformBlockSize = glGetParameter(35376);
                caps.maxTextureSize = glGetParameter(3379);
                caps.maxCubeMapTextureSize = glGetParameter(34076);
                caps.maxArrayTextureLayers = glGetParameter(35071);
                caps.max3DTextureSize = glGetParameter(32883);
                caps.uboOffsetAlignment = glGetParameter(35380);
                var extensions = gl.getSupportedExtensions();
                var extStr = '';
                if (extensions) {
                  extensions.forEach(function (ext) {
                    extStr += ext + " ";
                  });
                }
                var exts = getExtensions(gl);
                if (exts.WEBGL_debug_renderer_info) {
                  this._renderer = glGetParameter(exts.WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
                  this._vendor = glGetParameter(exts.WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
                } else {
                  this._renderer = glGetParameter(7937);
                  this._vendor = glGetParameter(7936);
                }
                var version = glGetParameter(7938);
                var features = this._features;
                features.fill(false);
                this.initFormatFeatures(exts);
                features[0] = true;
                features[1] = true;
                features[2] = true;
                features[3] = true;
                var compressedFormat = '';
                if (this.getFormatFeatures(72)) {
                  compressedFormat += 'etc1 ';
                }
                if (this.getFormatFeatures(73)) {
                  compressedFormat += 'etc2 ';
                }
                if (this.getFormatFeatures(56)) {
                  compressedFormat += 'dxt ';
                }
                if (this.getFormatFeatures(83)) {
                  compressedFormat += 'pvrtc ';
                }
                if (this.getFormatFeatures(89)) {
                  compressedFormat += 'astc ';
                }
                debug('WebGL2 device initialized.');
                debug("RENDERER: " + this._renderer);
                debug("VENDOR: " + this._vendor);
                debug("VERSION: " + version);
                debug("COMPRESSED_FORMAT: " + compressedFormat);
                debug("EXTENSIONS: " + extStr);
                return true;
              };
              _proto.destroy = function destroy() {
                if (this._queue) {
                  this._queue.destroy();
                  this._queue = null;
                }
                if (this._cmdBuff) {
                  this._cmdBuff.destroy();
                  this._cmdBuff = null;
                }
                var it = this._samplers.values();
                var res = it.next();
                while (!res.done) {
                  res.value.destroy();
                  res = it.next();
                }
                this._swapchain = null;
              };
              _proto.flushCommands = function flushCommands(cmdBuffs) {};
              _proto.acquire = function acquire(swapchains) {};
              _proto.present = function present() {
                var queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls;
                this._numInstances = queue.numInstances;
                this._numTris = queue.numTris;
                queue.clear();
              };
              _proto.initFormatFeatures = function initFormatFeatures(exts) {
                var formatFeatures = this._formatFeatures;
                var textureExclusive = this._textureExclusive;
                formatFeatures.fill(0);
                textureExclusive.fill(true);
                var tempFeature = 1 | 2 | 8 | 4 | 16;
                setFormatFeature(formatFeatures, [4, 14, 24, 35], tempFeature);
                tempFeature = 1 | 2 | 8 | 4;
                setFormatFeature(formatFeatures, [5, 15, 26, 38, 47, 50, 49, 51, 25, 37, 48, 53, 54, 55], tempFeature);
                formatFeatures[52] = 1 | 8 | 2 | 4;
                tempFeature = 1 | 2 | 8 | 16;
                setFormatFeature(formatFeatures, [8, 18, 29, 41], tempFeature);
                tempFeature = 8 | 2 | 16;
                setFormatFeature(formatFeatures, [11, 21, 32, 44], tempFeature);
                formatFeatures[52] = 1 | 8 | 2 | 4;
                tempFeature = 1 | 8 | 2 | 4 | 16;
                setFormatFeature(formatFeatures, [7, 6, 10, 9, 13, 12, 17, 16, 20, 19, 23, 22, 28, 27, 31, 30, 34, 33, 40, 39, 43, 42, 46, 45], tempFeature);
                setTextureExclusive(textureExclusive, [4, 14, 24, 47, 50, 49, 35, 51, 52, 37, 7, 6, 10, 9, 13, 12, 17, 16, 20, 19, 23, 22, 40, 39, 43, 42, 46, 45, 54, 55], false);
                if (exts.EXT_color_buffer_float) {
                  formatFeatures[11] |= 1;
                  formatFeatures[21] |= 1;
                  formatFeatures[44] |= 1;
                  setTextureExclusive(textureExclusive, [11, 21, 44], false);
                }
                if (exts.EXT_color_buffer_half_float) {
                  setTextureExclusive(textureExclusive, [8, 18, 41], false);
                }
                if (exts.OES_texture_float_linear) {
                  formatFeatures[32] |= 4;
                  formatFeatures[44] |= 4;
                  formatFeatures[11] |= 4;
                  formatFeatures[21] |= 4;
                }
                if (exts.OES_texture_half_float_linear) {
                  formatFeatures[29] |= 4;
                  formatFeatures[41] |= 4;
                  formatFeatures[8] |= 4;
                  formatFeatures[18] |= 4;
                }
                var compressedFeature = 2 | 4;
                if (exts.WEBGL_compressed_texture_etc1) {
                  formatFeatures[72] = compressedFeature;
                }
                if (exts.WEBGL_compressed_texture_etc) {
                  setFormatFeature(formatFeatures, [73, 77, 74, 78, 75, 76], compressedFeature);
                }
                if (exts.WEBGL_compressed_texture_s3tc) {
                  setFormatFeature(formatFeatures, [56, 57, 58, 59, 60, 61, 62, 63], compressedFeature);
                }
                if (exts.WEBGL_compressed_texture_pvrtc) {
                  setFormatFeature(formatFeatures, [83, 84, 85, 86], compressedFeature);
                }
                if (exts.WEBGL_compressed_texture_astc) {
                  setFormatFeature(formatFeatures, [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116], compressedFeature);
                }
              };
              _proto.createCommandBuffer = function createCommandBuffer(info) {
                var Ctor = info.type === 0 ? WebGL2PrimaryCommandBuffer : WebGL2CommandBuffer;
                var cmdBuff = new Ctor();
                cmdBuff.initialize(info);
                return cmdBuff;
              };
              _proto.createSwapchain = function createSwapchain(info) {
                var swapchain = new WebGL2Swapchain();
                this._swapchain = swapchain;
                swapchain.initialize(info);
                return swapchain;
              };
              _proto.createBuffer = function createBuffer(info) {
                var buffer = new WebGL2Buffer();
                buffer.initialize(info);
                return buffer;
              };
              _proto.createTexture = function createTexture(info) {
                var texture = new WebGL2Texture();
                texture.initialize(info);
                return texture;
              };
              _proto.createDescriptorSet = function createDescriptorSet(info) {
                var descriptorSet = new WebGL2DescriptorSet();
                descriptorSet.initialize(info);
                return descriptorSet;
              };
              _proto.createShader = function createShader(info) {
                var shader = new WebGL2Shader();
                shader.initialize(info);
                return shader;
              };
              _proto.createInputAssembler = function createInputAssembler(info) {
                var inputAssembler = new WebGL2InputAssembler();
                inputAssembler.initialize(info);
                return inputAssembler;
              };
              _proto.createRenderPass = function createRenderPass(info) {
                var renderPass = new WebGL2RenderPass();
                renderPass.initialize(info);
                return renderPass;
              };
              _proto.createFramebuffer = function createFramebuffer(info) {
                var framebuffer = new WebGL2Framebuffer();
                framebuffer.initialize(info);
                return framebuffer;
              };
              _proto.createDescriptorSetLayout = function createDescriptorSetLayout(info) {
                var descriptorSetLayout = new WebGL2DescriptorSetLayout();
                descriptorSetLayout.initialize(info);
                return descriptorSetLayout;
              };
              _proto.createPipelineLayout = function createPipelineLayout(info) {
                var pipelineLayout = new WebGL2PipelineLayout();
                pipelineLayout.initialize(info);
                return pipelineLayout;
              };
              _proto.createPipelineState = function createPipelineState(info) {
                var pipelineState = new WebGL2PipelineState();
                pipelineState.initialize(info);
                return pipelineState;
              };
              _proto.createQueue = function createQueue(info) {
                var queue = new WebGL2Queue();
                queue.initialize(info);
                return queue;
              };
              _proto.getSampler = function getSampler(info) {
                var hash = Sampler.computeHash(info);
                if (!this._samplers.has(hash)) {
                  this._samplers.set(hash, new WebGL2Sampler(info, hash));
                }
                return this._samplers.get(hash);
              };
              _proto.getSwapchains = function getSwapchains() {
                return [this._swapchain];
              };
              _proto.getGeneralBarrier = function getGeneralBarrier(info) {
                var hash = GeneralBarrier.computeHash(info);
                if (!this._generalBarrierss.has(hash)) {
                  this._generalBarrierss.set(hash, new GeneralBarrier(info, hash));
                }
                return this._generalBarrierss.get(hash);
              };
              _proto.getTextureBarrier = function getTextureBarrier(info) {
                var hash = TextureBarrier.computeHash(info);
                if (!this._textureBarriers.has(hash)) {
                  this._textureBarriers.set(hash, new TextureBarrier(info, hash));
                }
                return this._textureBarriers.get(hash);
              };
              _proto.getBufferBarrier = function getBufferBarrier(info) {
                var hash = BufferBarrier.computeHash(info);
                if (!this._bufferBarriers.has(hash)) {
                  this._bufferBarriers.set(hash, new BufferBarrier(info, hash));
                }
                return this._bufferBarriers.get(hash);
              };
              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                WebGL2CmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
              };
              _proto.copyTextureToBuffers = function copyTextureToBuffers(texture, buffers, regions) {
                WebGL2CmdFuncCopyTextureToBuffers(this, texture.gpuTexture, buffers, regions);
              };
              _proto.copyTexImagesToTexture = function copyTexImagesToTexture(texImages, texture, regions) {
                WebGL2CmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
              };
              _createClass(WebGL2Device, [{
                key: "gl",
                get: function get() {
                  return this._context;
                }
              }, {
                key: "extensions",
                get: function get() {
                  return this._swapchain.extensions;
                }
              }, {
                key: "nullTex2D",
                get: function get() {
                  return this._swapchain.nullTex2D;
                }
              }, {
                key: "nullTexCube",
                get: function get() {
                  return this._swapchain.nullTexCube;
                }
              }, {
                key: "textureExclusive",
                get: function get() {
                  return this._textureExclusive;
                }
              }, {
                key: "bindingMappings",
                get: function get() {
                  return this._bindingMappings;
                }
              }, {
                key: "blitManager",
                get: function get() {
                  return this._swapchain.blitManager;
                }
              }]);
              return WebGL2Device;
            }(Device));

            legacyCC.WebGL2Device = WebGL2Device;

            var Counter = function () {
              function Counter(id, opts, now) {
                this._total = 0;
                this._value = 0;
                this._averageValue = 0;
                this._accumValue = 0;
                this._accumSamples = 0;
                this._id = id;
                this._opts = opts;
                this._accumStart = now;
              }
              var _proto = Counter.prototype;
              _proto.sample = function sample(now) {
                this._average(this._value, now);
              };
              _proto.human = function human() {
                var _this$_opts = this._opts,
                  average = _this$_opts.average,
                  isInteger = _this$_opts.isInteger;
                var v = average ? this._averageValue : this._value;
                return isInteger ? Math.round(v) : Math.round(v * 100) / 100;
              };
              _proto.alarm = function alarm() {
                if (this._opts.below !== undefined && this._value < this._opts.below) {
                  return true;
                }
                if (this._opts.over !== undefined && this._value > this._opts.over) {
                  return true;
                }
                return false;
              };
              _proto._average = function _average(v, now) {
                if (now === undefined) {
                  now = 0;
                }
                if (this._opts.average) {
                  this._accumValue += v;
                  ++this._accumSamples;
                  var t = now;
                  if (t - this._accumStart >= this._opts.average) {
                    this._averageValue = this._accumValue / this._accumSamples;
                    this._accumValue = 0;
                    this._accumStart = t;
                    this._accumSamples = 0;
                  }
                }
              };
              _createClass(Counter, [{
                key: "value",
                get: function get() {
                  return this._value;
                },
                set: function set(val) {
                  this._value = val;
                }
              }]);
              return Counter;
            }();

            var _dec$8, _class$8;
            var PerfCounter = (_dec$8 = ccclass$6('cc.PerfCounter'), _dec$8(_class$8 = function (_Counter) {
              _inheritsLoose(PerfCounter, _Counter);
              function PerfCounter(id, opts, now) {
                var _this;
                _this = _Counter.call(this, id, opts, now) || this;
                _this._time = now;
                return _this;
              }
              var _proto = PerfCounter.prototype;
              _proto.start = function start(now) {
                if (now === undefined) {
                  now = 0;
                }
                this._time = now;
              };
              _proto.end = function end(now) {
                if (now === undefined) {
                  now = 0;
                }
                this._value = now - this._time;
                this._average(this._value);
              };
              _proto.tick = function tick() {
                this.end();
                this.start();
              };
              _proto.frame = function frame(now) {
                var t = now;
                var e = t - this._time;
                this._total++;
                var avg = this._opts.average || 1000;
                if (e > avg) {
                  this._value = this._total * 1000 / e;
                  this._total = 0;
                  this._time = t;
                  this._average(this._value);
                }
              };
              return PerfCounter;
            }(Counter)) || _class$8);

            var _characters = '0123456789. ';
            var _average = 500;
            var _string2offset = {
              0: 0,
              1: 1,
              2: 2,
              3: 3,
              4: 4,
              5: 5,
              6: 6,
              7: 7,
              8: 8,
              9: 9,
              '.': 10
            };
            var _profileInfo = {
              fps: {
                desc: "Framerate (FPS)",
                below: 30,
                average: _average,
                isInteger: true
              },
              draws: {
                desc: 'Draw call',
                isInteger: true
              },
              frame: {
                desc: 'Frame time (ms)',
                min: 0,
                max: 50,
                average: _average
              },
              instances: {
                desc: 'Instance Count',
                isInteger: true
              },
              tricount: {
                desc: 'Triangle',
                isInteger: true
              },
              logic: {
                desc: 'Game Logic (ms)',
                min: 0,
                max: 50,
                average: _average,
                color: '#080'
              },
              physics: {
                desc: 'Physics (ms)',
                min: 0,
                max: 50,
                average: _average
              },
              render: {
                desc: 'Renderer (ms)',
                min: 0,
                max: 50,
                average: _average,
                color: '#f90'
              },
              present: {
                desc: 'Present (ms)',
                min: 0,
                max: 50,
                average: _average,
                color: '#f90'
              },
              textureMemory: {
                desc: 'GFX Texture Mem(M)'
              },
              bufferMemory: {
                desc: 'GFX Buffer Mem(M)'
              }
            };
            var _constants = {
              fontSize: 23,
              quadHeight: 0.4,
              segmentsPerLine: 8,
              textureWidth: 280,
              textureHeight: 280
            };
            var Profiler = exports("Profiler", function (_System) {
              _inheritsLoose(Profiler, _System);
              function Profiler() {
                var _this;
                _this = _System.call(this) || this;
                _this._profilerStats = null;
                _this._showFPS = false;
                _this._rootNode = null;
                _this._device = null;
                _this._swapchain = null;
                _this._meshRenderer = null;
                _this._canvas = null;
                _this._ctx = null;
                _this._texture = null;
                _this._region = new BufferTextureCopy();
                _this._canvasArr = [];
                _this._regionArr = [_this._region];
                _this.digitsData = null;
                _this.offsetData = null;
                _this.pass = null;
                _this._canvasDone = false;
                _this._statsDone = false;
                _this._inited = false;
                _this._lineHeight = _constants.textureHeight / (Object.keys(_profileInfo).length + 1);
                _this._wordHeight = 0;
                _this._eachNumWidth = 0;
                _this._totalLines = 0;
                _this.lastTime = 0;
                _this._backgroundColor = new Color(150, 150, 150, 100);
                _this._fontColor = Color.WHITE.clone();
                return _this;
              }
              var _proto = Profiler.prototype;
              _proto.init = function init() {
                var showFPS = !!settings.querySettings("profiling", 'showFPS');
                if (showFPS) {
                  this.showStats();
                } else {
                  this.hideStats();
                }
              };
              _proto.setBackgroundColor = function setBackgroundColor(color) {
                if (this._backgroundColor.equals(color)) {
                  return;
                }
                this._backgroundColor.set(color);
                if (this._showFPS) {
                  this.hideStats();
                  this.showStats();
                }
              };
              _proto.setFontColor = function setFontColor(color) {
                if (this._fontColor.equals(color)) {
                  return;
                }
                this._fontColor.set(color);
                if (this._showFPS) {
                  this.hideStats();
                  this.showStats();
                }
              };
              _proto.isShowingStats = function isShowingStats() {
                return this._showFPS;
              };
              _proto.hideStats = function hideStats() {
                var self = this;
                if (self._showFPS) {
                  self._profilerStats = null;
                  if (self._rootNode) {
                    self._rootNode.destroy();
                    self._rootNode = null;
                  }
                  self._device = null;
                  self._swapchain = null;
                  var meshRenderer = self._meshRenderer;
                  if (meshRenderer) {
                    var _meshRenderer$sharedM, _meshRenderer$mesh;
                    (_meshRenderer$sharedM = meshRenderer.sharedMaterial) == null ? undefined : _meshRenderer$sharedM.destroy();
                    (_meshRenderer$mesh = meshRenderer.mesh) == null ? undefined : _meshRenderer$mesh.destroy();
                    meshRenderer.destroy();
                    self._meshRenderer = null;
                  }
                  self._canvas = null;
                  self._ctx = null;
                  if (self._texture) {
                    self._texture.destroy();
                    self._texture = null;
                  }
                  self._canvasArr.length = 0;
                  self.digitsData = null;
                  self.offsetData = null;
                  self.pass = null;
                  self._canvasDone = false;
                  self._statsDone = false;
                  self._inited = false;
                  self._wordHeight = 0;
                  self._eachNumWidth = 0;
                  self._totalLines = 0;
                  self.lastTime = 0;
                  director.off("director_before_update", self.beforeUpdate, self);
                  director.off("director_after_update", self.afterUpdate, self);
                  director.off("director_before_physics", self.beforePhysics, self);
                  director.off("director_after_physics", self.afterPhysics, self);
                  director.off("director_before_draw", self.beforeDraw, self);
                  director.off("director_after_render", self.afterRender, self);
                  director.off("director_after_draw", self.afterPresent, self);
                  self._showFPS = false;
                  director.root.pipeline.profiler = null;
                  cclegacy.game.config.showFPS = false;
                }
              };
              _proto.showStats = function showStats() {
                var game = cclegacy.game;
                if (!this._showFPS) {
                  this._canvas = ccwindow.document.createElement('canvas');
                  this._ctx = this._canvas.getContext('2d');
                  this._canvasArr.push(this._canvas);
                  if (!this._device) {
                    var root = cclegacy.director.root;
                    this._device = deviceManager.gfxDevice;
                    this._swapchain = root.mainWindow.swapchain;
                  }
                  this.generateCanvas();
                  this.generateStats();
                  game.once(Game.EVENT_ENGINE_INITED, this.generateNode, this);
                  game.on(Game.EVENT_RESTART, this.generateNode, this);
                  if (this._rootNode) {
                    this._rootNode.active = true;
                  }
                  director.on("director_before_update", this.beforeUpdate, this);
                  director.on("director_after_update", this.afterUpdate, this);
                  director.on("director_before_physics", this.beforePhysics, this);
                  director.on("director_after_physics", this.afterPhysics, this);
                  director.on("director_before_draw", this.beforeDraw, this);
                  director.on("director_after_render", this.afterRender, this);
                  director.on("director_after_draw", this.afterPresent, this);
                  this._showFPS = true;
                  this._canvasDone = true;
                  this._statsDone = true;
                  game.config.showFPS = true;
                }
              };
              _proto.generateCanvas = function generateCanvas() {
                if (this._canvasDone) {
                  return;
                }
                var textureWidth = _constants.textureWidth,
                  textureHeight = _constants.textureHeight;
                var canvas = this._canvas;
                var ctx = this._ctx;
                if (!ctx || !canvas) {
                  return;
                }
                canvas.width = textureWidth;
                canvas.height = textureHeight;
                canvas.style.width = "" + canvas.width;
                canvas.style.height = "" + canvas.height;
                ctx.font = _constants.fontSize + "px Arial";
                ctx.textBaseline = 'top';
                var fontColor = this._fontColor;
                ctx.fillStyle = "rgba(" + fontColor.r + ", " + fontColor.g + ", " + fontColor.b + ", " + fontColor.a / 255 + ")";
                this._texture = this._device.createTexture(new TextureInfo(1, 4 | 2, 35, textureWidth, textureHeight));
                var texExtent = this._region.texExtent;
                texExtent.width = textureWidth;
                texExtent.height = textureHeight;
              };
              _proto.generateStats = function generateStats() {
                var canvas = this._canvas;
                var ctx = this._ctx;
                if (this._statsDone || !ctx || !canvas) {
                  return;
                }
                this._profilerStats = null;
                var now = performance.now();
                ctx.textAlign = 'left';
                var i = 0;
                for (var id in _profileInfo) {
                  var element = _profileInfo[id];
                  ctx.fillText(element.desc, 0, i * this._lineHeight);
                  element.counter = new PerfCounter(id, element, now);
                  i++;
                }
                this._totalLines = i;
                this._wordHeight = this._totalLines * this._lineHeight / canvas.height;
                var j = 0;
                for (j = 0; j < _characters.length; ++j) {
                  var offset = ctx.measureText(_characters[j]).width;
                  this._eachNumWidth = Math.max(this._eachNumWidth, offset);
                }
                for (j = 0; j < _characters.length; ++j) {
                  ctx.fillText(_characters[j], j * this._eachNumWidth, this._totalLines * this._lineHeight);
                }
                var bgColor = this._backgroundColor;
                ctx.fillStyle = "rgba(" + bgColor.r + ", " + bgColor.g + ", " + bgColor.b + ", " + bgColor.a / 255 + ")";
                ctx.fillRect(canvas.width - 4, canvas.height - 4, 4, 4);
                this._eachNumWidth /= canvas.width;
                this._profilerStats = _profileInfo;
                this._canvasArr[0] = canvas;
                this._device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
              };
              _proto.generateNode = function generateNode() {
                if (this._rootNode && this._rootNode.isValid) {
                  return;
                }
                var canvas = this._canvas;
                this._rootNode = new Node$1('PROFILER_NODE');
                this._rootNode._objFlags = 8 | 1024;
                game.addPersistRootNode(this._rootNode);
                var managerNode = new Node$1('Profiler_Root');
                managerNode.parent = this._rootNode;
                var height = _constants.quadHeight;
                var rowHeight = height / this._totalLines;
                var lWidth = height / this._wordHeight;
                var scale = rowHeight / _constants.fontSize;
                var columnWidth = this._eachNumWidth * canvas.width * scale;
                var bgRight = lWidth + _constants.segmentsPerLine * columnWidth;
                var bgPadding = columnWidth;
                var vertexPos = [-bgPadding, height + bgPadding, 0, bgRight + bgPadding, height + bgPadding, 0, bgRight + bgPadding, -bgPadding, 0, -bgPadding, -bgPadding, 0];
                var vertexindices = [0, 2, 1, 0, 3, 2];
                var bgUvOriginX = (canvas.width - 3) / canvas.width;
                var bgUvOriginY = (canvas.height - 3) / canvas.height;
                var bgUvRight = (canvas.width - 1) / canvas.width;
                var bgUvTop = (canvas.height - 1) / canvas.width;
                var vertexUV = [bgUvOriginX, bgUvOriginY, -1, 0, bgUvRight, bgUvOriginY, -1, 0, bgUvRight, bgUvTop, -1, 0, bgUvOriginX, bgUvTop, -1, 0];
                vertexPos.push(0, height, 0, lWidth, height, 0, lWidth, 0, 0, 0, 0, 0);
                vertexindices.push(4, 6, 5, 4, 7, 6);
                vertexUV.push(0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0);
                var offset = 0;
                for (var i = 0; i < this._totalLines; i++) {
                  for (var j = 0; j < _constants.segmentsPerLine; j++) {
                    vertexPos.push(lWidth + j * columnWidth, height - i * rowHeight, 0);
                    vertexPos.push(lWidth + (j + 1) * columnWidth, height - i * rowHeight, 0);
                    vertexPos.push(lWidth + (j + 1) * columnWidth, height - (i + 1) * rowHeight, 0);
                    vertexPos.push(lWidth + j * columnWidth, height - (i + 1) * rowHeight, 0);
                    offset = (i * _constants.segmentsPerLine + j + 2) * 4;
                    vertexindices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);
                    var idx = i * _constants.segmentsPerLine + j;
                    var z = Math.floor(idx / 4);
                    var w = idx - z * 4;
                    vertexUV.push(0, this._wordHeight, z, w);
                    vertexUV.push(this._eachNumWidth, this._wordHeight, z, w);
                    vertexUV.push(this._eachNumWidth, 1, z, w);
                    vertexUV.push(0, 1, z, w);
                  }
                }
                this._meshRenderer = managerNode.addComponent(MeshRenderer);
                this._meshRenderer.mesh = _createMesh({
                  positions: vertexPos,
                  indices: vertexindices,
                  colors: vertexUV
                });
                var _material = new Material();
                _material.initialize({
                  effectName: 'util/profiler'
                });
                var pass = this.pass = _material.passes[0];
                var hTexture = pass.getBinding('mainTexture');
                var bDigits = pass.getBinding('digits');
                var bOffset = pass.getBinding('offset');
                pass.bindTexture(hTexture, this._texture);
                this.digitsData = pass.blocks[bDigits];
                this.offsetData = pass.blocks[bOffset];
                this.offsetData[3] = -1;
                this._meshRenderer.material = _material;
                this._meshRenderer.node.layer = Layers.Enum.PROFILER;
                this._inited = true;
              };
              _proto.beforeUpdate = function beforeUpdate() {
                var profilerStats = this._profilerStats;
                if (!profilerStats) {
                  return;
                }
                var now = performance.now();
                profilerStats.frame.counter.start(now);
                profilerStats.logic.counter.start(now);
              };
              _proto.afterUpdate = function afterUpdate() {
                var profilerStats = this._profilerStats;
                if (!profilerStats) {
                  return;
                }
                var now = performance.now();
                if (director.isPaused()) {
                  profilerStats.frame.counter.start(now);
                } else {
                  profilerStats.logic.counter.end(now);
                }
              };
              _proto.beforePhysics = function beforePhysics() {
                if (!this._profilerStats) {
                  return;
                }
                var now = performance.now();
                this._profilerStats.physics.counter.start(now);
              };
              _proto.afterPhysics = function afterPhysics() {
                if (!this._profilerStats) {
                  return;
                }
                var now = performance.now();
                this._profilerStats.physics.counter.end(now);
              };
              _proto.beforeDraw = function beforeDraw() {
                if (!this._profilerStats || !this._inited) {
                  return;
                }
                var surfaceTransform = this._swapchain.surfaceTransform;
                var clipSpaceSignY = this._device.capabilities.clipSpaceSignY;
                if (surfaceTransform !== this.offsetData[3]) {
                  var preTransform = preTransforms[surfaceTransform];
                  var x = -0.9;
                  var y = -0.9 * clipSpaceSignY;
                  this.offsetData[0] = x * preTransform[0] + y * preTransform[2];
                  this.offsetData[1] = x * preTransform[1] + y * preTransform[3];
                  this.offsetData[2] = this._eachNumWidth;
                  this.offsetData[3] = surfaceTransform;
                }
                this.pass.setRootBufferDirty(true);
                if (this._meshRenderer.model) {
                  director.root.pipeline.profiler = this._meshRenderer.model;
                } else {
                  director.root.pipeline.profiler = null;
                }
                var now = performance.now();
                this._profilerStats.render.counter.start(now);
              };
              _proto.afterRender = function afterRender() {
                var profilerStats = this._profilerStats;
                if (!profilerStats || !this._inited) {
                  return;
                }
                var now = performance.now();
                profilerStats.render.counter.end(now);
                profilerStats.present.counter.start(now);
              };
              _proto.afterPresent = function afterPresent() {
                var profilerStats = this._profilerStats;
                if (!profilerStats || !this._inited) {
                  return;
                }
                var now = performance.now();
                profilerStats.frame.counter.end(now);
                profilerStats.fps.counter.frame(now);
                profilerStats.present.counter.end(now);
                if (now - this.lastTime < _average) {
                  return;
                }
                this.lastTime = now;
                var device = this._device;
                profilerStats.draws.counter.value = device.numDrawCalls;
                profilerStats.instances.counter.value = device.numInstances;
                profilerStats.bufferMemory.counter.value = device.memoryStatus.bufferSize / (1024 * 1024);
                profilerStats.textureMemory.counter.value = device.memoryStatus.textureSize / (1024 * 1024);
                profilerStats.tricount.counter.value = device.numTris;
                var i = 0;
                var view = this.digitsData;
                var segmentsPerLine = _constants.segmentsPerLine;
                for (var id in profilerStats) {
                  var stat = profilerStats[id];
                  stat.counter.sample(now);
                  var result = stat.counter.human().toString();
                  for (var j = segmentsPerLine - 1; j >= 0; j--) {
                    var index = i * segmentsPerLine + j;
                    var character = result[result.length - (segmentsPerLine - j)];
                    var offset = _string2offset[character];
                    if (offset === undefined) {
                      offset = 11;
                    }
                    view[index] = offset;
                  }
                  i++;
                }
              };
              _createClass(Profiler, [{
                key: "_stats",
                get: function get() {
                  warnID(16381);
                  return this._profilerStats;
                }
              }, {
                key: "stats",
                get: function get() {
                  return this._profilerStats;
                }
              }]);
              return Profiler;
            }(System));
            var profiler = exports("profiler", new Profiler());
            director.registerSystem('profiler', profiler, 0);
            cclegacy.profiler = profiler;

            var _v3_tmp_1 = new Vec3();
            var _v3_tmp_2 = new Vec3();
            function createSplineProperty(mode, knots) {
              var spline = null;
              return {
                value: knots.length > 0 ? knots[knots.length - 1] : Vec3.ZERO,
                progress: function progress(start, end, current, ratio) {
                  return spline.getPoint(ratio);
                },
                clone: function clone(v) {
                  return Vec3.clone(v);
                },
                add: function add(a, b) {
                  return a.clone().add(b);
                },
                sub: function sub(a, b) {
                  return a.clone().subtract(b);
                },
                onStart: function onStart(param) {
                  var start = param.start,
                    end = param.end,
                    relative = param.relative,
                    reversed = param.reversed;
                  spline = Spline.create(mode);
                  spline.addKnot(start);
                  var reversedLast = null;
                  if (relative && reversed) {
                    reversedLast = _v3_tmp_2;
                    Vec3.subtract(reversedLast, start, knots[knots.length - 1]);
                  }
                  for (var i = 0, len = knots.length; i < len; ++i) {
                    var v = reversed ? knots[len - 1 - i] : knots[i];
                    if (relative) {
                      if (reversed) {
                        if (i > 0) {
                          spline.addKnot(Vec3.copy(_v3_tmp_1, reversedLast).add(v));
                        }
                      } else {
                        spline.addKnot(Vec3.copy(_v3_tmp_1, start).add(v));
                      }
                    } else {
                      spline.addKnot(v);
                    }
                  }
                  if (relative && reversed) {
                    spline.addKnot(end);
                  }
                },
                onComplete: function onComplete() {
                  spline = null;
                },
                onStop: function onStop() {
                  spline = null;
                },
                legacyProgress: false
              };
            }
            function bezier() {
              for (var _len = arguments.length, knots = new Array(_len), _key = 0; _key < _len; _key++) {
                knots[_key] = arguments[_key];
              }
              return createSplineProperty(1, knots);
            }
            function catmullRom() {
              for (var _len2 = arguments.length, knots = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                knots[_key2] = arguments[_key2];
              }
              return createSplineProperty(2, knots);
            }

            var tweenProgress = /*#__PURE__*/Object.freeze({
                __proto__: null,
                bezier: bezier,
                catmullRom: catmullRom
            });
            exports("tweenProgress", tweenProgress);

            var HashElement = function HashElement() {
              this.actions = [];
              this.target = null;
              this.actionIndex = 0;
              this.currentAction = null;
              this.paused = false;
              this.lock = false;
            };
            var ActionManager = function () {
              function ActionManager() {
                this._hashTargets = new Map();
                this._arrayTargets = [];
                this._currentTarget = undefined;
                this._elementPool = [];
              }
              var _proto = ActionManager.prototype;
              _proto._getElement = function _getElement(target, paused) {
                var element = this._elementPool.pop();
                if (!element) {
                  element = new HashElement();
                }
                element.target = target;
                element.paused = !!paused;
                return element;
              };
              _proto._putElement = function _putElement(element) {
                element.actions.length = 0;
                element.actionIndex = 0;
                element.currentAction = null;
                element.paused = false;
                element.target = null;
                element.lock = false;
                this._elementPool.push(element);
              };
              _proto._onNodeActiveChanged = function _onNodeActiveChanged(target, active) {
                if (active) {
                  this.resumeTarget(target);
                } else {
                  this.pauseTarget(target);
                }
              };
              _proto._onNodeDestroy = function _onNodeDestroy(target) {
                this._removeAllActionsFromTarget(target, false);
              };
              _proto._registerNodeEvent = function _registerNodeEvent(target) {
                if (target.isValid) {
                  target.on("active-changed", this._onNodeActiveChanged, this);
                  target.on("node-destroyed", this._onNodeDestroy, this);
                }
              };
              _proto._unregisterNodeEvent = function _unregisterNodeEvent(target) {
                if (target.isValid) {
                  target.off("active-changed", this._onNodeActiveChanged, this);
                  target.off("node-destroyed", this._onNodeDestroy, this);
                }
              };
              _proto.addAction = function addAction(action, target, paused, isBindNodeState) {
                if (isBindNodeState === undefined) {
                  isBindNodeState = true;
                }
                if (!action || !target) {
                  errorID(1000);
                  return;
                }
                var element = this._hashTargets.get(target);
                if (!element) {
                  element = this._getElement(target, paused);
                  this._hashTargets.set(target, element);
                  this._arrayTargets.push(element);
                } else if (!element.actions) {
                  element.actions = [];
                }
                var registerNodeEvent = isBindNodeState && element.actions.length === 0 && target instanceof Node$1;
                if (registerNodeEvent) {
                  this._registerNodeEvent(target);
                  if (!target.active) {
                    element.paused = true;
                  }
                }
                element.target = target;
                element.actions.push(action);
                action.startWithTarget(target);
              };
              _proto.removeAllActions = function removeAllActions() {
                var locTargets = this._arrayTargets;
                for (var i = 0; i < locTargets.length; i++) {
                  var element = locTargets[i];
                  if (element) {
                    if (element.target instanceof Node$1) {
                      this._unregisterNodeEvent(element.target);
                    }
                    this._putElement(element);
                  }
                }
                this._arrayTargets.length = 0;
                this._hashTargets = new Map();
              };
              _proto.removeAllActionsFromTarget = function removeAllActionsFromTarget(target) {
                this._removeAllActionsFromTarget(target, true);
              };
              _proto._removeAllActionsFromTarget = function _removeAllActionsFromTarget(target, offNodeEvent) {
                if (target == null) return;
                var element = this._hashTargets.get(target);
                if (element) {
                  if (offNodeEvent && target instanceof Node$1) {
                    this._unregisterNodeEvent(target);
                  }
                  element.actions.length = 0;
                  this._deleteHashElement(element);
                }
              };
              _proto.removeAction = function removeAction(action) {
                if (action == null) return;
                var target = action.getOriginalTarget();
                var element = this._hashTargets.get(target);
                if (element) {
                  for (var i = 0; i < element.actions.length; i++) {
                    if (element.actions[i] === action) {
                      element.actions.splice(i, 1);
                      if (element.actionIndex >= i) element.actionIndex--;
                      break;
                    }
                  }
                }
              };
              _proto._removeActionByTag = function _removeActionByTag(tag, element, target) {
                for (var i = 0, l = element.actions.length; i < l; ++i) {
                  var action = element.actions[i];
                  if (action && action.getTag() === tag) {
                    if (target && action.getOriginalTarget() !== target) {
                      continue;
                    }
                    this._removeActionAtIndex(i, element);
                    break;
                  }
                }
              };
              _proto._removeAllActionsByTag = function _removeAllActionsByTag(tag, element, target) {
                for (var i = element.actions.length - 1; i >= 0; --i) {
                  var action = element.actions[i];
                  if (action && action.getTag() === tag) {
                    if (target && action.getOriginalTarget() !== target) {
                      continue;
                    }
                    this._removeActionAtIndex(i, element);
                  }
                }
              };
              _proto.removeActionByTag = function removeActionByTag(tag, target) {
                var _this = this;
                if (tag === -1) logID(1002);
                var hashTargets = this._hashTargets;
                if (target) {
                  var element = hashTargets.get(target);
                  if (element) {
                    this._removeActionByTag(tag, element, target);
                  }
                } else {
                  hashTargets.forEach(function (element) {
                    _this._removeActionByTag(tag, element);
                  });
                }
              };
              _proto.removeAllActionsByTag = function removeAllActionsByTag(tag, target) {
                var _this2 = this;
                if (tag === -1) logID(1002);
                var hashTargets = this._hashTargets;
                if (target) {
                  var element = hashTargets.get(target);
                  if (element) {
                    this._removeAllActionsByTag(tag, element, target);
                  }
                } else {
                  hashTargets.forEach(function (element) {
                    _this2._removeAllActionsByTag(tag, element);
                  });
                }
              };
              _proto.getActionByTag = function getActionByTag(tag, target) {
                if (tag === -1) logID(1004);
                var element = this._hashTargets.get(target);
                if (element) {
                  if (element.actions != null) {
                    for (var i = 0; i < element.actions.length; ++i) {
                      var action = element.actions[i];
                      if (action && action.getTag() === tag) {
                        return action;
                      }
                    }
                  }
                  logID(1005, tag);
                }
                return null;
              };
              _proto.getNumberOfRunningActionsInTarget = function getNumberOfRunningActionsInTarget(target) {
                var element = this._hashTargets.get(target);
                if (element) {
                  return element.actions ? element.actions.length : 0;
                }
                return 0;
              };
              _proto.pauseTarget = function pauseTarget(target) {
                var element = this._hashTargets.get(target);
                if (element) element.paused = true;
              };
              _proto.resumeTarget = function resumeTarget(target) {
                var element = this._hashTargets.get(target);
                if (element) element.paused = false;
              };
              _proto.pauseAllRunningActions = function pauseAllRunningActions() {
                var idsWithActions = [];
                var locTargets = this._arrayTargets;
                for (var i = 0; i < locTargets.length; i++) {
                  var element = locTargets[i];
                  if (element && !element.paused) {
                    element.paused = true;
                    if (element.target) {
                      idsWithActions.push(element.target);
                    }
                  }
                }
                return idsWithActions;
              };
              _proto.resumeTargets = function resumeTargets(targetsToResume) {
                if (!targetsToResume) return;
                for (var i = 0; i < targetsToResume.length; i++) {
                  if (targetsToResume[i]) this.resumeTarget(targetsToResume[i]);
                }
              };
              _proto.pauseTargets = function pauseTargets(targetsToPause) {
                if (!targetsToPause) return;
                for (var i = 0; i < targetsToPause.length; i++) {
                  if (targetsToPause[i]) this.pauseTarget(targetsToPause[i]);
                }
              };
              _proto.isActionRunning = function isActionRunning(action) {
                var elements = this._hashTargets.get(action.getOriginalTarget());
                var index = -1;
                if (elements) index = elements.actions.indexOf(action);
                return index !== -1;
              };
              _proto._removeActionAtIndex = function _removeActionAtIndex(index, element) {
                element.actions.splice(index, 1);
                if (element.actionIndex >= index) element.actionIndex--;
                if (element.actions.length === 0) {
                  if (element.target instanceof Node$1) {
                    this._unregisterNodeEvent(element.target);
                  }
                  this._deleteHashElement(element);
                }
              };
              _proto._deleteHashElement = function _deleteHashElement(element) {
                var ret = false;
                if (element && !element.lock) {
                  if (this._hashTargets.get(element.target)) {
                    this._hashTargets["delete"](element.target);
                    var targets = this._arrayTargets;
                    for (var i = 0, l = targets.length; i < l; i++) {
                      if (targets[i] === element) {
                        targets.splice(i, 1);
                        break;
                      }
                    }
                    this._putElement(element);
                    ret = true;
                  }
                }
                return ret;
              };
              _proto.update = function update(dt) {
                var locTargets = this._arrayTargets;
                var locCurrTarget;
                for (var elt = 0; elt < locTargets.length; elt++) {
                  this._currentTarget = locTargets[elt];
                  locCurrTarget = this._currentTarget;
                  var target = locCurrTarget.target;
                  if (isCCObject(target) && !target.isValid) {
                    this.removeAllActionsFromTarget(target);
                    elt--;
                    continue;
                  }
                  if (!locCurrTarget.paused && locCurrTarget.actions) {
                    locCurrTarget.lock = true;
                    for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
                      locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                      if (!locCurrTarget.currentAction) continue;
                      locCurrTarget.currentAction.step(dt);
                      if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                        locCurrTarget.currentAction.stop();
                        var action = locCurrTarget.currentAction;
                        locCurrTarget.currentAction = null;
                        this.removeAction(action);
                      }
                      locCurrTarget.currentAction = null;
                    }
                    locCurrTarget.lock = false;
                  }
                  if (locCurrTarget.actions.length === 0) {
                    if (target instanceof Node$1) {
                      this._unregisterNodeEvent(target);
                    }
                    if (this._deleteHashElement(locCurrTarget)) {
                      elt--;
                    }
                  }
                }
              };
              return ActionManager;
            }();

            var TweenSystem = exports("TweenSystem", function (_System) {
              _inheritsLoose(TweenSystem, _System);
              function TweenSystem() {
                var _this;
                _this = _System.call(this) || this;
                _this.actionMgr = new ActionManager();
                return _this;
              }
              var _proto = TweenSystem.prototype;
              _proto.update = function update(dt) {
                {
                  this.actionMgr.update(dt);
                }
              };
              _createClass(TweenSystem, [{
                key: "ActionManager",
                get: function get() {
                  return this.actionMgr;
                }
              }]);
              return TweenSystem;
            }(System));
            TweenSystem.ID = 'TWEEN';
            TweenSystem.instance = undefined;
            director.on("director_init", function () {
              var sys = new TweenSystem();
              TweenSystem.instance = sys;
              director.registerSystem(TweenSystem.ID, sys, 100);
            });

            var Action = function () {
              function Action() {
                this.originalTarget = null;
                this.target = null;
                this._owner = null;
                this.tag = -1;
                this._id = undefined;
                this._paused = false;
              }
              var _proto = Action.prototype;
              _proto.isDone = function isDone() {
                return true;
              };
              _proto.startWithTarget = function startWithTarget(target) {
                this.originalTarget = target;
                this.target = target;
              };
              _proto.stop = function stop() {
                this.target = null;
              };
              _proto.getTarget = function getTarget() {
                return this.target;
              };
              _proto.setTarget = function setTarget(target) {
                this.target = target;
              };
              _proto.getOriginalTarget = function getOriginalTarget() {
                return this.originalTarget;
              };
              _proto.setOriginalTarget = function setOriginalTarget(originalTarget) {
                this.originalTarget = originalTarget;
              };
              _proto._getWorkerTarget = function _getWorkerTarget() {
                var _this$_owner;
                var workerTarget = (_this$_owner = this._owner) == null ? undefined : _this$_owner.getTarget();
                return workerTarget !== null && workerTarget !== undefined ? workerTarget : this.target;
              };
              _proto.getTag = function getTag() {
                return this.tag;
              };
              _proto.setTag = function setTag(tag) {
                this.tag = tag;
              };
              _proto.setId = function setId(id) {
                this._id = id;
              };
              _proto.getId = function getId() {
                return this._id;
              };
              _proto.setPaused = function setPaused(paused) {
                this._paused = paused;
              };
              return Action;
            }();
            var FiniteTimeAction = function (_Action) {
              _inheritsLoose(FiniteTimeAction, _Action);
              function FiniteTimeAction() {
                var _this;
                _this = _Action.call(this) || this;
                _this._duration = 0;
                return _this;
              }
              var _proto2 = FiniteTimeAction.prototype;
              _proto2.getDurationScaled = function getDurationScaled() {
                return this._duration;
              };
              _proto2.getDuration = function getDuration() {
                return this._duration;
              };
              _proto2.setDuration = function setDuration(duration) {
                this._duration = duration;
              };
              return FiniteTimeAction;
            }(Action);

            var ActionInstant = function (_FiniteTimeAction) {
              _inheritsLoose(ActionInstant, _FiniteTimeAction);
              function ActionInstant() {
                return _FiniteTimeAction.apply(this, arguments) || this;
              }
              var _proto = ActionInstant.prototype;
              _proto.isDone = function isDone() {
                return true;
              };
              _proto.step = function step(_dt) {
                this.update(1);
              };
              _proto.update = function update(_dt) {};
              _proto.reverse = function reverse() {
                return this.clone();
              };
              _proto.isUnknownDuration = function isUnknownDuration() {
                return false;
              };
              return ActionInstant;
            }(FiniteTimeAction);
            var Show = function (_ActionInstant) {
              _inheritsLoose(Show, _ActionInstant);
              function Show() {
                return _ActionInstant.apply(this, arguments) || this;
              }
              var _proto2 = Show.prototype;
              _proto2.update = function update(_dt) {
                var target = this._getWorkerTarget();
                if (!target) return;
                var _renderComps = target.getComponentsInChildren(Renderer);
                for (var i = 0; i < _renderComps.length; ++i) {
                  var render = _renderComps[i];
                  render.enabled = true;
                }
              };
              _proto2.reverse = function reverse() {
                return new Hide();
              };
              _proto2.clone = function clone() {
                var action = new Show();
                action._id = this._id;
                return action;
              };
              _proto2.toString = function toString() {
                return '<Show>';
              };
              return Show;
            }(ActionInstant);
            function show() {
              return new Show();
            }
            var Hide = function (_ActionInstant2) {
              _inheritsLoose(Hide, _ActionInstant2);
              function Hide() {
                return _ActionInstant2.apply(this, arguments) || this;
              }
              var _proto3 = Hide.prototype;
              _proto3.update = function update(_dt) {
                var target = this._getWorkerTarget();
                if (!target) return;
                var _renderComps = target.getComponentsInChildren(Renderer);
                for (var i = 0; i < _renderComps.length; ++i) {
                  var render = _renderComps[i];
                  render.enabled = false;
                }
              };
              _proto3.reverse = function reverse() {
                return new Show();
              };
              _proto3.clone = function clone() {
                var action = new Hide();
                action._id = this._id;
                return action;
              };
              _proto3.toString = function toString() {
                return '<Hide>';
              };
              return Hide;
            }(ActionInstant);
            function hide() {
              return new Hide();
            }
            (function (_ActionInstant3) {
              _inheritsLoose(ToggleVisibility, _ActionInstant3);
              function ToggleVisibility() {
                return _ActionInstant3.apply(this, arguments) || this;
              }
              var _proto4 = ToggleVisibility.prototype;
              _proto4.update = function update(_dt) {
                var target = this._getWorkerTarget();
                if (!target) return;
                var _renderComps = target.getComponentsInChildren(Renderer);
                for (var i = 0; i < _renderComps.length; ++i) {
                  var render = _renderComps[i];
                  render.enabled = !render.enabled;
                }
              };
              _proto4.reverse = function reverse() {
                return new ToggleVisibility();
              };
              _proto4.clone = function clone() {
                var action = new ToggleVisibility();
                action._id = this._id;
                return action;
              };
              _proto4.toString = function toString() {
                return '<ToggleVisibility>';
              };
              return ToggleVisibility;
            })(ActionInstant);
            var RemoveSelf = function (_ActionInstant4) {
              _inheritsLoose(RemoveSelf, _ActionInstant4);
              function RemoveSelf(isNeedCleanUp) {
                var _this;
                _this = _ActionInstant4.call(this) || this;
                _this._isNeedCleanUp = true;
                if (isNeedCleanUp !== undefined) _this.init(isNeedCleanUp);
                return _this;
              }
              var _proto5 = RemoveSelf.prototype;
              _proto5.update = function update(_dt) {
                var target = this._getWorkerTarget();
                if (!target) return;
                target.removeFromParent();
                if (this._isNeedCleanUp) {
                  target.destroy();
                }
              };
              _proto5.init = function init(isNeedCleanUp) {
                this._isNeedCleanUp = isNeedCleanUp;
                return true;
              };
              _proto5.reverse = function reverse() {
                return new RemoveSelf(this._isNeedCleanUp);
              };
              _proto5.clone = function clone() {
                var action = new RemoveSelf(this._isNeedCleanUp);
                action._id = this._id;
                return action;
              };
              _proto5.toString = function toString() {
                return '<RemoveSelf>';
              };
              return RemoveSelf;
            }(ActionInstant);
            function removeSelf(isNeedCleanUp) {
              return new RemoveSelf(isNeedCleanUp);
            }
            var CallFunc = function (_ActionInstant5) {
              _inheritsLoose(CallFunc, _ActionInstant5);
              function CallFunc(selector, callbackThis, data) {
                var _this2;
                _this2 = _ActionInstant5.call(this) || this;
                _this2._callbackThis = undefined;
                _this2._callback = undefined;
                _this2._data = undefined;
                _this2.initWithFunction(selector, callbackThis, data);
                return _this2;
              }
              var _proto6 = CallFunc.prototype;
              _proto6.initWithFunction = function initWithFunction(callback, callbackThis, data) {
                if (callback) {
                  this._callback = callback;
                }
                if (callbackThis) {
                  this._callbackThis = callbackThis;
                }
                if (data !== undefined) {
                  this._data = data;
                }
                return true;
              };
              _proto6.execute = function execute() {
                if (this._callback) {
                  var _target = this._getWorkerTarget();
                  this._callback.call(this._callbackThis, _target, this._data);
                }
              };
              _proto6.update = function update(_dt) {
                this.execute();
              };
              _proto6.getTargetCallback = function getTargetCallback() {
                return this._callbackThis;
              };
              _proto6.setTargetCallback = function setTargetCallback(sel) {
                if (sel !== this._callbackThis) {
                  this._callbackThis = sel;
                }
              };
              _proto6.clone = function clone() {
                var action = new CallFunc();
                action._id = this._id;
                if (this._callback) action.initWithFunction(this._callback, this._callbackThis, this._data);
                return action;
              };
              _proto6.toString = function toString() {
                return "<CallFunc>";
              };
              return CallFunc;
            }(ActionInstant);
            function callFunc(selector, selectorTarget, data) {
              return new CallFunc(selector, selectorTarget, data);
            }

            var DummyAction = function (_FiniteTimeAction) {
              _inheritsLoose(DummyAction, _FiniteTimeAction);
              function DummyAction() {
                return _FiniteTimeAction.apply(this, arguments) || this;
              }
              var _proto = DummyAction.prototype;
              _proto.clone = function clone() {
                return new DummyAction();
              };
              _proto.reverse = function reverse() {
                return this.clone();
              };
              _proto.update = function update(time) {};
              _proto.step = function step(dt) {};
              _proto.isUnknownDuration = function isUnknownDuration() {
                return false;
              };
              _proto.toString = function toString() {
                return "DummyAction";
              };
              return DummyAction;
            }(FiniteTimeAction);
            var ActionInterval = function (_FiniteTimeAction2) {
              _inheritsLoose(ActionInterval, _FiniteTimeAction2);
              function ActionInterval(d) {
                var _this;
                _this = _FiniteTimeAction2.call(this) || this;
                _this.MAX_VALUE = 2;
                _this._elapsed = 0;
                _this._startTime = 0;
                _this._firstTick = false;
                _this._speed = 1;
                if (d !== undefined && !Number.isNaN(d)) {
                  _this.initWithDuration(d);
                }
                return _this;
              }
              var _proto2 = ActionInterval.prototype;
              _proto2.setStartTime = function setStartTime(time) {
                time = time < 0 ? 0 : time > this._duration ? this._duration : time;
                this._startTime = time;
              };
              _proto2.getElapsed = function getElapsed() {
                return this._elapsed;
              };
              _proto2.initWithDuration = function initWithDuration(d) {
                this._duration = d === 0 ? macro.FLT_EPSILON : d;
                this._elapsed = 0;
                this._firstTick = true;
                return true;
              };
              _proto2.isDone = function isDone() {
                return this._elapsed >= this._duration && !this.isUnknownDuration();
              };
              _proto2._cloneDecoration = function _cloneDecoration(action) {
                action._speed = this._speed;
              };
              _proto2.step = function step(dt) {
                if (this._paused || this._speed === 0) return;
                dt *= this._speed;
                if (this._firstTick) {
                  this._elapsed = this._startTime;
                } else this._elapsed += dt;
                var t = this._elapsed / (this._duration > 0.0000001192092896 ? this._duration : 0.0000001192092896);
                t = t < 1 ? t : 1;
                this.update(t > 0 ? t : 0);
                if (this.isUnknownDuration() && !this._firstTick) {
                  if (t < 1) {
                    this._elapsed -= dt;
                  } else {
                    this._elapsed = this._startTime + this._duration;
                  }
                }
                if (this._firstTick) {
                  this._firstTick = false;
                  if (this._startTime > 0) {
                    this._startTime = 0;
                  }
                }
              };
              _proto2.startWithTarget = function startWithTarget(target) {
                _FiniteTimeAction2.prototype.startWithTarget.call(this, target);
                this._elapsed = 0;
                this._firstTick = true;
              };
              _proto2.getSpeed = function getSpeed() {
                return this._speed;
              };
              _proto2.setSpeed = function setSpeed(speed) {
                this._speed = speed;
              };
              _proto2.getDurationScaled = function getDurationScaled() {
                return this._duration / this._speed;
              };
              return ActionInterval;
            }(FiniteTimeAction);
            function sequenceActionWithOneTwo(actionOne, actionTwo) {
              var sequence = new Sequence();
              sequence.initWithTwoActions(actionOne, actionTwo);
              return sequence;
            }
            var Sequence = function (_ActionInterval) {
              _inheritsLoose(Sequence, _ActionInterval);
              function Sequence(actions) {
                var _this2;
                _this2 = _ActionInterval.call(this) || this;
                _this2._actions = [];
                _this2._split = 0;
                _this2._last = 0;
                _this2._reversed = false;
                if (!actions || actions.length === 0) {
                  return _assertThisInitialized(_this2);
                }
                if (actions.length === 1) {
                  actions.push(new DummyAction());
                }
                var last = actions.length - 1;
                if (last >= 0 && actions[last] == null) logID(1015);
                if (last >= 0) {
                  var prev = actions[0];
                  var action1;
                  for (var i = 1; i < last; i++) {
                    if (actions[i]) {
                      action1 = prev;
                      prev = sequenceActionWithOneTwo(action1, actions[i]);
                    }
                  }
                  _this2.initWithTwoActions(prev, actions[last]);
                }
                return _this2;
              }
              var _proto3 = Sequence.prototype;
              _proto3.initWithTwoActions = function initWithTwoActions(actionOne, actionTwo) {
                if (!actionOne || !actionTwo) {
                  errorID(1025);
                  return false;
                }
                var durationOne = actionOne.getDurationScaled();
                var durationTwo = actionTwo.getDurationScaled();
                var d = durationOne + durationTwo;
                this.initWithDuration(d);
                this._actions[0] = actionOne;
                this._actions[1] = actionTwo;
                return true;
              };
              _proto3.clone = function clone() {
                var action = new Sequence();
                action._id = this._id;
                action._speed = this._speed;
                this._cloneDecoration(action);
                action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
                return action;
              };
              _proto3.startWithTarget = function startWithTarget(target) {
                _ActionInterval.prototype.startWithTarget.call(this, target);
                if (this._actions.length === 0) {
                  return;
                }
                this._split = this._actions[0].getDurationScaled() / this._duration;
                this._last = -1;
              };
              _proto3.stop = function stop() {
                if (this._actions.length === 0) {
                  return;
                }
                if (this._last !== -1) this._actions[this._last].stop();
                _ActionInterval.prototype.stop.call(this);
              };
              _proto3.update = function update(t) {
                var locActions = this._actions;
                if (locActions.length === 0) {
                  return;
                }
                var new_t = 0;
                var found = 0;
                var locSplit = this._split;
                var locLast = this._last;
                if (t < locSplit) {
                  new_t = locSplit !== 0 ? t / locSplit : 1;
                  if (found === 0 && locLast === 1 && this._reversed) {
                    var two = locActions[1];
                    two.update(0);
                    if (two.isUnknownDuration()) return;
                    two.stop();
                  }
                } else {
                  var one = locActions[0];
                  found = 1;
                  new_t = locSplit === 1 ? 1 : (t - locSplit) / (1 - locSplit);
                  if (locLast === -1) {
                    one.startWithTarget(this.target);
                    one.update(1);
                    if (one.isUnknownDuration()) return;
                    one.stop();
                  }
                  if (locLast === 0) {
                    one.update(1);
                    if (one.isUnknownDuration()) return;
                    one.stop();
                  }
                }
                var actionFound = locActions[found];
                if (locLast === found && actionFound.isDone()) return;
                if (locLast !== found) actionFound.startWithTarget(this.target);
                actionFound.update(new_t > 1 ? new_t % 1 : new_t);
                this._last = found;
              };
              _proto3.reverse = function reverse() {
                var action = sequenceActionWithOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
                this._cloneDecoration(action);
                action._reversed = true;
                return action;
              };
              _proto3.updateOwner = function updateOwner(owner) {
                if (this._actions.length < 2) {
                  return;
                }
                var actionOne = this._actions[0];
                var actionTwo = this._actions[1];
                if (!actionTwo._owner) {
                  actionTwo._owner = owner;
                }
                if (actionOne instanceof Sequence || actionOne instanceof Spawn) {
                  actionOne.updateOwner(owner);
                } else if (!actionOne._owner) {
                  actionOne._owner = owner;
                }
              };
              _proto3.findAction = function findAction(id) {
                for (var i = 0, len = this._actions.length; i < len; ++i) {
                  var action = this._actions[i];
                  if (action.getId() === id) {
                    return action;
                  }
                  if (action instanceof Sequence || action instanceof Spawn) {
                    action = action.findAction(id);
                    if (action && action.getId() === id) {
                      return action;
                    }
                  }
                }
                return null;
              };
              _proto3.isUnknownDuration = function isUnknownDuration() {
                if (this._actions.length === 0) return false;
                var one = this._actions[0];
                var two = this._actions[1];
                if (this._last < 1) {
                  return one.isUnknownDuration();
                }
                return two.isUnknownDuration();
              };
              _proto3.toString = function toString() {
                return "<Sequence>";
              };
              return Sequence;
            }(ActionInterval);
            function sequence(actions) {
              return new Sequence(actions);
            }
            var Repeat = function (_ActionInterval2) {
              _inheritsLoose(Repeat, _ActionInterval2);
              function Repeat(action, times) {
                var _this3;
                _this3 = _ActionInterval2.call(this) || this;
                _this3._times = 0;
                _this3._total = 0;
                _this3._nextDt = 0;
                _this3._actionInstant = false;
                _this3._innerAction = null;
                _this3.initWithAction(action, times);
                return _this3;
              }
              var _proto4 = Repeat.prototype;
              _proto4.initWithAction = function initWithAction(action, times) {
                if (!action || times === undefined) {
                  return false;
                }
                var duration = action.getDurationScaled() * times;
                if (this.initWithDuration(duration)) {
                  this._times = times;
                  this._innerAction = action;
                  if (action instanceof ActionInstant) {
                    this._actionInstant = true;
                    this._times -= 1;
                  }
                  this._total = 0;
                  return true;
                }
                return false;
              };
              _proto4.clone = function clone() {
                var action = new Repeat();
                action._id = this._id;
                action._speed = this._speed;
                this._cloneDecoration(action);
                if (this._innerAction) {
                  action.initWithAction(this._innerAction.clone(), this._times);
                }
                return action;
              };
              _proto4.startWithTarget = function startWithTarget(target) {
                this._total = 0;
                this._nextDt = (this._innerAction ? this._innerAction.getDurationScaled() : 0) / this._duration;
                _ActionInterval2.prototype.startWithTarget.call(this, target);
                if (this._innerAction) this._innerAction.startWithTarget(target);
              };
              _proto4.stop = function stop() {
                if (this._innerAction) this._innerAction.stop();
                _ActionInterval2.prototype.stop.call(this);
              };
              _proto4.update = function update(dt) {
                var locInnerAction = this._innerAction;
                var locDuration = this._duration;
                var locTimes = this._times;
                var locNextDt = this._nextDt;
                if (!locInnerAction) {
                  return;
                }
                if (dt >= locNextDt) {
                  while (dt > locNextDt && this._total < locTimes) {
                    locInnerAction.update(1);
                    if (locInnerAction.isUnknownDuration()) return;
                    this._total++;
                    locInnerAction.stop();
                    locInnerAction.startWithTarget(this.target);
                    locNextDt += locInnerAction.getDurationScaled() / locDuration;
                    this._nextDt = locNextDt > 1 ? 1 : locNextDt;
                  }
                  if (dt >= 1.0 && this._total < locTimes) {
                    locInnerAction.update(1);
                    if (locInnerAction.isUnknownDuration()) return;
                    this._total++;
                  }
                  if (!this._actionInstant) {
                    if (this._total === locTimes) {
                      locInnerAction.stop();
                    } else {
                      locInnerAction.update(dt - (locNextDt - locInnerAction.getDurationScaled() / locDuration));
                    }
                  }
                } else {
                  locInnerAction.update(dt * locTimes % 1.0);
                }
              };
              _proto4.isDone = function isDone() {
                return this._total === this._times;
              };
              _proto4.reverse = function reverse() {
                var actionArg = this._innerAction ? this._innerAction.reverse() : undefined;
                var action = new Repeat(actionArg, this._times);
                this._cloneDecoration(action);
                return action;
              };
              _proto4.setInnerAction = function setInnerAction(action) {
                if (this._innerAction !== action) {
                  this._innerAction = action;
                }
              };
              _proto4.getInnerAction = function getInnerAction() {
                return this._innerAction;
              };
              _proto4.isUnknownDuration = function isUnknownDuration() {
                if (this._innerAction) {
                  return this._innerAction.isUnknownDuration();
                }
                return false;
              };
              _proto4.toString = function toString() {
                return "<Repeat>";
              };
              return Repeat;
            }(ActionInterval);
            function repeat(action, times) {
              return new Repeat(action, times);
            }
            var RepeatForever = function (_ActionInterval3) {
              _inheritsLoose(RepeatForever, _ActionInterval3);
              function RepeatForever(action) {
                var _this4;
                _this4 = _ActionInterval3.call(this) || this;
                _this4._innerAction = null;
                if (action) _this4.initWithAction(action);
                return _this4;
              }
              var _proto5 = RepeatForever.prototype;
              _proto5.initWithAction = function initWithAction(action) {
                if (!action) {
                  errorID(1026);
                  return false;
                }
                this._innerAction = action;
                this._duration = Infinity;
                return true;
              };
              _proto5.clone = function clone() {
                var action = new RepeatForever();
                action._id = this._id;
                action._speed = this._speed;
                this._cloneDecoration(action);
                if (this._innerAction) {
                  action.initWithAction(this._innerAction.clone());
                }
                return action;
              };
              _proto5.startWithTarget = function startWithTarget(target) {
                _ActionInterval3.prototype.startWithTarget.call(this, target);
                if (this._innerAction) {
                  this._innerAction.startWithTarget(target);
                }
              };
              _proto5.stop = function stop() {
                if (this._innerAction) this._innerAction.stop();
                _ActionInterval3.prototype.stop.call(this);
              };
              _proto5.step = function step(dt) {
                if (this._paused || this._speed === 0) return;
                var locInnerAction = this._innerAction;
                if (!locInnerAction) {
                  return;
                }
                dt *= this._speed;
                locInnerAction.step(dt);
                if (locInnerAction.isDone()) {
                  locInnerAction.startWithTarget(this.target);
                  locInnerAction.step(locInnerAction.getElapsed() - locInnerAction.getDurationScaled());
                }
              };
              _proto5.update = function update(_t) {
                logID(1007);
              };
              _proto5.isDone = function isDone() {
                return false;
              };
              _proto5.reverse = function reverse() {
                if (this._innerAction) {
                  var action = new RepeatForever(this._innerAction.reverse());
                  this._cloneDecoration(action);
                  return action;
                }
                return this;
              };
              _proto5.setInnerAction = function setInnerAction(action) {
                if (this._innerAction !== action) {
                  this._innerAction = action;
                }
              };
              _proto5.getInnerAction = function getInnerAction() {
                return this._innerAction;
              };
              _proto5.isUnknownDuration = function isUnknownDuration() {
                if (this._innerAction) {
                  return this._innerAction.isUnknownDuration();
                }
                return false;
              };
              _proto5.toString = function toString() {
                return "<RepeatForever>";
              };
              return RepeatForever;
            }(ActionInterval);
            function repeatForever(action) {
              return new RepeatForever(action);
            }
            function spawnActionWithOneTwo(action1, action2) {
              var spawn = new Spawn();
              spawn.initWithTwoActions(action1, action2);
              return spawn;
            }
            var Spawn = function (_ActionInterval4) {
              _inheritsLoose(Spawn, _ActionInterval4);
              function Spawn(actions) {
                var _this5;
                _this5 = _ActionInterval4.call(this) || this;
                _this5._one = null;
                _this5._two = null;
                _this5._finished = false;
                if (!actions || actions.length === 0) {
                  return _assertThisInitialized(_this5);
                }
                if (actions.length === 1) {
                  actions.push(new DummyAction());
                }
                var last = actions.length - 1;
                if (last >= 0 && actions[last] == null) logID(1015);
                if (last >= 0) {
                  var prev = actions[0];
                  var action1;
                  for (var i = 1; i < last; i++) {
                    if (actions[i]) {
                      action1 = prev;
                      prev = spawnActionWithOneTwo(action1, actions[i]);
                    }
                  }
                  _this5.initWithTwoActions(prev, actions[last]);
                }
                return _this5;
              }
              var _proto6 = Spawn.prototype;
              _proto6.initWithTwoActions = function initWithTwoActions(action1, action2) {
                if (!action1 || !action2) {
                  errorID(1027);
                  return false;
                }
                var ret = false;
                var d1 = action1.getDurationScaled();
                var d2 = action2.getDurationScaled();
                if (this.initWithDuration(Math.max(d1, d2))) {
                  this._one = action1;
                  this._two = action2;
                  if (d1 > d2) {
                    this._two = sequenceActionWithOneTwo(action2, delayTime(d1 - d2));
                  } else if (d1 < d2) {
                    this._one = sequenceActionWithOneTwo(action1, delayTime(d2 - d1));
                  }
                  ret = true;
                }
                return ret;
              };
              _proto6.clone = function clone() {
                var action = new Spawn();
                action._id = this._id;
                action._speed = this._speed;
                this._cloneDecoration(action);
                if (this._one && this._two) {
                  action.initWithTwoActions(this._one.clone(), this._two.clone());
                }
                return action;
              };
              _proto6.startWithTarget = function startWithTarget(target) {
                _ActionInterval4.prototype.startWithTarget.call(this, target);
                if (this._one) this._one.startWithTarget(target);
                if (this._two) this._two.startWithTarget(target);
              };
              _proto6.stop = function stop() {
                if (this._one) this._one.stop();
                if (this._two) this._two.stop();
                _ActionInterval4.prototype.stop.call(this);
              };
              _proto6.update = function update(t) {
                if (this._one) {
                  if (!this._finished || this._one.isUnknownDuration()) {
                    this._one.update(t);
                  }
                }
                if (this._two) {
                  if (!this._finished || this._two.isUnknownDuration()) {
                    this._two.update(t);
                  }
                }
                this._finished = t === 1;
              };
              _proto6.reverse = function reverse() {
                if (this._one && this._two) {
                  var action = spawnActionWithOneTwo(this._one.reverse(), this._two.reverse());
                  this._cloneDecoration(action);
                  return action;
                }
                return this;
              };
              _proto6.updateOwner = function updateOwner(owner) {
                if (!this._one || !this._two) {
                  return;
                }
                if (!this._two._owner) {
                  this._two._owner = owner;
                }
                var one = this._one;
                if (one instanceof Spawn || one instanceof Sequence) {
                  one.updateOwner(owner);
                } else if (!one._owner) {
                  one._owner = owner;
                }
              };
              _proto6.findAction = function findAction(id) {
                var one = this._one;
                var two = this._two;
                var foundAction = null;
                var find = function find(action) {
                  if (action.getId() === id) return action;
                  if (action instanceof Sequence || action instanceof Spawn) {
                    var found = action.findAction(id);
                    if (found) return found;
                  }
                  return null;
                };
                if (one) {
                  foundAction = find(one);
                  if (foundAction) return foundAction;
                }
                if (two) {
                  foundAction = find(two);
                  if (foundAction) return foundAction;
                }
                return null;
              };
              _proto6.isUnknownDuration = function isUnknownDuration() {
                var one = this._one;
                var two = this._two;
                if (one == null || two == null) return false;
                var isOneUnknownTime = one.isUnknownDuration();
                var isTwoUnknownTime = two.isUnknownDuration();
                if (isOneUnknownTime || isTwoUnknownTime) {
                  if (isOneUnknownTime && isTwoUnknownTime) return true;else if (this._finished) return true;
                }
                return false;
              };
              _proto6.toString = function toString() {
                return "<Spawn>";
              };
              return Spawn;
            }(ActionInterval);
            function spawn(actions) {
              return new Spawn(actions);
            }
            var DelayTime = function (_ActionInterval5) {
              _inheritsLoose(DelayTime, _ActionInterval5);
              function DelayTime() {
                return _ActionInterval5.apply(this, arguments) || this;
              }
              var _proto7 = DelayTime.prototype;
              _proto7.update = function update(_dt) {};
              _proto7.reverse = function reverse() {
                var action = new DelayTime(this._duration);
                this._cloneDecoration(action);
                return action;
              };
              _proto7.clone = function clone() {
                var action = new DelayTime();
                action._id = this._id;
                action._speed = this._speed;
                this._cloneDecoration(action);
                action.initWithDuration(this._duration);
                return action;
              };
              _proto7.isUnknownDuration = function isUnknownDuration() {
                return false;
              };
              _proto7.toString = function toString() {
                return "<DelayTime>";
              };
              return DelayTime;
            }(ActionInterval);
            function delayTime(d) {
              return new DelayTime(d);
            }
            var ReverseTime = function (_ActionInterval6) {
              _inheritsLoose(ReverseTime, _ActionInterval6);
              function ReverseTime(action) {
                var _this6;
                _this6 = _ActionInterval6.call(this) || this;
                _this6._other = null;
                if (action) _this6.initWithAction(action);
                return _this6;
              }
              var _proto8 = ReverseTime.prototype;
              _proto8.initWithAction = function initWithAction(action) {
                if (!action) {
                  errorID(1028);
                  return false;
                }
                if (action === this._other) {
                  errorID(1029);
                  return false;
                }
                if (_ActionInterval6.prototype.initWithDuration.call(this, action.getDurationScaled())) {
                  this._other = action;
                  return true;
                }
                return false;
              };
              _proto8.clone = function clone() {
                var action = new ReverseTime();
                action._id = this._id;
                action._speed = this._speed;
                this._cloneDecoration(action);
                if (this._other) {
                  action.initWithAction(this._other.clone());
                }
                return action;
              };
              _proto8.startWithTarget = function startWithTarget(target) {
                _ActionInterval6.prototype.startWithTarget.call(this, target);
                if (this._other) this._other.startWithTarget(target);
              };
              _proto8.update = function update(dt) {
                if (this._other) this._other.update(1 - dt);
              };
              _proto8.reverse = function reverse() {
                if (this._other) {
                  return this._other.clone();
                }
                return this;
              };
              _proto8.stop = function stop() {
                if (this._other) this._other.stop();
                _ActionInterval6.prototype.stop.call(this);
              };
              _proto8.isUnknownDuration = function isUnknownDuration() {
                return false;
              };
              _proto8.toString = function toString() {
                return "<ReverseTime>";
              };
              return ReverseTime;
            }(ActionInterval);
            function reverseTime(action) {
              return new ReverseTime(action);
            }
            var ActionCustomUpdate = function (_ActionInterval7) {
              _inheritsLoose(ActionCustomUpdate, _ActionInterval7);
              function ActionCustomUpdate(duration, cb, args) {
                var _this7;
                _this7 = _ActionInterval7.call(this, duration) || this;
                _this7._cb = cb;
                _this7._args = args;
                return _this7;
              }
              var _proto9 = ActionCustomUpdate.prototype;
              _proto9.clone = function clone() {
                return new ActionCustomUpdate(this._duration, this._cb, this._args);
              };
              _proto9.update = function update(ratio) {
                this._cb.apply(this, [this.target, ratio].concat(this._args));
              };
              _proto9.reverse = function reverse() {
                return this.clone();
              };
              _proto9.isUnknownDuration = function isUnknownDuration() {
                return false;
              };
              _proto9.toString = function toString() {
                return "<ActionCustomUpdate>";
              };
              return ActionCustomUpdate;
            }(ActionInterval);

            var ActionUnknownDuration = function (_FiniteTimeAction) {
              _inheritsLoose(ActionUnknownDuration, _FiniteTimeAction);
              function ActionUnknownDuration(cb, args) {
                var _this;
                _this = _FiniteTimeAction.call(this) || this;
                _this._finished = false;
                _this._cb = cb;
                _this._args = args;
                return _this;
              }
              var _proto = ActionUnknownDuration.prototype;
              _proto.clone = function clone() {
                return new ActionUnknownDuration(this._cb, this._args);
              };
              _proto.reverse = function reverse() {
                return this.clone();
              };
              _proto.step = function step(dt) {
                throw new Error('should never go here');
              };
              _proto.update = function update(t) {
                var dt = cclegacy.game.deltaTime;
                this._finished = this._cb.apply(this, [this.target, dt].concat(this._args));
              };
              _proto.isDone = function isDone() {
                return this._finished;
              };
              _proto.isUnknownDuration = function isUnknownDuration() {
                return !this.isDone();
              };
              _proto.toString = function toString() {
                return "<ActionUnknownDuration>";
              };
              return ActionUnknownDuration;
            }(FiniteTimeAction);

            function TweenEasingAdapter(easingName) {
              var initialChar = easingName.charAt(0);
              if (/[A-Z]/.test(initialChar)) {
                easingName = easingName.replace(initialChar, initialChar.toLowerCase());
                var arr = easingName.split('-');
                if (arr.length === 2) {
                  var str0 = arr[0];
                  if (str0 === 'linear') {
                    easingName = 'linear';
                  } else {
                    var str1 = arr[1];
                    switch (str0) {
                      case 'quadratic':
                        easingName = "quad" + str1;
                        break;
                      case 'quartic':
                        easingName = "quart" + str1;
                        break;
                      case 'quintic':
                        easingName = "quint" + str1;
                        break;
                      case 'sinusoidal':
                        easingName = "sine" + str1;
                        break;
                      case 'exponential':
                        easingName = "expo" + str1;
                        break;
                      case 'circular':
                        easingName = "circ" + str1;
                        break;
                      default:
                        easingName = str0 + str1;
                        break;
                    }
                  }
                }
              }
              return easingName;
            }
            function TweenOptionChecker(opts) {
              var header = ' [Tween:] ';
              var message = " option is not support in v + " + engineVersion;
              var _opts = opts;
              if (_opts.delay) {
                warn(header + "delay" + message);
              }
              if (_opts.repeat) {
                warn(header + "repeat" + message);
              }
              if (_opts.repeatDelay) {
                warn(header + "repeatDelay" + message);
              }
              if (_opts.interpolation) {
                warn(header + "interpolation" + message);
              }
              if (_opts.onStop) {
                warn(header + "onStop" + message);
              }
            }
            var TweenAction = exports("TweenAction", function (_ActionInterval) {
              _inheritsLoose(TweenAction, _ActionInterval);
              function TweenAction(duration, props, opts) {
                var _this;
                _this = _ActionInterval.call(this) || this;
                _this._reversed = false;
                if (opts == null) {
                  opts = Object.create(null);
                } else {
                  TweenOptionChecker(opts);
                  if (opts.easing && typeof opts.easing === 'string') {
                    opts.easing = TweenEasingAdapter(opts.easing);
                  }
                  if (!opts.progress) {
                    opts.progress = _this.progress;
                  }
                  if (opts.easing && typeof opts.easing === 'string') {
                    var easingName = opts.easing;
                    opts.easing = easing[easingName];
                    if (!opts.easing) {
                      warnID(1031, easingName);
                    }
                  }
                }
                _this._opts = opts;
                _this._props = Object.create(null);
                for (var name in props) {
                  var _value$legacyProgress;
                  if (!props.hasOwnProperty(name)) continue;
                  var value = props[name];
                  if (typeof value === 'function') {
                    value = value();
                  } else if (value == null) {
                    continue;
                  }
                  var customEasing = undefined;
                  var customProgress = undefined;
                  var customValue = undefined;
                  if (value.value !== undefined) {
                    customValue = value.value;
                    if (typeof customValue === 'function') {
                      customValue = customValue();
                    }
                    if (value.easing !== undefined) {
                      if (typeof value.easing === 'string') {
                        customEasing = easing[value.easing];
                        if (!customEasing) warnID(1031, value.easing);
                      } else {
                        customEasing = value.easing;
                      }
                    }
                    if (value.progress !== undefined) {
                      customProgress = value.progress;
                    }
                  } else {
                    customValue = value;
                  }
                  var prop = Object.create(null);
                  prop.start = prop.current = prop.end = null;
                  prop.keys = null;
                  prop.value = customValue;
                  prop.easing = customEasing;
                  prop.progress = customProgress;
                  prop.convert = value.convert;
                  prop.clone = value.clone;
                  prop.add = value.add;
                  prop.sub = value.sub;
                  prop.legacyProgress = (_value$legacyProgress = value.legacyProgress) !== null && _value$legacyProgress !== undefined ? _value$legacyProgress : true;
                  prop.toFixed = value.toFixed;
                  prop.onStart = value.onStart;
                  prop.onStop = value.onStop;
                  prop.onComplete = value.onComplete;
                  prop.valid = true;
                  _this._props[name] = prop;
                }
                _this._originProps = props;
                _this.initWithDuration(duration);
                return _this;
              }
              var _proto = TweenAction.prototype;
              _proto.clone = function clone() {
                var action = new TweenAction(this._duration, this._originProps, this._opts);
                action._reversed = this._reversed;
                action._owner = this._owner;
                action._id = this._id;
                this._cloneDecoration(action);
                return action;
              };
              _proto.reverse = function reverse() {
                if (!this._opts.relative) {
                  warnID(16382);
                  return new TweenAction(0, {});
                }
                var action = new TweenAction(this._duration, this._originProps, this._opts);
                this._cloneDecoration(action);
                action._reversed = !this._reversed;
                action._owner = this._owner;
                return action;
              };
              _proto.startWithTarget = function startWithTarget(target) {
                _ActionInterval.prototype.startWithTarget.call(this, target);
                var workerTarget = this._getWorkerTarget();
                if (!workerTarget) return;
                var relative = !!this._opts.relative;
                var props = this._props;
                var reversed = this._reversed;
                var _loop = function _loop() {
                    var _t = workerTarget[property];
                    if (_t === undefined) {
                      return 0;
                    }
                    var prop = props[property];
                    var value = prop.value;
                    if (typeof _t === 'number') {
                      prop.start = _t;
                      prop.current = _t;
                      prop.end = relative ? reversed ? _t - value : _t + value : value;
                    } else if (typeof _t === 'object') {
                      if (prop.legacyProgress) {
                        if (prop.start == null) {
                          var Ctor = _t.constructor;
                          prop.start = new Ctor();
                          prop.current = new Ctor();
                          prop.end = new Ctor();
                        }
                        var propertyKeys;
                        if (value.getModifiableProperties) {
                          propertyKeys = value.getModifiableProperties();
                        } else {
                          propertyKeys = Object.keys(value);
                        }
                        prop.keys = propertyKeys;
                        for (var i = 0, len = propertyKeys.length; i < len; ++i) {
                          var k = propertyKeys[i];
                          if (isNaN(_t[k])) continue;
                          prop.start[k] = _t[k];
                          prop.current[k] = _t[k];
                          prop.end[k] = relative ? reversed ? _t[k] - value[k] : _t[k] + value[k] : value[k];
                        }
                      } else {
                        var clone = prop.clone;
                        if (!clone) {
                          warnID(16383, property);
                          prop.valid = false;
                          return 0;
                        } else {
                          var add = prop.add;
                          var sub = prop.sub;
                          if (relative) {
                            if (!add) {
                              warnID(16384, property);
                              prop.valid = false;
                            }
                            if (reversed && !sub) {
                              warnID(16385, property);
                              prop.valid = false;
                            }
                            if (!prop.valid) return 0;
                          }
                          prop.start = clone(_t);
                          prop.current = clone(_t);
                          prop.end = relative ? reversed ? sub(_t, value) : add(_t, value) : clone(value);
                        }
                      }
                    } else if (typeof _t === 'string') {
                      var convertFn = prop.convert;
                      var convertToNumber = function convertToNumber(v) {
                        if (typeof v === 'number') return v;
                        var convertedValue = v;
                        if (convertFn) {
                          convertedValue = convertFn(v);
                        }
                        if (typeof convertedValue !== 'number') {
                          convertedValue = Number(convertedValue);
                          if (Number.isNaN(convertedValue)) {
                            warnID(16386, "" + v);
                            return null;
                          }
                        }
                        return convertedValue;
                      };
                      var targetNumValue = convertToNumber(value);
                      var startNumValue = convertToNumber(_t);
                      if (targetNumValue == null || startNumValue == null) {
                        prop.valid = false;
                        return 0;
                      }
                      prop.start = startNumValue;
                      prop.current = _t;
                      prop.end = relative ? reversed ? startNumValue - targetNumValue : startNumValue + targetNumValue : targetNumValue;
                    }
                    if (prop.onStart) {
                      prop.onStart({
                        relative: relative,
                        reversed: reversed,
                        start: prop.start,
                        end: prop.end
                      });
                    }
                  },
                  _ret;
                for (var property in props) {
                  _ret = _loop();
                  if (_ret === 0) continue;
                }
                if (this._opts.onStart) {
                  this._opts.onStart(workerTarget);
                }
              };
              _proto.stop = function stop() {
                var props = this._props;
                for (var name in props) {
                  var prop = props[name];
                  if (!prop.valid) continue;
                  if (prop.onStop) {
                    prop.onStop();
                  }
                }
                _ActionInterval.prototype.stop.call(this);
              };
              _proto.update = function update(t) {
                var workerTarget = this._getWorkerTarget();
                if (!workerTarget) return;
                if (!this._opts) return;
                var props = this._props;
                var opts = this._opts;
                var easingTime = t;
                if (typeof opts.easing === 'function') easingTime = opts.easing(t);
                var progress = opts.progress;
                for (var name in props) {
                  var prop = props[name];
                  if (!prop.valid) continue;
                  var time = prop.easing ? prop.easing(t) : easingTime;
                  var interpolation = prop.progress ? prop.progress : progress;
                  var start = prop.start;
                  var end = prop.end;
                  var current = prop.current;
                  if (typeof current === 'number') {
                    prop.current = interpolation(start, end, prop.current, time);
                  } else if (typeof start === 'object') {
                    if (prop.legacyProgress) {
                      var keys = prop.keys;
                      for (var i = 0, len = keys.length; i < len; ++i) {
                        var k = keys[i];
                        prop.current[k] = interpolation(start[k], end[k], prop.current[k], time);
                      }
                    } else {
                      prop.current = interpolation(start, end, prop.current, time);
                    }
                  } else if (typeof current === 'string') {
                    var newCurrent = interpolation(start, end, prop.current, time);
                    if (typeof newCurrent === 'number') {
                      var _prop$toFixed;
                      newCurrent = newCurrent.toFixed((_prop$toFixed = prop.toFixed) !== null && _prop$toFixed !== undefined ? _prop$toFixed : 0);
                    } else if (typeof newCurrent !== 'string') {
                      warnID(16387);
                      continue;
                    }
                    prop.current = newCurrent;
                  }
                  workerTarget[name] = prop.current;
                  if (t === 1 && prop.onComplete) {
                    prop.onComplete();
                  }
                }
                if (opts.onUpdate) {
                  opts.onUpdate(workerTarget, t);
                }
                if (t === 1 && opts.onComplete) {
                  opts.onComplete(workerTarget);
                }
              };
              _proto.progress = function progress(start, end, current, t) {
                return start + (end - start) * t;
              };
              _proto.isUnknownDuration = function isUnknownDuration() {
                return false;
              };
              _createClass(TweenAction, [{
                key: "relative",
                get: function get() {
                  return !!this._opts.relative;
                }
              }]);
              return TweenAction;
            }(ActionInterval));

            var SetAction = function (_ActionInstant) {
              _inheritsLoose(SetAction, _ActionInstant);
              function SetAction(props) {
                var _this;
                _this = _ActionInstant.call(this) || this;
                _this._props = undefined;
                _this._props = {};
                if (props) _this.init(props);
                return _this;
              }
              var _proto = SetAction.prototype;
              _proto.init = function init(props) {
                for (var name in props) {
                  this._props[name] = props[name];
                }
                return true;
              };
              _proto.update = function update() {
                var props = this._props;
                var target = this._getWorkerTarget();
                for (var name in props) {
                  target[name] = props[name];
                }
              };
              _proto.clone = function clone() {
                var action = new SetAction();
                action._id = this._id;
                action.init(this._props);
                return action;
              };
              _proto.isUnknownDuration = function isUnknownDuration() {
                return false;
              };
              return SetAction;
            }(ActionInstant);

            function getActionManager() {
              return TweenSystem.instance.ActionManager;
            }
            var Tween = exports("Tween", function () {
              function Tween(target) {
                this._actions = [];
                this._finalAction = null;
                this._target = null;
                this._tag = -1;
                this._timeScale = 1;
                this._isBindNodeState = true;
                this._target = target === undefined ? null : target;
              }
              var _proto = Tween.prototype;
              _proto.bindNodeState = function bindNodeState(isBindNodeState) {
                this._isBindNodeState = isBindNodeState;
                return this;
              };
              _proto.tag = function tag(_tag) {
                this._tag = _tag;
                return this;
              };
              _proto.id = function (_id) {
                function id(_x) {
                  return _id.apply(this, arguments);
                }
                id.toString = function () {
                  return _id.toString();
                };
                return id;
              }(function (id) {
                if (this._actions.length > 0) {
                  this._actions[this._actions.length - 1].setId(id);
                }
                return this;
              });
              _proto.then = function then(other) {
                var u = other._union(true);
                if (u) {
                  u.setSpeed(other._timeScale);
                  this._actions.push(u);
                }
                return this;
              };
              _proto.reverse = function reverse(otherTweenOrId, id) {
                if (otherTweenOrId == null && id == null) {
                  return this.reverseTween();
                }
                var tweenForFindAction;
                var actionId;
                if (otherTweenOrId instanceof Tween) {
                  tweenForFindAction = otherTweenOrId;
                  if (id !== undefined) {
                    actionId = id;
                  }
                } else if (typeof otherTweenOrId === 'number') {
                  tweenForFindAction = this;
                  actionId = otherTweenOrId;
                }
                if (tweenForFindAction) {
                  var reversedAction = Tween.reverseAction(tweenForFindAction, actionId);
                  if (reversedAction) {
                    this._actions.push(reversedAction);
                  }
                }
                return this;
              };
              _proto.reverseTween = function reverseTween() {
                if (this._actions.length === 0) {
                  warnID(16388);
                  return this.clone(this._target);
                }
                var action = this._union(false);
                var r = tween(this._target);
                r._timeScale = this._timeScale;
                if (action) r.insertAction(action.reverse());
                return r;
              };
              Tween.reverseAction = function reverseAction(t, actionId) {
                var actions = t._actions;
                if (actions.length === 0) return null;
                var action = null;
                var reversedAction = null;
                if (typeof actionId === 'number') {
                  action = t.findAction(actionId, actions);
                } else if (t) {
                  action = t._union(false);
                }
                if (action) {
                  reversedAction = action.reverse();
                  reversedAction._owner = t;
                } else {
                  warnID(16391, "" + actionId);
                }
                return reversedAction;
              };
              _proto.findAction = function findAction(id, actions) {
                var action = null;
                for (var i = 0, len = actions.length; i < len; ++i) {
                  action = actions[i];
                  if (action.getId() === id) return action;
                  if (action instanceof Sequence || action instanceof Spawn) {
                    action = action.findAction(id);
                    if (action) return action;
                  }
                }
                return null;
              };
              _proto.insertAction = function insertAction(other) {
                var action = other.clone();
                this.updateOwnerForAction(action);
                this._actions.push(action);
                return this;
              };
              _proto.updateOwnerForAction = function updateOwnerForAction(action) {
                if (!action) return;
                if (action instanceof Sequence || action instanceof Spawn) {
                  action.updateOwner(this);
                } else if (!action._owner) {
                  action._owner = this;
                }
              };
              _proto.target = function (_target) {
                function target(_x2) {
                  return _target.apply(this, arguments);
                }
                target.toString = function () {
                  return _target.toString();
                };
                return target;
              }(function (target) {
                this._target = target;
                return this;
              });
              _proto.getTarget = function getTarget() {
                return this._target;
              };
              _proto.start = function start(time) {
                if (time === undefined) {
                  time = 0;
                }
                if (!this._target) {
                  warnID(16392);
                  return this;
                }
                if (this._finalAction) {
                  getActionManager().removeAction(this._finalAction);
                }
                var _final = this._unionForStart();
                this._finalAction = _final;
                if (_final) {
                  _final.setTag(this._tag);
                  _final.setSpeed(this._timeScale);
                  _final.setStartTime(time);
                  _final.setPaused(false);
                  getActionManager().addAction(_final, this._target, false, this._isBindNodeState);
                } else {
                  warnID(16393);
                }
                return this;
              };
              _proto.stop = function stop() {
                if (this._finalAction) {
                  this._finalAction.stop();
                  getActionManager().removeAction(this._finalAction);
                  this._finalAction = null;
                }
                return this;
              };
              _proto.pause = function pause() {
                if (this._finalAction) {
                  this._finalAction.setPaused(true);
                } else {
                  warnID(16389);
                }
                return this;
              };
              _proto.resume = function resume() {
                if (this._finalAction) {
                  this._finalAction.setPaused(false);
                } else {
                  warnID(16390);
                }
                return this;
              };
              _proto.clone = function clone(target) {
                var action = this._union(false);
                var r = tween(target !== null && target !== undefined ? target : this._target);
                r._timeScale = this._timeScale;
                return action ? r.insertAction(action) : r;
              };
              _proto.union = function union(fromId) {
                var _this = this;
                var unionAll = function unionAll() {
                  var action = _this._union(false);
                  _this._actions.length = 0;
                  if (action) _this._actions.push(action);
                };
                if (fromId === undefined) {
                  unionAll();
                  return this;
                }
                var actions = this._actions;
                var index = actions.findIndex(function (action) {
                  return action.getId() === fromId;
                });
                var len = actions.length;
                if (len > 1) {
                  var actionsToUnion = actions.splice(index);
                  if (actionsToUnion.length === 1) {
                    actions.push(actionsToUnion[0]);
                  } else {
                    actions.push(sequence(actionsToUnion));
                  }
                }
                return this;
              };
              _proto.to = function to(duration, props, opts) {
                var options = opts || Object.create(null);
                options.relative = false;
                var action = new TweenAction(duration, props, options);
                this._actions.push(action);
                return this;
              };
              _proto.by = function by(duration, props, opts) {
                var options = opts || Object.create(null);
                options.relative = true;
                var action = new TweenAction(duration, props, options);
                this._actions.push(action);
                return this;
              };
              _proto.update = function update(duration, cb) {
                for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                  args[_key - 2] = arguments[_key];
                }
                var action = new ActionCustomUpdate(duration, cb, args);
                this._actions.push(action);
                return this;
              };
              _proto.updateUntil = function updateUntil(cb) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                var action = new ActionUnknownDuration(cb, args);
                this._actions.push(action);
                return this;
              };
              _proto.set = function set(props) {
                var action = new SetAction(props);
                this._actions.push(action);
                return this;
              };
              _proto.delay = function delay(duration) {
                var action = delayTime(duration);
                this._actions.push(action);
                return this;
              };
              _proto.call = function call(callback, callbackThis, data) {
                var action = callFunc(callback, callbackThis, data);
                this._actions.push(action);
                return this;
              };
              _proto.sequence = function sequence() {
                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }
                var action = Tween._wrappedSequence(args);
                if (action) this._actions.push(action);
                return this;
              };
              _proto.parallel = function parallel() {
                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  args[_key4] = arguments[_key4];
                }
                var action = Tween._wrappedParallel(args);
                if (action) this._actions.push(action);
                return this;
              };
              _proto.timeScale = function timeScale(scale) {
                this._timeScale = scale;
                if (this._finalAction) {
                  this._finalAction.setSpeed(scale);
                }
                return this;
              };
              _proto.getTimeScale = function getTimeScale() {
                return this._timeScale;
              };
              _proto.repeat = function repeat$1(repeatTimes, embedTween) {
                if (repeatTimes === Infinity) {
                  return this.repeatForever(embedTween);
                }
                var actions = this._actions;
                var action;
                if (embedTween instanceof Tween) {
                  action = embedTween._union(false);
                } else {
                  action = actions.pop();
                }
                if (action) actions.push(repeat(action, repeatTimes));
                return this;
              };
              _proto.repeatForever = function repeatForever$1(embedTween) {
                var actions = this._actions;
                var action;
                if (embedTween instanceof Tween) {
                  action = embedTween._union(false);
                } else {
                  action = actions.pop();
                }
                if (action && actions.length !== 0) {
                  actions.push(repeat(action, Number.MAX_SAFE_INTEGER));
                } else if (action instanceof ActionInterval) {
                  actions.push(repeatForever(action));
                } else {
                  warnID(16394);
                }
                return this;
              };
              _proto.reverseTime = function reverseTime$1(embedTween) {
                var actions = this._actions;
                var action;
                if (embedTween instanceof Tween) {
                  action = embedTween._union(false);
                } else {
                  action = actions.pop();
                }
                if (action instanceof ActionInterval) {
                  actions.push(reverseTime(action));
                } else {
                  warnID(16395);
                }
                return this;
              };
              _proto.hide = function hide$1() {
                var isNode = this._target instanceof Node$1;
                if (isNode) {
                  var action = hide();
                  this._actions.push(action);
                }
                return this;
              };
              _proto.show = function show$1() {
                var isNode = this._target instanceof Node$1;
                if (isNode) {
                  var action = show();
                  this._actions.push(action);
                }
                return this;
              };
              _proto.removeSelf = function removeSelf$1() {
                var isNode = this._target instanceof Node$1;
                if (isNode) {
                  var action = removeSelf(false);
                  this._actions.push(action);
                }
                return this;
              };
              _proto.destroySelf = function destroySelf() {
                var isNode = this._target instanceof Node$1;
                if (isNode) {
                  var action = removeSelf(true);
                  this._actions.push(action);
                }
                return this;
              };
              Tween.getRunningCount = function getRunningCount(target) {
                return getActionManager().getNumberOfRunningActionsInTarget(target);
              };
              Tween.stopAll = function stopAll() {
                getActionManager().removeAllActions();
              };
              Tween.stopAllByTag = function stopAllByTag(tag, target) {
                getActionManager().removeAllActionsByTag(tag, target);
              };
              Tween.stopAllByTarget = function stopAllByTarget(target) {
                getActionManager().removeAllActionsFromTarget(target);
              };
              Tween.pauseAllByTarget = function pauseAllByTarget(target) {
                getActionManager().pauseTarget(target);
              };
              Tween.resumeAllByTarget = function resumeAllByTarget(target) {
                getActionManager().resumeTarget(target);
              };
              _proto._union = function _union(needUpdateOwner) {
                var actions = this._actions;
                if (actions.length === 0) return null;
                var action = sequence(actions);
                if (needUpdateOwner) {
                  this.updateOwnerForAction(action);
                }
                return action;
              };
              _proto._unionForStart = function _unionForStart() {
                var actions = this._actions;
                if (actions.length === 0) return null;
                var action;
                if (actions.length === 1 && actions[0] instanceof RepeatForever) {
                  action = actions[0];
                } else {
                  action = sequence(actions);
                }
                return action;
              };
              Tween._tweenToActions = function _tweenToActions(args) {
                var tmpArgs = Tween._tmpArgs;
                tmpArgs.length = 0;
                for (var l = args.length, i = 0; i < l; i++) {
                  var t = args[i];
                  var action = t._union(true);
                  if (action) {
                    action.setSpeed(t._timeScale);
                    tmpArgs.push(action);
                  }
                }
              };
              Tween._wrappedSequence = function _wrappedSequence(args) {
                Tween._tweenToActions(args);
                var ret = sequence(Tween._tmpArgs);
                this._tmpArgs.length = 0;
                return ret;
              };
              Tween._wrappedParallel = function _wrappedParallel(args) {
                Tween._tweenToActions(args);
                var ret = spawn(Tween._tmpArgs);
                this._tmpArgs.length = 0;
                return ret;
              };
              _createClass(Tween, [{
                key: "running",
                get: function get() {
                  if (this._finalAction) {
                    return getActionManager().isActionRunning(this._finalAction);
                  }
                  return false;
                }
              }, {
                key: "duration",
                get: function get() {
                  if (this._finalAction) {
                    return this._finalAction.getDuration();
                  }
                  return 0;
                }
              }]);
              return Tween;
            }());
            Tween._tmpArgs = [];
            legacyCC.Tween = Tween;
            function tween(target) {
              return new Tween(target);
            }
            legacyCC.tween = tween;
            function tweenUtil(target) {
              warnID(16396);
              return new Tween(target);
            }
            legacyCC.tweenUtil = tweenUtil;

            deprecateModuleExportedName({
              RenderComponent: {
                newName: 'UIRenderer',
                since: '1.2.0',
                removed: true
              },
              UITransformComponent: {
                newName: 'UITransform',
                since: '1.2.0',
                removed: false
              },
              CanvasComponent: {
                newName: 'Canvas',
                since: '1.2.0',
                removed: false
              }
            });

            deprecateModuleExportedName({
              UIRenderable: {
                newName: 'UIRenderer',
                since: '3.0.0',
                removed: true
              }
            });

            deprecateModuleExportedName({
              Renderable2D: {
                newName: 'UIRenderer',
                since: '3.6.0',
                removed: false
              }
            });

            var _dec$7, _dec2$6, _class$7, _class2$5, _initializer$4, _initializer2$4, _class3$2;
            var _vec2a = new Vec2();
            var _vec2b = new Vec2();
            var _vec3a = new Vec3();
            var _mat4_temp$1 = new Mat4();
            var _matrix = new Mat4();
            var _worldMatrix = new Mat4();
            var _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            var _rect = new Rect();
            var UITransform = (_dec$7 = ccclass$6('cc.UITransform'), _dec2$6 = executionOrder$1(110), _dec$7(_class$7 = _dec2$6(_class$7 = disallowMultiple$1(_class$7 = (_class2$5 = (_class3$2 = function (_Component) {
              _inheritsLoose(UITransform, _Component);
              function UITransform() {
                var _this;
                _this = _Component.call(this) || this;
                _this._priority = 0;
                _this._contentSize = _initializer$4 && _initializer$4();
                _this._anchorPoint = _initializer2$4 && _initializer2$4();
                return _this;
              }
              var _proto = UITransform.prototype;
              _proto.__preload = function __preload() {
                this.node._uiProps.uiTransformComp = this;
              };
              _proto.onLoad = function onLoad() {
                if (this.node.parent) {
                  UITransform.insertChangeMap(this.node.parent);
                }
              };
              _proto.onEnable = function onEnable() {
                this.node.on("parent-changed", this._parentChanged, this);
                this._markRenderDataDirty();
              };
              _proto.onDisable = function onDisable() {
                this.node.off("parent-changed", this._parentChanged, this);
              };
              _proto.onDestroy = function onDestroy() {
                this.node._uiProps.uiTransformComp = null;
              };
              _proto.setContentSize = function setContentSize(size, height) {
                var locContentSize = this._contentSize;
                var locWidth;
                var locHeight;
                if (height === undefined) {
                  size = size;
                  if (approx(size.width, locContentSize.width, EPSILON$1) && approx(size.height, locContentSize.height, EPSILON$1)) {
                    return;
                  }
                  locWidth = size.width;
                  locHeight = size.height;
                } else {
                  size = size;
                  if (approx(size, locContentSize.width, EPSILON$1) && approx(height, locContentSize.height, EPSILON$1)) {
                    return;
                  }
                  locWidth = size;
                  locHeight = height;
                }
                {
                  locContentSize.width = locWidth;
                  locContentSize.height = locHeight;
                  this.node.emit("size-changed");
                }
                this._markRenderDataDirty();
              };
              _proto.setAnchorPoint = function setAnchorPoint(point, y) {
                var locAnchorPoint = this._anchorPoint;
                if (y === undefined) {
                  point = point;
                  if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
                    return;
                  }
                  locAnchorPoint.x = point.x;
                  locAnchorPoint.y = point.y;
                } else {
                  if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
                    return;
                  }
                  locAnchorPoint.x = point;
                  locAnchorPoint.y = y;
                }
                this.node.emit("anchor-changed", this._anchorPoint);
                this._markRenderDataDirty();
              };
              _proto.isHit = function isHit(uiPoint) {
                var w = this._contentSize.width;
                var h = this._contentSize.height;
                var v2WorldPt = _vec2a;
                var testPt = _vec2b;
                var cameras = this._getRenderScene().cameras;
                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (!(camera.visibility & this.node.layer)) continue;
                  camera.node.getWorldRT(_mat4_temp$1);
                  var m12 = _mat4_temp$1.m12;
                  var m13 = _mat4_temp$1.m13;
                  var center = visibleRect.center;
                  _mat4_temp$1.m12 = center.x - (_mat4_temp$1.m00 * m12 + _mat4_temp$1.m04 * m13);
                  _mat4_temp$1.m13 = center.y - (_mat4_temp$1.m01 * m12 + _mat4_temp$1.m05 * m13);
                  Mat4.invert(_mat4_temp$1, _mat4_temp$1);
                  Vec2.transformMat4(v2WorldPt, uiPoint, _mat4_temp$1);
                  this.node.getWorldMatrix(_worldMatrix);
                  Mat4.invert(_mat4_temp$1, _worldMatrix);
                  if (Mat4.strictEquals(_mat4_temp$1, _zeroMatrix)) {
                    continue;
                  }
                  Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp$1);
                  testPt.x += this._anchorPoint.x * w;
                  testPt.y += this._anchorPoint.y * h;
                  var hit = false;
                  if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                    hit = this._maskTest(v2WorldPt);
                  }
                  if (hit) {
                    return true;
                  }
                }
                return false;
              };
              _proto.hitTest = function hitTest(screenPoint, windowId) {
                if (windowId === undefined) {
                  windowId = 0;
                }
                var w = this._contentSize.width;
                var h = this._contentSize.height;
                var v3WorldPt = _vec3a;
                var v2WorldPt = _vec2a;
                var testPt = _vec2b;
                var cameras = this._getRenderScene().cameras;
                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (!(camera.visibility & this.node.layer) || camera.window && !camera.window.swapchain) {
                    continue;
                  }
                  if (camera.systemWindowId !== windowId) {
                    continue;
                  }
                  Vec3.set(v3WorldPt, screenPoint.x, screenPoint.y, 0);
                  camera.screenToWorld(v3WorldPt, v3WorldPt);
                  Vec2.set(v2WorldPt, v3WorldPt.x, v3WorldPt.y);
                  this.node.getWorldMatrix(_worldMatrix);
                  Mat4.invert(_mat4_temp$1, _worldMatrix);
                  if (Mat4.strictEquals(_mat4_temp$1, _zeroMatrix)) {
                    continue;
                  }
                  Vec2.transformMat4(testPt, v2WorldPt, _mat4_temp$1);
                  testPt.x += this._anchorPoint.x * w;
                  testPt.y += this._anchorPoint.y * h;
                  var hit = false;
                  if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                    hit = this._maskTest(v2WorldPt);
                  }
                  if (hit) {
                    return true;
                  }
                }
                return false;
              };
              _proto._maskTest = function _maskTest(pointInWorldSpace) {
                var _this$node, _this$node$eventProce;
                var maskList = (_this$node = this.node) == null ? undefined : (_this$node$eventProce = _this$node.eventProcessor) == null ? undefined : _this$node$eventProce.maskList;
                if (maskList) {
                  var parent = this.node;
                  var length = maskList.length;
                  for (var i = 0, j = 0; parent && j < length; ++i, parent = parent.parent) {
                    var temp = maskList[j];
                    if (i === temp.index) {
                      if (parent === temp.comp.node) {
                        var comp = temp.comp;
                        if (comp && comp._enabled && !comp.isHit(pointInWorldSpace)) {
                          return false;
                        }
                        j++;
                      } else {
                        maskList.length = j;
                        break;
                      }
                    } else if (i > temp.index) {
                      maskList.length = j;
                      break;
                    }
                  }
                }
                return true;
              };
              _proto.convertToNodeSpaceAR = function convertToNodeSpaceAR(worldPoint, out) {
                this.node.getWorldMatrix(_worldMatrix);
                Mat4.invert(_mat4_temp$1, _worldMatrix);
                if (!out) {
                  out = new Vec3();
                }
                return Vec3.transformMat4(out, worldPoint, _mat4_temp$1);
              };
              _proto.convertToWorldSpaceAR = function convertToWorldSpaceAR(nodePoint, out) {
                this.node.getWorldMatrix(_worldMatrix);
                if (!out) {
                  out = new Vec3();
                }
                return Vec3.transformMat4(out, nodePoint, _worldMatrix);
              };
              _proto.getBoundingBox = function getBoundingBox() {
                var rect = new Rect();
                this._selfBoundingBox(rect);
                Mat4.fromSRT(_matrix, this.node.rotation, this.node.position, this.node.scale);
                rect.transformMat4(_matrix);
                return rect;
              };
              _proto.getBoundingBoxToWorld = function getBoundingBoxToWorld() {
                var rect = new Rect();
                var locChildren = this.node.children;
                for (var i = 0; i < locChildren.length; ++i) {
                  var child = locChildren[i];
                  if (child && child.active) {
                    var uiTransform = child.getComponent(UITransform);
                    if (uiTransform && uiTransform.contentSize.width && uiTransform.contentSize.height) {
                      uiTransform._selfBoundingBox(_rect);
                      _rect.transformMat4(child.worldMatrix);
                      if (rect.width === 0) {
                        rect.set(_rect);
                      } else {
                        Rect.union(rect, rect, _rect);
                      }
                    }
                  }
                }
                if (this._contentSize.width && this._contentSize.height) {
                  this._selfBoundingBox(_rect);
                  _rect.transformMat4(this.node.worldMatrix);
                  if (rect.width === 0) {
                    rect.set(_rect);
                  } else {
                    Rect.union(rect, rect, _rect);
                  }
                }
                return rect;
              };
              _proto.getBoundingBoxTo = function getBoundingBoxTo(targetMat) {
                var rect = new Rect();
                var locChildren = this.node.children;
                Mat4.invert(_mat4_temp$1, targetMat);
                for (var i = 0; i < locChildren.length; ++i) {
                  var child = locChildren[i];
                  if (child && child.active) {
                    var uiTransform = child.getComponent(UITransform);
                    if (uiTransform && uiTransform.contentSize.width && uiTransform.contentSize.height) {
                      uiTransform._selfBoundingBox(_rect);
                      Mat4.multiply(_matrix, child.worldMatrix, _mat4_temp$1);
                      _rect.transformMat4(_matrix);
                      if (rect.width === 0) {
                        rect.set(_rect);
                      } else {
                        Rect.union(rect, rect, _rect);
                      }
                    }
                  }
                }
                if (this._contentSize.width && this._contentSize.height) {
                  this._selfBoundingBox(_rect);
                  Mat4.multiply(_matrix, this.node.worldMatrix, _mat4_temp$1);
                  _rect.transformMat4(_matrix);
                  if (rect.width === 0) {
                    rect.set(_rect);
                  } else {
                    Rect.union(rect, rect, _rect);
                  }
                }
                return rect;
              };
              _proto.getComputeAABB = function getComputeAABB(out) {
                var width = this._contentSize.width;
                var height = this._contentSize.height;
                _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                _rect.transformMat4(this.node.worldMatrix);
                var px = _rect.x + _rect.width * 0.5;
                var py = _rect.y + _rect.height * 0.5;
                var pz = this.node.worldPosition.z;
                var w = _rect.width / 2;
                var h = _rect.height / 2;
                var l = 0.001;
                if (out != null) {
                  AABB.set(out, px, py, pz, w, h, l);
                  return out;
                } else {
                  return new AABB(px, py, pz, w, h, l);
                }
              };
              _proto._selfBoundingBox = function _selfBoundingBox(out) {
                var width = this._contentSize.width;
                var height = this._contentSize.height;
                out.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                return out;
              };
              _proto._parentChanged = function _parentChanged(node) {
                if (this.node.getComponent('cc.RenderRoot2D')) {
                  return;
                }
                if (this.node.parent) {
                  UITransform.insertChangeMap(this.node.parent);
                }
              };
              _proto._markRenderDataDirty = function _markRenderDataDirty() {
                var uiComp = this.node._uiProps.uiComp;
                if (uiComp) {
                  uiComp._markForUpdateRenderData();
                }
              };
              UITransform.insertChangeMap = function insertChangeMap(node) {
                var key = node.uuid;
                if (!UITransform.priorityChangeNodeMap.has(key)) {
                  UITransform.priorityChangeNodeMap.set(key, node);
                }
              };
              UITransform._sortChildrenSibling = function _sortChildrenSibling(node) {
                var siblings = node.children;
                if (siblings) {
                  siblings.sort(function (a, b) {
                    var aComp = a._getUITransformComp();
                    var bComp = b._getUITransformComp();
                    var ca = aComp ? aComp._priority : 0;
                    var cb = bComp ? bComp._priority : 0;
                    var diff = ca - cb;
                    if (diff === 0) return a.siblingIndex - b.siblingIndex;
                    return diff;
                  });
                }
              };
              UITransform._sortSiblings = function _sortSiblings() {
                UITransform.priorityChangeNodeMap.forEach(function (node, ID) {
                  UITransform._sortChildrenSibling(node);
                  node._updateSiblingIndex();
                  node.emit('childrenSiblingOrderChanged');
                });
                UITransform.priorityChangeNodeMap.clear();
              };
              UITransform._cleanChangeMap = function _cleanChangeMap() {
                UITransform.priorityChangeNodeMap.clear();
              };
              _createClass(UITransform, [{
                key: "contentSize",
                get: function get() {
                  return this._contentSize;
                },
                set: function set(value) {
                  if (this._contentSize.equals(value)) {
                    return;
                  }
                  {
                    this._contentSize.set(value);
                    this.node.emit("size-changed");
                  }
                  this._markRenderDataDirty();
                }
              }, {
                key: "width",
                get: function get() {
                  return this._contentSize.width;
                },
                set: function set(value) {
                  if (this._contentSize.width === value) {
                    return;
                  }
                  {
                    this._contentSize.width = value;
                    this.node.emit("size-changed");
                  }
                  this._markRenderDataDirty();
                }
              }, {
                key: "height",
                get: function get() {
                  return this._contentSize.height;
                },
                set: function set(value) {
                  if (this.contentSize.height === value) {
                    return;
                  }
                  {
                    this._contentSize.height = value;
                    this.node.emit("size-changed");
                  }
                  this._markRenderDataDirty();
                }
              }, {
                key: "anchorPoint",
                get: function get() {
                  return this._anchorPoint;
                },
                set: function set(value) {
                  if (this._anchorPoint.equals(value)) {
                    return;
                  }
                  this._anchorPoint.set(value);
                  this.node.emit("anchor-changed", this._anchorPoint);
                  this._markRenderDataDirty();
                }
              }, {
                key: "anchorX",
                get: function get() {
                  return this._anchorPoint.x;
                },
                set: function set(value) {
                  if (this._anchorPoint.x === value) {
                    return;
                  }
                  this._anchorPoint.x = value;
                  this.node.emit("anchor-changed", this._anchorPoint);
                  this._markRenderDataDirty();
                }
              }, {
                key: "anchorY",
                get: function get() {
                  return this._anchorPoint.y;
                },
                set: function set(value) {
                  if (this._anchorPoint.y === value) {
                    return;
                  }
                  this._anchorPoint.y = value;
                  this.node.emit("anchor-changed", this._anchorPoint);
                  this._markRenderDataDirty();
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(value) {
                  if (this._priority === value) {
                    return;
                  }
                  if (this.node.getComponent('cc.RenderRoot2D')) {
                    warnID(6706);
                    return;
                  }
                  this._priority = value;
                  if (this.node.parent) {
                    UITransform.insertChangeMap(this.node.parent);
                  }
                }
              }, {
                key: "visibility",
                get: function get() {
                  var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
                  return camera ? camera.visibility : 0;
                }
              }, {
                key: "cameraPriority",
                get: function get() {
                  var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
                  return camera ? camera.priority : 0;
                }
              }]);
              return UITransform;
            }(Component), _class3$2.EventType = NodeEventType, _class3$2.priorityChangeNodeMap = new Map(), _class3$2), (_initializer$4 = applyDecoratedInitializer(_class2$5.prototype, "_contentSize", [serializable$5], function () {
              return new Size(100, 100);
            }), _initializer2$4 = applyDecoratedInitializer(_class2$5.prototype, "_anchorPoint", [serializable$5], function () {
              return new Vec2(0.5, 0.5);
            })), _class2$5)) || _class$7) || _class$7) || _class$7);
            director.on("director_after_update", UITransform._sortSiblings);
            director.on("director_before_scene_launch", UITransform._cleanChangeMap);

            var _dec$6, _dec2$5, _dec3$5, _class$6;
            var RenderRoot2D = (_dec$6 = ccclass$6('cc.RenderRoot2D'), _dec2$5 = executionOrder$1(100), _dec3$5 = requireComponent(UITransform), _dec$6(_class$6 = _dec2$5(_class$6 = _dec3$5(_class$6 = disallowMultiple$1(_class$6 = function (_Component) {
              _inheritsLoose(RenderRoot2D, _Component);
              function RenderRoot2D() {
                return _Component.apply(this, arguments) || this;
              }
              var _proto = RenderRoot2D.prototype;
              _proto.onEnable = function onEnable() {
                cclegacy.director.root.batcher2D.addScreen(this);
              };
              _proto.onDisable = function onDisable() {
                cclegacy.director.root.batcher2D.removeScreen(this);
              };
              _proto.onDestroy = function onDestroy() {
                cclegacy.director.root.batcher2D.removeScreen(this);
              };
              return RenderRoot2D;
            }(Component)) || _class$6) || _class$6) || _class$6) || _class$6);

            var _dec$5, _dec2$4, _dec3$4, _dec4$1, _class$5, _class2$4, _initializer$3, _initializer2$3;
            var _worldPos = new Vec3();
            var Canvas = (_dec$5 = ccclass$6('cc.Canvas'), _dec2$4 = executionOrder$1(100), _dec3$4 = type$5(Camera), _dec4$1 = type$5(Camera), _dec$5(_class$5 = _dec2$4(_class$5 = disallowMultiple$1(_class$5 = (_class2$4 = function (_RenderRoot2D) {
              _inheritsLoose(Canvas, _RenderRoot2D);
              function Canvas() {
                var _this;
                _this = _RenderRoot2D.call(this) || this;
                _this._cameraComponent = _initializer$3 && _initializer$3();
                _this._alignCanvasWithScreen = _initializer2$3 && _initializer2$3();
                _this._pos = new Vec3();
                _this._renderMode = 0;
                _this._thisOnCameraResized = _this._onResizeCamera.bind(_assertThisInitialized(_this));
                return _this;
              }
              var _proto = Canvas.prototype;
              _proto.__preload = function __preload() {
                var widget = this.getComponent('cc.Widget');
                if (widget) {
                  widget.updateAlignment();
                }
                {
                  if (this._cameraComponent) {
                    this._cameraComponent._createCamera();
                    this._cameraComponent.node.on("tex-change", this._thisOnCameraResized);
                  }
                }
                this._onResizeCamera();
                {
                  view.on('canvas-resize', this._thisOnCameraResized, this);
                  view.on('design-resolution-changed', this._thisOnCameraResized, this);
                }
              };
              _proto.onEnable = function onEnable() {
                _RenderRoot2D.prototype.onEnable.call(this);
                if (this._cameraComponent) {
                  this._cameraComponent.node.on("tex-change", this._thisOnCameraResized);
                }
              };
              _proto.onDisable = function onDisable() {
                _RenderRoot2D.prototype.onDisable.call(this);
                if (this._cameraComponent) {
                  this._cameraComponent.node.off("tex-change", this._thisOnCameraResized);
                }
              };
              _proto.onDestroy = function onDestroy() {
                _RenderRoot2D.prototype.onDestroy.call(this);
                view.off('canvas-resize', this._thisOnCameraResized, this);
                view.off('design-resolution-changed', this._thisOnCameraResized, this);
              };
              _proto._onResizeCamera = function _onResizeCamera() {
                if (this._cameraComponent && this._alignCanvasWithScreen) {
                  if (this._cameraComponent.targetTexture) {
                    this._cameraComponent.orthoHeight = visibleRect.height / 2;
                  } else {
                    var size = screen$1.windowSize;
                    this._cameraComponent.orthoHeight = size.height / view.getScaleY() / 2;
                  }
                  this.node.getWorldPosition(_worldPos);
                  this._cameraComponent.node.setWorldPosition(_worldPos.x, _worldPos.y, 1000);
                }
              };
              _proto._getViewPriority = function _getViewPriority() {
                if (this._cameraComponent) {
                  var _this$cameraComponent;
                  var priority = (_this$cameraComponent = this.cameraComponent) == null ? undefined : _this$cameraComponent.priority;
                  priority = this._renderMode === 0 ? priority | 1 << 30 : priority & -1073741825;
                  return priority;
                }
                return 0;
              };
              _createClass(Canvas, [{
                key: "renderMode",
                get: function get() {
                  return this._renderMode;
                },
                set: function set(val) {
                  this._renderMode = val;
                  if (this._cameraComponent) {
                    this._cameraComponent.priority = this._getViewPriority();
                  }
                }
              }, {
                key: "cameraComponent",
                get: function get() {
                  return this._cameraComponent;
                },
                set: function set(value) {
                  if (this._cameraComponent === value) {
                    return;
                  }
                  this._cameraComponent = value;
                  this._onResizeCamera();
                }
              }, {
                key: "alignCanvasWithScreen",
                get: function get() {
                  return this._alignCanvasWithScreen;
                },
                set: function set(value) {
                  this._alignCanvasWithScreen = value;
                  this._onResizeCamera();
                }
              }]);
              return Canvas;
            }(RenderRoot2D), (_applyDecoratedDescriptor(_class2$4.prototype, "cameraComponent", [_dec3$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "cameraComponent"), _class2$4.prototype), _initializer$3 = applyDecoratedInitializer(_class2$4.prototype, "_cameraComponent", [_dec4$1], function () {
              return null;
            }), _initializer2$3 = applyDecoratedInitializer(_class2$4.prototype, "_alignCanvasWithScreen", [serializable$5], function () {
              return true;
            })), _class2$4)) || _class$5) || _class$5) || _class$5);
            cclegacy.Canvas = Canvas;

            var _dec$4, _dec2$3, _dec3$3, _class$4;
            var UIComponent = (_dec$4 = ccclass$6('cc.UIComponent'), _dec2$3 = requireComponent(UITransform), _dec3$3 = executionOrder$1(110), _dec$4(_class$4 = _dec2$3(_class$4 = _dec3$3(_class$4 = disallowMultiple$1(_class$4 = function (_Component) {
              _inheritsLoose(UIComponent, _Component);
              function UIComponent() {
                var _this;
                _this = _Component.call(this) || this;
                _this._lastParent = null;
                _this.stencilStage = 0;
                return _this;
              }
              var _proto = UIComponent.prototype;
              _proto.__preload = function __preload() {
                this.node._uiProps.uiComp = this;
              };
              _proto.onEnable = function onEnable() {};
              _proto.onDisable = function onDisable() {};
              _proto.onDestroy = function onDestroy() {
                var uiProps = this.node._uiProps;
                if (uiProps.uiComp === this) {
                  uiProps.uiComp = null;
                }
              };
              _proto.postUpdateAssembler = function postUpdateAssembler(render) {};
              _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
              };
              _proto.setNodeDirty = function setNodeDirty() {};
              _proto.setTextureDirty = function setTextureDirty() {};
              return UIComponent;
            }(Component)) || _class$4) || _class$4) || _class$4) || _class$4);

            var ATTR_POSITION = "a_position";
            var ATTR_COLOR = "a_color";
            var ATTR_TEX_COORD = "a_texCoord";
            var ATTR_COLOR2 = "a_color2";
            [new Attribute(ATTR_POSITION, 32)];
            [new Attribute(ATTR_POSITION, 32), new Attribute(ATTR_COLOR, 44)];
            var vfmtPosUvColor = [new Attribute(ATTR_POSITION, 32), new Attribute(ATTR_TEX_COORD, 21), new Attribute(ATTR_COLOR, 44)];
            var vfmtPosUvColor4B = [new Attribute(ATTR_POSITION, 32), new Attribute(ATTR_TEX_COORD, 21), new Attribute(ATTR_COLOR, 35, true)];
            var vfmtPosUvTwoColor = [new Attribute(ATTR_POSITION, 32), new Attribute(ATTR_TEX_COORD, 21), new Attribute(ATTR_COLOR, 44), new Attribute(ATTR_COLOR2, 44)];
            var vfmtPosUvTwoColor4B = [new Attribute(ATTR_POSITION, 32), new Attribute(ATTR_TEX_COORD, 21), new Attribute(ATTR_COLOR, 35, true), new Attribute(ATTR_COLOR2, 35, true)];
            function getAttributeStride(attrs) {
              var count = 0;
              for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                var info = FormatInfos[attr.format];
                count += info.size;
              }
              return count;
            }
            cclegacy.internal.vfmtPosUvColor = vfmtPosUvColor;
            cclegacy.internal.vfmtPosUvTwoColor = vfmtPosUvTwoColor;
            cclegacy.internal.vfmtPosUvColor4B = vfmtPosUvColor4B;
            cclegacy.internal.vfmtPosUvTwoColor4B = vfmtPosUvTwoColor4B;

            var IA_POOL_USED_SCALE = 1 / 2;
            var MeshBuffer = function () {
              var _proto = MeshBuffer.prototype;
              _proto.initSharedBuffer = function initSharedBuffer() {
              };
              _proto.syncSharedBufferToNative = function syncSharedBufferToNative() {
              };
              function MeshBuffer() {
                this._byteOffset = 0;
                this._vertexOffset = 0;
                this._indexOffset = 0;
                this._dirty = false;
                this._floatsPerVertex = 0;
                this._vData = null;
                this._iData = null;
                this._vertexFormatBytes = 0;
                this._initVDataCount = 0;
                this._initIDataCount = 0;
                this._attributes = null;
                this._iaPool = [];
                this._iaInfo = null;
                this._nextFreeIAHandle = 0;
              }
              _proto.initialize = function initialize(device, attrs, vFloatCount, iCount) {
                this._initVDataCount = vFloatCount;
                this._initIDataCount = iCount;
                this._attributes = attrs;
                this.floatsPerVertex = getAttributeStride(attrs) >> 2;
                assertIsTrue(this._initVDataCount / this._floatsPerVertex < 65536, getError(9005));
                if (!this.vData || !this.iData) {
                  this.vData = new Float32Array(this._initVDataCount);
                  this.iData = new Uint16Array(this._initIDataCount);
                }
                this._iaPool.push(this.createNewIA(device));
              };
              _proto.reset = function reset() {
                this._nextFreeIAHandle = 0;
                this.dirty = false;
              };
              _proto.destroy = function destroy() {
                this.reset();
                this._attributes = null;
                this._iaInfo = null;
                this.vData = null;
                this.iData = null;
                for (var i = 0; i < this._iaPool.length; ++i) {
                  var iaRef = this._iaPool[i];
                  var vertexBuffer0 = iaRef.vertexBuffers[0];
                  if (vertexBuffer0) {
                    vertexBuffer0.destroy();
                  }
                  var indexBuffer = iaRef.indexBuffer;
                  if (indexBuffer) {
                    indexBuffer.destroy();
                  }
                  iaRef.ia.destroy();
                }
                this._iaPool.length = 0;
              };
              _proto.setDirty = function setDirty() {
                this.dirty = true;
              };
              _proto.request = function request(vertexCount, indexCount) {
                warnID(9002);
                return false;
              };
              _proto.requireFreeIA = function requireFreeIA(device) {
                if (this._iaPool.length <= this._nextFreeIAHandle) {
                  this._iaPool.push(this.createNewIA(device));
                }
                var ia = this._iaPool[this._nextFreeIAHandle++].ia;
                return ia;
              };
              _proto.recycleIA = function recycleIA(ia) {
                var pool = this._iaPool;
                for (var i = 0; i < this._nextFreeIAHandle; ++i) {
                  if (ia === pool[i].ia) {
                    var iaRef = pool[i];
                    pool[i] = pool[--this._nextFreeIAHandle];
                    pool[this._nextFreeIAHandle] = iaRef;
                    return;
                  }
                }
              };
              _proto.checkCapacity = function checkCapacity(vertexCount, indexCount) {
                var maxVertex = (this.vertexOffset + vertexCount) * this._floatsPerVertex;
                var maxIndex = this.indexOffset + indexCount;
                if (maxVertex > this._initVDataCount || maxIndex > this._initIDataCount) {
                  return false;
                }
                return true;
              };
              _proto.uploadBuffers = function uploadBuffers() {
                if (this.byteOffset === 0 || !this._dirty) {
                  return;
                }
                var iOS14 = sys.__isWebIOS14OrIPadOS14Env;
                var submitCount = iOS14 ? this._nextFreeIAHandle : 1;
                if (iOS14 && submitCount / this._iaPool.length < IA_POOL_USED_SCALE) {
                  var count = submitCount / IA_POOL_USED_SCALE;
                  var length = this._iaPool.length;
                  for (var i = length - 1; i >= count; i--) {
                    var iaRef = this._iaPool[i];
                    if (iaRef.vertexBuffers[0]) {
                      iaRef.vertexBuffers[0].destroy();
                    }
                    if (iaRef.indexBuffer) {
                      iaRef.indexBuffer.destroy();
                    }
                    iaRef.ia.destroy();
                  }
                  this._iaPool.length = count;
                }
                var byteCount = this.byteOffset;
                var indexCount = this.indexOffset;
                for (var _i = 0; _i < submitCount; ++_i) {
                  var _iaRef = this._iaPool[_i];
                  var verticesData = new Float32Array(this.vData.buffer, 0, byteCount >> 2);
                  var indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
                  var vertexBuffer = _iaRef.vertexBuffers[0];
                  if (byteCount > vertexBuffer.size) {
                    vertexBuffer.resize(byteCount);
                  }
                  vertexBuffer.update(verticesData);
                  if (indexCount * 2 > _iaRef.indexBuffer.size) {
                    _iaRef.indexBuffer.resize(indexCount * 2);
                  }
                  _iaRef.indexBuffer.update(indicesData);
                }
                this.dirty = false;
              };
              _proto.createNewIA = function createNewIA(device) {
                var ia;
                var vertexBuffers;
                var indexBuffer;
                if (sys.__isWebIOS14OrIPadOS14Env || !this._iaPool[0]) {
                  var vbStride = this._vertexFormatBytes = this._floatsPerVertex * 4;
                  var ibStride = 2;
                  var vertexBuffer = device.createBuffer(new BufferInfo(8 | 2, 2 | 1, vbStride, vbStride));
                  indexBuffer = device.createBuffer(new BufferInfo(4 | 2, 2 | 1, ibStride, ibStride));
                  vertexBuffers = [vertexBuffer];
                  this._iaInfo = new InputAssemblerInfo(this._attributes, vertexBuffers, indexBuffer);
                  ia = device.createInputAssembler(this._iaInfo);
                } else {
                  ia = device.createInputAssembler(this._iaInfo);
                  vertexBuffers = this._iaInfo.vertexBuffers;
                  indexBuffer = this._iaInfo.indexBuffer;
                }
                return {
                  ia: ia,
                  vertexBuffers: vertexBuffers,
                  indexBuffer: indexBuffer
                };
              };
              _createClass(MeshBuffer, [{
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
              }, {
                key: "vertexFormatBytes",
                get: function get() {
                  return this._vertexFormatBytes;
                }
              }, {
                key: "byteOffset",
                get: function get() {
                  return this._byteOffset;
                },
                set: function set(val) {
                  this._byteOffset = val;
                }
              }, {
                key: "vertexOffset",
                get: function get() {
                  return this._vertexOffset;
                },
                set: function set(val) {
                  this._vertexOffset = val;
                }
              }, {
                key: "indexOffset",
                get: function get() {
                  return this._indexOffset;
                },
                set: function set(val) {
                  this._indexOffset = val;
                }
              }, {
                key: "dirty",
                get: function get() {
                  return this._dirty;
                },
                set: function set(val) {
                  this._dirty = val;
                }
              }, {
                key: "floatsPerVertex",
                get: function get() {
                  return this._floatsPerVertex;
                },
                set: function set(val) {
                  this._floatsPerVertex = val;
                }
              }, {
                key: "vData",
                get: function get() {
                  return this._vData;
                },
                set: function set(val) {
                  this._vData = val;
                }
              }, {
                key: "iData",
                get: function get() {
                  return this._iData;
                },
                set: function set(val) {
                  this._iData = val;
                }
              }, {
                key: "nativeObj",
                get: function get() {
                  return this._nativeObj;
                }
              }, {
                key: "sharedBuffer",
                get: function get() {
                  return this._sharedBuffer;
                }
              }]);
              return MeshBuffer;
            }();

            var BufferAccessor = function () {
              function BufferAccessor(device, attributes) {
                this._buffers = [];
                this._device = device;
                this._attributes = attributes;
                this._floatsPerVertex = getAttributeStride(attributes) >> 2;
                this._vertexFormatBytes = this._floatsPerVertex * 4;
              }
              var _proto = BufferAccessor.prototype;
              _proto.initialize = function initialize() {};
              _proto.reset = function reset() {};
              _proto.request = function request(vertexCount, indexCount) {
              };
              _proto.appendBuffers = function appendBuffers(vertices, indices) {};
              _proto.uploadBuffers = function uploadBuffers() {};
              _proto.destroy = function destroy() {
                this._attributes.length = 0;
              };
              _createClass(BufferAccessor, [{
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
              }, {
                key: "vertexFormatBytes",
                get: function get() {
                  return this._vertexFormatBytes;
                }
              }, {
                key: "floatsPerVertex",
                get: function get() {
                  return this._floatsPerVertex;
                }
              }]);
              return BufferAccessor;
            }();

            var _entryPool = new Pool(function () {
              return {
                offset: 0,
                length: 0
              };
            }, 32);
            var StaticVBChunk = function () {
              function StaticVBChunk(vertexAccessor, bufferId, meshBuffer, vertexOffset, vb, indexCount) {
                this.vertexAccessor = vertexAccessor;
                this.bufferId = bufferId;
                this.meshBuffer = meshBuffer;
                this.vertexOffset = vertexOffset;
                this.vb = vb;
                this.indexCount = indexCount;
                assertIsTrue(meshBuffer === vertexAccessor.getMeshBuffer(bufferId));
              }
              var _proto = StaticVBChunk.prototype;
              _proto.setIndexBuffer = function setIndexBuffer(indices) {
              };
              _createClass(StaticVBChunk, [{
                key: "ib",
                get: function get() {
                  return this._ib;
                }
              }]);
              return StaticVBChunk;
            }();
            var StaticVBAccessor = function (_BufferAccessor) {
              _inheritsLoose(StaticVBAccessor, _BufferAccessor);
              function StaticVBAccessor(device, attributes, vCount, iCount) {
                var _this;
                _this = _BufferAccessor.call(this, device, attributes) || this;
                _this._freeLists = [];
                _this._vCount = 0;
                _this._iCount = 0;
                _this._id = 0;
                _this._vCount = vCount || Math.floor(macro.BATCHER2D_MEM_INCREMENT * 1024 / _this._vertexFormatBytes);
                _this._iCount = iCount || _this._vCount * StaticVBAccessor.IB_SCALE;
                _this._id = StaticVBAccessor.generateID();
                _this._allocateBuffer();
                return _this;
              }
              var _proto2 = StaticVBAccessor.prototype;
              _proto2.destroy = function destroy() {
                for (var i = 0; i < this._buffers.length; ++i) {
                  this._buffers[i].destroy();
                  var freeList = this._freeLists[i];
                  for (var j = 0; j < freeList.length; ++j) {
                    _entryPool.free(freeList[j]);
                  }
                }
                this._buffers.length = 0;
                this._freeLists.length = 0;
                _BufferAccessor.prototype.destroy.call(this);
              };
              _proto2.reset = function reset() {
                for (var i = 0; i < this._buffers.length; ++i) {
                  var buffer = this._buffers[i];
                  buffer.indexOffset = 0;
                  buffer.reset();
                }
              };
              _proto2.getVertexBuffer = function getVertexBuffer(bid) {
                return this._buffers[bid].vData;
              };
              _proto2.getIndexBuffer = function getIndexBuffer(bid) {
                return this._buffers[bid].iData;
              };
              _proto2.getMeshBuffer = function getMeshBuffer(bid) {
                return this._buffers[bid];
              };
              _proto2.uploadBuffers = function uploadBuffers() {
                for (var i = 0; i < this._buffers.length; ++i) {
                  var firstEntry = this._freeLists[i][0];
                  var buffer = this._buffers[i];
                  if (!firstEntry || firstEntry.length < buffer.vData.byteLength) {
                    buffer.uploadBuffers();
                  }
                }
              };
              _proto2.appendIndices = function appendIndices(bufferId, indices) {
                var buf = this._buffers[bufferId];
                var iCount = indices.length;
                if (iCount) {
                  var needLength = buf.indexOffset + indices.length;
                  if (buf.iData.length < needLength) {
                    var expansionLength = Math.floor(1.25 * needLength);
                    var newIData = new Uint16Array(expansionLength);
                    newIData.set(buf.iData);
                    buf.iData = newIData;
                  }
                  buf.iData.set(indices, buf.indexOffset);
                  buf.indexOffset += indices.length;
                }
              };
              _proto2.allocateChunk = function allocateChunk(vertexCount, indexCount) {
                var byteLength = vertexCount * this.vertexFormatBytes;
                if (vertexCount > this._vCount || indexCount > this._iCount) {
                  errorID(9004, byteLength);
                  return null;
                }
                var buf = null;
                var freeList;
                var bid = 0;
                var eid = -1;
                var entry = null;
                for (var i = 0; i < this._buffers.length; ++i) {
                  buf = this._buffers[i];
                  freeList = this._freeLists[i];
                  for (var e = 0; e < freeList.length; ++e) {
                    if (freeList[e].length >= byteLength) {
                      entry = freeList[e];
                      bid = i;
                      eid = e;
                      break;
                    }
                  }
                  if (entry) break;
                }
                if (!entry) {
                  bid = this._allocateBuffer();
                  buf = this._buffers[bid];
                  if (buf) {
                    eid = 0;
                    entry = this._freeLists[bid][eid];
                  }
                }
                if (entry) {
                  var _vertexOffset = entry.offset / this.vertexFormatBytes;
                  assertIsTrue(Number.isInteger(_vertexOffset));
                  var _vb = new Float32Array(buf.vData.buffer, entry.offset, byteLength >> 2).fill(0);
                  this._allocateChunkFromEntry(bid, eid, entry, byteLength);
                  return new StaticVBChunk(this, bid, buf, _vertexOffset, _vb, indexCount);
                } else {
                  return null;
                }
              };
              _proto2.recycleChunk = function recycleChunk(chunk) {
                var freeList = this._freeLists[chunk.bufferId];
                var buf = this._buffers[chunk.bufferId];
                var offset = chunk.vertexOffset * this.vertexFormatBytes;
                var bytes = chunk.vb.byteLength;
                if (bytes === 0) return;
                var recycled = false;
                var i = 0;
                var prevEntry = null;
                var nextEntry = freeList[i];
                while (nextEntry && nextEntry.offset < offset) {
                  prevEntry = nextEntry;
                  nextEntry = freeList[++i];
                }
                if (prevEntry) {
                  var distance = offset - (prevEntry.offset + prevEntry.length);
                  assertIsTrue(distance >= 0);
                  if (distance === 0) {
                    prevEntry.length += bytes;
                    offset = prevEntry.offset;
                    bytes = prevEntry.length;
                    if (nextEntry && nextEntry.offset - (offset + bytes) === 0) {
                      prevEntry.length += nextEntry.length;
                      freeList.splice(i, 1);
                      _entryPool.free(nextEntry);
                      nextEntry = null;
                    }
                    recycled = true;
                  }
                }
                if (!recycled && nextEntry) {
                  var _distance = nextEntry.offset - (offset + bytes);
                  assertIsTrue(_distance >= 0);
                  if (_distance === 0) {
                    nextEntry.offset = offset;
                    nextEntry.length += bytes;
                  } else {
                    var newEntry = _entryPool.alloc();
                    newEntry.offset = offset;
                    newEntry.length = bytes;
                    freeList.splice(i, 0, newEntry);
                  }
                  recycled = true;
                }
                if (recycled) {
                  if (offset + bytes === buf.byteOffset) {
                    buf.byteOffset = offset;
                  }
                } else {
                  var _newEntry = _entryPool.alloc();
                  _newEntry.offset = offset;
                  _newEntry.length = bytes;
                  freeList.push(_newEntry);
                }
              };
              _proto2._allocateChunkFromEntry = function _allocateChunkFromEntry(bid, eid, entry, bytes) {
                var remaining = entry.length - bytes;
                var offset = entry.offset + bytes;
                var buf = this._buffers[bid];
                if (buf.byteOffset < offset) {
                  buf.byteOffset = offset;
                }
                assertID(remaining >= 0, 9004, bid, entry.offset, entry.length);
                if (remaining === 0) {
                  this._freeLists[bid].splice(eid, 1);
                  _entryPool.free(entry);
                } else {
                  entry.offset += bytes;
                  entry.length = remaining;
                }
              };
              _proto2._allocateBuffer = function _allocateBuffer() {
                assertID(this._buffers.length === this._freeLists.length, 9003);
                var buffer = new MeshBuffer();
                var vFloatCount = this._vCount * this._floatsPerVertex;
                buffer.initialize(this._device, this._attributes, vFloatCount, this._iCount);
                this._buffers.push(buffer);
                var entry = _entryPool.alloc();
                entry.offset = 0;
                entry.length = buffer.vData.byteLength;
                var freeList = [entry];
                this._freeLists.push(freeList);
                var batcher = director.root.batcher2D;
                batcher.syncMeshBuffersToNative(this.id, this._buffers);
                return this._buffers.length - 1;
              };
              StaticVBAccessor.generateID = function generateID() {
                return StaticVBAccessor.ID_COUNT++;
              };
              _createClass(StaticVBAccessor, [{
                key: "id",
                get: function get() {
                  return this._id;
                }
              }]);
              return StaticVBAccessor;
            }(BufferAccessor);
            StaticVBAccessor.IB_SCALE = 4;
            StaticVBAccessor.ID_COUNT = 0;

            (function () {
              function RenderDrawInfo(nativeDrawInfo) {
                this._accId = -1;
                this._bufferId = -1;
                this._vertexOffset = 0;
                this._indexOffset = 0;
                this._vb = null;
                this._ib = null;
                this._vData = null;
                this._iData = null;
                this._vertDirty = false;
                this._vbCount = 0;
                this._ibCount = 0;
                this._dataHash = 0;
                this._isMeshBuffer = false;
                this._material = null;
                this._texture = null;
                this._sampler = null;
                this._stride = 0;
                this._useLocal = false;
                this._model = null;
                this._drawInfoType = 0;
                this._subNode = null;
                this._render2dBuffer = null;
              }
              var _proto = RenderDrawInfo.prototype;
              _proto.init = function init(nativeDrawInfo) {
              };
              _proto.clear = function clear() {
                return;
              };
              _proto.setAccId = function setAccId(accId) {
                this._accId = accId;
              };
              _proto.setBufferId = function setBufferId(bufferId) {
                this._bufferId = bufferId;
              };
              _proto.setAccAndBuffer = function setAccAndBuffer(accId, bufferId) {
                this._bufferId = bufferId;
                this._accId = accId;
              };
              _proto.setVertexOffset = function setVertexOffset(vertexOffset) {
                this._vertexOffset = vertexOffset;
              };
              _proto.setIndexOffset = function setIndexOffset(indexOffset) {
                this._indexOffset = indexOffset;
              };
              _proto.setVB = function setVB(vbBuffer) {
              };
              _proto.setIB = function setIB(ibBuffer) {
              };
              _proto.setVData = function setVData(vDataBuffer) {
              };
              _proto.setIData = function setIData(iDataBuffer) {
              };
              _proto.setVBCount = function setVBCount(vbCount) {
                this._vbCount = vbCount;
              };
              _proto.setIBCount = function setIBCount(ibCount) {
              };
              _proto.setVertDirty = function setVertDirty(val) {
                this._vertDirty = val;
              };
              _proto.setDataHash = function setDataHash(dataHash) {
                this._dataHash = dataHash;
              };
              _proto.setIsMeshBuffer = function setIsMeshBuffer(isMeshBuffer) {
                this._isMeshBuffer = isMeshBuffer;
              };
              _proto.setVertexPositionInWorld = function setVertexPositionInWorld(isVertexPositionInWorld) {
              };
              _proto.setMaterial = function setMaterial(material) {
                this._material = material;
              };
              _proto.setTexture = function setTexture(texture) {
                this._texture = texture;
              };
              _proto.setSampler = function setSampler(sampler) {
                this._sampler = sampler;
              };
              _proto.setModel = function setModel(model) {
              };
              _proto.setDrawInfoType = function setDrawInfoType(drawInfoType) {
                this._drawInfoType = drawInfoType;
              };
              _proto.setSubNode = function setSubNode(node) {
                this._subNode = node;
              };
              _proto.setStride = function setStride(stride) {
                this._stride = stride;
              };
              _proto.initRender2dBuffer = function initRender2dBuffer() {
              };
              _proto.fillRender2dBuffer = function fillRender2dBuffer(vertexDataArr) {
              };
              _createClass(RenderDrawInfo, [{
                key: "nativeObj",
                get: function get() {
                  return this._nativeObj;
                }
              }, {
                key: "render2dBuffer",
                get: function get() {
                  return this._render2dBuffer;
                }
              }]);
              return RenderDrawInfo;
            })();

            var DEFAULT_STRIDE = getAttributeStride(vfmtPosUvColor) >> 2;
            var BaseRenderData = function () {
              function BaseRenderData(vertexFormat) {
                if (vertexFormat === undefined) {
                  vertexFormat = vfmtPosUvColor;
                }
                this.chunk = null;
                this._renderDrawInfo = null;
                this._material = null;
                this._dataHash = 0;
                this._isMeshBuffer = false;
                this._vc = 0;
                this._ic = 0;
                this._floatStride = 0;
                this._vertexFormat = vfmtPosUvColor;
                this._drawInfoType = 0;
                this._multiOwner = false;
                this._batcher = null;
                this._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
                this._vertexFormat = vertexFormat;
              }
              var _proto = BaseRenderData.prototype;
              _proto.isValid = function isValid() {
                return this._ic > 0 && this.chunk.vertexAccessor;
              };
              _proto.initRenderDrawInfo = function initRenderDrawInfo(comp, drawInfoType) {
              };
              _proto.removeRenderDrawInfo = function removeRenderDrawInfo(comp) {
              };
              _proto.setRenderDrawInfoAttributes = function setRenderDrawInfoAttributes() {
              };
              _createClass(BaseRenderData, [{
                key: "vertexCount",
                get: function get() {
                  return this._vc;
                }
              }, {
                key: "indexCount",
                get: function get() {
                  return this._ic;
                }
              }, {
                key: "stride",
                get: function get() {
                  return this._floatStride << 2;
                }
              }, {
                key: "floatStride",
                get: function get() {
                  return this._floatStride;
                }
              }, {
                key: "vertexFormat",
                get: function get() {
                  return this._vertexFormat;
                }
              }, {
                key: "drawInfoType",
                get: function get() {
                  return this._drawInfoType;
                },
                set: function set(type) {
                  this._drawInfoType = type;
                }
              }, {
                key: "renderDrawInfo",
                get: function get() {
                  return this._renderDrawInfo;
                }
              }, {
                key: "material",
                get: function get() {
                  return this._material;
                },
                set: function set(val) {
                  this._material = val;
                }
              }, {
                key: "dataHash",
                get: function get() {
                  return this._dataHash;
                },
                set: function set(val) {
                  this._dataHash = val;
                }
              }, {
                key: "multiOwner",
                get: function get() {
                  return this._multiOwner;
                },
                set: function set(val) {
                  this._multiOwner = val;
                }
              }, {
                key: "batcher",
                get: function get() {
                  if (!this._batcher) {
                    this._batcher = director.root.batcher2D;
                  }
                  return this._batcher;
                }
              }]);
              return BaseRenderData;
            }();
            var RenderData = function (_BaseRenderData) {
              _inheritsLoose(RenderData, _BaseRenderData);
              RenderData.add = function add(vertexFormat, accessor) {
                if (vertexFormat === undefined) {
                  vertexFormat = vfmtPosUvColor;
                }
                if (accessor === undefined) {
                  accessor = null;
                }
                var rd = new RenderData(vertexFormat, accessor);
                if (!accessor) {
                  var batcher = director.root.batcher2D;
                  accessor = batcher.switchBufferAccessor(rd._vertexFormat);
                }
                rd._accessor = accessor;
                return rd;
              };
              RenderData.remove = function remove(data) {
                data.clear();
                data._accessor = null;
              };
              function RenderData(vertexFormat, accessor) {
                var _this;
                if (vertexFormat === undefined) {
                  vertexFormat = vfmtPosUvColor;
                }
                if (accessor === undefined) {
                  accessor = null;
                }
                _this = _BaseRenderData.call(this, vertexFormat) || this;
                _this._vertDirty = true;
                _this._textureHash = 0;
                _this.indices = null;
                _this.layer = 0;
                _this.nodeDirty = true;
                _this.passDirty = true;
                _this.textureDirty = true;
                _this.hashDirty = true;
                _this._data = [];
                _this._frame = null;
                _this._accessor = null;
                _this.vertexRow = 1;
                _this.vertexCol = 1;
                if (!accessor) {
                  accessor = _this.batcher.switchBufferAccessor(_this._vertexFormat);
                }
                _this._accessor = accessor;
                return _this;
              }
              var _proto2 = RenderData.prototype;
              _proto2.resize = function resize(vertexCount, indexCount) {
                if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
                this._vc = vertexCount;
                this._ic = indexCount;
                if (this.chunk) {
                  this._accessor.recycleChunk(this.chunk);
                  this.chunk = null;
                }
                this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);
                this.updateHash();
              };
              _proto2.setRenderDrawInfoAttributes = function setRenderDrawInfoAttributes() {
              };
              _proto2.fillDrawInfoAttributes = function fillDrawInfoAttributes(drawInfo) {
              };
              _proto2.syncRender2dBuffer = function syncRender2dBuffer() {
              };
              _proto2.resizeAndCopy = function resizeAndCopy(vertexCount, indexCount) {
                if (vertexCount === this._vc && indexCount === this._ic && this.chunk) return;
                this._vc = vertexCount;
                this._ic = indexCount;
                var oldChunk = this.chunk;
                this.chunk = this._accessor.allocateChunk(vertexCount, indexCount);
                if (oldChunk) {
                  this.chunk.vb.set(oldChunk.vb);
                  this._accessor.recycleChunk(oldChunk);
                }
                this.updateHash();
              };
              _proto2.getMeshBuffer = function getMeshBuffer() {
                if (this.chunk && this._accessor) {
                  return this._accessor.getMeshBuffer(this.chunk.bufferId);
                } else {
                  return null;
                }
              };
              _proto2.updateNode = function updateNode(comp) {
                this.layer = comp.node.layer;
                this.nodeDirty = false;
                this.hashDirty = true;
              };
              _proto2.updatePass = function updatePass(comp) {
                this.material = comp.getRenderMaterial(0);
                this.passDirty = false;
                this.hashDirty = true;
              };
              _proto2.updateTexture = function updateTexture(frame) {
                this.frame = frame;
                this.textureHash = frame.getHash();
                this.textureDirty = false;
                this.hashDirty = true;
              };
              _proto2.updateHash = function updateHash() {
                var bid = this.chunk ? this.chunk.bufferId : -1;
                var hashString = "" + bid + this.layer + " " + this.textureHash;
                this.dataHash = murmurhash2_32_gc(hashString, 666);
                this.hashDirty = false;
              };
              _proto2.updateRenderData = function updateRenderData(comp, frame) {
                if (this.passDirty) {
                  this.material = comp.getRenderMaterial(0);
                  this.passDirty = false;
                  this.hashDirty = true;
                }
                if (this.nodeDirty) {
                  var renderScene = comp.node.scene ? comp._getRenderScene() : null;
                  this.layer = comp.node.layer;
                  if (renderScene !== null) {
                    this.nodeDirty = false;
                  }
                  this.hashDirty = true;
                }
                if (this.textureDirty) {
                  this.frame = frame;
                  this.textureHash = frame.getHash();
                  this.textureDirty = false;
                  this.hashDirty = true;
                }
                if (this.hashDirty) {
                  this.updateHash();
                }
              };
              _proto2.clear = function clear() {
                this.resize(0, 0);
                this._data.length = 0;
                this.indices = null;
                this.vertDirty = true;
                this.material = null;
                this.nodeDirty = true;
                this.passDirty = true;
                this.textureDirty = true;
                this.hashDirty = true;
                this.layer = 0;
                this.frame = null;
                this.textureHash = 0;
                this.dataHash = 0;
              };
              RenderData.createStaticVBAccessor = function createStaticVBAccessor(attributes, vCount, iCount) {
                var device = director.root.device;
                var accessor = new StaticVBAccessor(device, attributes, vCount, iCount);
                return accessor;
              };
              _createClass(RenderData, [{
                key: "dataLength",
                get: function get() {
                  return this._data.length;
                },
                set: function set(length) {
                  var data = this._data;
                  if (data.length !== length) {
                    for (var i = data.length; i < length; i++) {
                      data.push({
                        x: 0,
                        y: 0,
                        z: 0,
                        u: 0,
                        v: 0,
                        color: Color.WHITE.clone()
                      });
                    }
                    data.length = length;
                  }
                  this.syncRender2dBuffer();
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }, {
                key: "vertDirty",
                get: function get() {
                  return this._vertDirty;
                },
                set: function set(val) {
                  this._vertDirty = val;
                }
              }, {
                key: "textureHash",
                get: function get() {
                  return this._textureHash;
                },
                set: function set(val) {
                  this._textureHash = val;
                }
              }, {
                key: "frame",
                get: function get() {
                  return this._frame;
                },
                set: function set(val) {
                  this._frame = val;
                }
              }, {
                key: "accessor",
                get: function get() {
                  return this._accessor;
                }
              }]);
              return RenderData;
            }(BaseRenderData);
            (function (_BaseRenderData2) {
              _inheritsLoose(MeshRenderData, _BaseRenderData2);
              MeshRenderData.add = function add(vertexFormat) {
                if (vertexFormat === undefined) {
                  vertexFormat = vfmtPosUvColor;
                }
                var rd = new MeshRenderData();
                rd._floatStride = vertexFormat === vfmtPosUvColor ? DEFAULT_STRIDE : getAttributeStride(vertexFormat) >> 2;
                rd._vertexFormat = vertexFormat;
                return rd;
              };
              MeshRenderData.remove = function remove(data) {
                data.clear();
              };
              function MeshRenderData(vertexFormat) {
                var _this2;
                if (vertexFormat === undefined) {
                  vertexFormat = vfmtPosUvColor;
                }
                _this2 = _BaseRenderData2.call(this, vertexFormat) || this;
                _this2._isMeshBuffer = true;
                _this2.vertexStart = 0;
                _this2.vertexRange = 0;
                _this2.indexStart = 0;
                _this2.indexRange = 0;
                _this2.lastFilledIndex = 0;
                _this2.lastFilledVertex = 0;
                _this2.frame = null;
                _this2._byteLength = 0;
                _this2._vertexBuffers = [];
                _this2._indexBuffer = null;
                _this2._iaPool = null;
                _this2._iaInfo = null;
                _this2.vData = new Float32Array(256 * _this2.stride);
                _this2.iData = new Uint16Array(256 * 6);
                return _this2;
              }
              var _proto3 = MeshRenderData.prototype;
              _proto3.request = function request(vertexCount, indexCount) {
                var byteOffset = this._byteLength + vertexCount * this.stride;
                var succeed = this.reserve(vertexCount, indexCount);
                if (!succeed) return false;
                this._vc += vertexCount;
                this._ic += indexCount;
                this._byteLength = byteOffset;
                this.vertexRange = this._vc;
                this.indexRange = this._ic;
                return true;
              };
              _proto3.reserve = function reserve(vertexCount, indexCount) {
                var newVBytes = this._byteLength + vertexCount * this.stride;
                var newICount = this.indexCount + indexCount;
                if (vertexCount + this.vertexCount > 65535) {
                  return false;
                }
                var byteLength = this.vData.byteLength;
                var indicesLength = this.iData.length;
                var vCount = this.vData.length;
                var iCount = this.iData.length;
                if (newVBytes > byteLength || newICount > indicesLength) {
                  while (byteLength < newVBytes || indicesLength < newICount) {
                    vCount *= 2;
                    iCount *= 2;
                    byteLength = vCount * 4;
                    indicesLength = iCount;
                  }
                  this._reallocBuffer(vCount, iCount);
                }
                return true;
              };
              _proto3.resize = function resize(vertexCount, indexCount) {
                var byteLength = vertexCount * this.stride;
                assertIsTrue(vertexCount >= 0 && indexCount >= 0 && byteLength <= this.vData.byteLength && indexCount <= this.iData.length);
                this._vc = vertexCount;
                this._ic = indexCount;
                this._byteLength = byteLength;
                this.updateRange(0, vertexCount, 0, indexCount);
              };
              _proto3.updateRange = function updateRange(vertOffset, vertexCount, indexOffset, indexCount) {
                assertIsTrue(vertexCount >= 0 && indexCount >= 0 && vertexCount <= this._vc && indexCount <= this._ic);
                this.vertexStart = vertOffset;
                this.indexStart = indexOffset;
                this.vertexRange = vertexCount;
                this.indexRange = indexCount;
              };
              _proto3.requestIA = function requestIA(device) {
                this._initIAInfo(device);
                var ia = this._iaPool.add();
                ia.firstIndex = this.indexStart;
                ia.indexCount = this.indexRange;
                return ia;
              };
              _proto3.uploadBuffers = function uploadBuffers() {
                if (this._byteLength === 0 || !this._vertexBuffers[0] || !this._indexBuffer) {
                  return;
                }
                var indexCount = this._ic;
                var verticesData = new Float32Array(this.vData.buffer, 0, this._byteLength >> 2);
                var indicesData = new Uint16Array(this.iData.buffer, 0, indexCount);
                var vertexBuffer = this._vertexBuffers[0];
                if (this._byteLength > vertexBuffer.size) {
                  vertexBuffer.resize(this._byteLength);
                }
                vertexBuffer.update(verticesData);
                var indexBytes = indexCount << 1;
                if (indexBytes > this._indexBuffer.size) {
                  this._indexBuffer.resize(indexBytes);
                }
                this._indexBuffer.update(indicesData);
              };
              _proto3.freeIAPool = function freeIAPool() {
                if (this._iaPool) {
                  this._iaPool.reset();
                }
              };
              _proto3.reset = function reset() {
                this._vc = 0;
                this._ic = 0;
                this._byteLength = 0;
                this.vertexStart = 0;
                this.vertexRange = 0;
                this.indexStart = 0;
                this.indexRange = 0;
                this.lastFilledIndex = 0;
                this.lastFilledVertex = 0;
                this.material = null;
                this.freeIAPool();
              };
              _proto3.clear = function clear() {
                this.reset();
                if (this._iaPool) {
                  this._iaPool.destroy();
                }
                if (this._vertexBuffers[0]) {
                  this._vertexBuffers[0].destroy();
                  this._vertexBuffers = [];
                }
                this._iaInfo = null;
                this.vData = new Float32Array(256 * this.stride);
                this.iData = new Uint16Array(256 * 6);
              };
              _proto3._initIAInfo = function _initIAInfo(device) {
                var _this3 = this;
                if (!this._iaInfo) {
                  var vbStride = this.stride;
                  var vbs = this._vertexBuffers;
                  if (!vbs.length) {
                    vbs.push(device.createBuffer(new BufferInfo(8 | 2, 1, vbStride, vbStride)));
                  }
                  var ibStride = 2;
                  if (!this._indexBuffer) {
                    this._indexBuffer = device.createBuffer(new BufferInfo(4 | 2, 1, ibStride, ibStride));
                  }
                  this._iaInfo = new InputAssemblerInfo(this._vertexFormat, vbs, this._indexBuffer);
                  this._iaPool = new RecyclePool(function () {
                    return device.createInputAssembler(_this3._iaInfo);
                  }, 1, function (ia) {
                    ia.destroy();
                  });
                }
              };
              _proto3._reallocBuffer = function _reallocBuffer(vCount, iCount) {
                var oldVData = this.vData;
                this.vData = new Float32Array(vCount);
                if (oldVData) {
                  this.vData.set(oldVData, 0);
                }
                var oldIData = this.iData;
                this.iData = new Uint16Array(iCount);
                if (oldIData) {
                  this.iData.set(oldIData, 0);
                }
              };
              _proto3.setRenderDrawInfoAttributes = function setRenderDrawInfoAttributes() {
              };
              _proto3.particleInitRenderDrawInfo = function particleInitRenderDrawInfo(entity) {
              };
              _createClass(MeshRenderData, [{
                key: "formatByte",
                get: function get() {
                  return this.stride;
                },
                set: function set(value) {}
              }, {
                key: "floatStride",
                get: function get() {
                  return this._floatStride;
                }
              }, {
                key: "vDataOffset",
                get: function get() {
                  return this._byteLength >>> 2;
                }
              }]);
              return MeshRenderData;
            })(BaseRenderData);

            var RenderEntity = function () {
              var _proto = RenderEntity.prototype;
              _proto.setPriority = function setPriority(val) {
              };
              _proto.setUseLocal = function setUseLocal(useLocal) {
                this._useLocal = useLocal;
              };
              function RenderEntity(entityType) {
                this._renderEntityType = 0;
                this._dynamicDrawInfoArr = [];
                this._node = null;
                this._renderTransform = null;
                this._stencilStage = 0;
                this._colorDirty = true;
                this._enabled = false;
                this._useLocal = false;
                this._maskMode = 0;
                this._color = Color.WHITE.clone();
              }
              _proto.addDynamicRenderDrawInfo = function addDynamicRenderDrawInfo(renderDrawInfo) {
              };
              _proto.removeDynamicRenderDrawInfo = function removeDynamicRenderDrawInfo() {
              };
              _proto.clearDynamicRenderDrawInfos = function clearDynamicRenderDrawInfos() {
              };
              _proto.clearStaticRenderDrawInfos = function clearStaticRenderDrawInfos() {
              };
              _proto.clearRenderDrawInfos = function clearRenderDrawInfos() {
              };
              _proto.setDynamicRenderDrawInfo = function setDynamicRenderDrawInfo(renderDrawInfo, index) {
              };
              _proto.setMaskMode = function setMaskMode(mode) {
                this._maskMode = mode;
              };
              _proto.setFillColorType = function setFillColorType(fillColorType) {
              };
              _proto.getStaticRenderDrawInfo = function getStaticRenderDrawInfo() {
                return null;
              };
              _proto.setNode = function setNode(node) {
                this._node = node;
              };
              _proto.setRenderTransform = function setRenderTransform(renderTransform) {
                this._renderTransform = renderTransform;
              };
              _proto.setStencilStage = function setStencilStage(stage) {
                this._stencilStage = stage;
              };
              _proto.initSharedBuffer = function initSharedBuffer() {
              };
              _createClass(RenderEntity, [{
                key: "nativeObj",
                get: function get() {
                  return this._nativeObj;
                }
              }, {
                key: "renderDrawInfoArr",
                get: function get() {
                  return this._dynamicDrawInfoArr;
                }
              }, {
                key: "renderEntityType",
                get: function get() {
                  return this._renderEntityType;
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(val) {
                  this._color = val;
                }
              }, {
                key: "colorDirty",
                get: function get() {
                  return this._colorDirty;
                },
                set: function set(val) {
                  this._colorDirty = val;
                }
              }, {
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  this._enabled = val;
                }
              }]);
              return RenderEntity;
            }();

            var _dec$3, _dec2$2, _dec3$2, _dec4, _class$3, _class2$3, _initializer$2, _initializer2$2, _initializer3$1, _initializer4$1, _initializer5$1, _class3$1;
            ccenum(BlendFactor);
            ccenum(BlendOp);
            ccenum(ColorMask);
            var UIRenderer = (_dec$3 = ccclass$6('cc.UIRenderer'), _dec2$2 = requireComponent(UITransform), _dec3$2 = type$5(Material), _dec4 = type$5(Material), _dec$3(_class$3 = _dec2$2(_class$3 = (_class2$3 = (_class3$1 = function (_Renderer) {
              _inheritsLoose(UIRenderer, _Renderer);
              function UIRenderer() {
                var _this;
                _this = _Renderer.call(this) || this;
                _this._renderData = null;
                _this._materials = _initializer$2 && _initializer$2();
                _this._customMaterial = _initializer2$2 && _initializer2$2();
                _this._srcBlendFactor = _initializer3$1 && _initializer3$1();
                _this._dstBlendFactor = _initializer4$1 && _initializer4$1();
                _this._color = _initializer5$1 && _initializer5$1();
                _this._stencilStage = 0;
                _this._assembler = null;
                _this._postAssembler = null;
                _this._renderFlag = true;
                _this._instanceMaterialType = -1;
                _this._srcBlendFactorCache = 2;
                _this._dstBlendFactorCache = 4;
                _this._dirtyVersion = -1;
                _this._internalId = -1;
                _this._flagChangedVersion = -1;
                _this._priority = 0;
                _this._fillColorType = 0;
                _this._lastParent = null;
                _this._renderEntity = _this.createRenderEntity();
                return _this;
              }
              var _proto = UIRenderer.prototype;
              _proto.setRenderData = function setRenderData(renderData) {
                this._renderData = renderData;
              };
              _proto.getFillColorType = function getFillColorType() {
                return this._fillColorType;
              };
              _proto.setFillColorType = function setFillColorType(val) {
                this._fillColorType = val;
              };
              _proto.onLoad = function onLoad() {
                this._renderEntity.setNode(this.node);
              };
              _proto.__preload = function __preload() {
                this.node._uiProps.uiComp = this;
                if (this._flushAssembler) {
                  this._flushAssembler();
                }
              };
              _proto.onEnable = function onEnable() {
                this.node.on("anchor-changed", this._nodeStateChange, this);
                this.node.on("size-changed", this._nodeStateChange, this);
                this.node.on("parent-changed", this._colorDirty, this);
                if (!this._renderData && this._flushAssembler) {
                  this._flushAssembler();
                }
                this.updateMaterial();
                this._colorDirty();
                uiRendererManager.addRenderer(this);
                this._markForUpdateRenderData();
              };
              _proto.onRestore = function onRestore() {
                this.updateMaterial();
                this._markForUpdateRenderData();
              };
              _proto._destroyData = function _destroyData() {
                this.destroyRenderData();
                if (this._materials) {
                  for (var i = 0; i < this._materials.length; i++) {
                    this.setSharedMaterial(null, i, true);
                  }
                }
              };
              _proto.onDisable = function onDisable() {
                this.node.off("anchor-changed", this._nodeStateChange, this);
                this.node.off("size-changed", this._nodeStateChange, this);
                this.node.off("parent-changed", this._colorDirty, this);
                this._destroyData();
                uiRendererManager.removeRenderer(this);
                this._renderFlag = false;
                this._renderEntity.enabled = false;
              };
              _proto.onDestroy = function onDestroy() {
                this._renderEntity.setNode(null);
                if (this.node._uiProps.uiComp === this) {
                  this.node._uiProps.uiComp = null;
                }
                this._destroyData();
              };
              _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
                if (enable === undefined) {
                  enable = true;
                }
                this._markForUpdateRenderData(enable);
              };
              _proto._markForUpdateRenderData = function _markForUpdateRenderData(enable) {
                if (enable === undefined) {
                  enable = true;
                }
                if (enable) {
                  var renderData = this._renderData;
                  if (renderData) {
                    renderData.vertDirty = true;
                  }
                  uiRendererManager.markDirtyRenderer(this);
                }
              };
              _proto.requestRenderData = function requestRenderData(drawInfoType) {
                if (drawInfoType === undefined) {
                  drawInfoType = 0;
                }
                var data = RenderData.add();
                data.initRenderDrawInfo(this, drawInfoType);
                this._renderData = data;
                return data;
              };
              _proto.destroyRenderData = function destroyRenderData() {
                this.renderEntity.clearRenderDrawInfos();
                if (!this._renderData) {
                  return;
                }
                RenderData.remove(this._renderData);
                this._renderData = null;
              };
              _proto.updateRenderer = function updateRenderer() {
                var assembler = this._assembler;
                if (assembler && assembler.updateRenderData) {
                  assembler.updateRenderData(this);
                }
                this._renderFlag = this._canRender();
                this._renderEntity.enabled = this._renderFlag;
              };
              _proto.fillBuffers = function fillBuffers(render) {
                if (this._renderFlag) {
                  this._render(render);
                }
              };
              _proto.postUpdateAssembler = function postUpdateAssembler(render) {
                if (this._postAssembler && this._renderFlag) {
                  this._postRender(render);
                }
              };
              _proto._render = function _render(render) {};
              _proto._postRender = function _postRender(render) {};
              _proto._canRender = function _canRender() {
                {
                  assert(this.isValid, 'this component should not be invalid!');
                }
                return this.getSharedMaterial(0) !== null && this._enabled && this._color.a > 0;
              };
              _proto._postCanRender = function _postCanRender() {};
              _proto.updateMaterial = function updateMaterial() {
                if (this._customMaterial) {
                  if (this.getSharedMaterial(0) !== this._customMaterial) {
                    this.setSharedMaterial(this._customMaterial, 0);
                  }
                  return;
                }
                var mat = this._updateBuiltinMaterial();
                this.setSharedMaterial(mat, 0);
                if (this.stencilStage === 2 || this.stencilStage === 6) {
                  this.getMaterialInstance(0).recompileShaders({
                    USE_ALPHA_TEST: true
                  });
                }
                this._updateBlendFunc();
              };
              _proto._updateColor = function _updateColor() {
                this.node._uiProps.colorDirty = true;
                this.setEntityColorDirty(true);
                this.setEntityColor(this._color);
                var assembler = this._assembler;
                if (assembler) {
                  if (assembler.updateColor) {
                    assembler.updateColor(this);
                  }
                  var renderFlag = this._renderFlag;
                  this._renderFlag = this._canRender();
                  this.setEntityEnabled(this._renderFlag);
                  if (renderFlag !== this._renderFlag) {
                    var renderData = this.renderData;
                    if (renderData) {
                      renderData.vertDirty = true;
                    }
                  }
                }
              };
              _proto.setEntityColorDirty = function setEntityColorDirty(dirty) {
              };
              _proto.setEntityColor = function setEntityColor(color) {
              };
              _proto.setEntityOpacity = function setEntityOpacity(opacity) {
              };
              _proto.setEntityEnabled = function setEntityEnabled(enabled) {
              };
              _proto._updateBlendFunc = function _updateBlendFunc() {
                var target = this.getRenderMaterial(0).passes[0].blendState.targets[0];
                this._dstBlendFactorCache = target.blendDst;
                this._srcBlendFactorCache = target.blendSrc;
                if (this._dstBlendFactorCache !== this._dstBlendFactor || this._srcBlendFactorCache !== this._srcBlendFactor) {
                  target = this.getMaterialInstance(0).passes[0].blendState.targets[0];
                  target.blend = true;
                  target.blendDstAlpha = 4;
                  target.blendDst = this._dstBlendFactor;
                  target.blendSrc = this._srcBlendFactor;
                  var targetPass = this.getMaterialInstance(0).passes[0];
                  targetPass.blendState.setTarget(0, target);
                  targetPass._updatePassHash();
                  this._dstBlendFactorCache = this._dstBlendFactor;
                  this._srcBlendFactorCache = this._srcBlendFactor;
                }
              };
              _proto._nodeStateChange = function _nodeStateChange(transformType) {
                if (this._renderData) {
                  this._markForUpdateRenderData();
                }
                for (var i = 0; i < this.node.children.length; ++i) {
                  var child = this.node.children[i];
                  var renderComp = child.getComponent(UIRenderer);
                  if (renderComp) {
                    renderComp._markForUpdateRenderData();
                  }
                }
              };
              _proto._colorDirty = function _colorDirty() {
                this.node._uiProps.colorDirty = true;
                this.setEntityColorDirty(true);
              };
              _proto._onMaterialModified = function _onMaterialModified(idx, material) {
                if (this._renderData) {
                  this._markForUpdateRenderData();
                  this._renderData.passDirty = true;
                }
                _Renderer.prototype._onMaterialModified.call(this, idx, material);
              };
              _proto._updateBuiltinMaterial = function _updateBuiltinMaterial() {
                var mat;
                switch (this._instanceMaterialType) {
                  case 0:
                    mat = builtinResMgr.get("ui-base-material");
                    break;
                  case 2:
                    mat = builtinResMgr.get("ui-sprite-gray-material");
                    break;
                  case 3:
                    mat = builtinResMgr.get("ui-sprite-alpha-sep-material");
                    break;
                  case 4:
                    mat = builtinResMgr.get("ui-sprite-gray-alpha-sep-material");
                    break;
                  default:
                    mat = builtinResMgr.get("ui-sprite-material");
                    break;
                }
                return mat;
              };
              _proto.setNodeDirty = function setNodeDirty() {
                if (this._renderData) {
                  this._renderData.nodeDirty = true;
                }
              };
              _proto.setTextureDirty = function setTextureDirty() {
                if (this._renderData) {
                  this._renderData.textureDirty = true;
                }
              };
              _proto.createRenderEntity = function createRenderEntity() {
                return new RenderEntity(0);
              };
              _createClass(UIRenderer, [{
                key: "sharedMaterials",
                get: function get() {
                  return this._materials;
                },
                set: function set(val) {
                  for (var i = 0; i < val.length; i++) {
                    if (val[i] !== this._materials[i]) {
                      this.setSharedMaterial(val[i], i);
                    }
                  }
                  if (val.length < this._materials.length) {
                    for (var _i = val.length; _i < this._materials.length; _i++) {
                      this.setSharedMaterial(null, _i);
                    }
                    this._materials.splice(val.length);
                  }
                }
              }, {
                key: "customMaterial",
                get: function get() {
                  return this._customMaterial;
                },
                set: function set(val) {
                  this._customMaterial = val;
                  this.updateMaterial();
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color.equals(value)) {
                    return;
                  }
                  this._color.set(value);
                  this._updateColor();
                }
              }, {
                key: "renderData",
                get: function get() {
                  return this._renderData;
                }
              }, {
                key: "stencilStage",
                get: function get() {
                  return this._stencilStage;
                },
                set: function set(val) {
                  this._stencilStage = val;
                  this._renderEntity.setStencilStage(val);
                }
              }, {
                key: "srcBlendFactor",
                get: function get() {
                  return this._srcBlendFactor;
                },
                set: function set(srcBlendFactor) {
                  this._srcBlendFactor = srcBlendFactor;
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(val) {
                  this._priority = val;
                }
              }, {
                key: "batcher",
                get: function get() {
                  return director.root.batcher2D;
                }
              }, {
                key: "renderEntity",
                get: function get() {
                  {
                    assert(Boolean(this._renderEntity), 'this._renderEntity should not be invalid');
                  }
                  return this._renderEntity;
                }
              }, {
                key: "_useVertexOpacity",
                get: function get() {
                  return this._fillColorType === 1;
                },
                set: function set(val) {
                  this.setFillColorType(1);
                }
              }, {
                key: "useVertexOpacity",
                get: function get() {
                  return this._fillColorType === 1;
                }
              }]);
              return UIRenderer;
            }(Renderer), _class3$1.BlendState = BlendFactor, _class3$1.Assembler = null, _class3$1.PostAssembler = null, _class3$1), (_applyDecoratedDescriptor(_class2$3.prototype, "sharedMaterials", [override], Object.getOwnPropertyDescriptor(_class2$3.prototype, "sharedMaterials"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "customMaterial", [_dec3$2], Object.getOwnPropertyDescriptor(_class2$3.prototype, "customMaterial"), _class2$3.prototype), _initializer$2 = applyDecoratedInitializer(_class2$3.prototype, "_materials", [override], function () {
              return [];
            }), _initializer2$2 = applyDecoratedInitializer(_class2$3.prototype, "_customMaterial", [_dec4], function () {
              return null;
            }), _initializer3$1 = applyDecoratedInitializer(_class2$3.prototype, "_srcBlendFactor", [serializable$5], function () {
              return 2;
            }), _initializer4$1 = applyDecoratedInitializer(_class2$3.prototype, "_dstBlendFactor", [serializable$5], function () {
              return 4;
            }), _initializer5$1 = applyDecoratedInitializer(_class2$3.prototype, "_color", [serializable$5], function () {
              return Color.WHITE.clone();
            })), _class2$3)) || _class$3) || _class$3);
            cclegacy.internal.UIRenderer = UIRenderer;

            removeProperty(UIComponent.prototype, 'UIComponent', [{
              name: '_visibility'
            }, {
              name: 'setVisibility'
            }]);
            replaceProperty(Canvas.prototype, 'Canvas.prototype', [{
              name: 'camera',
              newName: 'cameraComponent.camera',
              customGetter: function customGetter() {
                var _this$_cameraComponen;
                return (_this$_cameraComponen = this._cameraComponent) == null ? undefined : _this$_cameraComponen.camera;
              }
            }, {
              name: 'clearFlag',
              newName: 'cameraComponent.clearFlags',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.clearFlags : 0;
              },
              customSetter: function customSetter(val) {
                if (this._cameraComponent) this._cameraComponent.clearFlags = val;
              }
            }, {
              name: 'color',
              newName: 'cameraComponent.clearColor',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.clearColor : Color.BLACK;
              },
              customSetter: function customSetter(val) {
                if (this._cameraComponent) this._cameraComponent.clearColor = val;
              }
            }, {
              name: 'priority',
              newName: 'cameraComponent.priority',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.priority : 0;
              },
              customSetter: function customSetter(val) {
                if (this._cameraComponent) this._cameraComponent.priority = val;
              }
            }, {
              name: 'targetTexture',
              newName: 'cameraComponent.targetTexture',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.targetTexture : null;
              },
              customSetter: function customSetter(value) {
                if (this._cameraComponent) this._cameraComponent.targetTexture = value;
              }
            }, {
              name: 'visibility',
              newName: 'cameraComponent.visibility',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.visibility : 0;
              }
            }]);
            markAsWarning(UITransform.prototype, 'UITransform.prototype', [{
              name: 'priority',
              suggest: "Please use setSiblingIndex to change index of the current node in its parent's children array."
            }]);
            cclegacy.UITransformComponent = UITransform;
            setClassAlias(UITransform, 'cc.UITransformComponent');
            setClassAlias(UIRenderer, 'cc.RenderComponent');
            cclegacy.CanvasComponent = Canvas;
            setClassAlias(Canvas, 'cc.CanvasComponent');
            cclegacy.internal.Renderable2D = UIRenderer;
            setClassAlias(UIRenderer, 'cc.Renderable2D');

            var space = 2;
            function drawTextureAt(texture, image, x, y) {
              texture.drawTextureAt(image, x, y);
            }
            var Atlas = function () {
              function Atlas(width, height) {
                this._innerTextureInfos = {};
                this._innerSpriteFrames = [];
                this._count = 0;
                var texture = new DynamicAtlasTexture();
                texture.initWithSize(width, height);
                this._texture = texture;
                this._width = width;
                this._height = height;
                this._x = space;
                this._y = space;
                this._nextY = space;
              }
              var _proto = Atlas.prototype;
              _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
                var rect = spriteFrame.rect;
                var texture = spriteFrame.texture;
                var info = this._innerTextureInfos[texture.getId()];
                var sx = rect.x;
                var sy = rect.y;
                if (info) {
                  sx += info.x;
                  sy += info.y;
                } else {
                  var width = texture.width;
                  var height = texture.height;
                  if (this._x + width + space > this._width) {
                    this._x = space;
                    this._y = this._nextY;
                  }
                  if (this._y + height + space > this._nextY) {
                    this._nextY = this._y + height + space;
                  }
                  if (this._nextY > this._height) {
                    return null;
                  }
                  var thisTexture = this._texture;
                  var image = texture.image;
                  if (cclegacy.internal.dynamicAtlasManager.textureBleeding) {
                    if (width <= 8 || height <= 8) {
                      drawTextureAt(thisTexture, image, this._x - 1, this._y - 1);
                      drawTextureAt(thisTexture, image, this._x - 1, this._y + 1);
                      drawTextureAt(thisTexture, image, this._x + 1, this._y - 1);
                      drawTextureAt(thisTexture, image, this._x + 1, this._y + 1);
                    }
                    drawTextureAt(thisTexture, image, this._x - 1, this._y);
                    drawTextureAt(thisTexture, image, this._x + 1, this._y);
                    drawTextureAt(thisTexture, image, this._x, this._y - 1);
                    drawTextureAt(thisTexture, image, this._x, this._y + 1);
                  }
                  drawTextureAt(thisTexture, image, this._x, this._y);
                  this._innerTextureInfos[texture.getId()] = {
                    x: this._x,
                    y: this._y,
                    texture: texture
                  };
                  this._count++;
                  sx += this._x;
                  sy += this._y;
                  this._x += width + space;
                }
                var frame = {
                  x: sx,
                  y: sy,
                  texture: this._texture
                };
                this._innerSpriteFrames.push(spriteFrame);
                return frame;
              };
              _proto.removeSpriteFrame = function removeSpriteFrame(spriteFrame) {
                fastRemove(this._innerSpriteFrames, spriteFrame);
              };
              _proto.deleteInnerTexture = function deleteInnerTexture(texture) {
                if (texture && this._innerTextureInfos[texture.getId()]) {
                  delete this._innerTextureInfos[texture.getId()];
                  this._count--;
                }
              };
              _proto.isEmpty = function isEmpty() {
                return this._count <= 0;
              };
              _proto.reset = function reset() {
                this._x = space;
                this._y = space;
                this._nextY = space;
                var frames = this._innerSpriteFrames;
                for (var i = 0, l = frames.length; i < l; i++) {
                  var frame = frames[i];
                  if (!frame.isValid) {
                    continue;
                  }
                  frame._resetDynamicAtlasFrame();
                }
                this._innerSpriteFrames.length = 0;
                this._innerTextureInfos = {};
              };
              _proto.destroy = function destroy() {
                this.reset();
                this._texture.destroy();
              };
              return Atlas;
            }();
            var DynamicAtlasTexture = function (_Texture2D) {
              _inheritsLoose(DynamicAtlasTexture, _Texture2D);
              function DynamicAtlasTexture() {
                return _Texture2D.apply(this, arguments) || this;
              }
              var _proto2 = DynamicAtlasTexture.prototype;
              _proto2.initWithSize = function initWithSize(width, height, format) {
                if (format === undefined) {
                  format = 35;
                }
                this.reset({
                  width: width,
                  height: height,
                  format: format
                });
              };
              _proto2.drawTextureAt = function drawTextureAt(image, x, y) {
                var gfxTexture = this.getGFXTexture();
                if (!image || !gfxTexture) {
                  return;
                }
                var gfxDevice = this._getGFXDevice();
                if (!gfxDevice) {
                  warnID(16363);
                  return;
                }
                var region = new BufferTextureCopy();
                region.texOffset.x = x;
                region.texOffset.y = y;
                region.texExtent.width = image.width;
                region.texExtent.height = image.height;
                gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
              };
              return DynamicAtlasTexture;
            }(Texture2D);

            var DynamicAtlasManager = function (_System) {
              _inheritsLoose(DynamicAtlasManager, _System);
              function DynamicAtlasManager() {
                var _this;
                _this = _System.call(this) || this;
                _this._atlases = [];
                _this._atlasIndex = -1;
                _this._maxAtlasCount = 5;
                _this._textureSize = 2048;
                _this._maxFrameSize = 512;
                _this._textureBleeding = true;
                _this._enabled = false;
                return _this;
              }
              var _proto = DynamicAtlasManager.prototype;
              _proto.newAtlas = function newAtlas() {
                var atlas = this._atlases[++this._atlasIndex];
                if (!atlas && this._atlasIndex < this.maxAtlasCount) {
                  atlas = new Atlas(this._textureSize, this._textureSize);
                  this._atlases.push(atlas);
                }
                return atlas;
              };
              _proto.beforeSceneLoad = function beforeSceneLoad() {
                this.reset();
              };
              _proto.init = function init() {
                this.enabled = !macro.CLEANUP_IMAGE_CACHE;
              };
              _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
                if (!this._enabled || this._atlasIndex >= this._maxAtlasCount || !spriteFrame || spriteFrame.original) return null;
                if (!spriteFrame.packable) return null;
                var sampler = spriteFrame.texture.getSamplerInfo();
                if (sampler.minFilter !== 2 || sampler.magFilter !== 2 || sampler.mipFilter !== 0) {
                  return null;
                }
                var atlas = this._atlases[this._atlasIndex];
                if (!atlas) {
                  atlas = this.newAtlas();
                }
                var frame = atlas ? atlas.insertSpriteFrame(spriteFrame) : null;
                if (!frame && this._atlasIndex < this._maxAtlasCount) {
                  atlas = this.newAtlas();
                  return atlas ? atlas.insertSpriteFrame(spriteFrame) : null;
                }
                return frame;
              };
              _proto.reset = function reset() {
                for (var i = 0, l = this._atlases.length; i < l; i++) {
                  this._atlases[i].destroy();
                }
                this._atlases.length = 0;
                this._atlasIndex = -1;
              };
              _proto.deleteAtlasSpriteFrame = function deleteAtlasSpriteFrame(spriteFrame) {
                if (!spriteFrame.original) return;
                var atlas;
                for (var i = this._atlases.length - 1; i >= 0; i--) {
                  atlas = this._atlases[i];
                  atlas.removeSpriteFrame(spriteFrame);
                }
                var texture = spriteFrame.original._texture;
                this.deleteAtlasTexture(texture);
              };
              _proto.deleteAtlasTexture = function deleteAtlasTexture(texture) {
                if (texture) {
                  for (var i = this._atlases.length - 1; i >= 0; i--) {
                    this._atlases[i].deleteInnerTexture(texture);
                    if (this._atlases[i].isEmpty()) {
                      this._atlases[i].destroy();
                      this._atlases.splice(i, 1);
                      this._atlasIndex--;
                    }
                  }
                }
              };
              _proto.packToDynamicAtlas = function packToDynamicAtlas(comp, frame) {
                if (!this._enabled) return;
                if (frame && !frame.original && frame.packable && frame.texture && frame.texture.width > 0 && frame.texture.height > 0) {
                  var packedFrame = this.insertSpriteFrame(frame);
                  if (packedFrame) {
                    frame._setDynamicAtlasFrame(packedFrame);
                  }
                }
              };
              _createClass(DynamicAtlasManager, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(value) {
                  if (this._enabled === value) return;
                  if (value) {
                    this.reset();
                    director.on("director_before_scene_launch", this.beforeSceneLoad, this);
                  } else {
                    this.reset();
                    director.off("director_before_scene_launch", this.beforeSceneLoad, this);
                  }
                  this._enabled = value;
                }
              }, {
                key: "maxAtlasCount",
                get: function get() {
                  return this._maxAtlasCount;
                },
                set: function set(value) {
                  this._maxAtlasCount = value;
                }
              }, {
                key: "atlasCount",
                get: function get() {
                  return this._atlases.length;
                }
              }, {
                key: "textureBleeding",
                get: function get() {
                  return this._textureBleeding;
                },
                set: function set(enable) {
                  this._textureBleeding = enable;
                }
              }, {
                key: "textureSize",
                get: function get() {
                  return this._textureSize;
                },
                set: function set(value) {
                  this._textureSize = value;
                }
              }, {
                key: "maxFrameSize",
                get: function get() {
                  return this._maxFrameSize;
                },
                set: function set(value) {
                  this._maxFrameSize = value;
                }
              }]);
              return DynamicAtlasManager;
            }(System);
            DynamicAtlasManager.instance = undefined;
            var dynamicAtlasManager = DynamicAtlasManager.instance = new DynamicAtlasManager();
            director.registerSystem('dynamicAtlasManager', dynamicAtlasManager, 0);
            cclegacy.internal.dynamicAtlasManager = dynamicAtlasManager;

            var _dec$2, _class$2, _class2$2;
            var INSET_LEFT = 0;
            var INSET_TOP = 1;
            var INSET_RIGHT = 2;
            var INSET_BOTTOM = 3;
            var temp_vec3 = v3();
            var temp_matrix = mat4();
            var vec3TransformMat4 = Vec3.transformMat4;
            var vec3ToArray = Vec3.toArray;
            var MeshType = {
              RECT: 0,
              POLYGON: 1
            };
            var temp_uvs = [{
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }];
            var SpriteFrame = (_dec$2 = ccclass$6('cc.SpriteFrame'), _dec$2(_class$2 = (_class2$2 = function (_Asset) {
              _inheritsLoose(SpriteFrame, _Asset);
              SpriteFrame.createWithImage = function createWithImage(imageSourceOrImageAsset) {
                var img = imageSourceOrImageAsset instanceof ImageAsset ? imageSourceOrImageAsset : new ImageAsset(imageSourceOrImageAsset);
                var tex = new Texture2D();
                tex.image = img;
                var spf = new SpriteFrame();
                spf.texture = tex;
                return spf;
              };
              function SpriteFrame(name) {
                var _this;
                _this = _Asset.call(this, name) || this;
                _this.vertices = null;
                _this.uv = [];
                _this.unbiasUV = [];
                _this.uvSliced = [];
                _this._rect = rect();
                _this._trimmedBorder = v4();
                _this._offset = v2$1();
                _this._originalSize = size();
                _this._rotated = false;
                _this._capInsets = [0, 0, 0, 0];
                _this._atlasUuid = '';
                _this._texture = undefined;
                _this._isFlipUVY = false;
                _this._isFlipUVX = false;
                _this._original = null;
                _this._packable = true;
                _this._pixelsToUnit = 100;
                _this._pivot = v2$1(0.5, 0.5);
                _this._meshType = 0;
                _this._extrude = 0;
                _this._customOutLine = [];
                _this._mesh = null;
                _this._minPos = v3();
                _this._maxPos = v3();
                return _this;
              }
              var _proto = SpriteFrame.prototype;
              _proto.textureLoaded = function textureLoaded() {
                return !!this.texture;
              };
              _proto.isRotated = function isRotated() {
                return this._rotated;
              };
              _proto.setRotated = function setRotated(rotated) {
                this.rotated = rotated;
              };
              _proto.getRect = function getRect(out) {
                if (out) {
                  out.set(this._rect);
                  return out;
                }
                return this._rect.clone();
              };
              _proto.setRect = function setRect(rect) {
                this.rect = rect;
              };
              _proto.getOriginalSize = function getOriginalSize(out) {
                if (out) {
                  out.set(this._originalSize);
                  return out;
                }
                return this._originalSize.clone();
              };
              _proto.setOriginalSize = function setOriginalSize(size) {
                this.originalSize = size;
              };
              _proto.getOffset = function getOffset(out) {
                if (out) {
                  out.set(this._offset);
                  return out;
                }
                return this._offset.clone();
              };
              _proto.setOffset = function setOffset(offset) {
                this.offset = offset;
              };
              _proto.getGFXTexture = function getGFXTexture() {
                return this._texture.getGFXTexture();
              };
              _proto.getGFXSampler = function getGFXSampler() {
                return this._texture.getGFXSampler();
              };
              _proto.getHash = function getHash() {
                return this._texture.getHash();
              };
              _proto.getSamplerInfo = function getSamplerInfo() {
                return this._texture.getSamplerInfo();
              };
              _proto.reset = function reset(info, clearData) {
                if (clearData === undefined) {
                  clearData = false;
                }
                var self = this;
                var calUV = false;
                if (clearData) {
                  self._originalSize.set(0, 0);
                  self._rect.set(0, 0, 0, 0);
                  self._offset.set(0, 0);
                  self._capInsets = [0, 0, 0, 0];
                  self._rotated = false;
                  calUV = true;
                }
                if (info) {
                  if (info.texture) {
                    self._rect.set(0, 0, info.texture.width, info.texture.height);
                    self._refreshTexture(info.texture);
                    self.checkRect(self._texture);
                  }
                  if (info.originalSize) {
                    self._originalSize.set(info.originalSize);
                  }
                  if (info.rect) {
                    self._rect.set(info.rect);
                  }
                  if (info.offset) {
                    self._offset.set(info.offset);
                  }
                  var thisCapInsets = self._capInsets;
                  if (info.borderTop !== undefined) {
                    thisCapInsets[INSET_TOP] = info.borderTop;
                  }
                  if (info.borderBottom !== undefined) {
                    thisCapInsets[INSET_BOTTOM] = info.borderBottom;
                  }
                  if (info.borderLeft !== undefined) {
                    thisCapInsets[INSET_LEFT] = info.borderLeft;
                  }
                  if (info.borderRight !== undefined) {
                    thisCapInsets[INSET_RIGHT] = info.borderRight;
                  }
                  if (info.isRotate !== undefined) {
                    self._rotated = !!info.isRotate;
                  }
                  if (info.isFlipUv !== undefined) {
                    self._isFlipUVY = !!info.isFlipUv;
                  }
                  calUV = true;
                }
                if (calUV && self.texture) {
                  self._calculateUV();
                }
                self._calcTrimmedBorder();
              };
              _proto.checkRect = function checkRect(texture) {
                var rect = this._rect;
                var maxX = rect.x;
                var maxY = rect.y;
                if (this._rotated) {
                  maxX += rect.height;
                  maxY += rect.width;
                } else {
                  maxX += rect.width;
                  maxY += rect.height;
                }
                if (maxX > texture.width) {
                  errorID(3300, this.name + "/" + texture.name, maxX, texture.width);
                  return false;
                }
                if (maxY > texture.height) {
                  errorID(3301, this.name + "/" + texture.name, maxY, texture.height);
                  return false;
                }
                return true;
              };
              _proto._calcTrimmedBorder = function _calcTrimmedBorder() {
                var self = this;
                var ow = self._originalSize.width;
                var oh = self._originalSize.height;
                var rw = self._rect.width;
                var rh = self._rect.height;
                var halfTrimmedWidth = (ow - rw) * 0.5;
                var halfTrimmedHeight = (oh - rh) * 0.5;
                var thisOffset = self._offset;
                var thisTrimmedBorder = self._trimmedBorder;
                thisTrimmedBorder.x = thisOffset.x + halfTrimmedWidth;
                thisTrimmedBorder.y = thisOffset.x - halfTrimmedWidth;
                thisTrimmedBorder.z = thisOffset.y + halfTrimmedHeight;
                thisTrimmedBorder.w = thisOffset.y - halfTrimmedHeight;
              };
              _proto.ensureMeshData = function ensureMeshData() {
                if (this._mesh) return;
                this._initVertices();
                this._createMesh();
              };
              _proto.destroy = function destroy() {
                if (this._packable && dynamicAtlasManager) {
                  dynamicAtlasManager.deleteAtlasSpriteFrame(this);
                }
                return _Asset.prototype.destroy.call(this);
              };
              _proto._calculateSlicedUV = function _calculateSlicedUV() {
                var self = this;
                var rect = self._rect;
                var tex = self.texture;
                var capInsets = self._capInsets;
                var atlasWidth = tex.width;
                var atlasHeight = tex.height;
                var leftWidth = capInsets[INSET_LEFT];
                var rightWidth = capInsets[INSET_RIGHT];
                var centerWidth = rect.width - leftWidth - rightWidth;
                var topHeight = capInsets[INSET_TOP];
                var bottomHeight = capInsets[INSET_BOTTOM];
                var centerHeight = rect.height - topHeight - bottomHeight;
                var uvSliced = self.uvSliced;
                uvSliced.length = 0;
                if (self._rotated) {
                  temp_uvs[0].u = rect.x / atlasWidth;
                  temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
                  temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
                  temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
                  temp_uvs[3].v = rect.y / atlasHeight;
                  temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
                  temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
                  temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;
                  for (var row = 0; row < 4; ++row) {
                    var rowD = temp_uvs[row];
                    for (var col = 0; col < 4; ++col) {
                      var colD = temp_uvs[3 - col];
                      uvSliced.push({
                        u: rowD.u,
                        v: colD.v
                      });
                    }
                  }
                } else {
                  temp_uvs[0].u = rect.x / atlasWidth;
                  temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
                  temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
                  temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
                  temp_uvs[3].v = rect.y / atlasHeight;
                  temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
                  temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
                  temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
                  for (var _row = 0; _row < 4; ++_row) {
                    var _rowD = temp_uvs[_row];
                    for (var _col = 0; _col < 4; ++_col) {
                      var _colD = temp_uvs[_col];
                      uvSliced.push({
                        u: _colD.u,
                        v: _rowD.v
                      });
                    }
                  }
                }
                this.emit("uv_updated", this);
              };
              _proto._calculateUV = function _calculateUV() {
                var arrayFill = fillItems;
                var self = this;
                var rect = self._rect;
                var uv = self.uv;
                var unbiasUV = self.unbiasUV;
                var tex = self.texture;
                var texw = tex.width;
                var texh = tex.height;
                if (self._rotated) {
                  var l = texw === 0 ? 0 : rect.x / texw;
                  var r = texw === 0 ? 1 : (rect.x + rect.height) / texw;
                  var t = texh === 0 ? 0 : rect.y / texh;
                  var b = texh === 0 ? 1 : (rect.y + rect.width) / texh;
                  if (self._isFlipUVX && self._isFlipUVY) {
                    arrayFill(uv, r, b, r, t, l, b, l, t);
                  } else if (self._isFlipUVX) {
                    arrayFill(uv, r, t, r, b, l, t, l, b);
                  } else if (self._isFlipUVY) {
                    arrayFill(uv, l, b, l, t, r, b, r, t);
                  } else {
                    arrayFill(uv, l, t, l, b, r, t, r, b);
                  }
                  var ul = texw === 0 ? 0 : rect.x / texw;
                  var ur = texw === 0 ? 1 : (rect.x + rect.height) / texw;
                  var ut = texh === 0 ? 0 : rect.y / texh;
                  var ub = texh === 0 ? 1 : (rect.y + rect.width) / texh;
                  if (self._isFlipUVX && self._isFlipUVY) {
                    arrayFill(unbiasUV, ur, ub, ur, ut, ul, ub, ul, ut);
                  } else if (self._isFlipUVX) {
                    arrayFill(unbiasUV, ur, ut, ur, ub, ul, ut, ul, ub);
                  } else if (self._isFlipUVY) {
                    arrayFill(unbiasUV, ul, ub, ul, ut, ur, ub, ur, ut);
                  } else {
                    arrayFill(unbiasUV, ul, ut, ul, ub, ur, ut, ur, ub);
                  }
                } else {
                  var _l = texw === 0 ? 0 : rect.x / texw;
                  var _r = texw === 0 ? 1 : (rect.x + rect.width) / texw;
                  var _b = texh === 0 ? 1 : (rect.y + rect.height) / texh;
                  var _t = texh === 0 ? 0 : rect.y / texh;
                  if (self._isFlipUVX && self._isFlipUVY) {
                    arrayFill(uv, _r, _t, _l, _t, _r, _b, _l, _b);
                  } else if (self._isFlipUVX) {
                    arrayFill(uv, _r, _b, _l, _b, _r, _t, _l, _t);
                  } else if (self._isFlipUVY) {
                    arrayFill(uv, _l, _t, _r, _t, _l, _b, _r, _b);
                  } else {
                    arrayFill(uv, _l, _b, _r, _b, _l, _t, _r, _t);
                  }
                  var _ul = texw === 0 ? 0 : rect.x / texw;
                  var _ur = texw === 0 ? 1 : (rect.x + rect.width) / texw;
                  var _ub = texh === 0 ? 1 : (rect.y + rect.height) / texh;
                  var _ut = texh === 0 ? 0 : rect.y / texh;
                  if (self._isFlipUVX && self._isFlipUVY) {
                    arrayFill(unbiasUV, _ur, _ut, _ul, _ut, _ur, _ub, _ul, _ub);
                  } else if (self._isFlipUVX) {
                    arrayFill(unbiasUV, _ur, _ub, _ul, _ub, _ur, _ut, _ul, _ut);
                  } else if (self._isFlipUVY) {
                    arrayFill(unbiasUV, _ul, _ut, _ur, _ut, _ul, _ub, _ur, _ub);
                  } else {
                    arrayFill(unbiasUV, _ul, _ub, _ur, _ub, _ul, _ut, _ur, _ut);
                  }
                }
                self._calculateSlicedUV();
              };
              _proto._setDynamicAtlasFrame = function _setDynamicAtlasFrame(frame) {
                if (!frame) return;
                this._original = {
                  _texture: this._texture,
                  _x: this._rect.x,
                  _y: this._rect.y
                };
                this._texture = frame.texture;
                this._rect.x = frame.x;
                this._rect.y = frame.y;
                this._calculateUV();
              };
              _proto._resetDynamicAtlasFrame = function _resetDynamicAtlasFrame() {
                if (!this._original) return;
                this._rect.x = this._original._x;
                this._rect.y = this._original._y;
                this._texture = this._original._texture;
                this._original = null;
                this._calculateUV();
              };
              _proto._checkPackable = function _checkPackable() {
                var dynamicAtlas = dynamicAtlasManager;
                if (!dynamicAtlas) return;
                var texture = this._texture;
                if (!(texture instanceof Texture2D) || texture.isCompressed) {
                  this._packable = false;
                  return;
                }
                var w = this.width;
                var h = this.height;
                if (!texture.image || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize) {
                  this._packable = false;
                  return;
                }
                var CanvasElement = ccwindow.HTMLCanvasElement;
                if (texture.image && texture.image instanceof CanvasElement) {
                  this._packable = true;
                }
              };
              _proto._serialize = function _serialize(ctxForExporting) {
                return null;
              };
              _proto._deserialize = function _deserialize(serializeData, handle) {
                var self = this;
                var data = serializeData;
                var rect = data.rect;
                if (rect) {
                  self._rect = new Rect(rect.x, rect.y, rect.width, rect.height);
                }
                var offset = data.offset;
                if (data.offset) {
                  self._offset = v2$1(offset.x, offset.y);
                }
                var originalSize = data.originalSize;
                if (data.originalSize) {
                  self._originalSize = size(originalSize.width, originalSize.height);
                }
                self._rotated = !!data.rotated;
                self._name = data.name;
                self._packable = !!data.packable;
                self._pixelsToUnit = data.pixelsToUnit;
                var pivot = data.pivot;
                if (pivot) {
                  self._pivot = v2$1(pivot.x, pivot.y);
                }
                self._meshType = data.meshType;
                var capInsets = data.capInsets;
                if (capInsets) {
                  var thisCapInsets = self._capInsets;
                  thisCapInsets[INSET_LEFT] = capInsets[INSET_LEFT];
                  thisCapInsets[INSET_TOP] = capInsets[INSET_TOP];
                  thisCapInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
                  thisCapInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
                }
                var vertices = data.vertices;
                if (vertices) {
                  if (!self.vertices) {
                    self.vertices = {
                      rawPosition: [],
                      positions: [],
                      indexes: vertices.indexes,
                      uv: vertices.uv,
                      nuv: vertices.nuv,
                      minPos: v3(vertices.minPos.x, vertices.minPos.y, vertices.minPos.z),
                      maxPos: v3(vertices.maxPos.x, vertices.maxPos.y, vertices.maxPos.z)
                    };
                  }
                  self.vertices.rawPosition.length = 0;
                  var rawPosition = vertices.rawPosition;
                  for (var i = 0; i < rawPosition.length; i += 3) {
                    self.vertices.rawPosition.push(v3(rawPosition[i], rawPosition[i + 1], rawPosition[i + 2]));
                  }
                  self._updateMeshVertices();
                }
              };
              _proto.clone = function clone() {
                var _sp$uv, _sp$unbiasUV, _sp$uvSliced, _sp$_capInsets, _sp$_customOutLine;
                var self = this;
                var sp = new SpriteFrame();
                var v = self.vertices;
                sp.vertices = v ? {
                  rawPosition: v.rawPosition.slice(0),
                  positions: v.positions.slice(0),
                  indexes: v.indexes.slice(0),
                  uv: v.uv.slice(0),
                  nuv: v.nuv.slice(0),
                  minPos: v.minPos.clone(),
                  maxPos: v.maxPos.clone()
                } : null;
                (_sp$uv = sp.uv).splice.apply(_sp$uv, [0, sp.uv.length].concat(self.uv));
                (_sp$unbiasUV = sp.unbiasUV).splice.apply(_sp$unbiasUV, [0, sp.unbiasUV.length].concat(self.unbiasUV));
                (_sp$uvSliced = sp.uvSliced).splice.apply(_sp$uvSliced, [0, sp.uvSliced.length].concat(self.uvSliced));
                sp._rect.set(self._rect);
                sp._trimmedBorder.set(self._trimmedBorder);
                sp._offset.set(self._offset);
                sp._originalSize.set(self._originalSize);
                sp._rotated = self._rotated;
                (_sp$_capInsets = sp._capInsets).splice.apply(_sp$_capInsets, [0, sp._capInsets.length].concat(self._capInsets));
                sp._atlasUuid = self._atlasUuid;
                sp._texture = self._texture;
                sp._isFlipUVX = self._isFlipUVX;
                sp._isFlipUVY = self._isFlipUVY;
                if (self._original) {
                  sp._original = {
                    _texture: self._original._texture,
                    _x: self._original._x,
                    _y: self._original._y
                  };
                } else {
                  sp._original = null;
                }
                sp._packable = self._packable;
                sp._pixelsToUnit = self._pixelsToUnit;
                sp._pivot.set(self._pivot);
                sp._meshType = self._meshType;
                sp._extrude = self._extrude;
                (_sp$_customOutLine = sp._customOutLine).splice.apply(_sp$_customOutLine, [0, sp._customOutLine.length].concat(self._customOutLine));
                sp._minPos = self._minPos;
                sp._maxPos = self._maxPos;
                if (self._mesh) {
                  sp._createMesh();
                }
                return sp;
              };
              _proto._refreshTexture = function _refreshTexture(texture) {
                var self = this;
                self._texture = texture;
                var tex = self._texture;
                var config = {};
                var isReset = false;
                if (self._rect.width === 0 || self._rect.height === 0 || !self.checkRect(tex)) {
                  config.rect = rect(0, 0, tex.width, tex.height);
                  isReset = true;
                }
                if (self._originalSize.width === 0 || self._originalSize.height === 0 || isReset) {
                  config.originalSize = size(tex.width, tex.height);
                  isReset = true;
                }
                if (isReset) {
                  self.reset(config);
                }
                self._checkPackable();
                if (self._mesh) {
                  self._updateMesh();
                }
              };
              _proto.onLoaded = function onLoaded() {
                this._calcTrimmedBorder();
              };
              _proto.initDefault = function initDefault(uuid) {
                _Asset.prototype.initDefault.call(this, uuid);
                var texture = new Texture2D();
                texture.initDefault();
                this._refreshTexture(texture);
                this._calculateUV();
              };
              _proto.validate = function validate() {
                return this._texture && this._rect && this._rect.width !== 0 && this._rect.height !== 0;
              };
              _proto._initVertices = function _initVertices() {
                var self = this;
                if (!self.vertices) {
                  self.vertices = {
                    rawPosition: [],
                    positions: [],
                    indexes: [],
                    uv: [],
                    nuv: [],
                    minPos: v3(),
                    maxPos: v3()
                  };
                } else {
                  var vertices = self.vertices;
                  vertices.rawPosition.length = 0;
                  vertices.positions.length = 0;
                  vertices.indexes.length = 0;
                  vertices.uv.length = 0;
                  vertices.nuv.length = 0;
                  vertices.minPos.set(0, 0, 0);
                  vertices.maxPos.set(0, 0, 0);
                }
                var thisVertices = self.vertices;
                if (self._meshType === 1) ; else {
                  var tex = self.texture;
                  var texw = tex.width;
                  var texh = tex.height;
                  var _rect2 = self.rect;
                  var width = _rect2.width;
                  var height = _rect2.height;
                  var rectX = _rect2.x;
                  var rectY = texh - _rect2.y - height;
                  var halfWidth = width / 2;
                  var halfHeight = height / 2;
                  var l = texw === 0 ? 0 : rectX / texw;
                  var r = texw === 0 ? 1 : (rectX + width) / texw;
                  var t = texh === 0 ? 1 : (rectY + height) / texh;
                  var b = texh === 0 ? 0 : rectY / texh;
                  var uv = thisVertices.uv;
                  var nuv = thisVertices.nuv;
                  var rawPosition = thisVertices.rawPosition;
                  var indexes = thisVertices.indexes;
                  temp_vec3.set(-halfWidth, -halfHeight, 0);
                  rawPosition.push(temp_vec3.clone());
                  uv.push(rectX, rectY + height);
                  nuv.push(l, b);
                  thisVertices.minPos.set(temp_vec3);
                  temp_vec3.set(halfWidth, -halfHeight, 0);
                  rawPosition.push(temp_vec3.clone());
                  uv.push(rectX + width, rectY + height);
                  nuv.push(r, b);
                  temp_vec3.set(-halfWidth, halfHeight, 0);
                  rawPosition.push(temp_vec3.clone());
                  uv.push(rectX, rectY);
                  nuv.push(l, t);
                  temp_vec3.set(halfWidth, halfHeight, 0);
                  rawPosition.push(temp_vec3.clone());
                  uv.push(rectX + width, rectY);
                  nuv.push(r, t);
                  thisVertices.maxPos.set(temp_vec3);
                  indexes.push(0, 1, 2, 2, 1, 3);
                }
                this._updateMeshVertices();
              };
              _proto._updateMeshVertices = function _updateMeshVertices() {
                temp_matrix.identity();
                var units = 1 / this._pixelsToUnit;
                var PosX = -(this._pivot.x - 0.5) * this.rect.width * units;
                var PosY = -(this._pivot.y - 0.5) * this.rect.height * units;
                var temp_vec3 = v3(PosX, PosY, 0);
                temp_matrix.transform(temp_vec3);
                temp_vec3.set(units, units, 1);
                temp_matrix.scale(temp_vec3);
                var vertices = this.vertices;
                for (var i = 0; i < vertices.rawPosition.length; i++) {
                  var pos = vertices.rawPosition[i];
                  vec3TransformMat4(temp_vec3, pos, temp_matrix);
                  vec3ToArray(vertices.positions, temp_vec3, 3 * i);
                }
                vec3TransformMat4(this._minPos, vertices.minPos, temp_matrix);
                vec3TransformMat4(this._maxPos, vertices.maxPos, temp_matrix);
              };
              _proto._createMesh = function _createMesh$1() {
                this._mesh = _createMesh({
                  primitiveMode: 7,
                  positions: this.vertices.positions,
                  uvs: this.vertices.nuv,
                  indices: this.vertices.indexes,
                  minPos: this._minPos,
                  maxPos: this._maxPos,
                  attributes: [new Attribute("a_position", 32), new Attribute("a_texCoord", 21)]
                });
              };
              _proto._updateMesh = function _updateMesh() {
                if (this._mesh) {
                  this._mesh.destroy();
                }
                this._initVertices();
                this._createMesh();
              };
              _createClass(SpriteFrame, [{
                key: "insetTop",
                get: function get() {
                  return this._capInsets[INSET_TOP];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_TOP] === value) {
                    return;
                  }
                  this._capInsets[INSET_TOP] = value;
                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "insetBottom",
                get: function get() {
                  return this._capInsets[INSET_BOTTOM];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_BOTTOM] === value) {
                    return;
                  }
                  this._capInsets[INSET_BOTTOM] = value;
                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "insetLeft",
                get: function get() {
                  return this._capInsets[INSET_LEFT];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_LEFT] === value) {
                    return;
                  }
                  this._capInsets[INSET_LEFT] = value;
                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "insetRight",
                get: function get() {
                  return this._capInsets[INSET_RIGHT];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_RIGHT] === value) {
                    return;
                  }
                  this._capInsets[INSET_RIGHT] = value;
                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "rect",
                get: function get() {
                  return this._rect;
                },
                set: function set(value) {
                  if (this._rect.equals(value)) {
                    return;
                  }
                  this._rect.set(value);
                  if (this._texture) {
                    this._calculateUV();
                  }
                  this._calcTrimmedBorder();
                }
              }, {
                key: "originalSize",
                get: function get() {
                  return this._originalSize;
                },
                set: function set(value) {
                  if (this._originalSize.equals(value)) {
                    return;
                  }
                  this._originalSize.set(value);
                  if (this._texture) {
                    this._calculateUV();
                  }
                  this._calcTrimmedBorder();
                }
              }, {
                key: "offset",
                get: function get() {
                  return this._offset;
                },
                set: function set(value) {
                  this._offset.set(value);
                  this._calcTrimmedBorder();
                }
              }, {
                key: "rotated",
                get: function get() {
                  return this._rotated;
                },
                set: function set(rotated) {
                  if (this._rotated === rotated) {
                    return;
                  }
                  this._rotated = rotated;
                  if (this._texture) {
                    this._calculateUV();
                  }
                }
              }, {
                key: "texture",
                get: function get() {
                  return this._texture;
                },
                set: function set(value) {
                  if (!value) {
                    warnID(3122, this.name);
                    return;
                  }
                  if (value === this._texture) {
                    return;
                  }
                  this.reset({
                    texture: value
                  }, true);
                }
              }, {
                key: "atlasUuid",
                get: function get() {
                  return this._atlasUuid;
                },
                set: function set(value) {
                  this._atlasUuid = value;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._texture.width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._texture.height;
                }
              }, {
                key: "_textureSource",
                set: function set(value) {
                  if (globalThis.Build) {
                    this._texture = value;
                    return;
                  }
                  if (value) {
                    this._refreshTexture(value);
                    this._calculateUV();
                  }
                }
              }, {
                key: "flipUVX",
                get: function get() {
                  return this._isFlipUVX;
                },
                set: function set(value) {
                  this._isFlipUVX = value;
                  this._calculateUV();
                }
              }, {
                key: "flipUVY",
                get: function get() {
                  return this._isFlipUVY;
                },
                set: function set(value) {
                  this._isFlipUVY = value;
                  this._calculateUV();
                }
              }, {
                key: "packable",
                get: function get() {
                  return this._packable;
                },
                set: function set(value) {
                  this._packable = value;
                }
              }, {
                key: "original",
                get: function get() {
                  return this._original;
                }
              }, {
                key: "pixelsToUnit",
                get: function get() {
                  return this._pixelsToUnit;
                }
              }, {
                key: "pivot",
                get: function get() {
                  return this._pivot;
                }
              }, {
                key: "mesh",
                get: function get() {
                  return this._mesh;
                }
              }, {
                key: "trimmedBorder",
                get: function get() {
                  return this._trimmedBorder;
                }
              }]);
              return SpriteFrame;
            }(Asset), _class2$2.EVENT_UV_UPDATED = "uv_updated", _class2$2.MeshType = MeshType, _class2$2)) || _class$2);
            cclegacy.SpriteFrame = SpriteFrame;

            var _dec$1, _dec2$1, _dec3$1, _class$1, _class2$1, _initializer$1, _initializer2$1, _initializer3, _initializer4, _initializer5, _initializer6;
            (_dec$1 = ccclass$6('cc.SpriteRenderer'), _dec2$1 = executionOrder$1(100), _dec3$1 = type$5(SpriteFrame), _dec$1(_class$1 = _dec2$1(_class$1 = (_class2$1 = function (_ModelRenderer) {
              _inheritsLoose(SpriteRenderer, _ModelRenderer);
              function SpriteRenderer() {
                var _this;
                _this = _ModelRenderer.call(this) || this;
                _this._spriteFrame = _initializer$1 && _initializer$1();
                _this._mode = _initializer2$1 && _initializer2$1();
                _this._color = _initializer3 && _initializer3();
                _this._flipX = _initializer4 && _initializer4();
                _this._flipY = _initializer5 && _initializer5();
                _this._size = _initializer6 && _initializer6();
                _this._model = null;
                return _this;
              }
              var _proto = SpriteRenderer.prototype;
              _proto.onLoad = function onLoad() {
                if (this._spriteFrame) {
                  if (!this._spriteFrame.mesh) {
                    this._spriteFrame.ensureMeshData();
                  }
                  this._spriteFrame.mesh.initialize();
                }
                this._updateModels();
              };
              _proto.onRestore = function onRestore() {
                this._updateModels();
                if (this.enabledInHierarchy) {
                  this._attachToScene();
                }
              };
              _proto.onEnable = function onEnable() {
                _ModelRenderer.prototype.onEnable.call(this);
                if (!this._model) {
                  this._updateModels();
                }
                this._attachToScene();
              };
              _proto.onDisable = function onDisable() {
                if (this._model) {
                  this._detachFromScene();
                }
              };
              _proto.onDestroy = function onDestroy() {
                if (this._model) {
                  cclegacy.director.root.destroyModel(this._model);
                  this._model = null;
                  this._models.length = 0;
                }
              };
              _proto._updateModels = function _updateModels() {
                if (!this._spriteFrame) {
                  return;
                }
                var model = this._model;
                if (model) {
                  model.destroy();
                  model.initialize();
                  model.node = model.transform = this.node;
                } else {
                  this._createModel();
                }
                if (this._model) {
                  var mesh = this._spriteFrame.mesh;
                  this._model.createBoundingShape(mesh.struct.minPosition, mesh.struct.maxPosition);
                  this._updateModelParams();
                  this._onUpdateLocalDescriptorSet();
                }
              };
              _proto._createModel = function _createModel() {
                var model = this._model = cclegacy.director.root.createModel(Model);
                model.visFlags = this.visibility;
                model.node = model.transform = this.node;
                this._models.length = 0;
                this._models.push(this._model);
              };
              _proto._updateModelParams = function _updateModelParams() {
                if (!this._spriteFrame || !this._model) {
                  return;
                }
                this._spriteFrame.ensureMeshData();
                var mesh = this._spriteFrame.mesh;
                this.node.hasChangedFlags |= 1;
                this._model.transform.hasChangedFlags |= 1;
                var renderingMesh = mesh ? mesh.renderingSubMeshes : null;
                if (renderingMesh) {
                  var meshCount = renderingMesh.length;
                  for (var i = 0; i < meshCount; ++i) {
                    var material = this.getRenderMaterial(i);
                    if (material && !material.isValid) {
                      material = null;
                    }
                    var subMeshData = renderingMesh[i];
                    if (subMeshData) {
                      this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                    }
                  }
                }
                this._model.enabled = true;
              };
              _proto._getBuiltinMaterial = function _getBuiltinMaterial() {
                return builtinResMgr.get('missing-material');
              };
              _proto._onMaterialModified = function _onMaterialModified(idx, material) {
                _ModelRenderer.prototype._onMaterialModified.call(this, idx, material);
                if (!this._spriteFrame || !this._model || !this._model.inited) {
                  return;
                }
                this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
              };
              _proto._onRebuildPSO = function _onRebuildPSO(idx, material) {
                if (!this._model || !this._model.inited) {
                  return;
                }
                this._model.setSubModelMaterial(idx, material);
                this._onUpdateLocalDescriptorSet();
              };
              _proto._onUpdateLocalDescriptorSet = function _onUpdateLocalDescriptorSet() {
                if (!this._spriteFrame || !this._model || !this._model.inited) {
                  return;
                }
                var texture = this._spriteFrame.getGFXTexture();
                var sampler = this._spriteFrame.getGFXSampler();
                var subModels = this._model.subModels;
                var binding = 12;
                for (var i = 0; i < subModels.length; i++) {
                  var descriptorSet = subModels[i].descriptorSet;
                  descriptorSet.bindTexture(binding, texture);
                  descriptorSet.bindSampler(binding, sampler);
                  descriptorSet.update();
                }
              };
              _proto._attachToScene = function _attachToScene() {
                if (!this.node.scene || !this._model) {
                  return;
                }
                var renderScene = this._getRenderScene();
                if (this._model.scene !== null) {
                  this._detachFromScene();
                }
                renderScene.addModel(this._model);
              };
              _proto._detachFromScene = function _detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              };
              _createClass(SpriteRenderer, [{
                key: "spriteFrame",
                get: function get() {
                  return this._spriteFrame;
                },
                set: function set(value) {
                  if (this._spriteFrame === value) {
                    return;
                  }
                  this._spriteFrame;
                  this._spriteFrame = value;
                  if (this._spriteFrame) {
                    this._spriteFrame.ensureMeshData();
                    var mesh = this._spriteFrame.mesh;
                    mesh.initialize();
                  }
                  this._updateModels();
                  if (this.enabledInHierarchy) {
                    this._attachToScene();
                  }
                }
              }, {
                key: "model",
                get: function get() {
                  return this._model;
                }
              }]);
              return SpriteRenderer;
            }(ModelRenderer), (_applyDecoratedDescriptor(_class2$1.prototype, "spriteFrame", [_dec3$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "spriteFrame"), _class2$1.prototype), _initializer$1 = applyDecoratedInitializer(_class2$1.prototype, "_spriteFrame", [serializable$5], function () {
              return null;
            }), _initializer2$1 = applyDecoratedInitializer(_class2$1.prototype, "_mode", [serializable$5], function () {
              return 0;
            }), _initializer3 = applyDecoratedInitializer(_class2$1.prototype, "_color", [serializable$5], function () {
              return Color.WHITE.clone();
            }), _initializer4 = applyDecoratedInitializer(_class2$1.prototype, "_flipX", [serializable$5], function () {
              return false;
            }), _initializer5 = applyDecoratedInitializer(_class2$1.prototype, "_flipY", [serializable$5], function () {
              return false;
            }), _initializer6 = applyDecoratedInitializer(_class2$1.prototype, "_size", [serializable$5], function () {
              return new Vec2();
            })), _class2$1)) || _class$1) || _class$1);

            var WebViewImpl = function () {
              function WebViewImpl(component) {
                this._componentEventList = new Map();
                this._state = "none";
                this._wrapper = undefined;
                this._webview = null;
                this._loaded = false;
                this._forceUpdate = false;
                this._component = null;
                this._uiTrans = null;
                this._node = null;
                this._w = 0;
                this._h = 0;
                this._m00 = 0;
                this._m01 = 0;
                this._m04 = 0;
                this._m05 = 0;
                this._m12 = 0;
                this._m13 = 0;
                this._component = component;
                this._node = component.node;
                this._uiTrans = component.node.getComponent(UITransform);
                this.reset();
                this.createWebView();
              }
              var _proto = WebViewImpl.prototype;
              _proto.reset = function reset() {
                this._wrapper = null;
                this._webview = null;
                this._loaded = false;
                this._w = 0;
                this._h = 0;
                this._m00 = 0;
                this._m01 = 0;
                this._m04 = 0;
                this._m05 = 0;
                this._m12 = 0;
                this._m13 = 0;
                this._state = "none";
                this._forceUpdate = false;
              };
              _proto.dispatchEvent = function dispatchEvent(key) {
                var callback = this._componentEventList.get(key);
                if (callback) {
                  this._state = key;
                  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  callback.call(this, args);
                }
              };
              _proto.destroy = function destroy() {
                this.removeWebView();
                this._wrapper = null;
                this._webview = null;
                this._loaded = false;
                this._component = null;
                this._uiTrans = null;
                this._forceUpdate = false;
                this._componentEventList.clear();
              };
              _createClass(WebViewImpl, [{
                key: "loaded",
                get: function get() {
                  return this._loaded;
                }
              }, {
                key: "componentEventList",
                get: function get() {
                  return this._componentEventList;
                }
              }, {
                key: "webview",
                get: function get() {
                  return this._webview;
                }
              }, {
                key: "state",
                get: function get() {
                  return this._state;
                }
              }, {
                key: "UICamera",
                get: function get() {
                  return director.root.batcher2D.getFirstRenderCamera(this._node);
                }
              }]);
              return WebViewImpl;
            }();
            legacyCC.internal.WebViewImpl = WebViewImpl;

            var ccdocument = ccwindow.document;
            var _mat4_temp = mat4();
            var WebViewImplWeb = function (_WebViewImpl) {
              _inheritsLoose(WebViewImplWeb, _WebViewImpl);
              function WebViewImplWeb(component) {
                return _WebViewImpl.call(this, component) || this;
              }
              var _proto = WebViewImplWeb.prototype;
              _proto._bindDomEvent = function _bindDomEvent() {
                var _this = this;
                if (!this.webview) {
                  return;
                }
                var onLoaded = function onLoaded(e) {
                  _this._forceUpdate = true;
                  _this.dispatchEvent("loaded");
                  var iframe = e.target;
                  var body = iframe.contentDocument && iframe.contentDocument.body;
                  if (body && body.innerHTML.includes('404')) {
                    _this.dispatchEvent("error", body.innerHTML);
                  }
                };
                this.webview.addEventListener('load', onLoaded);
              };
              _proto.loadURL = function loadURL(url) {
                if (this.webview) {
                  this.webview.src = url;
                  this.dispatchEvent("loading");
                }
              };
              _proto.createWebView = function createWebView() {
                var wrapper = ccdocument.createElement('div');
                this._wrapper = wrapper;
                wrapper.id = 'webview-wrapper';
                var wrapperStyle = wrapper.style;
                wrapperStyle['-webkit-overflow'] = 'auto';
                wrapperStyle['-webkit-overflow-scrolling'] = 'touch';
                wrapperStyle.position = 'absolute';
                wrapperStyle.bottom = '0px';
                wrapperStyle.left = '0px';
                wrapperStyle.transformOrigin = '0px 100% 0px';
                wrapperStyle['-webkit-transform-origin'] = '0px 100% 0px';
                game.container.appendChild(wrapper);
                var webview = ccdocument.createElement('iframe');
                this._webview = webview;
                var webviewStyle = webview.style;
                webview.id = 'webview';
                webviewStyle.border = 'none';
                webviewStyle.width = '100%';
                webviewStyle.height = '100%';
                wrapper.appendChild(webview);
                this._bindDomEvent();
              };
              _proto.removeWebView = function removeWebView() {
                var wrapper = this._wrapper;
                if (contains(game.container, wrapper)) {
                  game.container.removeChild(wrapper);
                }
                this.reset();
              };
              _proto.enable = function enable() {
                if (this._wrapper) {
                  this._wrapper.style.visibility = 'visible';
                }
              };
              _proto.disable = function disable() {
                if (this._wrapper) {
                  this._wrapper.style.visibility = 'hidden';
                }
              };
              _proto.evaluateJS = function evaluateJS(str) {
                if (this.webview) {
                  var win = this.webview.contentWindow;
                  if (win) {
                    try {
                      win.eval(str);
                    } catch (e) {
                      this.dispatchEvent("error", e);
                      error(e);
                    }
                  }
                }
              };
              _proto.setOnJSCallback = function setOnJSCallback(callback) {
                warn('The platform does not support');
              };
              _proto.setJavascriptInterfaceScheme = function setJavascriptInterfaceScheme(scheme) {
                warn('The platform does not support');
              };
              _proto.syncMatrix = function syncMatrix() {
                if (!this._wrapper || !this._uiTrans || !this._component || this._wrapper.style.visibility === 'hidden') return;
                var camera = this.UICamera;
                if (!camera) {
                  return;
                }
                this._component.node.getWorldMatrix(_mat4_temp);
                camera.update(true);
                camera.worldMatrixToScreen(_mat4_temp, _mat4_temp, game.canvas.width, game.canvas.height);
                var _this$_uiTrans$conten = this._uiTrans.contentSize,
                  width = _this$_uiTrans$conten.width,
                  height = _this$_uiTrans$conten.height;
                if (!this._forceUpdate && this._m00 === _mat4_temp.m00 && this._m01 === _mat4_temp.m01 && this._m04 === _mat4_temp.m04 && this._m05 === _mat4_temp.m05 && this._m12 === _mat4_temp.m12 && this._m13 === _mat4_temp.m13 && this._w === width && this._h === height) {
                  return;
                }
                this._m00 = _mat4_temp.m00;
                this._m01 = _mat4_temp.m01;
                this._m04 = _mat4_temp.m04;
                this._m05 = _mat4_temp.m05;
                this._m12 = _mat4_temp.m12;
                this._m13 = _mat4_temp.m13;
                this._w = width;
                this._h = height;
                var dpr = screenAdapter.devicePixelRatio;
                var scaleX = 1 / dpr;
                var scaleY = 1 / dpr;
                var container = game.container;
                var sx = _mat4_temp.m00 * scaleX;
                var b = _mat4_temp.m01;
                var c = _mat4_temp.m04;
                var sy = _mat4_temp.m05 * scaleY;
                this._wrapper.style.width = width + "px";
                this._wrapper.style.height = height + "px";
                var w = this._w * scaleX;
                var h = this._h * scaleY;
                var appx = w * _mat4_temp.m00 * this._uiTrans.anchorX;
                var appy = h * _mat4_temp.m05 * this._uiTrans.anchorY;
                var offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0;
                var offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
                var tx = _mat4_temp.m12 * scaleX - appx + offsetX;
                var ty = _mat4_temp.m13 * scaleY - appy + offsetY;
                var matrix = "matrix(" + sx + "," + -b + "," + -c + "," + sy + "," + tx + "," + -ty + ")";
                this._wrapper.style.transform = matrix;
                this._wrapper.style['-webkit-transform'] = matrix;
                this._forceUpdate = false;
              };
              return WebViewImplWeb;
            }(WebViewImpl);

            var WebViewImplManager = function () {
              function WebViewImplManager() {}
              WebViewImplManager.getImpl = function getImpl(component) {
                return new WebViewImplWeb(component);
              };
              return WebViewImplManager;
            }();
            legacyCC.internal.WebViewImplManager = WebViewImplManager;

            var WebViewEventType = {
              NONE: "none",
              LOADING: "loading",
              LOADED: "loaded",
              ERROR: "error"
            };

            var _dec, _dec2, _dec3, _class, _class2, _initializer, _initializer2, _class3;
            var WebView = exports("WebView", (_dec = ccclass$6('cc.WebView'), _dec2 = requireComponent(UITransform), _dec3 = type$5([EventHandler]), _dec(_class = _dec2(_class = (_class2 = (_class3 = function (_Component) {
              _inheritsLoose(WebView, _Component);
              function WebView() {
                var _this;
                _this = _Component.call(this) || this;
                _this._url = _initializer && _initializer();
                _this._impl = null;
                _this.webviewEvents = _initializer2 && _initializer2();
                return _this;
              }
              var _proto = WebView.prototype;
              _proto.setJavascriptInterfaceScheme = function setJavascriptInterfaceScheme(scheme) {
                if (this._impl) {
                  this._impl.setJavascriptInterfaceScheme(scheme);
                }
              };
              _proto.setOnJSCallback = function setOnJSCallback(callback) {
                if (this._impl) {
                  this._impl.setOnJSCallback(callback);
                }
              };
              _proto.evaluateJS = function evaluateJS(str) {
                if (this._impl) {
                  this._impl.evaluateJS(str);
                }
              };
              _proto.__preload = function __preload() {
                this._impl = WebViewImplManager.getImpl(this);
                var componentEventList = this._impl.componentEventList;
                componentEventList.set("loading", this.onLoading.bind(this));
                componentEventList.set("loaded", this.onLoaded.bind(this));
                componentEventList.set("error", this.onError.bind(this));
                this._impl.loadURL(this._url);
              };
              _proto.onLoading = function onLoading() {
                EventHandler.emitEvents(this.webviewEvents, this, "loading");
                this.node.emit("loading", this);
              };
              _proto.onLoaded = function onLoaded() {
                EventHandler.emitEvents(this.webviewEvents, this, "loaded");
                this.node.emit("loaded", this);
              };
              _proto.onError = function onError() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                EventHandler.emitEvents(this.webviewEvents, this, "error", args);
                this.node.emit("error", this, args);
              };
              _proto.onEnable = function onEnable() {
                if (this._impl) {
                  this._impl.enable();
                }
              };
              _proto.onDisable = function onDisable() {
                if (this._impl) {
                  this._impl.disable();
                }
              };
              _proto.onDestroy = function onDestroy() {
                if (this._impl) {
                  this._impl.destroy();
                  this._impl = null;
                }
              };
              _proto.update = function update(dt) {
                if (this._impl) {
                  this._impl.syncMatrix();
                }
              };
              _createClass(WebView, [{
                key: "url",
                get: function get() {
                  return this._url;
                },
                set: function set(val) {
                  this._url = val;
                  if (this._impl) {
                    this._impl.loadURL(val);
                  }
                }
              }, {
                key: "nativeWebView",
                get: function get() {
                  return this._impl && this._impl.webview || null;
                }
              }, {
                key: "state",
                get: function get() {
                  if (!this._impl) {
                    return "none";
                  }
                  return this._impl.state;
                }
              }]);
              return WebView;
            }(Component), _class3.EventType = WebViewEventType, _class3), (_initializer = applyDecoratedInitializer(_class2.prototype, "_url", [serializable$5], function () {
              return 'https://cocos.com';
            }), _initializer2 = applyDecoratedInitializer(_class2.prototype, "webviewEvents", [serializable$5, _dec3], function () {
              return [];
            })), _class2)) || _class) || _class));
            legacyCC.internal.WebView = WebView;

        })
    };
}));
